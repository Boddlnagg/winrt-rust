use crate::prelude::*;
DEFINE_IID!(IID_ILowLevelDevicesAggregateProvider, 2805880348, 43713, 20167, 168, 82, 71, 159, 112, 96, 208, 31);
RT_INTERFACE!{interface ILowLevelDevicesAggregateProvider(ILowLevelDevicesAggregateProviderVtbl, ILowLevelDevicesAggregateProvider_Abi): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProvider] {
    fn get_AdcControllerProvider(&self, out: *mut <adc::provider::IAdcControllerProvider as RtType>::Abi) -> HRESULT,
    fn get_PwmControllerProvider(&self, out: *mut <pwm::provider::IPwmControllerProvider as RtType>::Abi) -> HRESULT,
    fn get_GpioControllerProvider(&self, out: *mut <gpio::provider::IGpioControllerProvider as RtType>::Abi) -> HRESULT,
    fn get_I2cControllerProvider(&self, out: *mut <i2c::provider::II2cControllerProvider as RtType>::Abi) -> HRESULT,
    fn get_SpiControllerProvider(&self, out: *mut <spi::provider::ISpiControllerProvider as RtType>::Abi) -> HRESULT
}}
impl ILowLevelDevicesAggregateProvider {
    #[inline] pub fn get_adc_controller_provider(&self) -> Result<Option<adc::provider::IAdcControllerProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdcControllerProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(adc::provider::IAdcControllerProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pwm_controller_provider(&self) -> Result<Option<pwm::provider::IPwmControllerProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PwmControllerProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(pwm::provider::IPwmControllerProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gpio_controller_provider(&self) -> Result<Option<gpio::provider::IGpioControllerProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GpioControllerProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(gpio::provider::IGpioControllerProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_i2c_controller_provider(&self) -> Result<Option<i2c::provider::II2cControllerProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_I2cControllerProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(i2c::provider::II2cControllerProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_spi_controller_provider(&self) -> Result<Option<spi::provider::ISpiControllerProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpiControllerProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(spi::provider::ISpiControllerProvider::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLevelDevicesAggregateProvider: ILowLevelDevicesAggregateProvider}
impl RtActivatable<ILowLevelDevicesAggregateProviderFactory> for LowLevelDevicesAggregateProvider {}
impl LowLevelDevicesAggregateProvider {
    #[inline] pub fn create(adc: &adc::provider::IAdcControllerProvider, pwm: &pwm::provider::IPwmControllerProvider, gpio: &gpio::provider::IGpioControllerProvider, i2c: &i2c::provider::II2cControllerProvider, spi: &spi::provider::ISpiControllerProvider) -> Result<LowLevelDevicesAggregateProvider> {
        <Self as RtActivatable<ILowLevelDevicesAggregateProviderFactory>>::get_activation_factory().create(adc, pwm, gpio, i2c, spi)
    }
}
DEFINE_CLSID!(LowLevelDevicesAggregateProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,65,103,103,114,101,103,97,116,101,80,114,111,118,105,100,101,114,0]) [CLSID_LowLevelDevicesAggregateProvider]);
DEFINE_IID!(IID_ILowLevelDevicesAggregateProviderFactory, 2596580086, 13427, 18014, 150, 213, 54, 40, 26, 44, 87, 175);
RT_INTERFACE!{static interface ILowLevelDevicesAggregateProviderFactory(ILowLevelDevicesAggregateProviderFactoryVtbl, ILowLevelDevicesAggregateProviderFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProviderFactory] {
    fn Create(&self, adc: <adc::provider::IAdcControllerProvider as RtType>::Abi, pwm: <pwm::provider::IPwmControllerProvider as RtType>::Abi, gpio: <gpio::provider::IGpioControllerProvider as RtType>::Abi, i2c: <i2c::provider::II2cControllerProvider as RtType>::Abi, spi: <spi::provider::ISpiControllerProvider as RtType>::Abi, out: *mut <LowLevelDevicesAggregateProvider as RtType>::Abi) -> HRESULT
}}
impl ILowLevelDevicesAggregateProviderFactory {
    #[inline] pub fn create(&self, adc: &adc::provider::IAdcControllerProvider, pwm: &pwm::provider::IPwmControllerProvider, gpio: &gpio::provider::IGpioControllerProvider, i2c: &i2c::provider::II2cControllerProvider, spi: &spi::provider::ISpiControllerProvider) -> Result<LowLevelDevicesAggregateProvider> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(adc) as *const _ as *mut _, get_abi(pwm) as *const _ as *mut _, get_abi(gpio) as *const _ as *mut _, get_abi(i2c) as *const _ as *mut _, get_abi(spi) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LowLevelDevicesAggregateProvider::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILowLevelDevicesController, 784481748, 6043, 17886, 155, 57, 58, 224, 37, 39, 222, 82);
RT_INTERFACE!{interface ILowLevelDevicesController(ILowLevelDevicesControllerVtbl, ILowLevelDevicesController_Abi): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesController] {
    
}}
RT_CLASS!{class LowLevelDevicesController: ILowLevelDevicesController}
impl RtActivatable<ILowLevelDevicesControllerStatics> for LowLevelDevicesController {}
impl LowLevelDevicesController {
    #[inline] pub fn get_default_provider() -> Result<Option<ILowLevelDevicesAggregateProvider>> {
        <Self as RtActivatable<ILowLevelDevicesControllerStatics>>::get_activation_factory().get_default_provider()
    }
    #[inline] pub fn set_default_provider(value: &ILowLevelDevicesAggregateProvider) -> Result<()> {
        <Self as RtActivatable<ILowLevelDevicesControllerStatics>>::get_activation_factory().set_default_provider(value)
    }
}
DEFINE_CLSID!(LowLevelDevicesController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_LowLevelDevicesController]);
DEFINE_IID!(IID_ILowLevelDevicesControllerStatics, 155095658, 64715, 17300, 166, 151, 25, 222, 99, 124, 45, 179);
RT_INTERFACE!{static interface ILowLevelDevicesControllerStatics(ILowLevelDevicesControllerStaticsVtbl, ILowLevelDevicesControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesControllerStatics] {
    fn get_DefaultProvider(&self, out: *mut <ILowLevelDevicesAggregateProvider as RtType>::Abi) -> HRESULT,
    fn put_DefaultProvider(&self, value: <ILowLevelDevicesAggregateProvider as RtType>::Abi) -> HRESULT
}}
impl ILowLevelDevicesControllerStatics {
    #[inline] pub fn get_default_provider(&self) -> Result<Option<ILowLevelDevicesAggregateProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ILowLevelDevicesAggregateProvider::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_provider(&self, value: &ILowLevelDevicesAggregateProvider) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
pub mod adc { // Windows.Devices.Adc
use crate::prelude::*;
DEFINE_IID!(IID_IAdcChannel, 67892244, 9608, 19030, 171, 239, 115, 162, 96, 172, 198, 10);
RT_INTERFACE!{interface IAdcChannel(IAdcChannelVtbl, IAdcChannel_Abi): IInspectable(IInspectableVtbl) [IID_IAdcChannel] {
    fn get_Controller(&self, out: *mut <AdcController as RtType>::Abi) -> HRESULT,
    fn ReadValue(&self, out: *mut i32) -> HRESULT,
    fn ReadRatio(&self, out: *mut f64) -> HRESULT
}}
impl IAdcChannel {
    #[inline] pub fn get_controller(&self) -> Result<Option<AdcController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Controller)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AdcController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read_ratio(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ReadRatio)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AdcChannel: IAdcChannel}
RT_ENUM! { enum AdcChannelMode: i32 {
    SingleEnded = 0, Differential = 1,
}}
DEFINE_IID!(IID_IAdcController, 712434864, 43158, 16921, 134, 182, 234, 140, 220, 233, 143, 86);
RT_INTERFACE!{interface IAdcController(IAdcControllerVtbl, IAdcController_Abi): IInspectable(IInspectableVtbl) [IID_IAdcController] {
    fn get_ChannelCount(&self, out: *mut i32) -> HRESULT,
    fn get_ResolutionInBits(&self, out: *mut i32) -> HRESULT,
    fn get_MinValue(&self, out: *mut i32) -> HRESULT,
    fn get_MaxValue(&self, out: *mut i32) -> HRESULT,
    fn get_ChannelMode(&self, out: *mut AdcChannelMode) -> HRESULT,
    fn put_ChannelMode(&self, value: AdcChannelMode) -> HRESULT,
    fn IsChannelModeSupported(&self, channelMode: AdcChannelMode, out: *mut bool) -> HRESULT,
    fn OpenChannel(&self, channelNumber: i32, out: *mut <AdcChannel as RtType>::Abi) -> HRESULT
}}
impl IAdcController {
    #[inline] pub fn get_channel_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resolution_in_bits(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResolutionInBits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_mode(&self) -> Result<AdcChannelMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_channel_mode(&self, value: AdcChannelMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChannelMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_channel_mode_supported(&self, channelMode: AdcChannelMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsChannelModeSupported)(self.0.as_abi() as *const _ as *mut _, channelMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_channel(&self, channelNumber: i32) -> Result<Option<AdcChannel>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenChannel)(self.0.as_abi() as *const _ as *mut _, channelNumber, &mut out);
        if hr == S_OK { Ok(AdcChannel::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdcController: IAdcController}
impl RtActivatable<IAdcControllerStatics> for AdcController {}
impl RtActivatable<IAdcControllerStatics2> for AdcController {}
impl AdcController {
    #[inline] pub fn get_controllers_async(provider: &provider::IAdcProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>>> {
        <Self as RtActivatable<IAdcControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<AdcController>> {
        <Self as RtActivatable<IAdcControllerStatics2>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(AdcController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,100,99,46,65,100,99,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_AdcController]);
DEFINE_IID!(IID_IAdcControllerStatics, 3437858316, 504, 18577, 188, 59, 190, 83, 239, 39, 156, 164);
RT_INTERFACE!{static interface IAdcControllerStatics(IAdcControllerStaticsVtbl, IAdcControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics] {
    fn GetControllersAsync(&self, provider: <provider::IAdcProvider as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>> as RtType>::Abi) -> HRESULT
}}
impl IAdcControllerStatics {
    #[inline] pub fn get_controllers_async(&self, provider: &provider::IAdcProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdcControllerStatics2, 2730048285, 38779, 20314, 165, 254, 166, 171, 175, 254, 100, 132);
RT_INTERFACE!{static interface IAdcControllerStatics2(IAdcControllerStatics2Vtbl, IAdcControllerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics2] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<AdcController> as RtType>::Abi) -> HRESULT
}}
impl IAdcControllerStatics2 {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<AdcController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
pub mod provider { // Windows.Devices.Adc.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IAdcControllerProvider, 3193198632, 33133, 19941, 160, 72, 171, 160, 105, 88, 170, 168);
RT_INTERFACE!{interface IAdcControllerProvider(IAdcControllerProviderVtbl, IAdcControllerProvider_Abi): IInspectable(IInspectableVtbl) [IID_IAdcControllerProvider] {
    fn get_ChannelCount(&self, out: *mut i32) -> HRESULT,
    fn get_ResolutionInBits(&self, out: *mut i32) -> HRESULT,
    fn get_MinValue(&self, out: *mut i32) -> HRESULT,
    fn get_MaxValue(&self, out: *mut i32) -> HRESULT,
    fn get_ChannelMode(&self, out: *mut ProviderAdcChannelMode) -> HRESULT,
    fn put_ChannelMode(&self, value: ProviderAdcChannelMode) -> HRESULT,
    fn IsChannelModeSupported(&self, channelMode: ProviderAdcChannelMode, out: *mut bool) -> HRESULT,
    fn AcquireChannel(&self, channel: i32) -> HRESULT,
    fn ReleaseChannel(&self, channel: i32) -> HRESULT,
    fn ReadValue(&self, channelNumber: i32, out: *mut i32) -> HRESULT
}}
impl IAdcControllerProvider {
    #[inline] pub fn get_channel_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resolution_in_bits(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResolutionInBits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_mode(&self) -> Result<ProviderAdcChannelMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_channel_mode(&self, value: ProviderAdcChannelMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChannelMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_channel_mode_supported(&self, channelMode: ProviderAdcChannelMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsChannelModeSupported)(self.0.as_abi() as *const _ as *mut _, channelMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn acquire_channel(&self, channel: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AcquireChannel)(self.0.as_abi() as *const _ as *mut _, channel);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn release_channel(&self, channel: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReleaseChannel)(self.0.as_abi() as *const _ as *mut _, channel);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_value(&self, channelNumber: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValue)(self.0.as_abi() as *const _ as *mut _, channelNumber, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdcProvider, 680867432, 37721, 19543, 188, 136, 226, 117, 232, 22, 56, 201);
RT_INTERFACE!{interface IAdcProvider(IAdcProviderVtbl, IAdcProvider_Abi): IInspectable(IInspectableVtbl) [IID_IAdcProvider] {
    fn GetControllers(&self, out: *mut <foundation::collections::IVectorView<IAdcControllerProvider> as RtType>::Abi) -> HRESULT
}}
impl IAdcProvider {
    #[inline] pub fn get_controllers(&self) -> Result<Option<foundation::collections::IVectorView<IAdcControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderAdcChannelMode: i32 {
    SingleEnded = 0, Differential = 1,
}}
} // Windows.Devices.Adc.Provider
} // Windows.Devices.Adc
pub mod alljoyn { // Windows.Devices.AllJoyn
use crate::prelude::*;
DEFINE_IID!(IID_IAllJoynAboutData, 3853106944, 8098, 18489, 147, 239, 249, 223, 64, 72, 144, 247);
RT_INTERFACE!{interface IAllJoynAboutData(IAllJoynAboutDataVtbl, IAllJoynAboutData_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutData] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_DefaultAppName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultAppName(&self, value: HSTRING) -> HRESULT,
    fn get_AppNames(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn get_DateOfManufacture(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn put_DateOfManufacture(&self, value: <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    fn get_DefaultDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultDescription(&self, value: HSTRING) -> HRESULT,
    fn get_Descriptions(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn get_DefaultManufacturer(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultManufacturer(&self, value: HSTRING) -> HRESULT,
    fn get_Manufacturers(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT,
    fn get_ModelNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ModelNumber(&self, value: HSTRING) -> HRESULT,
    fn get_SoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SoftwareVersion(&self, value: HSTRING) -> HRESULT,
    fn get_SupportUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn put_SupportUrl(&self, value: <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn put_AppId(&self, value: Guid) -> HRESULT
}}
impl IAllJoynAboutData {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultAppName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_app_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultAppName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_names(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppNames)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_of_manufacture(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateOfManufacture)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_date_of_manufacture(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DateOfManufacture)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultDescription)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptions(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_manufacturer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultManufacturer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_manufacturer(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultManufacturer)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturers(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Manufacturers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_model_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ModelNumber)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_software_version(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SoftwareVersion)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_support_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportUrl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_support_url(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SupportUrl)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_app_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAboutData: IAllJoynAboutData}
DEFINE_IID!(IID_IAllJoynAboutDataView, 1747128607, 25106, 18740, 156, 72, 225, 156, 164, 152, 66, 136);
RT_INTERFACE!{interface IAllJoynAboutDataView(IAllJoynAboutDataViewVtbl, IAllJoynAboutDataView_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataView] {
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_AJSoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn get_DateOfManufacture(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_DefaultLanguage(&self, out: *mut <super::super::globalization::Language as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HardwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_SupportedLanguages(&self, out: *mut <foundation::collections::IVectorView<super::super::globalization::Language> as RtType>::Abi) -> HRESULT,
    fn get_SupportUrl(&self, out: *mut <foundation::Uri as RtType>::Abi) -> HRESULT,
    fn get_AppName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Manufacturer(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAllJoynAboutDataView {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_aj_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AJSoftwareVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date_of_manufacture(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateOfManufacture)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_default_language(&self) -> Result<Option<super::super::globalization::Language>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultLanguage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::globalization::Language::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_languages(&self) -> Result<Option<foundation::collections::IVectorView<super::super::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedLanguages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_support_url(&self) -> Result<Option<foundation::Uri>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportUrl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Uri::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Manufacturer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAboutDataView: IAllJoynAboutDataView}
impl RtActivatable<IAllJoynAboutDataViewStatics> for AllJoynAboutDataView {}
impl AllJoynAboutDataView {
    #[inline] pub fn get_data_by_session_port_async(uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> {
        <Self as RtActivatable<IAllJoynAboutDataViewStatics>>::get_activation_factory().get_data_by_session_port_async(uniqueName, busAttachment, sessionPort)
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_data_by_session_port_with_language_async(uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16, language: &super::super::globalization::Language) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> {
        <Self as RtActivatable<IAllJoynAboutDataViewStatics>>::get_activation_factory().get_data_by_session_port_with_language_async(uniqueName, busAttachment, sessionPort, language)
    }
}
DEFINE_CLSID!(AllJoynAboutDataView(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,98,111,117,116,68,97,116,97,86,105,101,119,0]) [CLSID_AllJoynAboutDataView]);
DEFINE_IID!(IID_IAllJoynAboutDataViewStatics, 1475196552, 3166, 16750, 136, 181, 57, 179, 45, 37, 196, 125);
RT_INTERFACE!{static interface IAllJoynAboutDataViewStatics(IAllJoynAboutDataViewStaticsVtbl, IAllJoynAboutDataViewStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataViewStatics] {
    fn GetDataBySessionPortAsync(&self, uniqueName: HSTRING, busAttachment: <AllJoynBusAttachment as RtType>::Abi, sessionPort: u16, out: *mut <foundation::IAsyncOperation<AllJoynAboutDataView> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-globalization")] fn GetDataBySessionPortWithLanguageAsync(&self, uniqueName: HSTRING, busAttachment: <AllJoynBusAttachment as RtType>::Abi, sessionPort: u16, language: <super::super::globalization::Language as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AllJoynAboutDataView> as RtType>::Abi) -> HRESULT
}}
impl IAllJoynAboutDataViewStatics {
    #[inline] pub fn get_data_by_session_port_async(&self, uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDataBySessionPortAsync)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), get_abi(busAttachment) as *const _ as *mut _, sessionPort, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_data_by_session_port_with_language_async(&self, uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16, language: &super::super::globalization::Language) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDataBySessionPortWithLanguageAsync)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), get_abi(busAttachment) as *const _ as *mut _, sessionPort, get_abi(language) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAcceptSessionJoiner, 1302861778, 52509, 16419, 167, 196, 22, 222, 248, 156, 40, 223);
RT_INTERFACE!{interface IAllJoynAcceptSessionJoiner(IAllJoynAcceptSessionJoinerVtbl, IAllJoynAcceptSessionJoiner_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoiner] {
    fn Accept(&self) -> HRESULT
}}
impl IAllJoynAcceptSessionJoiner {
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Accept)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgs, 1325093733, 16010, 16983, 143, 16, 83, 156, 224, 213, 108, 15);
RT_INTERFACE!{interface IAllJoynAcceptSessionJoinerEventArgs(IAllJoynAcceptSessionJoinerEventArgsVtbl, IAllJoynAcceptSessionJoinerEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionPort(&self, out: *mut u16) -> HRESULT,
    fn get_TrafficType(&self, out: *mut AllJoynTrafficType) -> HRESULT,
    fn get_SamePhysicalNode(&self, out: *mut bool) -> HRESULT,
    fn get_SameNetwork(&self, out: *mut bool) -> HRESULT,
    fn Accept(&self) -> HRESULT
}}
impl IAllJoynAcceptSessionJoinerEventArgs {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_port(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionPort)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_traffic_type(&self) -> Result<AllJoynTrafficType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TrafficType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_same_physical_node(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SamePhysicalNode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_same_network(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SameNetwork)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Accept)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAcceptSessionJoinerEventArgs: IAllJoynAcceptSessionJoinerEventArgs}
impl RtActivatable<IAllJoynAcceptSessionJoinerEventArgsFactory> for AllJoynAcceptSessionJoinerEventArgs {}
impl AllJoynAcceptSessionJoinerEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: &IAllJoynAcceptSessionJoiner) -> Result<AllJoynAcceptSessionJoinerEventArgs> {
        <Self as RtActivatable<IAllJoynAcceptSessionJoinerEventArgsFactory>>::get_activation_factory().create(uniqueName, sessionPort, trafficType, proximity, acceptSessionJoiner)
    }
}
DEFINE_CLSID!(AllJoynAcceptSessionJoinerEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,99,99,101,112,116,83,101,115,115,105,111,110,74,111,105,110,101,114,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynAcceptSessionJoinerEventArgs]);
DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgsFactory, 3024313280, 24901, 17054, 132, 219, 213, 191, 231, 114, 177, 79);
RT_INTERFACE!{static interface IAllJoynAcceptSessionJoinerEventArgsFactory(IAllJoynAcceptSessionJoinerEventArgsFactoryVtbl, IAllJoynAcceptSessionJoinerEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: <IAllJoynAcceptSessionJoiner as RtType>::Abi, out: *mut <AllJoynAcceptSessionJoinerEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynAcceptSessionJoinerEventArgsFactory {
    #[inline] pub fn create(&self, uniqueName: &HStringArg, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: &IAllJoynAcceptSessionJoiner) -> Result<AllJoynAcceptSessionJoinerEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), sessionPort, trafficType, proximity, get_abi(acceptSessionJoiner) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynAcceptSessionJoinerEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAuthenticationCompleteEventArgs, 2545184796, 5596, 19283, 182, 164, 125, 19, 67, 0, 215, 191);
RT_INTERFACE!{interface IAllJoynAuthenticationCompleteEventArgs(IAllJoynAuthenticationCompleteEventArgsVtbl, IAllJoynAuthenticationCompleteEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynAuthenticationCompleteEventArgs] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT
}}
impl IAllJoynAuthenticationCompleteEventArgs {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationMechanism)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerUniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Succeeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAuthenticationCompleteEventArgs: IAllJoynAuthenticationCompleteEventArgs}
RT_ENUM! { enum AllJoynAuthenticationMechanism: i32 {
    None = 0, SrpAnonymous = 1, SrpLogon = 2, EcdheNull = 3, EcdhePsk = 4, EcdheEcdsa = 5, EcdheSpeke = 6,
}}
DEFINE_IID!(IID_IAllJoynBusAttachment, 4077515091, 7917, 17091, 162, 14, 67, 109, 65, 254, 98, 246);
RT_INTERFACE!{interface IAllJoynBusAttachment(IAllJoynBusAttachmentVtbl, IAllJoynBusAttachment_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment] {
    fn get_AboutData(&self, out: *mut <AllJoynAboutData as RtType>::Abi) -> HRESULT,
    fn get_ConnectionSpecification(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut AllJoynBusAttachmentState) -> HRESULT,
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn PingAsync(&self, uniqueName: HSTRING, out: *mut <foundation::IAsyncOperation<i32> as RtType>::Abi) -> HRESULT,
    fn Connect(&self) -> HRESULT,
    fn Disconnect(&self) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AuthenticationMechanisms(&self, out: *mut <foundation::collections::IVector<AllJoynAuthenticationMechanism> as RtType>::Abi) -> HRESULT,
    fn add_CredentialsRequested(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CredentialsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CredentialsVerificationRequested(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CredentialsVerificationRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AuthenticationComplete(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AuthenticationComplete(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAllJoynBusAttachment {
    #[inline] pub fn get_about_data(&self) -> Result<Option<AllJoynAboutData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AboutData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynAboutData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_specification(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionSpecification)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<AllJoynBusAttachmentState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn ping_async(&self, uniqueName: &HStringArg) -> Result<foundation::IAsyncOperation<i32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PingAsync)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Connect)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disconnect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Disconnect)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_mechanisms(&self) -> Result<Option<foundation::collections::IVector<AllJoynAuthenticationMechanism>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationMechanisms)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_credentials_requested(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CredentialsRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_credentials_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CredentialsRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_credentials_verification_requested(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CredentialsVerificationRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_credentials_verification_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CredentialsVerificationRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_authentication_complete(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AuthenticationComplete)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_authentication_complete(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AuthenticationComplete)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusAttachment: IAllJoynBusAttachment}
impl RtActivatable<IAllJoynBusAttachmentFactory> for AllJoynBusAttachment {}
impl RtActivatable<IAllJoynBusAttachmentStatics> for AllJoynBusAttachment {}
impl RtActivatable<IActivationFactory> for AllJoynBusAttachment {}
impl AllJoynBusAttachment {
    #[inline] pub fn create(connectionSpecification: &HStringArg) -> Result<AllJoynBusAttachment> {
        <Self as RtActivatable<IAllJoynBusAttachmentFactory>>::get_activation_factory().create(connectionSpecification)
    }
    #[inline] pub fn get_default() -> Result<Option<AllJoynBusAttachment>> {
        <Self as RtActivatable<IAllJoynBusAttachmentStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_watcher(requiredInterfaces: &foundation::collections::IIterable<HString>) -> Result<Option<super::enumeration::DeviceWatcher>> {
        <Self as RtActivatable<IAllJoynBusAttachmentStatics>>::get_activation_factory().get_watcher(requiredInterfaces)
    }
}
DEFINE_CLSID!(AllJoynBusAttachment(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,65,116,116,97,99,104,109,101,110,116,0]) [CLSID_AllJoynBusAttachment]);
DEFINE_IID!(IID_IAllJoynBusAttachment2, 880069406, 9064, 17330, 180, 62, 106, 58, 193, 39, 141, 152);
RT_INTERFACE!{interface IAllJoynBusAttachment2(IAllJoynBusAttachment2Vtbl, IAllJoynBusAttachment2_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment2] {
    fn GetAboutDataAsync(&self, serviceInfo: <AllJoynServiceInfo as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AllJoynAboutDataView> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-globalization")] fn GetAboutDataWithLanguageAsync(&self, serviceInfo: <AllJoynServiceInfo as RtType>::Abi, language: <super::super::globalization::Language as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AllJoynAboutDataView> as RtType>::Abi) -> HRESULT,
    fn add_AcceptSessionJoinerRequested(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AcceptSessionJoinerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SessionJoined(&self, handler: <foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionJoined(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAllJoynBusAttachment2 {
    #[inline] pub fn get_about_data_async(&self, serviceInfo: &AllJoynServiceInfo) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAboutDataAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceInfo) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_about_data_with_language_async(&self, serviceInfo: &AllJoynServiceInfo, language: &super::super::globalization::Language) -> Result<foundation::IAsyncOperation<AllJoynAboutDataView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAboutDataWithLanguageAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceInfo) as *const _ as *mut _, get_abi(language) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_accept_session_joiner_requested(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AcceptSessionJoinerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_accept_session_joiner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AcceptSessionJoinerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_session_joined(&self, handler: &foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionJoined)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_joined(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionJoined)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusAttachmentFactory, 1680798116, 44421, 19935, 144, 174, 96, 68, 82, 178, 34, 136);
RT_INTERFACE!{static interface IAllJoynBusAttachmentFactory(IAllJoynBusAttachmentFactoryVtbl, IAllJoynBusAttachmentFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentFactory] {
    fn Create(&self, connectionSpecification: HSTRING, out: *mut <AllJoynBusAttachment as RtType>::Abi) -> HRESULT
}}
impl IAllJoynBusAttachmentFactory {
    #[inline] pub fn create(&self, connectionSpecification: &HStringArg) -> Result<AllJoynBusAttachment> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, connectionSpecification.get(), &mut out);
        if hr == S_OK { Ok(AllJoynBusAttachment::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynBusAttachmentState: i32 {
    Disconnected = 0, Connecting = 1, Connected = 2, Disconnecting = 3,
}}
DEFINE_IID!(IID_IAllJoynBusAttachmentStateChangedEventArgs, 3626923508, 49194, 16876, 168, 213, 234, 177, 85, 137, 83, 170);
RT_INTERFACE!{interface IAllJoynBusAttachmentStateChangedEventArgs(IAllJoynBusAttachmentStateChangedEventArgsVtbl, IAllJoynBusAttachmentStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStateChangedEventArgs] {
    fn get_State(&self, out: *mut AllJoynBusAttachmentState) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl IAllJoynBusAttachmentStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<AllJoynBusAttachmentState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusAttachmentStateChangedEventArgs: IAllJoynBusAttachmentStateChangedEventArgs}
DEFINE_IID!(IID_IAllJoynBusAttachmentStatics, 2208124221, 4177, 16599, 135, 42, 141, 1, 65, 17, 91, 31);
RT_INTERFACE!{static interface IAllJoynBusAttachmentStatics(IAllJoynBusAttachmentStaticsVtbl, IAllJoynBusAttachmentStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStatics] {
    fn GetDefault(&self, out: *mut <AllJoynBusAttachment as RtType>::Abi) -> HRESULT,
    fn GetWatcher(&self, requiredInterfaces: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <super::enumeration::DeviceWatcher as RtType>::Abi) -> HRESULT
}}
impl IAllJoynBusAttachmentStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<AllJoynBusAttachment>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynBusAttachment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_watcher(&self, requiredInterfaces: &foundation::collections::IIterable<HString>) -> Result<Option<super::enumeration::DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetWatcher)(self.0.as_abi() as *const _ as *mut _, get_abi(requiredInterfaces) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusObject, 3908928094, 63290, 18700, 136, 4, 4, 224, 38, 100, 48, 71);
RT_INTERFACE!{interface IAllJoynBusObject(IAllJoynBusObjectVtbl, IAllJoynBusObject_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObject] {
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn AddProducer(&self, producer: <IAllJoynProducer as RtType>::Abi) -> HRESULT,
    fn get_BusAttachment(&self, out: *mut <AllJoynBusAttachment as RtType>::Abi) -> HRESULT,
    fn get_Session(&self, out: *mut <AllJoynSession as RtType>::Abi) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAllJoynBusObject {
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_producer(&self, producer: &IAllJoynProducer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AddProducer)(self.0.as_abi() as *const _ as *mut _, get_abi(producer) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_attachment(&self) -> Result<Option<AllJoynBusAttachment>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BusAttachment)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynBusAttachment::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session(&self) -> Result<Option<AllJoynSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusObject: IAllJoynBusObject}
impl RtActivatable<IAllJoynBusObjectFactory> for AllJoynBusObject {}
impl RtActivatable<IActivationFactory> for AllJoynBusObject {}
impl AllJoynBusObject {
    #[inline] pub fn create(objectPath: &HStringArg) -> Result<AllJoynBusObject> {
        <Self as RtActivatable<IAllJoynBusObjectFactory>>::get_activation_factory().create(objectPath)
    }
    #[inline] pub fn create_with_bus_attachment(objectPath: &HStringArg, busAttachment: &AllJoynBusAttachment) -> Result<AllJoynBusObject> {
        <Self as RtActivatable<IAllJoynBusObjectFactory>>::get_activation_factory().create_with_bus_attachment(objectPath, busAttachment)
    }
}
DEFINE_CLSID!(AllJoynBusObject(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,0]) [CLSID_AllJoynBusObject]);
DEFINE_IID!(IID_IAllJoynBusObjectFactory, 741318411, 36354, 20380, 172, 39, 234, 109, 173, 93, 59, 80);
RT_INTERFACE!{static interface IAllJoynBusObjectFactory(IAllJoynBusObjectFactoryVtbl, IAllJoynBusObjectFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectFactory] {
    fn Create(&self, objectPath: HSTRING, out: *mut <AllJoynBusObject as RtType>::Abi) -> HRESULT,
    fn CreateWithBusAttachment(&self, objectPath: HSTRING, busAttachment: <AllJoynBusAttachment as RtType>::Abi, out: *mut <AllJoynBusObject as RtType>::Abi) -> HRESULT
}}
impl IAllJoynBusObjectFactory {
    #[inline] pub fn create(&self, objectPath: &HStringArg) -> Result<AllJoynBusObject> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, objectPath.get(), &mut out);
        if hr == S_OK { Ok(AllJoynBusObject::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_bus_attachment(&self, objectPath: &HStringArg, busAttachment: &AllJoynBusAttachment) -> Result<AllJoynBusObject> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithBusAttachment)(self.0.as_abi() as *const _ as *mut _, objectPath.get(), get_abi(busAttachment) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynBusObject::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgs, 3725598997, 61326, 19778, 185, 59, 162, 174, 116, 81, 151, 102);
RT_INTERFACE!{interface IAllJoynBusObjectStoppedEventArgs(IAllJoynBusObjectStoppedEventArgsVtbl, IAllJoynBusObjectStoppedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl IAllJoynBusObjectStoppedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusObjectStoppedEventArgs: IAllJoynBusObjectStoppedEventArgs}
impl RtActivatable<IAllJoynBusObjectStoppedEventArgsFactory> for AllJoynBusObjectStoppedEventArgs {}
impl AllJoynBusObjectStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<AllJoynBusObjectStoppedEventArgs> {
        <Self as RtActivatable<IAllJoynBusObjectStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynBusObjectStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynBusObjectStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgsFactory, 1797455176, 53411, 16981, 149, 58, 71, 114, 180, 2, 128, 115);
RT_INTERFACE!{static interface IAllJoynBusObjectStoppedEventArgsFactory(IAllJoynBusObjectStoppedEventArgsFactoryVtbl, IAllJoynBusObjectStoppedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut <AllJoynBusObjectStoppedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynBusObjectStoppedEventArgsFactory {
    #[inline] pub fn create(&self, status: i32) -> Result<AllJoynBusObjectStoppedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(AllJoynBusObjectStoppedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynCredentials, 2185646322, 41360, 16561, 171, 171, 52, 158, 194, 68, 223, 170);
RT_INTERFACE!{interface IAllJoynCredentials(IAllJoynCredentialsVtbl, IAllJoynCredentials_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentials] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_Certificate(&self, out: *mut <super::super::security::cryptography::certificates::Certificate as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn put_Certificate(&self, value: <super::super::security::cryptography::certificates::Certificate as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PasswordCredential(&self, out: *mut <super::super::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-security")] fn put_PasswordCredential(&self, value: <super::super::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    fn get_Timeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Timeout(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl IAllJoynCredentials {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationMechanism)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_certificate(&self) -> Result<Option<super::super::security::cryptography::certificates::Certificate>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Certificate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::cryptography::certificates::Certificate::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_certificate(&self, value: &super::super::security::cryptography::certificates::Certificate) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Certificate)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_password_credential(&self) -> Result<Option<super::super::security::credentials::PasswordCredential>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PasswordCredential)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::credentials::PasswordCredential::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_password_credential(&self, value: &super::super::security::credentials::PasswordCredential) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PasswordCredential)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Timeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentials: IAllJoynCredentials}
DEFINE_IID!(IID_IAllJoynCredentialsRequestedEventArgs, 1787290446, 45161, 19328, 158, 26, 65, 188, 131, 124, 101, 210);
RT_INTERFACE!{interface IAllJoynCredentialsRequestedEventArgs(IAllJoynCredentialsRequestedEventArgsVtbl, IAllJoynCredentialsRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsRequestedEventArgs] {
    fn get_AttemptCount(&self, out: *mut u16) -> HRESULT,
    fn get_Credentials(&self, out: *mut <AllJoynCredentials as RtType>::Abi) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RequestedUserName(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAllJoynCredentialsRequestedEventArgs {
    #[inline] pub fn get_attempt_count(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttemptCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_credentials(&self) -> Result<Option<AllJoynCredentials>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Credentials)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynCredentials::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerUniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedUserName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentialsRequestedEventArgs: IAllJoynCredentialsRequestedEventArgs}
DEFINE_IID!(IID_IAllJoynCredentialsVerificationRequestedEventArgs, 2148169234, 47109, 17583, 162, 225, 121, 42, 182, 85, 162, 208);
RT_INTERFACE!{interface IAllJoynCredentialsVerificationRequestedEventArgs(IAllJoynCredentialsVerificationRequestedEventArgsVtbl, IAllJoynCredentialsVerificationRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsVerificationRequestedEventArgs] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerCertificate(&self, out: *mut <super::super::security::cryptography::certificates::Certificate as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_PeerCertificateErrorSeverity(&self, out: *mut super::super::networking::sockets::SocketSslErrorSeverity) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerCertificateErrors(&self, out: *mut <foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerIntermediateCertificates(&self, out: *mut <foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate> as RtType>::Abi) -> HRESULT,
    fn Accept(&self) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IAllJoynCredentialsVerificationRequestedEventArgs {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationMechanism)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerUniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_certificate(&self) -> Result<Option<super::super::security::cryptography::certificates::Certificate>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerCertificate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::cryptography::certificates::Certificate::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_peer_certificate_error_severity(&self) -> Result<super::super::networking::sockets::SocketSslErrorSeverity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerCertificateErrorSeverity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_certificate_errors(&self) -> Result<Option<foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerCertificateErrors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_intermediate_certificates(&self) -> Result<Option<foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PeerIntermediateCertificates)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Accept)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentialsVerificationRequestedEventArgs: IAllJoynCredentialsVerificationRequestedEventArgs}
DEFINE_IID!(IID_IAllJoynMessageInfo, 4281008423, 11282, 18521, 170, 58, 199, 68, 97, 238, 129, 76);
RT_INTERFACE!{interface IAllJoynMessageInfo(IAllJoynMessageInfoVtbl, IAllJoynMessageInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfo] {
    fn get_SenderUniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAllJoynMessageInfo {
    #[inline] pub fn get_sender_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SenderUniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynMessageInfo: IAllJoynMessageInfo}
impl RtActivatable<IAllJoynMessageInfoFactory> for AllJoynMessageInfo {}
impl AllJoynMessageInfo {
    #[inline] pub fn create(senderUniqueName: &HStringArg) -> Result<AllJoynMessageInfo> {
        <Self as RtActivatable<IAllJoynMessageInfoFactory>>::get_activation_factory().create(senderUniqueName)
    }
}
DEFINE_CLSID!(AllJoynMessageInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,77,101,115,115,97,103,101,73,110,102,111,0]) [CLSID_AllJoynMessageInfo]);
DEFINE_IID!(IID_IAllJoynMessageInfoFactory, 879119402, 33417, 17364, 180, 168, 63, 77, 227, 89, 240, 67);
RT_INTERFACE!{static interface IAllJoynMessageInfoFactory(IAllJoynMessageInfoFactoryVtbl, IAllJoynMessageInfoFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfoFactory] {
    fn Create(&self, senderUniqueName: HSTRING, out: *mut <AllJoynMessageInfo as RtType>::Abi) -> HRESULT
}}
impl IAllJoynMessageInfoFactory {
    #[inline] pub fn create(&self, senderUniqueName: &HStringArg) -> Result<AllJoynMessageInfo> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, senderUniqueName.get(), &mut out);
        if hr == S_OK { Ok(AllJoynMessageInfo::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynProducer, 2634565241, 18075, 18778, 167, 16, 172, 80, 241, 35, 6, 159);
RT_INTERFACE!{interface IAllJoynProducer(IAllJoynProducerVtbl, IAllJoynProducer_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynProducer] {
    fn SetBusObject(&self, busObject: <AllJoynBusObject as RtType>::Abi) -> HRESULT
}}
impl IAllJoynProducer {
    #[inline] pub fn set_bus_object(&self, busObject: &AllJoynBusObject) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBusObject)(self.0.as_abi() as *const _ as *mut _, get_abi(busObject) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgs, 1362138992, 18743, 18733, 128, 128, 35, 100, 57, 152, 124, 235);
RT_INTERFACE!{interface IAllJoynProducerStoppedEventArgs(IAllJoynProducerStoppedEventArgsVtbl, IAllJoynProducerStoppedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl IAllJoynProducerStoppedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynProducerStoppedEventArgs: IAllJoynProducerStoppedEventArgs}
impl RtActivatable<IAllJoynProducerStoppedEventArgsFactory> for AllJoynProducerStoppedEventArgs {}
impl AllJoynProducerStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<AllJoynProducerStoppedEventArgs> {
        <Self as RtActivatable<IAllJoynProducerStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynProducerStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,80,114,111,100,117,99,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynProducerStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgsFactory, 1448253793, 45593, 19822, 159, 120, 250, 63, 153, 250, 143, 229);
RT_INTERFACE!{static interface IAllJoynProducerStoppedEventArgsFactory(IAllJoynProducerStoppedEventArgsFactoryVtbl, IAllJoynProducerStoppedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut <AllJoynProducerStoppedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynProducerStoppedEventArgsFactory {
    #[inline] pub fn create(&self, status: i32) -> Result<AllJoynProducerStoppedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(AllJoynProducerStoppedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfo, 1287553545, 47422, 16770, 153, 155, 221, 208, 0, 249, 197, 117);
RT_INTERFACE!{interface IAllJoynServiceInfo(IAllJoynServiceInfoVtbl, IAllJoynServiceInfo_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfo] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ObjectPath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionPort(&self, out: *mut u16) -> HRESULT
}}
impl IAllJoynServiceInfo {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_object_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ObjectPath)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_port(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionPort)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynServiceInfo: IAllJoynServiceInfo}
impl RtActivatable<IAllJoynServiceInfoFactory> for AllJoynServiceInfo {}
impl RtActivatable<IAllJoynServiceInfoStatics> for AllJoynServiceInfo {}
impl AllJoynServiceInfo {
    #[inline] pub fn create(uniqueName: &HStringArg, objectPath: &HStringArg, sessionPort: u16) -> Result<AllJoynServiceInfo> {
        <Self as RtActivatable<IAllJoynServiceInfoFactory>>::get_activation_factory().create(uniqueName, objectPath, sessionPort)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<AllJoynServiceInfo>> {
        <Self as RtActivatable<IAllJoynServiceInfoStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(AllJoynServiceInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,0]) [CLSID_AllJoynServiceInfo]);
DEFINE_IID!(IID_IAllJoynServiceInfoFactory, 1971444413, 65027, 20299, 148, 164, 240, 47, 220, 189, 17, 184);
RT_INTERFACE!{static interface IAllJoynServiceInfoFactory(IAllJoynServiceInfoFactoryVtbl, IAllJoynServiceInfoFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoFactory] {
    fn Create(&self, uniqueName: HSTRING, objectPath: HSTRING, sessionPort: u16, out: *mut <AllJoynServiceInfo as RtType>::Abi) -> HRESULT
}}
impl IAllJoynServiceInfoFactory {
    #[inline] pub fn create(&self, uniqueName: &HStringArg, objectPath: &HStringArg, sessionPort: u16) -> Result<AllJoynServiceInfo> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), objectPath.get(), sessionPort, &mut out);
        if hr == S_OK { Ok(AllJoynServiceInfo::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgs, 811051359, 7487, 16883, 137, 105, 227, 39, 146, 98, 115, 150);
RT_INTERFACE!{interface IAllJoynServiceInfoRemovedEventArgs(IAllJoynServiceInfoRemovedEventArgsVtbl, IAllJoynServiceInfoRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAllJoynServiceInfoRemovedEventArgs {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynServiceInfoRemovedEventArgs: IAllJoynServiceInfoRemovedEventArgs}
impl RtActivatable<IAllJoynServiceInfoRemovedEventArgsFactory> for AllJoynServiceInfoRemovedEventArgs {}
impl AllJoynServiceInfoRemovedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<AllJoynServiceInfoRemovedEventArgs> {
        <Self as RtActivatable<IAllJoynServiceInfoRemovedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynServiceInfoRemovedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynServiceInfoRemovedEventArgs]);
DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgsFactory, 230655527, 39679, 18773, 146, 39, 105, 83, 186, 244, 21, 105);
RT_INTERFACE!{static interface IAllJoynServiceInfoRemovedEventArgsFactory(IAllJoynServiceInfoRemovedEventArgsFactoryVtbl, IAllJoynServiceInfoRemovedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut <AllJoynServiceInfoRemovedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynServiceInfoRemovedEventArgsFactory {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<AllJoynServiceInfoRemovedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(AllJoynServiceInfoRemovedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfoStatics, 1450727178, 24634, 18940, 183, 80, 14, 241, 54, 9, 33, 60);
RT_INTERFACE!{static interface IAllJoynServiceInfoStatics(IAllJoynServiceInfoStaticsVtbl, IAllJoynServiceInfoStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<AllJoynServiceInfo> as RtType>::Abi) -> HRESULT
}}
impl IAllJoynServiceInfoStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<AllJoynServiceInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSession, 3906018060, 49364, 16492, 136, 169, 169, 62, 250, 133, 212, 177);
RT_INTERFACE!{interface IAllJoynSession(IAllJoynSessionVtbl, IAllJoynSession_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSession] {
    fn get_Id(&self, out: *mut i32) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn RemoveMemberAsync(&self, uniqueName: HSTRING, out: *mut <foundation::IAsyncOperation<i32> as RtType>::Abi) -> HRESULT,
    fn add_MemberAdded(&self, handler: <foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MemberAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MemberRemoved(&self, handler: <foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MemberRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Lost(&self, handler: <foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Lost(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAllJoynSession {
    #[inline] pub fn get_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_async(&self, uniqueName: &HStringArg) -> Result<foundation::IAsyncOperation<i32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RemoveMemberAsync)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_member_added(&self, handler: &foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MemberAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MemberAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_member_removed(&self, handler: &foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MemberRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MemberRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_lost(&self, handler: &foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Lost)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_lost(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Lost)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSession: IAllJoynSession}
impl RtActivatable<IAllJoynSessionStatics> for AllJoynSession {}
impl AllJoynSession {
    #[inline] pub fn get_from_service_info_async(serviceInfo: &AllJoynServiceInfo) -> Result<foundation::IAsyncOperation<AllJoynSession>> {
        <Self as RtActivatable<IAllJoynSessionStatics>>::get_activation_factory().get_from_service_info_async(serviceInfo)
    }
    #[inline] pub fn get_from_service_info_and_bus_attachment_async(serviceInfo: &AllJoynServiceInfo, busAttachment: &AllJoynBusAttachment) -> Result<foundation::IAsyncOperation<AllJoynSession>> {
        <Self as RtActivatable<IAllJoynSessionStatics>>::get_activation_factory().get_from_service_info_and_bus_attachment_async(serviceInfo, busAttachment)
    }
}
DEFINE_CLSID!(AllJoynSession(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,0]) [CLSID_AllJoynSession]);
DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgs, 2661243856, 46551, 18373, 141, 171, 176, 64, 204, 25, 40, 113);
RT_INTERFACE!{interface IAllJoynSessionJoinedEventArgs(IAllJoynSessionJoinedEventArgsVtbl, IAllJoynSessionJoinedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgs] {
    fn get_Session(&self, out: *mut <AllJoynSession as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionJoinedEventArgs {
    #[inline] pub fn get_session(&self) -> Result<Option<AllJoynSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynSession::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionJoinedEventArgs: IAllJoynSessionJoinedEventArgs}
impl RtActivatable<IAllJoynSessionJoinedEventArgsFactory> for AllJoynSessionJoinedEventArgs {}
impl AllJoynSessionJoinedEventArgs {
    #[inline] pub fn create(session: &AllJoynSession) -> Result<AllJoynSessionJoinedEventArgs> {
        <Self as RtActivatable<IAllJoynSessionJoinedEventArgsFactory>>::get_activation_factory().create(session)
    }
}
DEFINE_CLSID!(AllJoynSessionJoinedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,74,111,105,110,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionJoinedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgsFactory, 1747244681, 54987, 19870, 160, 158, 53, 128, 104, 112, 177, 127);
RT_INTERFACE!{static interface IAllJoynSessionJoinedEventArgsFactory(IAllJoynSessionJoinedEventArgsFactoryVtbl, IAllJoynSessionJoinedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgsFactory] {
    fn Create(&self, session: <AllJoynSession as RtType>::Abi, out: *mut <AllJoynSessionJoinedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionJoinedEventArgsFactory {
    #[inline] pub fn create(&self, session: &AllJoynSession) -> Result<AllJoynSessionJoinedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(session) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AllJoynSessionJoinedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionLostEventArgs, 3882263690, 35768, 18772, 174, 103, 210, 250, 67, 209, 249, 107);
RT_INTERFACE!{interface IAllJoynSessionLostEventArgs(IAllJoynSessionLostEventArgsVtbl, IAllJoynSessionLostEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgs] {
    fn get_Reason(&self, out: *mut AllJoynSessionLostReason) -> HRESULT
}}
impl IAllJoynSessionLostEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<AllJoynSessionLostReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionLostEventArgs: IAllJoynSessionLostEventArgs}
impl RtActivatable<IAllJoynSessionLostEventArgsFactory> for AllJoynSessionLostEventArgs {}
impl AllJoynSessionLostEventArgs {
    #[inline] pub fn create(reason: AllJoynSessionLostReason) -> Result<AllJoynSessionLostEventArgs> {
        <Self as RtActivatable<IAllJoynSessionLostEventArgsFactory>>::get_activation_factory().create(reason)
    }
}
DEFINE_CLSID!(AllJoynSessionLostEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,76,111,115,116,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionLostEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionLostEventArgsFactory, 331087154, 54004, 18889, 152, 14, 40, 5, 225, 53, 134, 177);
RT_INTERFACE!{static interface IAllJoynSessionLostEventArgsFactory(IAllJoynSessionLostEventArgsFactoryVtbl, IAllJoynSessionLostEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgsFactory] {
    fn Create(&self, reason: AllJoynSessionLostReason, out: *mut <AllJoynSessionLostEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionLostEventArgsFactory {
    #[inline] pub fn create(&self, reason: AllJoynSessionLostReason) -> Result<AllJoynSessionLostEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(AllJoynSessionLostEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynSessionLostReason: i32 {
    None = 0, ProducerLeftSession = 1, ProducerClosedAbruptly = 2, RemovedByProducer = 3, LinkTimeout = 4, Other = 5,
}}
DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgs, 1235384714, 3537, 18113, 156, 214, 39, 25, 14, 80, 58, 94);
RT_INTERFACE!{interface IAllJoynSessionMemberAddedEventArgs(IAllJoynSessionMemberAddedEventArgsVtbl, IAllJoynSessionMemberAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAllJoynSessionMemberAddedEventArgs {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionMemberAddedEventArgs: IAllJoynSessionMemberAddedEventArgs}
impl RtActivatable<IAllJoynSessionMemberAddedEventArgsFactory> for AllJoynSessionMemberAddedEventArgs {}
impl AllJoynSessionMemberAddedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<AllJoynSessionMemberAddedEventArgs> {
        <Self as RtActivatable<IAllJoynSessionMemberAddedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynSessionMemberAddedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,65,100,100,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionMemberAddedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgsFactory, 874373970, 7475, 16545, 161, 211, 229, 119, 112, 32, 225, 241);
RT_INTERFACE!{static interface IAllJoynSessionMemberAddedEventArgsFactory(IAllJoynSessionMemberAddedEventArgsFactoryVtbl, IAllJoynSessionMemberAddedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut <AllJoynSessionMemberAddedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionMemberAddedEventArgsFactory {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<AllJoynSessionMemberAddedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(AllJoynSessionMemberAddedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgs, 1083842975, 43594, 18579, 180, 48, 186, 161, 182, 60, 98, 25);
RT_INTERFACE!{interface IAllJoynSessionMemberRemovedEventArgs(IAllJoynSessionMemberRemovedEventArgsVtbl, IAllJoynSessionMemberRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAllJoynSessionMemberRemovedEventArgs {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UniqueName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionMemberRemovedEventArgs: IAllJoynSessionMemberRemovedEventArgs}
impl RtActivatable<IAllJoynSessionMemberRemovedEventArgsFactory> for AllJoynSessionMemberRemovedEventArgs {}
impl AllJoynSessionMemberRemovedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<AllJoynSessionMemberRemovedEventArgs> {
        <Self as RtActivatable<IAllJoynSessionMemberRemovedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynSessionMemberRemovedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionMemberRemovedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgsFactory, 3302184424, 17080, 19303, 183, 87, 208, 207, 202, 213, 146, 128);
RT_INTERFACE!{static interface IAllJoynSessionMemberRemovedEventArgsFactory(IAllJoynSessionMemberRemovedEventArgsFactoryVtbl, IAllJoynSessionMemberRemovedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut <AllJoynSessionMemberRemovedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionMemberRemovedEventArgsFactory {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<AllJoynSessionMemberRemovedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(AllJoynSessionMemberRemovedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionStatics, 2651182596, 41068, 18132, 180, 108, 11, 11, 84, 16, 91, 68);
RT_INTERFACE!{static interface IAllJoynSessionStatics(IAllJoynSessionStaticsVtbl, IAllJoynSessionStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionStatics] {
    fn GetFromServiceInfoAsync(&self, serviceInfo: <AllJoynServiceInfo as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AllJoynSession> as RtType>::Abi) -> HRESULT,
    fn GetFromServiceInfoAndBusAttachmentAsync(&self, serviceInfo: <AllJoynServiceInfo as RtType>::Abi, busAttachment: <AllJoynBusAttachment as RtType>::Abi, out: *mut <foundation::IAsyncOperation<AllJoynSession> as RtType>::Abi) -> HRESULT
}}
impl IAllJoynSessionStatics {
    #[inline] pub fn get_from_service_info_async(&self, serviceInfo: &AllJoynServiceInfo) -> Result<foundation::IAsyncOperation<AllJoynSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFromServiceInfoAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceInfo) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from_service_info_and_bus_attachment_async(&self, serviceInfo: &AllJoynServiceInfo, busAttachment: &AllJoynBusAttachment) -> Result<foundation::IAsyncOperation<AllJoynSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFromServiceInfoAndBusAttachmentAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceInfo) as *const _ as *mut _, get_abi(busAttachment) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class AllJoynStatus}
impl RtActivatable<IAllJoynStatusStatics> for AllJoynStatus {}
impl AllJoynStatus {
    #[inline] pub fn get_ok() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ok()
    }
    #[inline] pub fn get_fail() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_fail()
    }
    #[inline] pub fn get_operation_timed_out() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_operation_timed_out()
    }
    #[inline] pub fn get_other_end_closed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_other_end_closed()
    }
    #[inline] pub fn get_connection_refused() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_connection_refused()
    }
    #[inline] pub fn get_authentication_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_authentication_failed()
    }
    #[inline] pub fn get_authentication_rejected_by_user() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_authentication_rejected_by_user()
    }
    #[inline] pub fn get_ssl_connect_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ssl_connect_failed()
    }
    #[inline] pub fn get_ssl_identity_verification_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ssl_identity_verification_failed()
    }
    #[inline] pub fn get_insufficient_security() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_insufficient_security()
    }
    #[inline] pub fn get_invalid_argument1() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument1()
    }
    #[inline] pub fn get_invalid_argument2() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument2()
    }
    #[inline] pub fn get_invalid_argument3() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument3()
    }
    #[inline] pub fn get_invalid_argument4() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument4()
    }
    #[inline] pub fn get_invalid_argument5() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument5()
    }
    #[inline] pub fn get_invalid_argument6() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument6()
    }
    #[inline] pub fn get_invalid_argument7() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument7()
    }
    #[inline] pub fn get_invalid_argument8() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument8()
    }
}
DEFINE_CLSID!(AllJoynStatus(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,116,97,116,117,115,0]) [CLSID_AllJoynStatus]);
DEFINE_IID!(IID_IAllJoynStatusStatics, 3501695358, 3369, 19881, 138, 198, 84, 197, 84, 190, 219, 197);
RT_INTERFACE!{static interface IAllJoynStatusStatics(IAllJoynStatusStaticsVtbl, IAllJoynStatusStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynStatusStatics] {
    fn get_Ok(&self, out: *mut i32) -> HRESULT,
    fn get_Fail(&self, out: *mut i32) -> HRESULT,
    fn get_OperationTimedOut(&self, out: *mut i32) -> HRESULT,
    fn get_OtherEndClosed(&self, out: *mut i32) -> HRESULT,
    fn get_ConnectionRefused(&self, out: *mut i32) -> HRESULT,
    fn get_AuthenticationFailed(&self, out: *mut i32) -> HRESULT,
    fn get_AuthenticationRejectedByUser(&self, out: *mut i32) -> HRESULT,
    fn get_SslConnectFailed(&self, out: *mut i32) -> HRESULT,
    fn get_SslIdentityVerificationFailed(&self, out: *mut i32) -> HRESULT,
    fn get_InsufficientSecurity(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument1(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument2(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument3(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument4(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument5(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument6(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument7(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument8(&self, out: *mut i32) -> HRESULT
}}
impl IAllJoynStatusStatics {
    #[inline] pub fn get_ok(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ok)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_fail(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Fail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_operation_timed_out(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationTimedOut)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_other_end_closed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OtherEndClosed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_refused(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionRefused)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationFailed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_rejected_by_user(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationRejectedByUser)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssl_connect_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SslConnectFailed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssl_identity_verification_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SslIdentityVerificationFailed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_security(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientSecurity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument1(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument2(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument3(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument4(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument4)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument5(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument6(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument6)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument7(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument7)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument8(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidArgument8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynTrafficType: i32 {
    Unknown = 0, Messages = 1, RawUnreliable = 2, RawReliable = 4,
}}
DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgs, 3388776507, 28701, 19112, 151, 221, 162, 187, 10, 143, 95, 163);
RT_INTERFACE!{interface IAllJoynWatcherStoppedEventArgs(IAllJoynWatcherStoppedEventArgsVtbl, IAllJoynWatcherStoppedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl IAllJoynWatcherStoppedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynWatcherStoppedEventArgs: IAllJoynWatcherStoppedEventArgs}
impl RtActivatable<IAllJoynWatcherStoppedEventArgsFactory> for AllJoynWatcherStoppedEventArgs {}
impl AllJoynWatcherStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<AllJoynWatcherStoppedEventArgs> {
        <Self as RtActivatable<IAllJoynWatcherStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynWatcherStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,87,97,116,99,104,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynWatcherStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgsFactory, 2274338216, 11600, 18401, 144, 74, 32, 191, 13, 72, 199, 130);
RT_INTERFACE!{static interface IAllJoynWatcherStoppedEventArgsFactory(IAllJoynWatcherStoppedEventArgsFactoryVtbl, IAllJoynWatcherStoppedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut <AllJoynWatcherStoppedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IAllJoynWatcherStoppedEventArgsFactory {
    #[inline] pub fn create(&self, status: i32) -> Result<AllJoynWatcherStoppedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(AllJoynWatcherStoppedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.AllJoyn
pub mod background { // Windows.Devices.Background
use crate::prelude::*;
DEFINE_IID!(IID_IDeviceServicingDetails, 1252781609, 9028, 19140, 133, 39, 74, 142, 246, 144, 86, 69);
RT_INTERFACE!{interface IDeviceServicingDetails(IDeviceServicingDetailsVtbl, IDeviceServicingDetails_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceServicingDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpectedDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IDeviceServicingDetails {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Arguments)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expected_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpectedDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceServicingDetails: IDeviceServicingDetails}
DEFINE_IID!(IID_IDeviceUseDetails, 2102808897, 21886, 16724, 185, 148, 228, 247, 161, 31, 179, 35);
RT_INTERFACE!{interface IDeviceUseDetails(IDeviceUseDetailsVtbl, IDeviceUseDetails_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceUseDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDeviceUseDetails {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Arguments)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceUseDetails: IDeviceUseDetails}
} // Windows.Devices.Background
pub mod bluetooth { // Windows.Devices.Bluetooth
use crate::prelude::*;
DEFINE_IID!(IID_IBluetoothAdapter, 2037706828, 24442, 18996, 146, 37, 168, 85, 248, 75, 26, 139);
RT_INTERFACE!{interface IBluetoothAdapter(IBluetoothAdapterVtbl, IBluetoothAdapter_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn get_IsClassicSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsLowEnergySupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPeripheralRoleSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCentralRoleSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsAdvertisementOffloadSupported(&self, out: *mut bool) -> HRESULT,
    fn GetRadioAsync(&self, out: *mut <foundation::IAsyncOperation<super::radios::Radio> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothAdapter {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_classic_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsClassicSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_low_energy_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLowEnergySupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_peripheral_role_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPeripheralRoleSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_central_role_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCentralRoleSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_advertisement_offload_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAdvertisementOffloadSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_radio_async(&self) -> Result<foundation::IAsyncOperation<super::radios::Radio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRadioAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothAdapter: IBluetoothAdapter}
impl RtActivatable<IBluetoothAdapterStatics> for BluetoothAdapter {}
impl BluetoothAdapter {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothAdapter>> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<BluetoothAdapter>> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(BluetoothAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,65,100,97,112,116,101,114,0]) [CLSID_BluetoothAdapter]);
DEFINE_IID!(IID_IBluetoothAdapter2, 2895433420, 9429, 16819, 145, 109, 16, 151, 197, 11, 16, 43);
RT_INTERFACE!{interface IBluetoothAdapter2(IBluetoothAdapter2Vtbl, IBluetoothAdapter2_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapter2] {
    fn get_AreClassicSecureConnectionsSupported(&self, out: *mut bool) -> HRESULT,
    fn get_AreLowEnergySecureConnectionsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IBluetoothAdapter2 {
    #[inline] pub fn get_are_classic_secure_connections_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AreClassicSecureConnectionsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_are_low_energy_secure_connections_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AreLowEnergySecureConnectionsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothAdapterStatics, 2332228458, 44108, 18241, 134, 97, 142, 171, 125, 23, 234, 159);
RT_INTERFACE!{static interface IBluetoothAdapterStatics(IBluetoothAdapterStaticsVtbl, IBluetoothAdapterStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapterStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<BluetoothAdapter> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<BluetoothAdapter> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothAdapterStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<BluetoothAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothAddressType: i32 {
    Public = 0, Random = 1, Unspecified = 2,
}}
RT_ENUM! { enum BluetoothCacheMode: i32 {
    Cached = 0, Uncached = 1,
}}
DEFINE_IID!(IID_IBluetoothClassOfDevice, 3594527358, 55255, 18017, 148, 84, 101, 3, 156, 161, 122, 43);
RT_INTERFACE!{interface IBluetoothClassOfDevice(IBluetoothClassOfDeviceVtbl, IBluetoothClassOfDevice_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDevice] {
    fn get_RawValue(&self, out: *mut u32) -> HRESULT,
    fn get_MajorClass(&self, out: *mut BluetoothMajorClass) -> HRESULT,
    fn get_MinorClass(&self, out: *mut BluetoothMinorClass) -> HRESULT,
    fn get_ServiceCapabilities(&self, out: *mut BluetoothServiceCapabilities) -> HRESULT
}}
impl IBluetoothClassOfDevice {
    #[inline] pub fn get_raw_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_major_class(&self) -> Result<BluetoothMajorClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MajorClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_minor_class(&self) -> Result<BluetoothMinorClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinorClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_capabilities(&self) -> Result<BluetoothServiceCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothClassOfDevice: IBluetoothClassOfDevice}
impl RtActivatable<IBluetoothClassOfDeviceStatics> for BluetoothClassOfDevice {}
impl BluetoothClassOfDevice {
    #[inline] pub fn from_raw_value(rawValue: u32) -> Result<Option<BluetoothClassOfDevice>> {
        <Self as RtActivatable<IBluetoothClassOfDeviceStatics>>::get_activation_factory().from_raw_value(rawValue)
    }
    #[inline] pub fn from_parts(majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities) -> Result<Option<BluetoothClassOfDevice>> {
        <Self as RtActivatable<IBluetoothClassOfDeviceStatics>>::get_activation_factory().from_parts(majorClass, minorClass, serviceCapabilities)
    }
}
DEFINE_CLSID!(BluetoothClassOfDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,67,108,97,115,115,79,102,68,101,118,105,99,101,0]) [CLSID_BluetoothClassOfDevice]);
DEFINE_IID!(IID_IBluetoothClassOfDeviceStatics, 3831575997, 4002, 16748, 145, 180, 193, 228, 140, 160, 97, 193);
RT_INTERFACE!{static interface IBluetoothClassOfDeviceStatics(IBluetoothClassOfDeviceStaticsVtbl, IBluetoothClassOfDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDeviceStatics] {
    fn FromRawValue(&self, rawValue: u32, out: *mut <BluetoothClassOfDevice as RtType>::Abi) -> HRESULT,
    fn FromParts(&self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities, out: *mut <BluetoothClassOfDevice as RtType>::Abi) -> HRESULT
}}
impl IBluetoothClassOfDeviceStatics {
    #[inline] pub fn from_raw_value(&self, rawValue: u32) -> Result<Option<BluetoothClassOfDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromRawValue)(self.0.as_abi() as *const _ as *mut _, rawValue, &mut out);
        if hr == S_OK { Ok(BluetoothClassOfDevice::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parts(&self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities) -> Result<Option<BluetoothClassOfDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromParts)(self.0.as_abi() as *const _ as *mut _, majorClass, minorClass, serviceCapabilities, &mut out);
        if hr == S_OK { Ok(BluetoothClassOfDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothConnectionStatus: i32 {
    Disconnected = 0, Connected = 1,
}}
DEFINE_IID!(IID_IBluetoothDevice, 590721366, 37074, 18948, 174, 245, 14, 32, 185, 230, 183, 7);
RT_INTERFACE!{interface IBluetoothDevice(IBluetoothDeviceVtbl, IBluetoothDevice_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_HostName(&self, out: *mut <super::super::networking::HostName as RtType>::Abi) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ClassOfDevice(&self, out: *mut <BluetoothClassOfDevice as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRecords(&self, out: *mut <foundation::collections::IVectorView<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn get_RfcommServices(&self, out: *mut <foundation::collections::IVectorView<rfcomm::RfcommDeviceService> as RtType>::Abi) -> HRESULT,
    fn get_ConnectionStatus(&self, out: *mut BluetoothConnectionStatus) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn add_NameChanged(&self, handler: <foundation::TypedEventHandler<BluetoothDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SdpRecordsChanged(&self, handler: <foundation::TypedEventHandler<BluetoothDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SdpRecordsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: <foundation::TypedEventHandler<BluetoothDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBluetoothDevice {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_host_name(&self) -> Result<Option<super::super::networking::HostName>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HostName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::networking::HostName::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_class_of_device(&self) -> Result<Option<BluetoothClassOfDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClassOfDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothClassOfDevice::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_records(&self) -> Result<Option<foundation::collections::IVectorView<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SdpRecords)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services(&self) -> Result<Option<foundation::collections::IVectorView<rfcomm::RfcommDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RfcommServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_status(&self) -> Result<BluetoothConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_name_changed(&self, handler: &foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NameChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_name_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NameChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sdp_records_changed(&self, handler: &foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SdpRecordsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sdp_records_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SdpRecordsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothDevice: IBluetoothDevice}
impl RtActivatable<IBluetoothDeviceStatics> for BluetoothDevice {}
impl RtActivatable<IBluetoothDeviceStatics2> for BluetoothDevice {}
impl BluetoothDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothDevice>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[cfg(feature="windows-networking")] #[inline] pub fn from_host_name_async(hostName: &super::super::networking::HostName) -> Result<foundation::IAsyncOperation<BluetoothDevice>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_host_name_async(hostName)
    }
    #[inline] pub fn from_bluetooth_address_async(address: u64) -> Result<foundation::IAsyncOperation<BluetoothDevice>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_bluetooth_address_async(address)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_pairing_state(pairingState: bool) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_pairing_state(pairingState)
    }
    #[inline] pub fn get_device_selector_from_connection_status(connectionStatus: BluetoothConnectionStatus) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_connection_status(connectionStatus)
    }
    #[inline] pub fn get_device_selector_from_device_name(deviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_device_name(deviceName)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address(bluetoothAddress: u64) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector_from_class_of_device(classOfDevice: &BluetoothClassOfDevice) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_class_of_device(classOfDevice)
    }
}
DEFINE_CLSID!(BluetoothDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,68,101,118,105,99,101,0]) [CLSID_BluetoothDevice]);
DEFINE_IID!(IID_IBluetoothDevice2, 20183380, 45398, 19920, 177, 245, 193, 27, 195, 26, 81, 99);
RT_INTERFACE!{interface IBluetoothDevice2(IBluetoothDevice2Vtbl, IBluetoothDevice2_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice2] {
    fn get_DeviceInformation(&self, out: *mut <super::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IBluetoothDevice2 {
    #[inline] pub fn get_device_information(&self) -> Result<Option<super::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice3, 1476392843, 25882, 17492, 185, 15, 235, 33, 239, 11, 13, 113);
RT_INTERFACE!{interface IBluetoothDevice3(IBluetoothDevice3Vtbl, IBluetoothDevice3_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice3] {
    fn get_DeviceAccessInformation(&self, out: *mut <super::enumeration::DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus> as RtType>::Abi) -> HRESULT,
    fn GetRfcommServicesAsync(&self, out: *mut <foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetRfcommServicesWithCacheModeAsync(&self, cacheMode: BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetRfcommServicesForIdAsync(&self, serviceId: <rfcomm::RfcommServiceId as RtType>::Abi, out: *mut <foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetRfcommServicesForIdWithCacheModeAsync(&self, serviceId: <rfcomm::RfcommServiceId as RtType>::Abi, cacheMode: BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothDevice3 {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<super::enumeration::DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceAccessInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_async(&self) -> Result<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRfcommServicesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_with_cache_mode_async(&self, cacheMode: BluetoothCacheMode) -> Result<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRfcommServicesWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_for_id_async(&self, serviceId: &rfcomm::RfcommServiceId) -> Result<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRfcommServicesForIdAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_for_id_with_cache_mode_async(&self, serviceId: &rfcomm::RfcommServiceId, cacheMode: BluetoothCacheMode) -> Result<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRfcommServicesForIdWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice4, 2172400813, 3740, 17074, 168, 220, 62, 128, 148, 148, 13, 18);
RT_INTERFACE!{interface IBluetoothDevice4(IBluetoothDevice4Vtbl, IBluetoothDevice4_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice4] {
    fn get_BluetoothDeviceId(&self, out: *mut <BluetoothDeviceId as RtType>::Abi) -> HRESULT
}}
impl IBluetoothDevice4 {
    #[inline] pub fn get_bluetooth_device_id(&self) -> Result<Option<BluetoothDeviceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothDeviceId::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice5, 3051402117, 24197, 17753, 161, 13, 28, 114, 129, 55, 159, 150);
RT_INTERFACE!{interface IBluetoothDevice5(IBluetoothDevice5Vtbl, IBluetoothDevice5_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice5] {
    fn get_WasSecureConnectionUsedForPairing(&self, out: *mut bool) -> HRESULT
}}
impl IBluetoothDevice5 {
    #[inline] pub fn get_was_secure_connection_used_for_pairing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WasSecureConnectionUsedForPairing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceId, 3245951407, 22465, 17986, 188, 206, 230, 192, 107, 32, 174, 118);
RT_INTERFACE!{interface IBluetoothDeviceId(IBluetoothDeviceIdVtbl, IBluetoothDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceId] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsClassicDevice(&self, out: *mut bool) -> HRESULT,
    fn get_IsLowEnergyDevice(&self, out: *mut bool) -> HRESULT
}}
impl IBluetoothDeviceId {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_classic_device(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsClassicDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_low_energy_device(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLowEnergyDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothDeviceId: IBluetoothDeviceId}
impl RtActivatable<IBluetoothDeviceIdStatics> for BluetoothDeviceId {}
impl BluetoothDeviceId {
    #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<BluetoothDeviceId>> {
        <Self as RtActivatable<IBluetoothDeviceIdStatics>>::get_activation_factory().from_id(deviceId)
    }
}
DEFINE_CLSID!(BluetoothDeviceId(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,68,101,118,105,99,101,73,100,0]) [CLSID_BluetoothDeviceId]);
DEFINE_IID!(IID_IBluetoothDeviceIdStatics, 2810728039, 16123, 20273, 187, 194, 129, 14, 9, 151, 116, 4);
RT_INTERFACE!{static interface IBluetoothDeviceIdStatics(IBluetoothDeviceIdStaticsVtbl, IBluetoothDeviceIdStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceIdStatics] {
    fn FromId(&self, deviceId: HSTRING, out: *mut <BluetoothDeviceId as RtType>::Abi) -> HRESULT
}}
impl IBluetoothDeviceIdStatics {
    #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<BluetoothDeviceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(BluetoothDeviceId::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceStatics, 160554833, 22491, 18213, 187, 215, 132, 246, 67, 39, 236, 44);
RT_INTERFACE!{static interface IBluetoothDeviceStatics(IBluetoothDeviceStaticsVtbl, IBluetoothDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<BluetoothDevice> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-networking")] fn FromHostNameAsync(&self, hostName: <super::super::networking::HostName as RtType>::Abi, out: *mut <foundation::IAsyncOperation<BluetoothDevice> as RtType>::Abi) -> HRESULT,
    fn FromBluetoothAddressAsync(&self, address: u64, out: *mut <foundation::IAsyncOperation<BluetoothDevice> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBluetoothDeviceStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn from_host_name_async(&self, hostName: &super::super::networking::HostName) -> Result<foundation::IAsyncOperation<BluetoothDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromHostNameAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(hostName) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_async(&self, address: u64) -> Result<foundation::IAsyncOperation<BluetoothDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromBluetoothAddressAsync)(self.0.as_abi() as *const _ as *mut _, address, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceStatics2, 3265170991, 19988, 17527, 170, 27, 184, 180, 126, 91, 126, 206);
RT_INTERFACE!{static interface IBluetoothDeviceStatics2(IBluetoothDeviceStatics2Vtbl, IBluetoothDeviceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics2] {
    fn GetDeviceSelectorFromPairingState(&self, pairingState: bool, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromConnectionStatus(&self, connectionStatus: BluetoothConnectionStatus, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromDeviceName(&self, deviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddress(&self, bluetoothAddress: u64, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromClassOfDevice(&self, classOfDevice: <BluetoothClassOfDevice as RtType>::Abi, out: *mut HSTRING) -> HRESULT
}}
impl IBluetoothDeviceStatics2 {
    #[inline] pub fn get_device_selector_from_pairing_state(&self, pairingState: bool) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromPairingState)(self.0.as_abi() as *const _ as *mut _, pairingState, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_connection_status(&self, connectionStatus: BluetoothConnectionStatus) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromConnectionStatus)(self.0.as_abi() as *const _ as *mut _, connectionStatus, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_device_name(&self, deviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromDeviceName)(self.0.as_abi() as *const _ as *mut _, deviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address(&self, bluetoothAddress: u64) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self.0.as_abi() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_class_of_device(&self, classOfDevice: &BluetoothClassOfDevice) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromClassOfDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(classOfDevice) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2, DeviceNotConnected = 3, OtherError = 4, DisabledByPolicy = 5, NotSupported = 6, DisabledByUser = 7, ConsentRequired = 8, TransportNotSupported = 9,
}}
DEFINE_IID!(IID_IBluetoothLEAppearance, 1562409458, 26280, 16984, 152, 94, 2, 180, 217, 80, 159, 24);
RT_INTERFACE!{interface IBluetoothLEAppearance(IBluetoothLEAppearanceVtbl, IBluetoothLEAppearance_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearance] {
    fn get_RawValue(&self, out: *mut u16) -> HRESULT,
    fn get_Category(&self, out: *mut u16) -> HRESULT,
    fn get_SubCategory(&self, out: *mut u16) -> HRESULT
}}
impl IBluetoothLEAppearance {
    #[inline] pub fn get_raw_value(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_category(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Category)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sub_category(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAppearance: IBluetoothLEAppearance}
impl RtActivatable<IBluetoothLEAppearanceStatics> for BluetoothLEAppearance {}
impl BluetoothLEAppearance {
    #[inline] pub fn from_raw_value(rawValue: u16) -> Result<Option<BluetoothLEAppearance>> {
        <Self as RtActivatable<IBluetoothLEAppearanceStatics>>::get_activation_factory().from_raw_value(rawValue)
    }
    #[inline] pub fn from_parts(appearanceCategory: u16, appearanceSubCategory: u16) -> Result<Option<BluetoothLEAppearance>> {
        <Self as RtActivatable<IBluetoothLEAppearanceStatics>>::get_activation_factory().from_parts(appearanceCategory, appearanceSubCategory)
    }
}
DEFINE_CLSID!(BluetoothLEAppearance(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,0]) [CLSID_BluetoothLEAppearance]);
RT_CLASS!{static class BluetoothLEAppearanceCategories}
impl RtActivatable<IBluetoothLEAppearanceCategoriesStatics> for BluetoothLEAppearanceCategories {}
impl BluetoothLEAppearanceCategories {
    #[inline] pub fn get_uncategorized() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_uncategorized()
    }
    #[inline] pub fn get_phone() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_phone()
    }
    #[inline] pub fn get_computer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_computer()
    }
    #[inline] pub fn get_watch() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_watch()
    }
    #[inline] pub fn get_clock() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_clock()
    }
    #[inline] pub fn get_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_display()
    }
    #[inline] pub fn get_remote_control() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_remote_control()
    }
    #[inline] pub fn get_eye_glasses() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_eye_glasses()
    }
    #[inline] pub fn get_tag() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_tag()
    }
    #[inline] pub fn get_keyring() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_keyring()
    }
    #[inline] pub fn get_media_player() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_media_player()
    }
    #[inline] pub fn get_barcode_scanner() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_barcode_scanner()
    }
    #[inline] pub fn get_thermometer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_thermometer()
    }
    #[inline] pub fn get_heart_rate() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_heart_rate()
    }
    #[inline] pub fn get_blood_pressure() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_blood_pressure()
    }
    #[inline] pub fn get_human_interface_device() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_human_interface_device()
    }
    #[inline] pub fn get_glucose_meter() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_glucose_meter()
    }
    #[inline] pub fn get_running_walking() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_running_walking()
    }
    #[inline] pub fn get_cycling() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_cycling()
    }
    #[inline] pub fn get_pulse_oximeter() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_pulse_oximeter()
    }
    #[inline] pub fn get_weight_scale() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_weight_scale()
    }
    #[inline] pub fn get_outdoor_sport_activity() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_outdoor_sport_activity()
    }
}
DEFINE_CLSID!(BluetoothLEAppearanceCategories(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,67,97,116,101,103,111,114,105,101,115,0]) [CLSID_BluetoothLEAppearanceCategories]);
DEFINE_IID!(IID_IBluetoothLEAppearanceCategoriesStatics, 1833784574, 1130, 16773, 170, 182, 130, 76, 240, 97, 8, 97);
RT_INTERFACE!{static interface IBluetoothLEAppearanceCategoriesStatics(IBluetoothLEAppearanceCategoriesStaticsVtbl, IBluetoothLEAppearanceCategoriesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceCategoriesStatics] {
    fn get_Uncategorized(&self, out: *mut u16) -> HRESULT,
    fn get_Phone(&self, out: *mut u16) -> HRESULT,
    fn get_Computer(&self, out: *mut u16) -> HRESULT,
    fn get_Watch(&self, out: *mut u16) -> HRESULT,
    fn get_Clock(&self, out: *mut u16) -> HRESULT,
    fn get_Display(&self, out: *mut u16) -> HRESULT,
    fn get_RemoteControl(&self, out: *mut u16) -> HRESULT,
    fn get_EyeGlasses(&self, out: *mut u16) -> HRESULT,
    fn get_Tag(&self, out: *mut u16) -> HRESULT,
    fn get_Keyring(&self, out: *mut u16) -> HRESULT,
    fn get_MediaPlayer(&self, out: *mut u16) -> HRESULT,
    fn get_BarcodeScanner(&self, out: *mut u16) -> HRESULT,
    fn get_Thermometer(&self, out: *mut u16) -> HRESULT,
    fn get_HeartRate(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressure(&self, out: *mut u16) -> HRESULT,
    fn get_HumanInterfaceDevice(&self, out: *mut u16) -> HRESULT,
    fn get_GlucoseMeter(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalking(&self, out: *mut u16) -> HRESULT,
    fn get_Cycling(&self, out: *mut u16) -> HRESULT,
    fn get_PulseOximeter(&self, out: *mut u16) -> HRESULT,
    fn get_WeightScale(&self, out: *mut u16) -> HRESULT,
    fn get_OutdoorSportActivity(&self, out: *mut u16) -> HRESULT
}}
impl IBluetoothLEAppearanceCategoriesStatics {
    #[inline] pub fn get_uncategorized(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uncategorized)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phone(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Phone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_computer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Computer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_watch(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Watch)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_clock(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Clock)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Display)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_control(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemoteControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_glasses(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EyeGlasses)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tag)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_keyring(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Keyring)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_player(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MediaPlayer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_barcode_scanner(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BarcodeScanner)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thermometer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Thermometer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeartRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_human_interface_device(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HumanInterfaceDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_meter(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GlucoseMeter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RunningWalking)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Cycling)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pulse_oximeter(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PulseOximeter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_weight_scale(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WeightScale)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_outdoor_sport_activity(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutdoorSportActivity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAppearanceStatics, 2710814919, 17668, 20298, 155, 165, 205, 16, 84, 229, 224, 101);
RT_INTERFACE!{static interface IBluetoothLEAppearanceStatics(IBluetoothLEAppearanceStaticsVtbl, IBluetoothLEAppearanceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceStatics] {
    fn FromRawValue(&self, rawValue: u16, out: *mut <BluetoothLEAppearance as RtType>::Abi) -> HRESULT,
    fn FromParts(&self, appearanceCategory: u16, appearanceSubCategory: u16, out: *mut <BluetoothLEAppearance as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAppearanceStatics {
    #[inline] pub fn from_raw_value(&self, rawValue: u16) -> Result<Option<BluetoothLEAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromRawValue)(self.0.as_abi() as *const _ as *mut _, rawValue, &mut out);
        if hr == S_OK { Ok(BluetoothLEAppearance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parts(&self, appearanceCategory: u16, appearanceSubCategory: u16) -> Result<Option<BluetoothLEAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromParts)(self.0.as_abi() as *const _ as *mut _, appearanceCategory, appearanceSubCategory, &mut out);
        if hr == S_OK { Ok(BluetoothLEAppearance::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class BluetoothLEAppearanceSubcategories}
impl RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics> for BluetoothLEAppearanceSubcategories {}
impl BluetoothLEAppearanceSubcategories {
    #[inline] pub fn get_generic() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_generic()
    }
    #[inline] pub fn get_sports_watch() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_sports_watch()
    }
    #[inline] pub fn get_thermometer_ear() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_thermometer_ear()
    }
    #[inline] pub fn get_heart_rate_belt() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_heart_rate_belt()
    }
    #[inline] pub fn get_blood_pressure_arm() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_blood_pressure_arm()
    }
    #[inline] pub fn get_blood_pressure_wrist() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_blood_pressure_wrist()
    }
    #[inline] pub fn get_keyboard() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_keyboard()
    }
    #[inline] pub fn get_mouse() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_mouse()
    }
    #[inline] pub fn get_joystick() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_joystick()
    }
    #[inline] pub fn get_gamepad() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_gamepad()
    }
    #[inline] pub fn get_digitizer_tablet() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_digitizer_tablet()
    }
    #[inline] pub fn get_card_reader() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_card_reader()
    }
    #[inline] pub fn get_digital_pen() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_digital_pen()
    }
    #[inline] pub fn get_barcode_scanner() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_barcode_scanner()
    }
    #[inline] pub fn get_running_walking_in_shoe() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_in_shoe()
    }
    #[inline] pub fn get_running_walking_on_shoe() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_on_shoe()
    }
    #[inline] pub fn get_running_walking_on_hip() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_on_hip()
    }
    #[inline] pub fn get_cycling_computer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_computer()
    }
    #[inline] pub fn get_cycling_speed_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_speed_sensor()
    }
    #[inline] pub fn get_cycling_cadence_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_cadence_sensor()
    }
    #[inline] pub fn get_cycling_power_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_power_sensor()
    }
    #[inline] pub fn get_cycling_speed_cadence_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_speed_cadence_sensor()
    }
    #[inline] pub fn get_oximeter_fingertip() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_oximeter_fingertip()
    }
    #[inline] pub fn get_oximeter_wrist_worn() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_oximeter_wrist_worn()
    }
    #[inline] pub fn get_location_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_display()
    }
    #[inline] pub fn get_location_navigation_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_navigation_display()
    }
    #[inline] pub fn get_location_pod() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_pod()
    }
    #[inline] pub fn get_location_navigation_pod() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_navigation_pod()
    }
}
DEFINE_CLSID!(BluetoothLEAppearanceSubcategories(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,83,117,98,99,97,116,101,103,111,114,105,101,115,0]) [CLSID_BluetoothLEAppearanceSubcategories]);
DEFINE_IID!(IID_IBluetoothLEAppearanceSubcategoriesStatics, 3850085894, 8516, 16730, 131, 18, 113, 204, 242, 145, 248, 209);
RT_INTERFACE!{static interface IBluetoothLEAppearanceSubcategoriesStatics(IBluetoothLEAppearanceSubcategoriesStaticsVtbl, IBluetoothLEAppearanceSubcategoriesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceSubcategoriesStatics] {
    fn get_Generic(&self, out: *mut u16) -> HRESULT,
    fn get_SportsWatch(&self, out: *mut u16) -> HRESULT,
    fn get_ThermometerEar(&self, out: *mut u16) -> HRESULT,
    fn get_HeartRateBelt(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressureArm(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressureWrist(&self, out: *mut u16) -> HRESULT,
    fn get_Keyboard(&self, out: *mut u16) -> HRESULT,
    fn get_Mouse(&self, out: *mut u16) -> HRESULT,
    fn get_Joystick(&self, out: *mut u16) -> HRESULT,
    fn get_Gamepad(&self, out: *mut u16) -> HRESULT,
    fn get_DigitizerTablet(&self, out: *mut u16) -> HRESULT,
    fn get_CardReader(&self, out: *mut u16) -> HRESULT,
    fn get_DigitalPen(&self, out: *mut u16) -> HRESULT,
    fn get_BarcodeScanner(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingInShoe(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingOnShoe(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingOnHip(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingComputer(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingSpeedSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingCadenceSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingPowerSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingSpeedCadenceSensor(&self, out: *mut u16) -> HRESULT,
    fn get_OximeterFingertip(&self, out: *mut u16) -> HRESULT,
    fn get_OximeterWristWorn(&self, out: *mut u16) -> HRESULT,
    fn get_LocationDisplay(&self, out: *mut u16) -> HRESULT,
    fn get_LocationNavigationDisplay(&self, out: *mut u16) -> HRESULT,
    fn get_LocationPod(&self, out: *mut u16) -> HRESULT,
    fn get_LocationNavigationPod(&self, out: *mut u16) -> HRESULT
}}
impl IBluetoothLEAppearanceSubcategoriesStatics {
    #[inline] pub fn get_generic(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Generic)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sports_watch(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SportsWatch)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thermometer_ear(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ThermometerEar)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_belt(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeartRateBelt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_arm(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressureArm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_wrist(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressureWrist)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_keyboard(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Keyboard)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mouse)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_joystick(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Joystick)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gamepad(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gamepad)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_digitizer_tablet(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DigitizerTablet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_card_reader(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CardReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_digital_pen(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DigitalPen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_barcode_scanner(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BarcodeScanner)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_in_shoe(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RunningWalkingInShoe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_on_shoe(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RunningWalkingOnShoe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_on_hip(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RunningWalkingOnHip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_computer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingComputer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingSpeedSensor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_cadence_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingCadenceSensor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPowerSensor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_cadence_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingSpeedCadenceSensor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_oximeter_fingertip(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OximeterFingertip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_oximeter_wrist_worn(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OximeterWristWorn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationDisplay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_navigation_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationNavigationDisplay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_pod(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationPod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_navigation_pod(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationNavigationPod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice, 3052285819, 19160, 17986, 172, 72, 128, 160, 181, 0, 232, 135);
RT_INTERFACE!{interface IBluetoothLEDevice(IBluetoothLEDeviceVtbl, IBluetoothLEDevice_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_GattServices(&self, out: *mut <foundation::collections::IVectorView<genericattributeprofile::GattDeviceService> as RtType>::Abi) -> HRESULT,
    fn get_ConnectionStatus(&self, out: *mut BluetoothConnectionStatus) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn GetGattService(&self, serviceUuid: Guid, out: *mut <genericattributeprofile::GattDeviceService as RtType>::Abi) -> HRESULT,
    fn add_NameChanged(&self, handler: <foundation::TypedEventHandler<BluetoothLEDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GattServicesChanged(&self, handler: <foundation::TypedEventHandler<BluetoothLEDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GattServicesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: <foundation::TypedEventHandler<BluetoothLEDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBluetoothLEDevice {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services(&self) -> Result<Option<foundation::collections::IVectorView<genericattributeprofile::GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GattServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_status(&self) -> Result<BluetoothConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_service(&self, serviceUuid: Guid) -> Result<Option<genericattributeprofile::GattDeviceService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGattService)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(genericattributeprofile::GattDeviceService::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_name_changed(&self, handler: &foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_NameChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_name_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_NameChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gatt_services_changed(&self, handler: &foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GattServicesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gatt_services_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GattServicesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEDevice: IBluetoothLEDevice}
impl RtActivatable<IBluetoothLEDeviceStatics> for BluetoothLEDevice {}
impl RtActivatable<IBluetoothLEDeviceStatics2> for BluetoothLEDevice {}
impl BluetoothLEDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn from_bluetooth_address_async(bluetoothAddress: u64) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().from_bluetooth_address_async(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_pairing_state(pairingState: bool) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_pairing_state(pairingState)
    }
    #[inline] pub fn get_device_selector_from_connection_status(connectionStatus: BluetoothConnectionStatus) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_connection_status(connectionStatus)
    }
    #[inline] pub fn get_device_selector_from_device_name(deviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_device_name(deviceName)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address(bluetoothAddress: u64) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address_with_bluetooth_address_type(bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address_with_bluetooth_address_type(bluetoothAddress, bluetoothAddressType)
    }
    #[inline] pub fn get_device_selector_from_appearance(appearance: &BluetoothLEAppearance) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_appearance(appearance)
    }
    #[inline] pub fn from_bluetooth_address_with_bluetooth_address_type_async(bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().from_bluetooth_address_with_bluetooth_address_type_async(bluetoothAddress, bluetoothAddressType)
    }
}
DEFINE_CLSID!(BluetoothLEDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,68,101,118,105,99,101,0]) [CLSID_BluetoothLEDevice]);
DEFINE_IID!(IID_IBluetoothLEDevice2, 653288115, 31470, 19761, 186, 186, 177, 185, 119, 95, 89, 22);
RT_INTERFACE!{interface IBluetoothLEDevice2(IBluetoothLEDevice2Vtbl, IBluetoothLEDevice2_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice2] {
    fn get_DeviceInformation(&self, out: *mut <super::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_Appearance(&self, out: *mut <BluetoothLEAppearance as RtType>::Abi) -> HRESULT,
    fn get_BluetoothAddressType(&self, out: *mut BluetoothAddressType) -> HRESULT
}}
impl IBluetoothLEDevice2 {
    #[inline] pub fn get_device_information(&self) -> Result<Option<super::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<Option<BluetoothLEAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Appearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAppearance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address_type(&self) -> Result<BluetoothAddressType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothAddressType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice3, 2934563987, 17580, 16604, 175, 51, 178, 193, 60, 1, 202, 70);
RT_INTERFACE!{interface IBluetoothLEDevice3(IBluetoothLEDevice3Vtbl, IBluetoothLEDevice3_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice3] {
    fn get_DeviceAccessInformation(&self, out: *mut <super::enumeration::DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus> as RtType>::Abi) -> HRESULT,
    fn GetGattServicesAsync(&self, out: *mut <foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetGattServicesWithCacheModeAsync(&self, cacheMode: BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetGattServicesForUuidAsync(&self, serviceUuid: Guid, out: *mut <foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetGattServicesForUuidWithCacheModeAsync(&self, serviceUuid: Guid, cacheMode: BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEDevice3 {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<super::enumeration::DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceAccessInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_async(&self) -> Result<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGattServicesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_with_cache_mode_async(&self, cacheMode: BluetoothCacheMode) -> Result<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGattServicesWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_for_uuid_async(&self, serviceUuid: Guid) -> Result<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGattServicesForUuidAsync)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_for_uuid_with_cache_mode_async(&self, serviceUuid: Guid, cacheMode: BluetoothCacheMode) -> Result<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGattServicesForUuidWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice4, 727732273, 8776, 19247, 172, 240, 124, 238, 54, 252, 88, 112);
RT_INTERFACE!{interface IBluetoothLEDevice4(IBluetoothLEDevice4Vtbl, IBluetoothLEDevice4_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice4] {
    fn get_BluetoothDeviceId(&self, out: *mut <BluetoothDeviceId as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEDevice4 {
    #[inline] pub fn get_bluetooth_device_id(&self) -> Result<Option<BluetoothDeviceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothDeviceId::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice5, 2640974432, 21127, 17806, 149, 186, 23, 200, 183, 187, 50, 110);
RT_INTERFACE!{interface IBluetoothLEDevice5(IBluetoothLEDevice5Vtbl, IBluetoothLEDevice5_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice5] {
    fn get_WasSecureConnectionUsedForPairing(&self, out: *mut bool) -> HRESULT
}}
impl IBluetoothLEDevice5 {
    #[inline] pub fn get_was_secure_connection_used_for_pairing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WasSecureConnectionUsedForPairing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDeviceStatics, 3369015833, 61622, 19440, 134, 137, 65, 48, 61, 226, 217, 244);
RT_INTERFACE!{static interface IBluetoothLEDeviceStatics(IBluetoothLEDeviceStaticsVtbl, IBluetoothLEDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<BluetoothLEDevice> as RtType>::Abi) -> HRESULT,
    fn FromBluetoothAddressAsync(&self, bluetoothAddress: u64, out: *mut <foundation::IAsyncOperation<BluetoothLEDevice> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBluetoothLEDeviceStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_async(&self, bluetoothAddress: u64) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromBluetoothAddressAsync)(self.0.as_abi() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDeviceStatics2, 1595064427, 15276, 17384, 173, 22, 86, 50, 113, 189, 65, 194);
RT_INTERFACE!{static interface IBluetoothLEDeviceStatics2(IBluetoothLEDeviceStatics2Vtbl, IBluetoothLEDeviceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics2] {
    fn GetDeviceSelectorFromPairingState(&self, pairingState: bool, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromConnectionStatus(&self, connectionStatus: BluetoothConnectionStatus, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromDeviceName(&self, deviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddress(&self, bluetoothAddress: u64, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromAppearance(&self, appearance: <BluetoothLEAppearance as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn FromBluetoothAddressWithBluetoothAddressTypeAsync(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut <foundation::IAsyncOperation<BluetoothLEDevice> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEDeviceStatics2 {
    #[inline] pub fn get_device_selector_from_pairing_state(&self, pairingState: bool) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromPairingState)(self.0.as_abi() as *const _ as *mut _, pairingState, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_connection_status(&self, connectionStatus: BluetoothConnectionStatus) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromConnectionStatus)(self.0.as_abi() as *const _ as *mut _, connectionStatus, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_device_name(&self, deviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromDeviceName)(self.0.as_abi() as *const _ as *mut _, deviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address(&self, bluetoothAddress: u64) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self.0.as_abi() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address_with_bluetooth_address_type(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType)(self.0.as_abi() as *const _ as *mut _, bluetoothAddress, bluetoothAddressType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_appearance(&self, appearance: &BluetoothLEAppearance) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromAppearance)(self.0.as_abi() as *const _ as *mut _, get_abi(appearance) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_with_bluetooth_address_type_async(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<foundation::IAsyncOperation<BluetoothLEDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromBluetoothAddressWithBluetoothAddressTypeAsync)(self.0.as_abi() as *const _ as *mut _, bluetoothAddress, bluetoothAddressType, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothMajorClass: i32 {
    Miscellaneous = 0, Computer = 1, Phone = 2, NetworkAccessPoint = 3, AudioVideo = 4, Peripheral = 5, Imaging = 6, Wearable = 7, Toy = 8, Health = 9,
}}
RT_ENUM! { enum BluetoothMinorClass: i32 {
    Uncategorized = 0, ComputerDesktop = 1, ComputerServer = 2, ComputerLaptop = 3, ComputerHandheld = 4, ComputerPalmSize = 5, ComputerWearable = 6, ComputerTablet = 7, PhoneCellular = 1, PhoneCordless = 2, PhoneSmartPhone = 3, PhoneWired = 4, PhoneIsdn = 5, NetworkFullyAvailable = 0, NetworkUsed01To17Percent = 8, NetworkUsed17To33Percent = 16, NetworkUsed33To50Percent = 24, NetworkUsed50To67Percent = 32, NetworkUsed67To83Percent = 40, NetworkUsed83To99Percent = 48, NetworkNoServiceAvailable = 56, AudioVideoWearableHeadset = 1, AudioVideoHandsFree = 2, AudioVideoMicrophone = 4, AudioVideoLoudspeaker = 5, AudioVideoHeadphones = 6, AudioVideoPortableAudio = 7, AudioVideoCarAudio = 8, AudioVideoSetTopBox = 9, AudioVideoHifiAudioDevice = 10, AudioVideoVcr = 11, AudioVideoVideoCamera = 12, AudioVideoCamcorder = 13, AudioVideoVideoMonitor = 14, AudioVideoVideoDisplayAndLoudspeaker = 15, AudioVideoVideoConferencing = 16, AudioVideoGamingOrToy = 18, PeripheralJoystick = 1, PeripheralGamepad = 2, PeripheralRemoteControl = 3, PeripheralSensing = 4, PeripheralDigitizerTablet = 5, PeripheralCardReader = 6, PeripheralDigitalPen = 7, PeripheralHandheldScanner = 8, PeripheralHandheldGesture = 9, WearableWristwatch = 1, WearablePager = 2, WearableJacket = 3, WearableHelmet = 4, WearableGlasses = 5, ToyRobot = 1, ToyVehicle = 2, ToyDoll = 3, ToyController = 4, ToyGame = 5, HealthBloodPressureMonitor = 1, HealthThermometer = 2, HealthWeighingScale = 3, HealthGlucoseMeter = 4, HealthPulseOximeter = 5, HealthHeartRateMonitor = 6, HealthHealthDataDisplay = 7, HealthStepCounter = 8, HealthBodyCompositionAnalyzer = 9, HealthPeakFlowMonitor = 10, HealthMedicationMonitor = 11, HealthKneeProsthesis = 12, HealthAnkleProsthesis = 13, HealthGenericHealthManager = 14, HealthPersonalMobilityDevice = 15,
}}
RT_ENUM! { enum BluetoothServiceCapabilities: u32 {
    None = 0, LimitedDiscoverableMode = 1, PositioningService = 8, NetworkingService = 16, RenderingService = 32, CapturingService = 64, ObjectTransferService = 128, AudioService = 256, TelephoneService = 512, InformationService = 1024,
}}
DEFINE_IID!(IID_IBluetoothSignalStrengthFilter, 3749409681, 27573, 19710, 144, 177, 93, 115, 36, 237, 207, 127);
RT_INTERFACE!{interface IBluetoothSignalStrengthFilter(IBluetoothSignalStrengthFilterVtbl, IBluetoothSignalStrengthFilter_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothSignalStrengthFilter] {
    fn get_InRangeThresholdInDBm(&self, out: *mut <foundation::IReference<i16> as RtType>::Abi) -> HRESULT,
    fn put_InRangeThresholdInDBm(&self, value: <foundation::IReference<i16> as RtType>::Abi) -> HRESULT,
    fn get_OutOfRangeThresholdInDBm(&self, out: *mut <foundation::IReference<i16> as RtType>::Abi) -> HRESULT,
    fn put_OutOfRangeThresholdInDBm(&self, value: <foundation::IReference<i16> as RtType>::Abi) -> HRESULT,
    fn get_OutOfRangeTimeout(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_OutOfRangeTimeout(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_SamplingInterval(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn put_SamplingInterval(&self, value: <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothSignalStrengthFilter {
    #[inline] pub fn get_in_range_threshold_in_dbm(&self) -> Result<Option<foundation::IReference<i16>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InRangeThresholdInDBm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_in_range_threshold_in_dbm(&self, value: &foundation::IReference<i16>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InRangeThresholdInDBm)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_out_of_range_threshold_in_dbm(&self) -> Result<Option<foundation::IReference<i16>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutOfRangeThresholdInDBm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_out_of_range_threshold_in_dbm(&self, value: &foundation::IReference<i16>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutOfRangeThresholdInDBm)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_out_of_range_timeout(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutOfRangeTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_out_of_range_timeout(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutOfRangeTimeout)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sampling_interval(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SamplingInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sampling_interval(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SamplingInterval)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothSignalStrengthFilter: IBluetoothSignalStrengthFilter}
impl RtActivatable<IActivationFactory> for BluetoothSignalStrengthFilter {}
DEFINE_CLSID!(BluetoothSignalStrengthFilter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,83,105,103,110,97,108,83,116,114,101,110,103,116,104,70,105,108,116,101,114,0]) [CLSID_BluetoothSignalStrengthFilter]);
RT_CLASS!{static class BluetoothUuidHelper}
impl RtActivatable<IBluetoothUuidHelperStatics> for BluetoothUuidHelper {}
impl BluetoothUuidHelper {
    #[inline] pub fn from_short_id(shortId: u32) -> Result<Guid> {
        <Self as RtActivatable<IBluetoothUuidHelperStatics>>::get_activation_factory().from_short_id(shortId)
    }
    #[inline] pub fn try_get_short_id(uuid: Guid) -> Result<Option<foundation::IReference<u32>>> {
        <Self as RtActivatable<IBluetoothUuidHelperStatics>>::get_activation_factory().try_get_short_id(uuid)
    }
}
DEFINE_CLSID!(BluetoothUuidHelper(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,85,117,105,100,72,101,108,112,101,114,0]) [CLSID_BluetoothUuidHelper]);
DEFINE_IID!(IID_IBluetoothUuidHelperStatics, 400493784, 53108, 19233, 175, 230, 245, 122, 17, 188, 222, 160);
RT_INTERFACE!{static interface IBluetoothUuidHelperStatics(IBluetoothUuidHelperStaticsVtbl, IBluetoothUuidHelperStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothUuidHelperStatics] {
    fn FromShortId(&self, shortId: u32, out: *mut Guid) -> HRESULT,
    fn TryGetShortId(&self, uuid: Guid, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothUuidHelperStatics {
    #[inline] pub fn from_short_id(&self, shortId: u32) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).FromShortId)(self.0.as_abi() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_short_id(&self, uuid: Guid) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetShortId)(self.0.as_abi() as *const _ as *mut _, uuid, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
pub mod advertisement { // Windows.Devices.Bluetooth.Advertisement
use crate::prelude::*;
DEFINE_IID!(IID_IBluetoothLEAdvertisement, 107983543, 13265, 20093, 131, 103, 207, 129, 208, 247, 150, 83);
RT_INTERFACE!{interface IBluetoothLEAdvertisement(IBluetoothLEAdvertisementVtbl, IBluetoothLEAdvertisement_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisement] {
    fn get_Flags(&self, out: *mut <foundation::IReference<BluetoothLEAdvertisementFlags> as RtType>::Abi) -> HRESULT,
    fn put_Flags(&self, value: <foundation::IReference<BluetoothLEAdvertisementFlags> as RtType>::Abi) -> HRESULT,
    fn get_LocalName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LocalName(&self, value: HSTRING) -> HRESULT,
    fn get_ServiceUuids(&self, out: *mut <foundation::collections::IVector<Guid> as RtType>::Abi) -> HRESULT,
    fn get_ManufacturerData(&self, out: *mut <foundation::collections::IVector<BluetoothLEManufacturerData> as RtType>::Abi) -> HRESULT,
    fn get_DataSections(&self, out: *mut <foundation::collections::IVector<BluetoothLEAdvertisementDataSection> as RtType>::Abi) -> HRESULT,
    fn GetManufacturerDataByCompanyId(&self, companyId: u16, out: *mut <foundation::collections::IVectorView<BluetoothLEManufacturerData> as RtType>::Abi) -> HRESULT,
    fn GetSectionsByType(&self, type_: u8, out: *mut <foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisement {
    #[inline] pub fn get_flags(&self) -> Result<Option<foundation::IReference<BluetoothLEAdvertisementFlags>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Flags)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_flags(&self, value: &foundation::IReference<BluetoothLEAdvertisementFlags>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Flags)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_local_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocalName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_local_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LocalName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_uuids(&self) -> Result<Option<foundation::collections::IVector<Guid>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_data(&self) -> Result<Option<foundation::collections::IVector<BluetoothLEManufacturerData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ManufacturerData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_data_sections(&self) -> Result<Option<foundation::collections::IVector<BluetoothLEAdvertisementDataSection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataSections)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_data_by_company_id(&self, companyId: u16) -> Result<Option<foundation::collections::IVectorView<BluetoothLEManufacturerData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetManufacturerDataByCompanyId)(self.0.as_abi() as *const _ as *mut _, companyId, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sections_by_type(&self, type_: u8) -> Result<Option<foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSectionsByType)(self.0.as_abi() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisement: IBluetoothLEAdvertisement}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisement {}
DEFINE_CLSID!(BluetoothLEAdvertisement(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,0]) [CLSID_BluetoothLEAdvertisement]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePattern, 4227520498, 47557, 18952, 188, 81, 80, 47, 142, 246, 138, 121);
RT_INTERFACE!{interface IBluetoothLEAdvertisementBytePattern(IBluetoothLEAdvertisementBytePatternVtbl, IBluetoothLEAdvertisementBytePattern_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePattern] {
    fn get_DataType(&self, out: *mut u8) -> HRESULT,
    fn put_DataType(&self, value: u8) -> HRESULT,
    fn get_Offset(&self, out: *mut i16) -> HRESULT,
    fn put_Offset(&self, value: i16) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementBytePattern {
    #[inline] pub fn get_data_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Offset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: i16) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Offset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementBytePattern: IBluetoothLEAdvertisementBytePattern}
impl RtActivatable<IBluetoothLEAdvertisementBytePatternFactory> for BluetoothLEAdvertisementBytePattern {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementBytePattern {}
impl BluetoothLEAdvertisementBytePattern {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(dataType: u8, offset: i16, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEAdvertisementBytePattern> {
        <Self as RtActivatable<IBluetoothLEAdvertisementBytePatternFactory>>::get_activation_factory().create(dataType, offset, data)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementBytePattern(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,66,121,116,101,80,97,116,116,101,114,110,0]) [CLSID_BluetoothLEAdvertisementBytePattern]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePatternFactory, 3269610867, 64860, 20163, 190, 42, 156, 166, 250, 17, 183, 189);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementBytePatternFactory(IBluetoothLEAdvertisementBytePatternFactoryVtbl, IBluetoothLEAdvertisementBytePatternFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePatternFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, dataType: u8, offset: i16, data: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <BluetoothLEAdvertisementBytePattern as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementBytePatternFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, dataType: u8, offset: i16, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEAdvertisementBytePattern> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, dataType, offset, get_abi(data) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisementBytePattern::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSection, 3609277204, 14915, 16633, 182, 240, 146, 191, 239, 195, 74, 227);
RT_INTERFACE!{interface IBluetoothLEAdvertisementDataSection(IBluetoothLEAdvertisementDataSectionVtbl, IBluetoothLEAdvertisementDataSection_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSection] {
    fn get_DataType(&self, out: *mut u8) -> HRESULT,
    fn put_DataType(&self, value: u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementDataSection {
    #[inline] pub fn get_data_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementDataSection: IBluetoothLEAdvertisementDataSection}
impl RtActivatable<IBluetoothLEAdvertisementDataSectionFactory> for BluetoothLEAdvertisementDataSection {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementDataSection {}
impl BluetoothLEAdvertisementDataSection {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(dataType: u8, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEAdvertisementDataSection> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataSectionFactory>>::get_activation_factory().create(dataType, data)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementDataSection(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,83,101,99,116,105,111,110,0]) [CLSID_BluetoothLEAdvertisementDataSection]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSectionFactory, 3886287170, 43077, 16453, 191, 126, 62, 153, 113, 219, 138, 107);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataSectionFactory(IBluetoothLEAdvertisementDataSectionFactoryVtbl, IBluetoothLEAdvertisementDataSectionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSectionFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, dataType: u8, data: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <BluetoothLEAdvertisementDataSection as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementDataSectionFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, dataType: u8, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEAdvertisementDataSection> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, dataType, get_abi(data) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisementDataSection::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class BluetoothLEAdvertisementDataTypes}
impl RtActivatable<IBluetoothLEAdvertisementDataTypesStatics> for BluetoothLEAdvertisementDataTypes {}
impl BluetoothLEAdvertisementDataTypes {
    #[inline] pub fn get_flags() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_flags()
    }
    #[inline] pub fn get_incomplete_service_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_16_bit_uuids()
    }
    #[inline] pub fn get_complete_service_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_16_bit_uuids()
    }
    #[inline] pub fn get_incomplete_service_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_32_bit_uuids()
    }
    #[inline] pub fn get_complete_service_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_32_bit_uuids()
    }
    #[inline] pub fn get_incomplete_service_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_128_bit_uuids()
    }
    #[inline] pub fn get_complete_service_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_128_bit_uuids()
    }
    #[inline] pub fn get_shortened_local_name() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_shortened_local_name()
    }
    #[inline] pub fn get_complete_local_name() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_local_name()
    }
    #[inline] pub fn get_tx_power_level() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_tx_power_level()
    }
    #[inline] pub fn get_slave_connection_interval_range() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_slave_connection_interval_range()
    }
    #[inline] pub fn get_service_solicitation_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_16_bit_uuids()
    }
    #[inline] pub fn get_service_solicitation_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_32_bit_uuids()
    }
    #[inline] pub fn get_service_solicitation_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_128_bit_uuids()
    }
    #[inline] pub fn get_service_data_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_16_bit_uuids()
    }
    #[inline] pub fn get_service_data_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_32_bit_uuids()
    }
    #[inline] pub fn get_service_data_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_128_bit_uuids()
    }
    #[inline] pub fn get_public_target_address() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_public_target_address()
    }
    #[inline] pub fn get_random_target_address() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_random_target_address()
    }
    #[inline] pub fn get_appearance() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_appearance()
    }
    #[inline] pub fn get_advertising_interval() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_advertising_interval()
    }
    #[inline] pub fn get_manufacturer_specific_data() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_manufacturer_specific_data()
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementDataTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,84,121,112,101,115,0]) [CLSID_BluetoothLEAdvertisementDataTypes]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataTypesStatics, 1001801519, 1542, 17227, 167, 110, 116, 21, 159, 6, 132, 211);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataTypesStatics(IBluetoothLEAdvertisementDataTypesStaticsVtbl, IBluetoothLEAdvertisementDataTypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataTypesStatics] {
    fn get_Flags(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ShortenedLocalName(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteLocalName(&self, out: *mut u8) -> HRESULT,
    fn get_TxPowerLevel(&self, out: *mut u8) -> HRESULT,
    fn get_SlaveConnectionIntervalRange(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_PublicTargetAddress(&self, out: *mut u8) -> HRESULT,
    fn get_RandomTargetAddress(&self, out: *mut u8) -> HRESULT,
    fn get_Appearance(&self, out: *mut u8) -> HRESULT,
    fn get_AdvertisingInterval(&self, out: *mut u8) -> HRESULT,
    fn get_ManufacturerSpecificData(&self, out: *mut u8) -> HRESULT
}}
impl IBluetoothLEAdvertisementDataTypesStatics {
    #[inline] pub fn get_flags(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Flags)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IncompleteService16BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompleteService16BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IncompleteService32BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompleteService32BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IncompleteService128BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompleteService128BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_shortened_local_name(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShortenedLocalName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_local_name(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompleteLocalName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power_level(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TxPowerLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_slave_connection_interval_range(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SlaveConnectionIntervalRange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceSolicitation16BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceSolicitation32BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceSolicitation128BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceData16BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceData32BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceData128BitUuids)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_public_target_address(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PublicTargetAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_random_target_address(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RandomTargetAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Appearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertising_interval(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisingInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_specific_data(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ManufacturerSpecificData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAdvertisementFilter, 320778451, 53326, 18353, 131, 126, 73, 64, 91, 246, 248, 15);
RT_INTERFACE!{interface IBluetoothLEAdvertisementFilter(IBluetoothLEAdvertisementFilterVtbl, IBluetoothLEAdvertisementFilter_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementFilter] {
    fn get_Advertisement(&self, out: *mut <BluetoothLEAdvertisement as RtType>::Abi) -> HRESULT,
    fn put_Advertisement(&self, value: <BluetoothLEAdvertisement as RtType>::Abi) -> HRESULT,
    fn get_BytePatterns(&self, out: *mut <foundation::collections::IVector<BluetoothLEAdvertisementBytePattern> as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementFilter {
    #[inline] pub fn get_advertisement(&self) -> Result<Option<BluetoothLEAdvertisement>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Advertisement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisement::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_advertisement(&self, value: &BluetoothLEAdvertisement) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Advertisement)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_byte_patterns(&self) -> Result<Option<foundation::collections::IVector<BluetoothLEAdvertisementBytePattern>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BytePatterns)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementFilter: IBluetoothLEAdvertisementFilter}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementFilter {}
DEFINE_CLSID!(BluetoothLEAdvertisementFilter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,70,105,108,116,101,114,0]) [CLSID_BluetoothLEAdvertisementFilter]);
RT_ENUM! { enum BluetoothLEAdvertisementFlags: u32 {
    None = 0, LimitedDiscoverableMode = 1, GeneralDiscoverableMode = 2, ClassicNotSupported = 4, DualModeControllerCapable = 8, DualModeHostCapable = 16,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisher, 3454542073, 55802, 17366, 162, 100, 221, 216, 183, 218, 139, 120);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisher(IBluetoothLEAdvertisementPublisherVtbl, IBluetoothLEAdvertisementPublisher_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisher] {
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Advertisement(&self, out: *mut <BluetoothLEAdvertisement as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_StatusChanged(&self, handler: <foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisher {
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement(&self) -> Result<Option<BluetoothLEAdvertisement>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Advertisement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisement::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisher: IBluetoothLEAdvertisementPublisher}
impl RtActivatable<IBluetoothLEAdvertisementPublisherFactory> for BluetoothLEAdvertisementPublisher {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementPublisher {}
impl BluetoothLEAdvertisementPublisher {
    #[inline] pub fn create(advertisement: &BluetoothLEAdvertisement) -> Result<BluetoothLEAdvertisementPublisher> {
        <Self as RtActivatable<IBluetoothLEAdvertisementPublisherFactory>>::get_activation_factory().create(advertisement)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementPublisher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,0]) [CLSID_BluetoothLEAdvertisementPublisher]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherFactory, 1549731422, 47203, 18817, 161, 175, 28, 84, 77, 139, 12, 13);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementPublisherFactory(IBluetoothLEAdvertisementPublisherFactoryVtbl, IBluetoothLEAdvertisementPublisherFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherFactory] {
    fn Create(&self, advertisement: <BluetoothLEAdvertisement as RtType>::Abi, out: *mut <BluetoothLEAdvertisementPublisher as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisherFactory {
    #[inline] pub fn create(&self, advertisement: &BluetoothLEAdvertisement) -> Result<BluetoothLEAdvertisementPublisher> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(advertisement) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisementPublisher::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEAdvertisementPublisherStatus: i32 {
    Created = 0, Waiting = 1, Started = 2, Stopping = 3, Stopped = 4, Aborted = 5,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs, 163757471, 11775, 19235, 134, 238, 13, 20, 251, 148, 174, 174);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherStatusChangedEventArgs(IBluetoothLEAdvertisementPublisherStatusChangedEventArgsVtbl, IBluetoothLEAdvertisementPublisherStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisherStatusChangedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherStatusChangedEventArgs: IBluetoothLEAdvertisementPublisherStatusChangedEventArgs}
DEFINE_IID!(IID_IBluetoothLEAdvertisementReceivedEventArgs, 664305119, 58774, 16830, 141, 67, 158, 103, 49, 212, 169, 19);
RT_INTERFACE!{interface IBluetoothLEAdvertisementReceivedEventArgs(IBluetoothLEAdvertisementReceivedEventArgsVtbl, IBluetoothLEAdvertisementReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementReceivedEventArgs] {
    fn get_RawSignalStrengthInDBm(&self, out: *mut i16) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn get_AdvertisementType(&self, out: *mut BluetoothLEAdvertisementType) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Advertisement(&self, out: *mut <BluetoothLEAdvertisement as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementReceivedEventArgs {
    #[inline] pub fn get_raw_signal_strength_in_dbm(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawSignalStrengthInDBm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_type(&self) -> Result<BluetoothLEAdvertisementType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisementType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement(&self) -> Result<Option<BluetoothLEAdvertisement>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Advertisement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisement::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementReceivedEventArgs: IBluetoothLEAdvertisementReceivedEventArgs}
RT_ENUM! { enum BluetoothLEAdvertisementType: i32 {
    ConnectableUndirected = 0, ConnectableDirected = 1, ScannableUndirected = 2, NonConnectableUndirected = 3, ScanResponse = 4,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcher, 2796303215, 62419, 17047, 141, 108, 200, 30, 166, 98, 63, 64);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcher(IBluetoothLEAdvertisementWatcherVtbl, IBluetoothLEAdvertisementWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcher] {
    fn get_MinSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MinOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementWatcherStatus) -> HRESULT,
    fn get_ScanningMode(&self, out: *mut BluetoothLEScanningMode) -> HRESULT,
    fn put_ScanningMode(&self, value: BluetoothLEScanningMode) -> HRESULT,
    fn get_SignalStrengthFilter(&self, out: *mut <super::BluetoothSignalStrengthFilter as RtType>::Abi) -> HRESULT,
    fn put_SignalStrengthFilter(&self, value: <super::BluetoothSignalStrengthFilter as RtType>::Abi) -> HRESULT,
    fn get_AdvertisementFilter(&self, out: *mut <BluetoothLEAdvertisementFilter as RtType>::Abi) -> HRESULT,
    fn put_AdvertisementFilter(&self, value: <BluetoothLEAdvertisementFilter as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_Received(&self, handler: <foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Received(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcher {
    #[inline] pub fn get_min_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinSamplingInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxSamplingInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinOutOfRangeTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxOutOfRangeTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scanning_mode(&self) -> Result<BluetoothLEScanningMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanningMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scanning_mode(&self, value: BluetoothLEScanningMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScanningMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_strength_filter(&self) -> Result<Option<super::BluetoothSignalStrengthFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignalStrengthFilter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothSignalStrengthFilter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_signal_strength_filter(&self, value: &super::BluetoothSignalStrengthFilter) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SignalStrengthFilter)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_filter(&self) -> Result<Option<BluetoothLEAdvertisementFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisementFilter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisementFilter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_advertisement_filter(&self, value: &BluetoothLEAdvertisementFilter) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AdvertisementFilter)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_received(&self, handler: &foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Received)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Received)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcher: IBluetoothLEAdvertisementWatcher}
impl RtActivatable<IBluetoothLEAdvertisementWatcherFactory> for BluetoothLEAdvertisementWatcher {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementWatcher {}
impl BluetoothLEAdvertisementWatcher {
    #[inline] pub fn create(advertisementFilter: &BluetoothLEAdvertisementFilter) -> Result<BluetoothLEAdvertisementWatcher> {
        <Self as RtActivatable<IBluetoothLEAdvertisementWatcherFactory>>::get_activation_factory().create(advertisementFilter)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementWatcher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,87,97,116,99,104,101,114,0]) [CLSID_BluetoothLEAdvertisementWatcher]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherFactory, 2595171670, 14764, 17726, 179, 42, 133, 198, 87, 224, 23, 241);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementWatcherFactory(IBluetoothLEAdvertisementWatcherFactoryVtbl, IBluetoothLEAdvertisementWatcherFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherFactory] {
    fn Create(&self, advertisementFilter: <BluetoothLEAdvertisementFilter as RtType>::Abi, out: *mut <BluetoothLEAdvertisementWatcher as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcherFactory {
    #[inline] pub fn create(&self, advertisementFilter: &BluetoothLEAdvertisementFilter) -> Result<BluetoothLEAdvertisementWatcher> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(advertisementFilter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEAdvertisementWatcher::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEAdvertisementWatcherStatus: i32 {
    Created = 0, Started = 1, Stopping = 2, Stopped = 3, Aborted = 4,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs, 3712022605, 59321, 17379, 156, 4, 6, 133, 208, 133, 253, 140);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherStoppedEventArgs(IBluetoothLEAdvertisementWatcherStoppedEventArgsVtbl, IBluetoothLEAdvertisementWatcherStoppedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcherStoppedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherStoppedEventArgs: IBluetoothLEAdvertisementWatcherStoppedEventArgs}
DEFINE_IID!(IID_IBluetoothLEManufacturerData, 2435693080, 26979, 17715, 176, 97, 70, 148, 218, 251, 52, 229);
RT_INTERFACE!{interface IBluetoothLEManufacturerData(IBluetoothLEManufacturerDataVtbl, IBluetoothLEManufacturerData_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerData] {
    fn get_CompanyId(&self, out: *mut u16) -> HRESULT,
    fn put_CompanyId(&self, value: u16) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEManufacturerData {
    #[inline] pub fn get_company_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompanyId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_company_id(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CompanyId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEManufacturerData: IBluetoothLEManufacturerData}
impl RtActivatable<IBluetoothLEManufacturerDataFactory> for BluetoothLEManufacturerData {}
impl RtActivatable<IActivationFactory> for BluetoothLEManufacturerData {}
impl BluetoothLEManufacturerData {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(companyId: u16, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEManufacturerData> {
        <Self as RtActivatable<IBluetoothLEManufacturerDataFactory>>::get_activation_factory().create(companyId, data)
    }
}
DEFINE_CLSID!(BluetoothLEManufacturerData(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,77,97,110,117,102,97,99,116,117,114,101,114,68,97,116,97,0]) [CLSID_BluetoothLEManufacturerData]);
DEFINE_IID!(IID_IBluetoothLEManufacturerDataFactory, 3231398392, 12698, 17438, 141, 229, 102, 168, 30, 135, 122, 108);
RT_INTERFACE!{static interface IBluetoothLEManufacturerDataFactory(IBluetoothLEManufacturerDataFactoryVtbl, IBluetoothLEManufacturerDataFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerDataFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, companyId: u16, data: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <BluetoothLEManufacturerData as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEManufacturerDataFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, companyId: u16, data: &crate::windows::storage::streams::IBuffer) -> Result<BluetoothLEManufacturerData> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, companyId, get_abi(data) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BluetoothLEManufacturerData::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEScanningMode: i32 {
    Passive = 0, Active = 1,
}}
} // Windows.Devices.Bluetooth.Advertisement
pub mod background { // Windows.Devices.Bluetooth.Background
use crate::prelude::*;
RT_ENUM! { enum BluetoothEventTriggeringMode: i32 {
    Serial = 0, Batch = 1, KeepLatest = 2,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherTriggerDetails, 1628359302, 13440, 16841, 169, 24, 125, 218, 223, 32, 126, 0);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherTriggerDetails(IBluetoothLEAdvertisementPublisherTriggerDetailsVtbl, IBluetoothLEAdvertisementPublisherTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherTriggerDetails] {
    fn get_Status(&self, out: *mut super::advertisement::BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisherTriggerDetails {
    #[inline] pub fn get_status(&self) -> Result<super::advertisement::BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherTriggerDetails: IBluetoothLEAdvertisementPublisherTriggerDetails}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherTriggerDetails, 2816170711, 8791, 20073, 151, 132, 254, 230, 69, 193, 220, 224);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherTriggerDetails(IBluetoothLEAdvertisementWatcherTriggerDetailsVtbl, IBluetoothLEAdvertisementWatcherTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherTriggerDetails] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Advertisements(&self, out: *mut <foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs> as RtType>::Abi) -> HRESULT,
    fn get_SignalStrengthFilter(&self, out: *mut <super::BluetoothSignalStrengthFilter as RtType>::Abi) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcherTriggerDetails {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisements(&self) -> Result<Option<foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Advertisements)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_strength_filter(&self) -> Result<Option<super::BluetoothSignalStrengthFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignalStrengthFilter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothSignalStrengthFilter::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherTriggerDetails: IBluetoothLEAdvertisementWatcherTriggerDetails}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerDetails, 2610969368, 4076, 17258, 147, 177, 244, 108, 105, 117, 50, 162);
RT_INTERFACE!{interface IGattCharacteristicNotificationTriggerDetails(IGattCharacteristicNotificationTriggerDetailsVtbl, IGattCharacteristicNotificationTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerDetails] {
    fn get_Characteristic(&self, out: *mut <super::genericattributeprofile::GattCharacteristic as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerDetails {
    #[inline] pub fn get_characteristic(&self) -> Result<Option<super::genericattributeprofile::GattCharacteristic>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristic)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::genericattributeprofile::GattCharacteristic::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristicNotificationTriggerDetails: IGattCharacteristicNotificationTriggerDetails}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerDetails2, 1920618716, 38045, 17738, 177, 146, 152, 52, 103, 227, 213, 15);
RT_INTERFACE!{interface IGattCharacteristicNotificationTriggerDetails2(IGattCharacteristicNotificationTriggerDetails2Vtbl, IGattCharacteristicNotificationTriggerDetails2_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerDetails2] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_EventTriggeringMode(&self, out: *mut BluetoothEventTriggeringMode) -> HRESULT,
    fn get_ValueChangedEvents(&self, out: *mut <foundation::collections::IVectorView<super::genericattributeprofile::GattValueChangedEventArgs> as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerDetails2 {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_event_triggering_mode(&self) -> Result<BluetoothEventTriggeringMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EventTriggeringMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value_changed_events(&self) -> Result<Option<foundation::collections::IVectorView<super::genericattributeprofile::GattValueChangedEventArgs>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ValueChangedEvents)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceProviderConnection, 2141305273, 12051, 16565, 149, 130, 142, 183, 142, 152, 239, 19);
RT_INTERFACE!{interface IGattServiceProviderConnection(IGattServiceProviderConnectionVtbl, IGattServiceProviderConnection_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderConnection] {
    fn get_TriggerId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Service(&self, out: *mut <super::genericattributeprofile::GattLocalService as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IGattServiceProviderConnection {
    #[inline] pub fn get_trigger_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TriggerId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service(&self) -> Result<Option<super::genericattributeprofile::GattLocalService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Service)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::genericattributeprofile::GattLocalService::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderConnection: IGattServiceProviderConnection}
impl RtActivatable<IGattServiceProviderConnectionStatics> for GattServiceProviderConnection {}
impl GattServiceProviderConnection {
    #[inline] pub fn get_all_services() -> Result<Option<foundation::collections::IMapView<HString, GattServiceProviderConnection>>> {
        <Self as RtActivatable<IGattServiceProviderConnectionStatics>>::get_activation_factory().get_all_services()
    }
}
DEFINE_CLSID!(GattServiceProviderConnection(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,97,99,107,103,114,111,117,110,100,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,67,111,110,110,101,99,116,105,111,110,0]) [CLSID_GattServiceProviderConnection]);
DEFINE_IID!(IID_IGattServiceProviderConnectionStatics, 1028693835, 2830, 17510, 184, 205, 110, 189, 218, 31, 161, 125);
RT_INTERFACE!{static interface IGattServiceProviderConnectionStatics(IGattServiceProviderConnectionStaticsVtbl, IGattServiceProviderConnectionStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderConnectionStatics] {
    fn get_AllServices(&self, out: *mut <foundation::collections::IMapView<HString, GattServiceProviderConnection> as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderConnectionStatics {
    #[inline] pub fn get_all_services(&self) -> Result<Option<foundation::collections::IMapView<HString, GattServiceProviderConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceProviderTriggerDetails, 2928412197, 1535, 19195, 177, 106, 222, 149, 243, 207, 1, 88);
RT_INTERFACE!{interface IGattServiceProviderTriggerDetails(IGattServiceProviderTriggerDetailsVtbl, IGattServiceProviderTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <GattServiceProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<GattServiceProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Connection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattServiceProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderTriggerDetails: IGattServiceProviderTriggerDetails}
DEFINE_IID!(IID_IRfcommConnectionTriggerDetails, 4179784525, 11836, 20220, 171, 89, 252, 92, 249, 111, 151, 227);
RT_INTERFACE!{interface IRfcommConnectionTriggerDetails(IRfcommConnectionTriggerDetailsVtbl, IRfcommConnectionTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommConnectionTriggerDetails] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_Socket(&self, out: *mut <crate::windows::networking::sockets::StreamSocket as RtType>::Abi) -> HRESULT,
    fn get_Incoming(&self, out: *mut bool) -> HRESULT,
    fn get_RemoteDevice(&self, out: *mut <super::BluetoothDevice as RtType>::Abi) -> HRESULT
}}
impl IRfcommConnectionTriggerDetails {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_socket(&self) -> Result<Option<crate::windows::networking::sockets::StreamSocket>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Socket)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::networking::sockets::StreamSocket::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Incoming)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_device(&self) -> Result<Option<super::BluetoothDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemoteDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommConnectionTriggerDetails: IRfcommConnectionTriggerDetails}
DEFINE_IID!(IID_IRfcommInboundConnectionInformation, 1832809896, 21545, 16473, 146, 227, 30, 139, 101, 82, 135, 7);
RT_INTERFACE!{interface IRfcommInboundConnectionInformation(IRfcommInboundConnectionInformationVtbl, IRfcommInboundConnectionInformation_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommInboundConnectionInformation] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRecord(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SdpRecord(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_LocalServiceId(&self, out: *mut <super::rfcomm::RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn put_LocalServiceId(&self, value: <super::rfcomm::RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_ServiceCapabilities(&self, out: *mut super::BluetoothServiceCapabilities) -> HRESULT,
    fn put_ServiceCapabilities(&self, value: super::BluetoothServiceCapabilities) -> HRESULT
}}
impl IRfcommInboundConnectionInformation {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_record(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SdpRecord)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_sdp_record(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SdpRecord)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_local_service_id(&self) -> Result<Option<super::rfcomm::RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocalServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::rfcomm::RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_local_service_id(&self, value: &super::rfcomm::RfcommServiceId) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LocalServiceId)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_capabilities(&self) -> Result<super::BluetoothServiceCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_service_capabilities(&self, value: super::BluetoothServiceCapabilities) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ServiceCapabilities)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommInboundConnectionInformation: IRfcommInboundConnectionInformation}
DEFINE_IID!(IID_IRfcommOutboundConnectionInformation, 2962301563, 62516, 19632, 153, 177, 74, 184, 206, 218, 237, 215);
RT_INTERFACE!{interface IRfcommOutboundConnectionInformation(IRfcommOutboundConnectionInformationVtbl, IRfcommOutboundConnectionInformation_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommOutboundConnectionInformation] {
    fn get_RemoteServiceId(&self, out: *mut <super::rfcomm::RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn put_RemoteServiceId(&self, value: <super::rfcomm::RfcommServiceId as RtType>::Abi) -> HRESULT
}}
impl IRfcommOutboundConnectionInformation {
    #[inline] pub fn get_remote_service_id(&self) -> Result<Option<super::rfcomm::RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemoteServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::rfcomm::RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_service_id(&self, value: &super::rfcomm::RfcommServiceId) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RemoteServiceId)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommOutboundConnectionInformation: IRfcommOutboundConnectionInformation}
} // Windows.Devices.Bluetooth.Background
pub mod genericattributeprofile { // Windows.Devices.Bluetooth.GenericAttributeProfile
use crate::prelude::*;
DEFINE_IID!(IID_IGattCharacteristic, 1506496705, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
RT_INTERFACE!{interface IGattCharacteristic(IGattCharacteristicVtbl, IGattCharacteristic_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic] {
    fn GetDescriptors(&self, descriptorUuid: Guid, out: *mut <foundation::collections::IVectorView<GattDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn get_ProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_ProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut <foundation::collections::IVectorView<GattPresentationFormat> as RtType>::Abi) -> HRESULT,
    fn ReadValueAsync(&self, out: *mut <foundation::IAsyncOperation<GattReadResult> as RtType>::Abi) -> HRESULT,
    fn ReadValueWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattReadResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattCommunicationStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithOptionAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, writeOption: GattWriteOption, out: *mut <foundation::IAsyncOperation<GattCommunicationStatus> as RtType>::Abi) -> HRESULT,
    fn ReadClientCharacteristicConfigurationDescriptorAsync(&self, out: *mut <foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult> as RtType>::Abi) -> HRESULT,
    fn WriteClientCharacteristicConfigurationDescriptorAsync(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue, out: *mut <foundation::IAsyncOperation<GattCommunicationStatus> as RtType>::Abi) -> HRESULT,
    fn add_ValueChanged(&self, valueChangedHandler: <foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, valueChangedEventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGattCharacteristic {
    #[inline] pub fn get_descriptors(&self, descriptorUuid: Guid) -> Result<Option<foundation::collections::IVectorView<GattDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptors)(self.0.as_abi() as *const _ as *mut _, descriptorUuid, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttributeHandle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<foundation::collections::IVectorView<GattPresentationFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_async(&self) -> Result<foundation::IAsyncOperation<GattReadResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValueAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattReadResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValueWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_async(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<GattCommunicationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_option_async(&self, value: &crate::windows::storage::streams::IBuffer, writeOption: GattWriteOption) -> Result<foundation::IAsyncOperation<GattCommunicationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueWithOptionAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, writeOption, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_client_characteristic_configuration_descriptor_async(&self) -> Result<foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadClientCharacteristicConfigurationDescriptorAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn write_client_characteristic_configuration_descriptor_async(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue) -> Result<foundation::IAsyncOperation<GattCommunicationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteClientCharacteristicConfigurationDescriptorAsync)(self.0.as_abi() as *const _ as *mut _, clientCharacteristicConfigurationDescriptorValue, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_value_changed(&self, valueChangedHandler: &foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ValueChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(valueChangedHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, valueChangedEventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ValueChanged)(self.0.as_abi() as *const _ as *mut _, valueChangedEventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristic: IGattCharacteristic}
impl RtActivatable<IGattCharacteristicStatics> for GattCharacteristic {}
impl GattCharacteristic {
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
}
DEFINE_CLSID!(GattCharacteristic(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,0]) [CLSID_GattCharacteristic]);
DEFINE_IID!(IID_IGattCharacteristic2, 2920985976, 60422, 18276, 183, 128, 152, 53, 161, 211, 93, 110);
RT_INTERFACE!{interface IGattCharacteristic2(IGattCharacteristic2Vtbl, IGattCharacteristic2_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic2] {
    fn get_Service(&self, out: *mut <GattDeviceService as RtType>::Abi) -> HRESULT,
    fn GetAllDescriptors(&self, out: *mut <foundation::collections::IVectorView<GattDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristic2 {
    #[inline] pub fn get_service(&self) -> Result<Option<GattDeviceService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Service)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattDeviceService::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<GattDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllDescriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristic3, 1060922942, 37844, 16491, 184, 23, 219, 129, 248, 237, 83, 179);
RT_INTERFACE!{interface IGattCharacteristic3(IGattCharacteristic3Vtbl, IGattCharacteristic3_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic3] {
    fn GetDescriptorsAsync(&self, out: *mut <foundation::IAsyncOperation<GattDescriptorsResult> as RtType>::Abi) -> HRESULT,
    fn GetDescriptorsWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattDescriptorsResult> as RtType>::Abi) -> HRESULT,
    fn GetDescriptorsForUuidAsync(&self, descriptorUuid: Guid, out: *mut <foundation::IAsyncOperation<GattDescriptorsResult> as RtType>::Abi) -> HRESULT,
    fn GetDescriptorsForUuidWithCacheModeAsync(&self, descriptorUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattDescriptorsResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattWriteResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAndOptionAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, writeOption: GattWriteOption, out: *mut <foundation::IAsyncOperation<GattWriteResult> as RtType>::Abi) -> HRESULT,
    fn WriteClientCharacteristicConfigurationDescriptorWithResultAsync(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue, out: *mut <foundation::IAsyncOperation<GattWriteResult> as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristic3 {
    #[inline] pub fn get_descriptors_async(&self) -> Result<foundation::IAsyncOperation<GattDescriptorsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptorsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattDescriptorsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptorsWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_for_uuid_async(&self, descriptorUuid: Guid) -> Result<foundation::IAsyncOperation<GattDescriptorsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptorsForUuidAsync)(self.0.as_abi() as *const _ as *mut _, descriptorUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_for_uuid_with_cache_mode_async(&self, descriptorUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattDescriptorsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptorsForUuidWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, descriptorUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_async(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<GattWriteResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueWithResultAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_and_option_async(&self, value: &crate::windows::storage::streams::IBuffer, writeOption: GattWriteOption) -> Result<foundation::IAsyncOperation<GattWriteResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueWithResultAndOptionAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, writeOption, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn write_client_characteristic_configuration_descriptor_with_result_async(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue) -> Result<foundation::IAsyncOperation<GattWriteResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteClientCharacteristicConfigurationDescriptorWithResultAsync)(self.0.as_abi() as *const _ as *mut _, clientCharacteristicConfigurationDescriptorValue, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattCharacteristicProperties: u32 {
    None = 0, Broadcast = 1, Read = 2, WriteWithoutResponse = 4, Write = 8, Notify = 16, Indicate = 32, AuthenticatedSignedWrites = 64, ExtendedProperties = 128, ReliableWrites = 256, WritableAuxiliaries = 512,
}}
DEFINE_IID!(IID_IGattCharacteristicsResult, 294949980, 45655, 20286, 157, 183, 246, 139, 201, 169, 174, 242);
RT_INTERFACE!{interface IGattCharacteristicsResult(IGattCharacteristicsResultVtbl, IGattCharacteristicsResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicsResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn get_Characteristics(&self, out: *mut <foundation::collections::IVectorView<GattCharacteristic> as RtType>::Abi) -> HRESULT
}}
impl IGattCharacteristicsResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<GattCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristicsResult: IGattCharacteristicsResult}
DEFINE_IID!(IID_IGattCharacteristicStatics, 1506496707, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
RT_INTERFACE!{static interface IGattCharacteristicStatics(IGattCharacteristicStaticsVtbl, IGattCharacteristicStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicStatics] {
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl IGattCharacteristicStatics {
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ConvertShortIdToUuid)(self.0.as_abi() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattCharacteristicUuids}
impl RtActivatable<IGattCharacteristicUuidsStatics> for GattCharacteristicUuids {}
impl RtActivatable<IGattCharacteristicUuidsStatics2> for GattCharacteristicUuids {}
impl GattCharacteristicUuids {
    #[inline] pub fn get_battery_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_battery_level()
    }
    #[inline] pub fn get_blood_pressure_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_blood_pressure_feature()
    }
    #[inline] pub fn get_blood_pressure_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_blood_pressure_measurement()
    }
    #[inline] pub fn get_body_sensor_location() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_body_sensor_location()
    }
    #[inline] pub fn get_csc_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_csc_feature()
    }
    #[inline] pub fn get_csc_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_csc_measurement()
    }
    #[inline] pub fn get_glucose_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_feature()
    }
    #[inline] pub fn get_glucose_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_measurement()
    }
    #[inline] pub fn get_glucose_measurement_context() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_measurement_context()
    }
    #[inline] pub fn get_heart_rate_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_heart_rate_control_point()
    }
    #[inline] pub fn get_heart_rate_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_heart_rate_measurement()
    }
    #[inline] pub fn get_intermediate_cuff_pressure() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_intermediate_cuff_pressure()
    }
    #[inline] pub fn get_intermediate_temperature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_intermediate_temperature()
    }
    #[inline] pub fn get_measurement_interval() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_measurement_interval()
    }
    #[inline] pub fn get_record_access_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_record_access_control_point()
    }
    #[inline] pub fn get_rsc_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_rsc_feature()
    }
    #[inline] pub fn get_rsc_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_rsc_measurement()
    }
    #[inline] pub fn get_sc_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_sc_control_point()
    }
    #[inline] pub fn get_sensor_location() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_sensor_location()
    }
    #[inline] pub fn get_temperature_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_temperature_measurement()
    }
    #[inline] pub fn get_temperature_type() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_temperature_type()
    }
    #[inline] pub fn get_alert_category_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_category_id()
    }
    #[inline] pub fn get_alert_category_id_bit_mask() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_category_id_bit_mask()
    }
    #[inline] pub fn get_alert_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_level()
    }
    #[inline] pub fn get_alert_notification_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_notification_control_point()
    }
    #[inline] pub fn get_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_status()
    }
    #[inline] pub fn get_gap_appearance() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_appearance()
    }
    #[inline] pub fn get_boot_keyboard_input_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_keyboard_input_report()
    }
    #[inline] pub fn get_boot_keyboard_output_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_keyboard_output_report()
    }
    #[inline] pub fn get_boot_mouse_input_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_mouse_input_report()
    }
    #[inline] pub fn get_current_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_current_time()
    }
    #[inline] pub fn get_cycling_power_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_control_point()
    }
    #[inline] pub fn get_cycling_power_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_feature()
    }
    #[inline] pub fn get_cycling_power_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_measurement()
    }
    #[inline] pub fn get_cycling_power_vector() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_vector()
    }
    #[inline] pub fn get_date_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_date_time()
    }
    #[inline] pub fn get_day_date_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_day_date_time()
    }
    #[inline] pub fn get_day_of_week() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_day_of_week()
    }
    #[inline] pub fn get_gap_device_name() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_device_name()
    }
    #[inline] pub fn get_dst_offset() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_dst_offset()
    }
    #[inline] pub fn get_exact_time_256() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_exact_time_256()
    }
    #[inline] pub fn get_firmware_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_firmware_revision_string()
    }
    #[inline] pub fn get_hardware_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hardware_revision_string()
    }
    #[inline] pub fn get_hid_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hid_control_point()
    }
    #[inline] pub fn get_hid_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hid_information()
    }
    #[inline] pub fn get_ieee1107320601_regulatory_certification_data_list() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ieee1107320601_regulatory_certification_data_list()
    }
    #[inline] pub fn get_ln_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ln_control_point()
    }
    #[inline] pub fn get_ln_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ln_feature()
    }
    #[inline] pub fn get_local_time_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_local_time_information()
    }
    #[inline] pub fn get_location_and_speed() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_location_and_speed()
    }
    #[inline] pub fn get_manufacturer_name_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_manufacturer_name_string()
    }
    #[inline] pub fn get_model_number_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_model_number_string()
    }
    #[inline] pub fn get_navigation() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_navigation()
    }
    #[inline] pub fn get_new_alert() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_new_alert()
    }
    #[inline] pub fn get_gap_peripheral_preferred_connection_parameters() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_peripheral_preferred_connection_parameters()
    }
    #[inline] pub fn get_gap_peripheral_privacy_flag() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_peripheral_privacy_flag()
    }
    #[inline] pub fn get_pnp_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_pnp_id()
    }
    #[inline] pub fn get_position_quality() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_position_quality()
    }
    #[inline] pub fn get_protocol_mode() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_protocol_mode()
    }
    #[inline] pub fn get_gap_reconnection_address() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_reconnection_address()
    }
    #[inline] pub fn get_reference_time_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_reference_time_information()
    }
    #[inline] pub fn get_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_report()
    }
    #[inline] pub fn get_report_map() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_report_map()
    }
    #[inline] pub fn get_ringer_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ringer_control_point()
    }
    #[inline] pub fn get_ringer_setting() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ringer_setting()
    }
    #[inline] pub fn get_scan_interval_window() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_scan_interval_window()
    }
    #[inline] pub fn get_scan_refresh() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_scan_refresh()
    }
    #[inline] pub fn get_serial_number_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_serial_number_string()
    }
    #[inline] pub fn get_gatt_service_changed() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gatt_service_changed()
    }
    #[inline] pub fn get_software_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_software_revision_string()
    }
    #[inline] pub fn get_supported_new_alert_category() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_supported_new_alert_category()
    }
    #[inline] pub fn get_support_unread_alert_category() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_support_unread_alert_category()
    }
    #[inline] pub fn get_system_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_system_id()
    }
    #[inline] pub fn get_time_accuracy() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_accuracy()
    }
    #[inline] pub fn get_time_source() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_source()
    }
    #[inline] pub fn get_time_update_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_update_control_point()
    }
    #[inline] pub fn get_time_update_state() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_update_state()
    }
    #[inline] pub fn get_time_with_dst() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_with_dst()
    }
    #[inline] pub fn get_time_zone() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_zone()
    }
    #[inline] pub fn get_tx_power_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_tx_power_level()
    }
    #[inline] pub fn get_unread_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_unread_alert_status()
    }
}
DEFINE_CLSID!(GattCharacteristicUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,85,117,105,100,115,0]) [CLSID_GattCharacteristicUuids]);
DEFINE_IID!(IID_IGattCharacteristicUuidsStatics, 1492796806, 45534, 18188, 183, 222, 13, 17, 255, 68, 244, 183);
RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics(IGattCharacteristicUuidsStaticsVtbl, IGattCharacteristicUuidsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics] {
    fn get_BatteryLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressureFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressureMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_BodySensorLocation(&self, out: *mut Guid) -> HRESULT,
    fn get_CscFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_CscMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseMeasurementContext(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRateControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRateMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_IntermediateCuffPressure(&self, out: *mut Guid) -> HRESULT,
    fn get_IntermediateTemperature(&self, out: *mut Guid) -> HRESULT,
    fn get_MeasurementInterval(&self, out: *mut Guid) -> HRESULT,
    fn get_RecordAccessControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_RscFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_RscMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_SCControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_SensorLocation(&self, out: *mut Guid) -> HRESULT,
    fn get_TemperatureMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_TemperatureType(&self, out: *mut Guid) -> HRESULT
}}
impl IGattCharacteristicUuidsStatics {
    #[inline] pub fn get_battery_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BatteryLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressureFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressureMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_body_sensor_location(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BodySensorLocation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_csc_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CscFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_csc_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CscMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GlucoseFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GlucoseMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_measurement_context(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GlucoseMeasurementContext)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeartRateControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeartRateMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_cuff_pressure(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IntermediateCuffPressure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_temperature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IntermediateTemperature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_measurement_interval(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MeasurementInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_record_access_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RecordAccessControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rsc_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RscFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rsc_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RscMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sc_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SCControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sensor_location(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SensorLocation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_temperature_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TemperatureMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_temperature_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TemperatureType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristicUuidsStatics2, 408269861, 54382, 18988, 156, 63, 237, 109, 234, 41, 231, 190);
RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics2(IGattCharacteristicUuidsStatics2Vtbl, IGattCharacteristicUuidsStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics2] {
    fn get_AlertCategoryId(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertCategoryIdBitMask(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertNotificationControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertStatus(&self, out: *mut Guid) -> HRESULT,
    fn get_GapAppearance(&self, out: *mut Guid) -> HRESULT,
    fn get_BootKeyboardInputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_BootKeyboardOutputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_BootMouseInputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_CurrentTime(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerVector(&self, out: *mut Guid) -> HRESULT,
    fn get_DateTime(&self, out: *mut Guid) -> HRESULT,
    fn get_DayDateTime(&self, out: *mut Guid) -> HRESULT,
    fn get_DayOfWeek(&self, out: *mut Guid) -> HRESULT,
    fn get_GapDeviceName(&self, out: *mut Guid) -> HRESULT,
    fn get_DstOffset(&self, out: *mut Guid) -> HRESULT,
    fn get_ExactTime256(&self, out: *mut Guid) -> HRESULT,
    fn get_FirmwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_HardwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_HidControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_HidInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_Ieee1107320601RegulatoryCertificationDataList(&self, out: *mut Guid) -> HRESULT,
    fn get_LnControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_LnFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_LocalTimeInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_LocationAndSpeed(&self, out: *mut Guid) -> HRESULT,
    fn get_ManufacturerNameString(&self, out: *mut Guid) -> HRESULT,
    fn get_ModelNumberString(&self, out: *mut Guid) -> HRESULT,
    fn get_Navigation(&self, out: *mut Guid) -> HRESULT,
    fn get_NewAlert(&self, out: *mut Guid) -> HRESULT,
    fn get_GapPeripheralPreferredConnectionParameters(&self, out: *mut Guid) -> HRESULT,
    fn get_GapPeripheralPrivacyFlag(&self, out: *mut Guid) -> HRESULT,
    fn get_PnpId(&self, out: *mut Guid) -> HRESULT,
    fn get_PositionQuality(&self, out: *mut Guid) -> HRESULT,
    fn get_ProtocolMode(&self, out: *mut Guid) -> HRESULT,
    fn get_GapReconnectionAddress(&self, out: *mut Guid) -> HRESULT,
    fn get_ReferenceTimeInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_Report(&self, out: *mut Guid) -> HRESULT,
    fn get_ReportMap(&self, out: *mut Guid) -> HRESULT,
    fn get_RingerControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_RingerSetting(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanIntervalWindow(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanRefresh(&self, out: *mut Guid) -> HRESULT,
    fn get_SerialNumberString(&self, out: *mut Guid) -> HRESULT,
    fn get_GattServiceChanged(&self, out: *mut Guid) -> HRESULT,
    fn get_SoftwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_SupportedNewAlertCategory(&self, out: *mut Guid) -> HRESULT,
    fn get_SupportUnreadAlertCategory(&self, out: *mut Guid) -> HRESULT,
    fn get_SystemId(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeAccuracy(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeSource(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeUpdateControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeUpdateState(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeWithDst(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeZone(&self, out: *mut Guid) -> HRESULT,
    fn get_TxPowerLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_UnreadAlertStatus(&self, out: *mut Guid) -> HRESULT
}}
impl IGattCharacteristicUuidsStatics2 {
    #[inline] pub fn get_alert_category_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertCategoryId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_category_id_bit_mask(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertCategoryIdBitMask)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_notification_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertNotificationControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_appearance(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GapAppearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_keyboard_input_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BootKeyboardInputReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_keyboard_output_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BootKeyboardOutputReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_mouse_input_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BootMouseInputReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPowerControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPowerFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPowerMeasurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_vector(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPowerVector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_day_date_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DayDateTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_day_of_week(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DayOfWeek)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_device_name(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GapDeviceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dst_offset(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DstOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_exact_time_256(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExactTime256)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_firmware_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FirmwareRevisionString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareRevisionString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HidControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HidInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ieee1107320601_regulatory_certification_data_list(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ieee1107320601RegulatoryCertificationDataList)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ln_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LnControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ln_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LnFeature)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_local_time_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocalTimeInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_and_speed(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationAndSpeed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_name_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ManufacturerNameString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModelNumberString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_navigation(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Navigation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_alert(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewAlert)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_peripheral_preferred_connection_parameters(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GapPeripheralPreferredConnectionParameters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_peripheral_privacy_flag(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GapPeripheralPrivacyFlag)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pnp_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PnpId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_quality(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionQuality)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_mode(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_reconnection_address(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GapReconnectionAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reference_time_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReferenceTimeInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_map(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportMap)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ringer_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RingerControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ringer_setting(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RingerSetting)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_interval_window(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanIntervalWindow)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_refresh(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanRefresh)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_number_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SerialNumberString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_service_changed(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GattServiceChanged)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_software_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoftwareRevisionString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_new_alert_category(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedNewAlertCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_support_unread_alert_category(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportUnreadAlertCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_system_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SystemId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_accuracy(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_source(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_update_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeUpdateControlPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_update_state(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeUpdateState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_with_dst(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeWithDst)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_zone(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TimeZone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TxPowerLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unread_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnreadAlertStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattClientCharacteristicConfigurationDescriptorValue: i32 {
    None = 0, Notify = 1, Indicate = 2,
}}
DEFINE_IID!(IID_IGattClientNotificationResult, 1349342617, 274, 16794, 142, 59, 174, 33, 175, 171, 210, 194);
RT_INTERFACE!{interface IGattClientNotificationResult(IGattClientNotificationResultVtbl, IGattClientNotificationResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattClientNotificationResult] {
    fn get_SubscribedClient(&self, out: *mut <GattSubscribedClient as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT
}}
impl IGattClientNotificationResult {
    #[inline] pub fn get_subscribed_client(&self) -> Result<Option<GattSubscribedClient>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubscribedClient)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattSubscribedClient::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattClientNotificationResult: IGattClientNotificationResult}
DEFINE_IID!(IID_IGattClientNotificationResult2, 2410595479, 17888, 18814, 149, 130, 41, 161, 254, 40, 26, 213);
RT_INTERFACE!{interface IGattClientNotificationResult2(IGattClientNotificationResult2Vtbl, IGattClientNotificationResult2_Abi): IInspectable(IInspectableVtbl) [IID_IGattClientNotificationResult2] {
    fn get_BytesSent(&self, out: *mut u16) -> HRESULT
}}
impl IGattClientNotificationResult2 {
    #[inline] pub fn get_bytes_sent(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BytesSent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattCommunicationStatus: i32 {
    Success = 0, Unreachable = 1, ProtocolError = 2, AccessDenied = 3,
}}
DEFINE_IID!(IID_IGattDescriptor, 2449825579, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
RT_INTERFACE!{interface IGattDescriptor(IGattDescriptorVtbl, IGattDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IGattDescriptor] {
    fn get_ProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_ProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT,
    fn ReadValueAsync(&self, out: *mut <foundation::IAsyncOperation<GattReadResult> as RtType>::Abi) -> HRESULT,
    fn ReadValueWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattReadResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn WriteValueAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattCommunicationStatus> as RtType>::Abi) -> HRESULT
}}
impl IGattDescriptor {
    #[inline] pub fn get_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttributeHandle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read_value_async(&self) -> Result<foundation::IAsyncOperation<GattReadResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValueAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattReadResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadValueWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_async(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<GattCommunicationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDescriptor: IGattDescriptor}
impl RtActivatable<IGattDescriptorStatics> for GattDescriptor {}
impl GattDescriptor {
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
}
DEFINE_CLSID!(GattDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_GattDescriptor]);
DEFINE_IID!(IID_IGattDescriptor2, 2404793657, 54832, 16492, 186, 17, 16, 205, 209, 107, 14, 94);
RT_INTERFACE!{interface IGattDescriptor2(IGattDescriptor2Vtbl, IGattDescriptor2_Abi): IInspectable(IInspectableVtbl) [IID_IGattDescriptor2] {
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattWriteResult> as RtType>::Abi) -> HRESULT
}}
impl IGattDescriptor2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_async(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<GattWriteResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WriteValueWithResultAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDescriptorsResult, 2613088755, 38375, 17545, 141, 37, 255, 129, 149, 90, 87, 185);
RT_INTERFACE!{interface IGattDescriptorsResult(IGattDescriptorsResultVtbl, IGattDescriptorsResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattDescriptorsResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn get_Descriptors(&self, out: *mut <foundation::collections::IVectorView<GattDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IGattDescriptorsResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<GattDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDescriptorsResult: IGattDescriptorsResult}
DEFINE_IID!(IID_IGattDescriptorStatics, 2449825581, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
RT_INTERFACE!{static interface IGattDescriptorStatics(IGattDescriptorStaticsVtbl, IGattDescriptorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattDescriptorStatics] {
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl IGattDescriptorStatics {
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ConvertShortIdToUuid)(self.0.as_abi() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattDescriptorUuids}
impl RtActivatable<IGattDescriptorUuidsStatics> for GattDescriptorUuids {}
impl GattDescriptorUuids {
    #[inline] pub fn get_characteristic_aggregate_format() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_aggregate_format()
    }
    #[inline] pub fn get_characteristic_extended_properties() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_extended_properties()
    }
    #[inline] pub fn get_characteristic_presentation_format() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_presentation_format()
    }
    #[inline] pub fn get_characteristic_user_description() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_user_description()
    }
    #[inline] pub fn get_client_characteristic_configuration() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_client_characteristic_configuration()
    }
    #[inline] pub fn get_server_characteristic_configuration() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_server_characteristic_configuration()
    }
}
DEFINE_CLSID!(GattDescriptorUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,85,117,105,100,115,0]) [CLSID_GattDescriptorUuids]);
DEFINE_IID!(IID_IGattDescriptorUuidsStatics, 2801296078, 40188, 17137, 145, 133, 255, 55, 183, 81, 129, 211);
RT_INTERFACE!{static interface IGattDescriptorUuidsStatics(IGattDescriptorUuidsStaticsVtbl, IGattDescriptorUuidsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattDescriptorUuidsStatics] {
    fn get_CharacteristicAggregateFormat(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicExtendedProperties(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicPresentationFormat(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicUserDescription(&self, out: *mut Guid) -> HRESULT,
    fn get_ClientCharacteristicConfiguration(&self, out: *mut Guid) -> HRESULT,
    fn get_ServerCharacteristicConfiguration(&self, out: *mut Guid) -> HRESULT
}}
impl IGattDescriptorUuidsStatics {
    #[inline] pub fn get_characteristic_aggregate_format(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicAggregateFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_extended_properties(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicExtendedProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_presentation_format(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicPresentationFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_user_description(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicUserDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_client_characteristic_configuration(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClientCharacteristicConfiguration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_server_characteristic_configuration(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServerCharacteristicConfiguration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceService, 2893773829, 45884, 18383, 153, 15, 107, 143, 85, 119, 223, 113);
RT_INTERFACE!{interface IGattDeviceService(IGattDeviceServiceVtbl, IGattDeviceService_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceService] {
    fn GetCharacteristics(&self, characteristicUuid: Guid, out: *mut <foundation::collections::IVectorView<GattCharacteristic> as RtType>::Abi) -> HRESULT,
    fn GetIncludedServices(&self, serviceUuid: Guid, out: *mut <foundation::collections::IVectorView<GattDeviceService> as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT
}}
impl IGattDeviceService {
    #[inline] pub fn get_characteristics(&self, characteristicUuid: Guid) -> Result<Option<foundation::collections::IVectorView<GattCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCharacteristics)(self.0.as_abi() as *const _ as *mut _, characteristicUuid, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services(&self, serviceUuid: Guid) -> Result<Option<foundation::collections::IVectorView<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIncludedServices)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttributeHandle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDeviceService: IGattDeviceService}
impl RtActivatable<IGattDeviceServiceStatics> for GattDeviceService {}
impl RtActivatable<IGattDeviceServiceStatics2> for GattDeviceService {}
impl GattDeviceService {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<GattDeviceService>> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector_from_uuid(serviceUuid: Guid) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().get_device_selector_from_uuid(serviceUuid)
    }
    #[inline] pub fn get_device_selector_from_short_id(serviceShortId: u16) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().get_device_selector_from_short_id(serviceShortId)
    }
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
    #[inline] pub fn from_id_with_sharing_mode_async(deviceId: &HStringArg, sharingMode: GattSharingMode) -> Result<foundation::IAsyncOperation<GattDeviceService>> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().from_id_with_sharing_mode_async(deviceId, sharingMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id(bluetoothDeviceId: &super::BluetoothDeviceId) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id(bluetoothDeviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_with_cache_mode(bluetoothDeviceId: &super::BluetoothDeviceId, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_with_cache_mode(bluetoothDeviceId, cacheMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid(bluetoothDeviceId: &super::BluetoothDeviceId, serviceUuid: Guid) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_and_uuid(bluetoothDeviceId, serviceUuid)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(bluetoothDeviceId: &super::BluetoothDeviceId, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(bluetoothDeviceId, serviceUuid, cacheMode)
    }
}
DEFINE_CLSID!(GattDeviceService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,118,105,99,101,83,101,114,118,105,99,101,0]) [CLSID_GattDeviceService]);
DEFINE_IID!(IID_IGattDeviceService2, 4233384459, 2829, 18184, 186, 224, 159, 253, 148, 137, 188, 89);
RT_INTERFACE!{interface IGattDeviceService2(IGattDeviceService2Vtbl, IGattDeviceService2_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceService2] {
    fn get_Device(&self, out: *mut <super::BluetoothLEDevice as RtType>::Abi) -> HRESULT,
    fn get_ParentServices(&self, out: *mut <foundation::collections::IVectorView<GattDeviceService> as RtType>::Abi) -> HRESULT,
    fn GetAllCharacteristics(&self, out: *mut <foundation::collections::IVectorView<GattCharacteristic> as RtType>::Abi) -> HRESULT,
    fn GetAllIncludedServices(&self, out: *mut <foundation::collections::IVectorView<GattDeviceService> as RtType>::Abi) -> HRESULT
}}
impl IGattDeviceService2 {
    #[inline] pub fn get_device(&self) -> Result<Option<super::BluetoothLEDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothLEDevice::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_services(&self) -> Result<Option<foundation::collections::IVectorView<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ParentServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<GattCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllCharacteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_included_services(&self) -> Result<Option<foundation::collections::IVectorView<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllIncludedServices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceService3, 2996021584, 3155, 17276, 169, 179, 92, 50, 16, 198, 229, 105);
RT_INTERFACE!{interface IGattDeviceService3(IGattDeviceService3Vtbl, IGattDeviceService3_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceService3] {
    fn get_DeviceAccessInformation(&self, out: *mut <super::super::enumeration::DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn get_Session(&self, out: *mut <GattSession as RtType>::Abi) -> HRESULT,
    fn get_SharingMode(&self, out: *mut GattSharingMode) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus> as RtType>::Abi) -> HRESULT,
    fn OpenAsync(&self, sharingMode: GattSharingMode, out: *mut <foundation::IAsyncOperation<GattOpenStatus> as RtType>::Abi) -> HRESULT,
    fn GetCharacteristicsAsync(&self, out: *mut <foundation::IAsyncOperation<GattCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetCharacteristicsWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetCharacteristicsForUuidAsync(&self, characteristicUuid: Guid, out: *mut <foundation::IAsyncOperation<GattCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetCharacteristicsForUuidWithCacheModeAsync(&self, characteristicUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetIncludedServicesAsync(&self, out: *mut <foundation::IAsyncOperation<GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetIncludedServicesWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetIncludedServicesForUuidAsync(&self, serviceUuid: Guid, out: *mut <foundation::IAsyncOperation<GattDeviceServicesResult> as RtType>::Abi) -> HRESULT,
    fn GetIncludedServicesForUuidWithCacheModeAsync(&self, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<GattDeviceServicesResult> as RtType>::Abi) -> HRESULT
}}
impl IGattDeviceService3 {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<super::super::enumeration::DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceAccessInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::enumeration::DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session(&self) -> Result<Option<GattSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<GattSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_async(&self, sharingMode: GattSharingMode) -> Result<foundation::IAsyncOperation<GattOpenStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenAsync)(self.0.as_abi() as *const _ as *mut _, sharingMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_async(&self) -> Result<foundation::IAsyncOperation<GattCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCharacteristicsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCharacteristicsWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_for_uuid_async(&self, characteristicUuid: Guid) -> Result<foundation::IAsyncOperation<GattCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCharacteristicsForUuidAsync)(self.0.as_abi() as *const _ as *mut _, characteristicUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_for_uuid_with_cache_mode_async(&self, characteristicUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCharacteristicsForUuidWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, characteristicUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_async(&self) -> Result<foundation::IAsyncOperation<GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIncludedServicesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIncludedServicesWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_for_uuid_async(&self, serviceUuid: Guid) -> Result<foundation::IAsyncOperation<GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIncludedServicesForUuidAsync)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_for_uuid_with_cache_mode_async(&self, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<GattDeviceServicesResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIncludedServicesForUuidWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceServicesResult, 387830766, 365, 16797, 131, 138, 87, 108, 244, 117, 163, 216);
RT_INTERFACE!{interface IGattDeviceServicesResult(IGattDeviceServicesResultVtbl, IGattDeviceServicesResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceServicesResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn get_Services(&self, out: *mut <foundation::collections::IVectorView<GattDeviceService> as RtType>::Abi) -> HRESULT
}}
impl IGattDeviceServicesResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_services(&self) -> Result<Option<foundation::collections::IVectorView<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Services)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDeviceServicesResult: IGattDeviceServicesResult}
DEFINE_IID!(IID_IGattDeviceServiceStatics, 426573858, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{static interface IGattDeviceServiceStatics(IGattDeviceServiceStaticsVtbl, IGattDeviceServiceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceServiceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<GattDeviceService> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelectorFromUuid(&self, serviceUuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromShortId(&self, serviceShortId: u16, out: *mut HSTRING) -> HRESULT,
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl IGattDeviceServiceStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<GattDeviceService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_uuid(&self, serviceUuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromUuid)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_short_id(&self, serviceShortId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromShortId)(self.0.as_abi() as *const _ as *mut _, serviceShortId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ConvertShortIdToUuid)(self.0.as_abi() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceServiceStatics2, 100931694, 9382, 19213, 162, 242, 48, 204, 1, 84, 93, 37);
RT_INTERFACE!{static interface IGattDeviceServiceStatics2(IGattDeviceServiceStatics2Vtbl, IGattDeviceServiceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGattDeviceServiceStatics2] {
    fn FromIdWithSharingModeAsync(&self, deviceId: HSTRING, sharingMode: GattSharingMode, out: *mut <foundation::IAsyncOperation<GattDeviceService> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceId(&self, bluetoothDeviceId: <super::BluetoothDeviceId as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdWithCacheMode(&self, bluetoothDeviceId: <super::BluetoothDeviceId as RtType>::Abi, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdAndUuid(&self, bluetoothDeviceId: <super::BluetoothDeviceId as RtType>::Abi, serviceUuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdAndUuidWithCacheMode(&self, bluetoothDeviceId: <super::BluetoothDeviceId as RtType>::Abi, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT
}}
impl IGattDeviceServiceStatics2 {
    #[inline] pub fn from_id_with_sharing_mode_async(&self, deviceId: &HStringArg, sharingMode: GattSharingMode) -> Result<foundation::IAsyncOperation<GattDeviceService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdWithSharingModeAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), sharingMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id(&self, bluetoothDeviceId: &super::BluetoothDeviceId) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceId)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDeviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_with_cache_mode(&self, bluetoothDeviceId: &super::BluetoothDeviceId, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdWithCacheMode)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDeviceId) as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid(&self, bluetoothDeviceId: &super::BluetoothDeviceId, serviceUuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdAndUuid)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDeviceId) as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(&self, bluetoothDeviceId: &super::BluetoothDeviceId, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdAndUuidWithCacheMode)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDeviceId) as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattLocalCharacteristic, 2933798765, 21522, 19828, 146, 168, 141, 235, 133, 38, 130, 156);
RT_INTERFACE!{interface IGattLocalCharacteristic(IGattLocalCharacteristicVtbl, IGattLocalCharacteristic_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristic] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn CreateDescriptorAsync(&self, descriptorUuid: Guid, parameters: <GattLocalDescriptorParameters as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattLocalDescriptorResult> as RtType>::Abi) -> HRESULT,
    fn get_Descriptors(&self, out: *mut <foundation::collections::IVectorView<GattLocalDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut <foundation::collections::IVectorView<GattPresentationFormat> as RtType>::Abi) -> HRESULT,
    fn get_SubscribedClients(&self, out: *mut <foundation::collections::IVectorView<GattSubscribedClient> as RtType>::Abi) -> HRESULT,
    fn add_SubscribedClientsChanged(&self, handler: <foundation::TypedEventHandler<GattLocalCharacteristic, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SubscribedClientsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReadRequested(&self, handler: <foundation::TypedEventHandler<GattLocalCharacteristic, GattReadRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WriteRequested(&self, handler: <foundation::TypedEventHandler<GattLocalCharacteristic, GattWriteRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WriteRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn NotifyValueAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<GattClientNotificationResult>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn NotifyValueForSubscribedClientAsync(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi, subscribedClient: <GattSubscribedClient as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattClientNotificationResult> as RtType>::Abi) -> HRESULT
}}
impl IGattLocalCharacteristic {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StaticValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_descriptor_async(&self, descriptorUuid: Guid, parameters: &GattLocalDescriptorParameters) -> Result<foundation::IAsyncOperation<GattLocalDescriptorResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDescriptorAsync)(self.0.as_abi() as *const _ as *mut _, descriptorUuid, get_abi(parameters) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<GattLocalDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<foundation::collections::IVectorView<GattPresentationFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subscribed_clients(&self) -> Result<Option<foundation::collections::IVectorView<GattSubscribedClient>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubscribedClients)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_subscribed_clients_changed(&self, handler: &foundation::TypedEventHandler<GattLocalCharacteristic, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SubscribedClientsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_subscribed_clients_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SubscribedClientsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_read_requested(&self, handler: &foundation::TypedEventHandler<GattLocalCharacteristic, GattReadRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_read_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_write_requested(&self, handler: &foundation::TypedEventHandler<GattLocalCharacteristic, GattWriteRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_WriteRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_write_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_WriteRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn notify_value_async(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<GattClientNotificationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).NotifyValueAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn notify_value_for_subscribed_client_async(&self, value: &crate::windows::storage::streams::IBuffer, subscribedClient: &GattSubscribedClient) -> Result<foundation::IAsyncOperation<GattClientNotificationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).NotifyValueForSubscribedClientAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, get_abi(subscribedClient) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristic: IGattLocalCharacteristic}
DEFINE_IID!(IID_IGattLocalCharacteristicParameters, 4210507188, 19711, 17607, 132, 69, 4, 14, 110, 173, 0, 99);
RT_INTERFACE!{interface IGattLocalCharacteristicParameters(IGattLocalCharacteristicParametersVtbl, IGattLocalCharacteristicParameters_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristicParameters] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_StaticValue(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn put_CharacteristicProperties(&self, value: GattCharacteristicProperties) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn put_ReadProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_WriteProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_UserDescription(&self, value: HSTRING) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut <foundation::collections::IVector<GattPresentationFormat> as RtType>::Abi) -> HRESULT
}}
impl IGattLocalCharacteristicParameters {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_static_value(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StaticValue)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StaticValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_characteristic_properties(&self, value: GattCharacteristicProperties) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CharacteristicProperties)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_read_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_user_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_UserDescription)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UserDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<foundation::collections::IVector<GattPresentationFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristicParameters: IGattLocalCharacteristicParameters}
impl RtActivatable<IActivationFactory> for GattLocalCharacteristicParameters {}
DEFINE_CLSID!(GattLocalCharacteristicParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,76,111,99,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattLocalCharacteristicParameters]);
DEFINE_IID!(IID_IGattLocalCharacteristicResult, 2037767835, 368, 17303, 150, 102, 146, 248, 99, 241, 46, 230);
RT_INTERFACE!{interface IGattLocalCharacteristicResult(IGattLocalCharacteristicResultVtbl, IGattLocalCharacteristicResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristicResult] {
    fn get_Characteristic(&self, out: *mut <GattLocalCharacteristic as RtType>::Abi) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IGattLocalCharacteristicResult {
    #[inline] pub fn get_characteristic(&self) -> Result<Option<GattLocalCharacteristic>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristic)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattLocalCharacteristic::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristicResult: IGattLocalCharacteristicResult}
DEFINE_IID!(IID_IGattLocalDescriptor, 4102995462, 30877, 19019, 134, 82, 189, 1, 123, 93, 47, 198);
RT_INTERFACE!{interface IGattLocalDescriptor(IGattLocalDescriptorVtbl, IGattLocalDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptor] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn add_ReadRequested(&self, handler: <foundation::TypedEventHandler<GattLocalDescriptor, GattReadRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WriteRequested(&self, handler: <foundation::TypedEventHandler<GattLocalDescriptor, GattWriteRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WriteRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGattLocalDescriptor {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StaticValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_read_requested(&self, handler: &foundation::TypedEventHandler<GattLocalDescriptor, GattReadRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_read_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_write_requested(&self, handler: &foundation::TypedEventHandler<GattLocalDescriptor, GattWriteRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_WriteRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_write_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_WriteRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptor: IGattLocalDescriptor}
DEFINE_IID!(IID_IGattLocalDescriptorParameters, 1608441450, 62401, 19302, 140, 75, 227, 210, 41, 59, 64, 233);
RT_INTERFACE!{interface IGattLocalDescriptorParameters(IGattLocalDescriptorParametersVtbl, IGattLocalDescriptorParameters_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptorParameters] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_StaticValue(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn put_ReadProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_WriteProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT
}}
impl IGattLocalDescriptorParameters {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_static_value(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StaticValue)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StaticValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_read_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptorParameters: IGattLocalDescriptorParameters}
impl RtActivatable<IActivationFactory> for GattLocalDescriptorParameters {}
DEFINE_CLSID!(GattLocalDescriptorParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,76,111,99,97,108,68,101,115,99,114,105,112,116,111,114,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattLocalDescriptorParameters]);
DEFINE_IID!(IID_IGattLocalDescriptorResult, 928485822, 12831, 17254, 191, 193, 59, 198, 184, 44, 121, 248);
RT_INTERFACE!{interface IGattLocalDescriptorResult(IGattLocalDescriptorResultVtbl, IGattLocalDescriptorResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptorResult] {
    fn get_Descriptor(&self, out: *mut <GattLocalDescriptor as RtType>::Abi) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IGattLocalDescriptorResult {
    #[inline] pub fn get_descriptor(&self) -> Result<Option<GattLocalDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattLocalDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptorResult: IGattLocalDescriptorResult}
DEFINE_IID!(IID_IGattLocalService, 4111721048, 63479, 18690, 184, 3, 87, 252, 199, 214, 254, 131);
RT_INTERFACE!{interface IGattLocalService(IGattLocalServiceVtbl, IGattLocalService_Abi): IInspectable(IInspectableVtbl) [IID_IGattLocalService] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn CreateCharacteristicAsync(&self, characteristicUuid: Guid, parameters: <GattLocalCharacteristicParameters as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattLocalCharacteristicResult> as RtType>::Abi) -> HRESULT,
    fn get_Characteristics(&self, out: *mut <foundation::collections::IVectorView<GattLocalCharacteristic> as RtType>::Abi) -> HRESULT
}}
impl IGattLocalService {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_characteristic_async(&self, characteristicUuid: Guid, parameters: &GattLocalCharacteristicParameters) -> Result<foundation::IAsyncOperation<GattLocalCharacteristicResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateCharacteristicAsync)(self.0.as_abi() as *const _ as *mut _, characteristicUuid, get_abi(parameters) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<GattLocalCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalService: IGattLocalService}
RT_ENUM! { enum GattOpenStatus: i32 {
    Unspecified = 0, Success = 1, AlreadyOpened = 2, NotFound = 3, SharingViolation = 4, AccessDenied = 5,
}}
DEFINE_IID!(IID_IGattPresentationFormat, 426573857, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{interface IGattPresentationFormat(IGattPresentationFormatVtbl, IGattPresentationFormat_Abi): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormat] {
    fn get_FormatType(&self, out: *mut u8) -> HRESULT,
    fn get_Exponent(&self, out: *mut i32) -> HRESULT,
    fn get_Unit(&self, out: *mut u16) -> HRESULT,
    fn get_Namespace(&self, out: *mut u8) -> HRESULT,
    fn get_Description(&self, out: *mut u16) -> HRESULT
}}
impl IGattPresentationFormat {
    #[inline] pub fn get_format_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FormatType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_exponent(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exponent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Unit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_namespace(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Namespace)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattPresentationFormat: IGattPresentationFormat}
impl RtActivatable<IGattPresentationFormatStatics> for GattPresentationFormat {}
impl RtActivatable<IGattPresentationFormatStatics2> for GattPresentationFormat {}
impl GattPresentationFormat {
    #[inline] pub fn get_bluetooth_sig_assigned_numbers() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatStatics>>::get_activation_factory().get_bluetooth_sig_assigned_numbers()
    }
    #[inline] pub fn from_parts(formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16) -> Result<Option<GattPresentationFormat>> {
        <Self as RtActivatable<IGattPresentationFormatStatics2>>::get_activation_factory().from_parts(formatType, exponent, unit, namespaceId, description)
    }
}
DEFINE_CLSID!(GattPresentationFormat(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,0]) [CLSID_GattPresentationFormat]);
DEFINE_IID!(IID_IGattPresentationFormatStatics, 426573856, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{static interface IGattPresentationFormatStatics(IGattPresentationFormatStaticsVtbl, IGattPresentationFormatStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatStatics] {
    fn get_BluetoothSigAssignedNumbers(&self, out: *mut u8) -> HRESULT
}}
impl IGattPresentationFormatStatics {
    #[inline] pub fn get_bluetooth_sig_assigned_numbers(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluetoothSigAssignedNumbers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattPresentationFormatStatics2, 2848069395, 47151, 17246, 182, 52, 33, 253, 133, 164, 60, 7);
RT_INTERFACE!{static interface IGattPresentationFormatStatics2(IGattPresentationFormatStatics2Vtbl, IGattPresentationFormatStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatStatics2] {
    fn FromParts(&self, formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16, out: *mut <GattPresentationFormat as RtType>::Abi) -> HRESULT
}}
impl IGattPresentationFormatStatics2 {
    #[inline] pub fn from_parts(&self, formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16) -> Result<Option<GattPresentationFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromParts)(self.0.as_abi() as *const _ as *mut _, formatType, exponent, unit, namespaceId, description, &mut out);
        if hr == S_OK { Ok(GattPresentationFormat::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattPresentationFormatTypes}
impl RtActivatable<IGattPresentationFormatTypesStatics> for GattPresentationFormatTypes {}
impl GattPresentationFormatTypes {
    #[inline] pub fn get_boolean() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_boolean()
    }
    #[inline] pub fn get_bit2() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_bit2()
    }
    #[inline] pub fn get_nibble() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_nibble()
    }
    #[inline] pub fn get_uint8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint8()
    }
    #[inline] pub fn get_uint12() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint12()
    }
    #[inline] pub fn get_uint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint16()
    }
    #[inline] pub fn get_uint24() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint24()
    }
    #[inline] pub fn get_uint32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint32()
    }
    #[inline] pub fn get_uint48() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint48()
    }
    #[inline] pub fn get_uint64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint64()
    }
    #[inline] pub fn get_uint128() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint128()
    }
    #[inline] pub fn get_sint8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint8()
    }
    #[inline] pub fn get_sint12() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint12()
    }
    #[inline] pub fn get_sint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint16()
    }
    #[inline] pub fn get_sint24() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint24()
    }
    #[inline] pub fn get_sint32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint32()
    }
    #[inline] pub fn get_sint48() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint48()
    }
    #[inline] pub fn get_sint64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint64()
    }
    #[inline] pub fn get_sint128() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint128()
    }
    #[inline] pub fn get_float32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float32()
    }
    #[inline] pub fn get_float64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float64()
    }
    #[inline] pub fn get_sfloat() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sfloat()
    }
    #[inline] pub fn get_float() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float()
    }
    #[inline] pub fn get_duint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_duint16()
    }
    #[inline] pub fn get_utf8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_utf8()
    }
    #[inline] pub fn get_utf16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_utf16()
    }
    #[inline] pub fn get_struct() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_struct()
    }
}
DEFINE_CLSID!(GattPresentationFormatTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,84,121,112,101,115,0]) [CLSID_GattPresentationFormatTypes]);
DEFINE_IID!(IID_IGattPresentationFormatTypesStatics, 4210145802, 12474, 16540, 190, 247, 207, 251, 109, 3, 184, 251);
RT_INTERFACE!{static interface IGattPresentationFormatTypesStatics(IGattPresentationFormatTypesStaticsVtbl, IGattPresentationFormatTypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatTypesStatics] {
    fn get_Boolean(&self, out: *mut u8) -> HRESULT,
    fn get_Bit2(&self, out: *mut u8) -> HRESULT,
    fn get_Nibble(&self, out: *mut u8) -> HRESULT,
    fn get_UInt8(&self, out: *mut u8) -> HRESULT,
    fn get_UInt12(&self, out: *mut u8) -> HRESULT,
    fn get_UInt16(&self, out: *mut u8) -> HRESULT,
    fn get_UInt24(&self, out: *mut u8) -> HRESULT,
    fn get_UInt32(&self, out: *mut u8) -> HRESULT,
    fn get_UInt48(&self, out: *mut u8) -> HRESULT,
    fn get_UInt64(&self, out: *mut u8) -> HRESULT,
    fn get_UInt128(&self, out: *mut u8) -> HRESULT,
    fn get_SInt8(&self, out: *mut u8) -> HRESULT,
    fn get_SInt12(&self, out: *mut u8) -> HRESULT,
    fn get_SInt16(&self, out: *mut u8) -> HRESULT,
    fn get_SInt24(&self, out: *mut u8) -> HRESULT,
    fn get_SInt32(&self, out: *mut u8) -> HRESULT,
    fn get_SInt48(&self, out: *mut u8) -> HRESULT,
    fn get_SInt64(&self, out: *mut u8) -> HRESULT,
    fn get_SInt128(&self, out: *mut u8) -> HRESULT,
    fn get_Float32(&self, out: *mut u8) -> HRESULT,
    fn get_Float64(&self, out: *mut u8) -> HRESULT,
    fn get_SFloat(&self, out: *mut u8) -> HRESULT,
    fn get_Float(&self, out: *mut u8) -> HRESULT,
    fn get_DUInt16(&self, out: *mut u8) -> HRESULT,
    fn get_Utf8(&self, out: *mut u8) -> HRESULT,
    fn get_Utf16(&self, out: *mut u8) -> HRESULT,
    fn get_Struct(&self, out: *mut u8) -> HRESULT
}}
impl IGattPresentationFormatTypesStatics {
    #[inline] pub fn get_boolean(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Boolean)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bit2(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bit2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_nibble(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Nibble)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint12(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt12)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint24(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt24)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint48(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt48)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt64)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint128(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UInt128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint12(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt12)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint24(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt24)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint48(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt48)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt64)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint128(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SInt128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Float32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Float64)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sfloat(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SFloat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Float)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DUInt16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_utf8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Utf8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_utf16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Utf16)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_struct(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Struct)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattProtectionLevel: i32 {
    Plain = 0, AuthenticationRequired = 1, EncryptionRequired = 2, EncryptionAndAuthenticationRequired = 3,
}}
RT_CLASS!{static class GattProtocolError}
impl RtActivatable<IGattProtocolErrorStatics> for GattProtocolError {}
impl GattProtocolError {
    #[inline] pub fn get_invalid_handle() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_handle()
    }
    #[inline] pub fn get_read_not_permitted() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_read_not_permitted()
    }
    #[inline] pub fn get_write_not_permitted() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_write_not_permitted()
    }
    #[inline] pub fn get_invalid_pdu() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_pdu()
    }
    #[inline] pub fn get_insufficient_authentication() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_authentication()
    }
    #[inline] pub fn get_request_not_supported() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_request_not_supported()
    }
    #[inline] pub fn get_invalid_offset() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_offset()
    }
    #[inline] pub fn get_insufficient_authorization() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_authorization()
    }
    #[inline] pub fn get_prepare_queue_full() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_prepare_queue_full()
    }
    #[inline] pub fn get_attribute_not_found() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_attribute_not_found()
    }
    #[inline] pub fn get_attribute_not_long() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_attribute_not_long()
    }
    #[inline] pub fn get_insufficient_encryption_key_size() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_encryption_key_size()
    }
    #[inline] pub fn get_invalid_attribute_value_length() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_attribute_value_length()
    }
    #[inline] pub fn get_unlikely_error() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_unlikely_error()
    }
    #[inline] pub fn get_insufficient_encryption() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_encryption()
    }
    #[inline] pub fn get_unsupported_group_type() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_unsupported_group_type()
    }
    #[inline] pub fn get_insufficient_resources() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_resources()
    }
}
DEFINE_CLSID!(GattProtocolError(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,111,116,111,99,111,108,69,114,114,111,114,0]) [CLSID_GattProtocolError]);
DEFINE_IID!(IID_IGattProtocolErrorStatics, 3393635781, 3788, 18441, 190, 163, 207, 121, 188, 153, 30, 55);
RT_INTERFACE!{static interface IGattProtocolErrorStatics(IGattProtocolErrorStaticsVtbl, IGattProtocolErrorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattProtocolErrorStatics] {
    fn get_InvalidHandle(&self, out: *mut u8) -> HRESULT,
    fn get_ReadNotPermitted(&self, out: *mut u8) -> HRESULT,
    fn get_WriteNotPermitted(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidPdu(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientAuthentication(&self, out: *mut u8) -> HRESULT,
    fn get_RequestNotSupported(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidOffset(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientAuthorization(&self, out: *mut u8) -> HRESULT,
    fn get_PrepareQueueFull(&self, out: *mut u8) -> HRESULT,
    fn get_AttributeNotFound(&self, out: *mut u8) -> HRESULT,
    fn get_AttributeNotLong(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientEncryptionKeySize(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidAttributeValueLength(&self, out: *mut u8) -> HRESULT,
    fn get_UnlikelyError(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientEncryption(&self, out: *mut u8) -> HRESULT,
    fn get_UnsupportedGroupType(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientResources(&self, out: *mut u8) -> HRESULT
}}
impl IGattProtocolErrorStatics {
    #[inline] pub fn get_invalid_handle(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidHandle)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_read_not_permitted(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadNotPermitted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_not_permitted(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteNotPermitted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_pdu(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidPdu)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_authentication(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientAuthentication)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_request_not_supported(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestNotSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_offset(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_authorization(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientAuthorization)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_prepare_queue_full(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrepareQueueFull)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_not_found(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttributeNotFound)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_not_long(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttributeNotLong)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_encryption_key_size(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientEncryptionKeySize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_attribute_value_length(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InvalidAttributeValueLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unlikely_error(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnlikelyError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_encryption(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientEncryption)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unsupported_group_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnsupportedGroupType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_resources(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InsufficientResources)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReadClientCharacteristicConfigurationDescriptorResult, 1671851785, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReadClientCharacteristicConfigurationDescriptorResult(IGattReadClientCharacteristicConfigurationDescriptorResultVtbl, IGattReadClientCharacteristicConfigurationDescriptorResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadClientCharacteristicConfigurationDescriptorResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ClientCharacteristicConfigurationDescriptor(&self, out: *mut GattClientCharacteristicConfigurationDescriptorValue) -> HRESULT
}}
impl IGattReadClientCharacteristicConfigurationDescriptorResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_client_characteristic_configuration_descriptor(&self) -> Result<GattClientCharacteristicConfigurationDescriptorValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClientCharacteristicConfigurationDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadClientCharacteristicConfigurationDescriptorResult: IGattReadClientCharacteristicConfigurationDescriptorResult}
DEFINE_IID!(IID_IGattReadClientCharacteristicConfigurationDescriptorResult2, 468821405, 47693, 17954, 134, 81, 244, 238, 21, 13, 10, 93);
RT_INTERFACE!{interface IGattReadClientCharacteristicConfigurationDescriptorResult2(IGattReadClientCharacteristicConfigurationDescriptorResult2Vtbl, IGattReadClientCharacteristicConfigurationDescriptorResult2_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadClientCharacteristicConfigurationDescriptorResult2] {
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT
}}
impl IGattReadClientCharacteristicConfigurationDescriptorResult2 {
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReadRequest, 4057818421, 27341, 17062, 164, 187, 215, 137, 218, 224, 4, 62);
RT_INTERFACE!{interface IGattReadRequest(IGattReadRequestVtbl, IGattReadRequest_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadRequest] {
    fn get_Offset(&self, out: *mut u32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<GattReadRequest, GattRequestStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn RespondWithValue(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn RespondWithProtocolError(&self, protocolError: u8) -> HRESULT
}}
impl IGattReadRequest {
    #[inline] pub fn get_offset(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Offset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<GattReadRequest, GattRequestStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn respond_with_value(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RespondWithValue)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond_with_protocol_error(&self, protocolError: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RespondWithProtocolError)(self.0.as_abi() as *const _ as *mut _, protocolError);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadRequest: IGattReadRequest}
DEFINE_IID!(IID_IGattReadRequestedEventArgs, 2471064131, 62364, 18507, 138, 182, 153, 107, 164, 134, 207, 163);
RT_INTERFACE!{interface IGattReadRequestedEventArgs(IGattReadRequestedEventArgsVtbl, IGattReadRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadRequestedEventArgs] {
    fn get_Session(&self, out: *mut <GattSession as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT,
    fn GetRequestAsync(&self, out: *mut <foundation::IAsyncOperation<GattReadRequest> as RtType>::Abi) -> HRESULT
}}
impl IGattReadRequestedEventArgs {
    #[inline] pub fn get_session(&self) -> Result<Option<GattSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_request_async(&self) -> Result<foundation::IAsyncOperation<GattReadRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRequestAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadRequestedEventArgs: IGattReadRequestedEventArgs}
DEFINE_IID!(IID_IGattReadResult, 1671851784, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReadResult(IGattReadResultVtbl, IGattReadResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IGattReadResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadResult: IGattReadResult}
DEFINE_IID!(IID_IGattReadResult2, 2702135456, 64323, 18607, 186, 170, 99, 138, 92, 99, 41, 254);
RT_INTERFACE!{interface IGattReadResult2(IGattReadResult2Vtbl, IGattReadResult2_Abi): IInspectable(IInspectableVtbl) [IID_IGattReadResult2] {
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT
}}
impl IGattReadResult2 {
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReliableWriteTransaction, 1671851783, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReliableWriteTransaction(IGattReliableWriteTransactionVtbl, IGattReliableWriteTransaction_Abi): IInspectable(IInspectableVtbl) [IID_IGattReliableWriteTransaction] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValue(&self, characteristic: <GattCharacteristic as RtType>::Abi, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn CommitAsync(&self, out: *mut <foundation::IAsyncOperation<GattCommunicationStatus> as RtType>::Abi) -> HRESULT
}}
impl IGattReliableWriteTransaction {
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value(&self, characteristic: &GattCharacteristic, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).WriteValue)(self.0.as_abi() as *const _ as *mut _, get_abi(characteristic) as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn commit_async(&self) -> Result<foundation::IAsyncOperation<GattCommunicationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CommitAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReliableWriteTransaction: IGattReliableWriteTransaction}
impl RtActivatable<IActivationFactory> for GattReliableWriteTransaction {}
DEFINE_CLSID!(GattReliableWriteTransaction(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,82,101,108,105,97,98,108,101,87,114,105,116,101,84,114,97,110,115,97,99,116,105,111,110,0]) [CLSID_GattReliableWriteTransaction]);
DEFINE_IID!(IID_IGattReliableWriteTransaction2, 1360083335, 61202, 17967, 159, 178, 161, 164, 58, 103, 148, 22);
RT_INTERFACE!{interface IGattReliableWriteTransaction2(IGattReliableWriteTransaction2Vtbl, IGattReliableWriteTransaction2_Abi): IInspectable(IInspectableVtbl) [IID_IGattReliableWriteTransaction2] {
    fn CommitWithResultAsync(&self, out: *mut <foundation::IAsyncOperation<GattWriteResult> as RtType>::Abi) -> HRESULT
}}
impl IGattReliableWriteTransaction2 {
    #[inline] pub fn commit_with_result_async(&self) -> Result<foundation::IAsyncOperation<GattWriteResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CommitWithResultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattRequestState: i32 {
    Pending = 0, Completed = 1, Canceled = 2,
}}
DEFINE_IID!(IID_IGattRequestStateChangedEventArgs, 3895777580, 10174, 17587, 157, 13, 79, 198, 232, 8, 221, 63);
RT_INTERFACE!{interface IGattRequestStateChangedEventArgs(IGattRequestStateChangedEventArgsVtbl, IGattRequestStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattRequestStateChangedEventArgs] {
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl IGattRequestStateChangedEventArgs {
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattRequestStateChangedEventArgs: IGattRequestStateChangedEventArgs}
DEFINE_IID!(IID_IGattServiceProvider, 2015540173, 10377, 20358, 160, 81, 63, 10, 237, 28, 39, 96);
RT_INTERFACE!{interface IGattServiceProvider(IGattServiceProviderVtbl, IGattServiceProvider_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProvider] {
    fn get_Service(&self, out: *mut <GattLocalService as RtType>::Abi) -> HRESULT,
    fn get_AdvertisementStatus(&self, out: *mut GattServiceProviderAdvertisementStatus) -> HRESULT,
    fn add_AdvertisementStatusChanged(&self, handler: <foundation::TypedEventHandler<GattServiceProvider, GattServiceProviderAdvertisementStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AdvertisementStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn StartAdvertising(&self) -> HRESULT,
    fn StartAdvertisingWithParameters(&self, parameters: <GattServiceProviderAdvertisingParameters as RtType>::Abi) -> HRESULT,
    fn StopAdvertising(&self) -> HRESULT
}}
impl IGattServiceProvider {
    #[inline] pub fn get_service(&self) -> Result<Option<GattLocalService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Service)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattLocalService::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_status(&self) -> Result<GattServiceProviderAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisementStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_advertisement_status_changed(&self, handler: &foundation::TypedEventHandler<GattServiceProvider, GattServiceProviderAdvertisementStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AdvertisementStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_advertisement_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AdvertisementStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartAdvertising)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_advertising_with_parameters(&self, parameters: &GattServiceProviderAdvertisingParameters) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartAdvertisingWithParameters)(self.0.as_abi() as *const _ as *mut _, get_abi(parameters) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopAdvertising)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProvider: IGattServiceProvider}
impl RtActivatable<IGattServiceProviderStatics> for GattServiceProvider {}
impl GattServiceProvider {
    #[inline] pub fn create_async(serviceUuid: Guid) -> Result<foundation::IAsyncOperation<GattServiceProviderResult>> {
        <Self as RtActivatable<IGattServiceProviderStatics>>::get_activation_factory().create_async(serviceUuid)
    }
}
DEFINE_CLSID!(GattServiceProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,0]) [CLSID_GattServiceProvider]);
RT_ENUM! { enum GattServiceProviderAdvertisementStatus: i32 {
    Created = 0, Stopped = 1, Started = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IGattServiceProviderAdvertisementStatusChangedEventArgs, 1504029285, 64033, 20476, 177, 85, 4, 217, 40, 1, 38, 134);
RT_INTERFACE!{interface IGattServiceProviderAdvertisementStatusChangedEventArgs(IGattServiceProviderAdvertisementStatusChangedEventArgsVtbl, IGattServiceProviderAdvertisementStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderAdvertisementStatusChangedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Status(&self, out: *mut GattServiceProviderAdvertisementStatus) -> HRESULT
}}
impl IGattServiceProviderAdvertisementStatusChangedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattServiceProviderAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderAdvertisementStatusChangedEventArgs: IGattServiceProviderAdvertisementStatusChangedEventArgs}
DEFINE_IID!(IID_IGattServiceProviderAdvertisingParameters, 3805163947, 25365, 19490, 155, 215, 120, 29, 188, 61, 141, 130);
RT_INTERFACE!{interface IGattServiceProviderAdvertisingParameters(IGattServiceProviderAdvertisingParametersVtbl, IGattServiceProviderAdvertisingParameters_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderAdvertisingParameters] {
    fn put_IsConnectable(&self, value: bool) -> HRESULT,
    fn get_IsConnectable(&self, out: *mut bool) -> HRESULT,
    fn put_IsDiscoverable(&self, value: bool) -> HRESULT,
    fn get_IsDiscoverable(&self, out: *mut bool) -> HRESULT
}}
impl IGattServiceProviderAdvertisingParameters {
    #[inline] pub fn set_is_connectable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsConnectable)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connectable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsConnectable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_discoverable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDiscoverable)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_discoverable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDiscoverable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderAdvertisingParameters: IGattServiceProviderAdvertisingParameters}
impl RtActivatable<IActivationFactory> for GattServiceProviderAdvertisingParameters {}
DEFINE_CLSID!(GattServiceProviderAdvertisingParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,65,100,118,101,114,116,105,115,105,110,103,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattServiceProviderAdvertisingParameters]);
DEFINE_IID!(IID_IGattServiceProviderResult, 1984337624, 50494, 17036, 138, 72, 103, 175, 224, 44, 58, 230);
RT_INTERFACE!{interface IGattServiceProviderResult(IGattServiceProviderResultVtbl, IGattServiceProviderResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderResult] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_ServiceProvider(&self, out: *mut <GattServiceProvider as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderResult {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_provider(&self) -> Result<Option<GattServiceProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceProvider)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattServiceProvider::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderResult: IGattServiceProviderResult}
DEFINE_IID!(IID_IGattServiceProviderStatics, 830029923, 21078, 16468, 164, 244, 123, 190, 119, 85, 165, 126);
RT_INTERFACE!{static interface IGattServiceProviderStatics(IGattServiceProviderStaticsVtbl, IGattServiceProviderStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderStatics] {
    fn CreateAsync(&self, serviceUuid: Guid, out: *mut <foundation::IAsyncOperation<GattServiceProviderResult> as RtType>::Abi) -> HRESULT
}}
impl IGattServiceProviderStatics {
    #[inline] pub fn create_async(&self, serviceUuid: Guid) -> Result<foundation::IAsyncOperation<GattServiceProviderResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattServiceUuids}
impl RtActivatable<IGattServiceUuidsStatics> for GattServiceUuids {}
impl RtActivatable<IGattServiceUuidsStatics2> for GattServiceUuids {}
impl GattServiceUuids {
    #[inline] pub fn get_battery() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_battery()
    }
    #[inline] pub fn get_blood_pressure() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_blood_pressure()
    }
    #[inline] pub fn get_cycling_speed_and_cadence() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_cycling_speed_and_cadence()
    }
    #[inline] pub fn get_generic_access() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_generic_access()
    }
    #[inline] pub fn get_generic_attribute() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_generic_attribute()
    }
    #[inline] pub fn get_glucose() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_glucose()
    }
    #[inline] pub fn get_health_thermometer() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_health_thermometer()
    }
    #[inline] pub fn get_heart_rate() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_heart_rate()
    }
    #[inline] pub fn get_running_speed_and_cadence() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_running_speed_and_cadence()
    }
    #[inline] pub fn get_alert_notification() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_alert_notification()
    }
    #[inline] pub fn get_current_time() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_current_time()
    }
    #[inline] pub fn get_cycling_power() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_cycling_power()
    }
    #[inline] pub fn get_device_information() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_device_information()
    }
    #[inline] pub fn get_human_interface_device() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_human_interface_device()
    }
    #[inline] pub fn get_immediate_alert() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_immediate_alert()
    }
    #[inline] pub fn get_link_loss() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_link_loss()
    }
    #[inline] pub fn get_location_and_navigation() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_location_and_navigation()
    }
    #[inline] pub fn get_next_dst_change() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_next_dst_change()
    }
    #[inline] pub fn get_phone_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_phone_alert_status()
    }
    #[inline] pub fn get_reference_time_update() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_reference_time_update()
    }
    #[inline] pub fn get_scan_parameters() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_scan_parameters()
    }
    #[inline] pub fn get_tx_power() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_tx_power()
    }
}
DEFINE_CLSID!(GattServiceUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,85,117,105,100,115,0]) [CLSID_GattServiceUuids]);
DEFINE_IID!(IID_IGattServiceUuidsStatics, 1841655896, 39610, 17431, 184, 242, 220, 224, 22, 211, 78, 226);
RT_INTERFACE!{static interface IGattServiceUuidsStatics(IGattServiceUuidsStaticsVtbl, IGattServiceUuidsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics] {
    fn get_Battery(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressure(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingSpeedAndCadence(&self, out: *mut Guid) -> HRESULT,
    fn get_GenericAccess(&self, out: *mut Guid) -> HRESULT,
    fn get_GenericAttribute(&self, out: *mut Guid) -> HRESULT,
    fn get_Glucose(&self, out: *mut Guid) -> HRESULT,
    fn get_HealthThermometer(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRate(&self, out: *mut Guid) -> HRESULT,
    fn get_RunningSpeedAndCadence(&self, out: *mut Guid) -> HRESULT
}}
impl IGattServiceUuidsStatics {
    #[inline] pub fn get_battery(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Battery)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BloodPressure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_and_cadence(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingSpeedAndCadence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_access(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GenericAccess)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_attribute(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GenericAttribute)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Glucose)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_health_thermometer(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HealthThermometer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeartRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_speed_and_cadence(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RunningSpeedAndCadence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceUuidsStatics2, 3534656757, 15637, 20345, 156, 12, 234, 175, 166, 117, 21, 92);
RT_INTERFACE!{static interface IGattServiceUuidsStatics2(IGattServiceUuidsStatics2Vtbl, IGattServiceUuidsStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics2] {
    fn get_AlertNotification(&self, out: *mut Guid) -> HRESULT,
    fn get_CurrentTime(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPower(&self, out: *mut Guid) -> HRESULT,
    fn get_DeviceInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_HumanInterfaceDevice(&self, out: *mut Guid) -> HRESULT,
    fn get_ImmediateAlert(&self, out: *mut Guid) -> HRESULT,
    fn get_LinkLoss(&self, out: *mut Guid) -> HRESULT,
    fn get_LocationAndNavigation(&self, out: *mut Guid) -> HRESULT,
    fn get_NextDstChange(&self, out: *mut Guid) -> HRESULT,
    fn get_PhoneAlertStatus(&self, out: *mut Guid) -> HRESULT,
    fn get_ReferenceTimeUpdate(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanParameters(&self, out: *mut Guid) -> HRESULT,
    fn get_TxPower(&self, out: *mut Guid) -> HRESULT
}}
impl IGattServiceUuidsStatics2 {
    #[inline] pub fn get_alert_notification(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlertNotification)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CyclingPower)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_human_interface_device(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HumanInterfaceDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_immediate_alert(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImmediateAlert)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_link_loss(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LinkLoss)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_and_navigation(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationAndNavigation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_next_dst_change(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NextDstChange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhoneAlertStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reference_time_update(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReferenceTimeUpdate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_parameters(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanParameters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TxPower)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattSession, 3527102787, 57422, 19492, 153, 156, 156, 37, 111, 152, 86, 177);
RT_INTERFACE!{interface IGattSession(IGattSessionVtbl, IGattSession_Abi): IInspectable(IInspectableVtbl) [IID_IGattSession] {
    fn get_DeviceId(&self, out: *mut <super::BluetoothDeviceId as RtType>::Abi) -> HRESULT,
    fn get_CanMaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn put_MaintainConnection(&self, value: bool) -> HRESULT,
    fn get_MaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn get_MaxPduSize(&self, out: *mut u16) -> HRESULT,
    fn get_SessionStatus(&self, out: *mut GattSessionStatus) -> HRESULT,
    fn add_MaxPduSizeChanged(&self, handler: <foundation::TypedEventHandler<GattSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MaxPduSizeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SessionStatusChanged(&self, handler: <foundation::TypedEventHandler<GattSession, GattSessionStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGattSession {
    #[inline] pub fn get_device_id(&self) -> Result<Option<super::BluetoothDeviceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothDeviceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanMaintainConnection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_maintain_connection(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaintainConnection)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaintainConnection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_pdu_size(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPduSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_session_status(&self) -> Result<GattSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_max_pdu_size_changed(&self, handler: &foundation::TypedEventHandler<GattSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MaxPduSizeChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_max_pdu_size_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MaxPduSizeChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_session_status_changed(&self, handler: &foundation::TypedEventHandler<GattSession, GattSessionStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSession: IGattSession}
impl RtActivatable<IGattSessionStatics> for GattSession {}
impl GattSession {
    #[inline] pub fn from_device_id_async(deviceId: &super::BluetoothDeviceId) -> Result<foundation::IAsyncOperation<GattSession>> {
        <Self as RtActivatable<IGattSessionStatics>>::get_activation_factory().from_device_id_async(deviceId)
    }
}
DEFINE_CLSID!(GattSession(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,115,115,105,111,110,0]) [CLSID_GattSession]);
DEFINE_IID!(IID_IGattSessionStatics, 778418524, 21407, 19895, 130, 168, 115, 189, 187, 247, 62, 191);
RT_INTERFACE!{static interface IGattSessionStatics(IGattSessionStaticsVtbl, IGattSessionStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGattSessionStatics] {
    fn FromDeviceIdAsync(&self, deviceId: <super::BluetoothDeviceId as RtType>::Abi, out: *mut <foundation::IAsyncOperation<GattSession> as RtType>::Abi) -> HRESULT
}}
impl IGattSessionStatics {
    #[inline] pub fn from_device_id_async(&self, deviceId: &super::BluetoothDeviceId) -> Result<foundation::IAsyncOperation<GattSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromDeviceIdAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(deviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattSessionStatus: i32 {
    Closed = 0, Active = 1,
}}
DEFINE_IID!(IID_IGattSessionStatusChangedEventArgs, 1980086062, 33663, 16460, 171, 52, 49, 99, 243, 157, 223, 50);
RT_INTERFACE!{interface IGattSessionStatusChangedEventArgs(IGattSessionStatusChangedEventArgsVtbl, IGattSessionStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattSessionStatusChangedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Status(&self, out: *mut GattSessionStatus) -> HRESULT
}}
impl IGattSessionStatusChangedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSessionStatusChangedEventArgs: IGattSessionStatusChangedEventArgs}
RT_ENUM! { enum GattSharingMode: i32 {
    Unspecified = 0, Exclusive = 1, SharedReadOnly = 2, SharedReadAndWrite = 3,
}}
DEFINE_IID!(IID_IGattSubscribedClient, 1936625665, 5540, 20162, 146, 72, 227, 242, 13, 70, 59, 233);
RT_INTERFACE!{interface IGattSubscribedClient(IGattSubscribedClientVtbl, IGattSubscribedClient_Abi): IInspectable(IInspectableVtbl) [IID_IGattSubscribedClient] {
    fn get_Session(&self, out: *mut <GattSession as RtType>::Abi) -> HRESULT,
    fn get_MaxNotificationSize(&self, out: *mut u16) -> HRESULT,
    fn add_MaxNotificationSizeChanged(&self, handler: <foundation::TypedEventHandler<GattSubscribedClient, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MaxNotificationSizeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGattSubscribedClient {
    #[inline] pub fn get_session(&self) -> Result<Option<GattSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_notification_size(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxNotificationSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_max_notification_size_changed(&self, handler: &foundation::TypedEventHandler<GattSubscribedClient, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MaxNotificationSizeChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_max_notification_size_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MaxNotificationSizeChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSubscribedClient: IGattSubscribedClient}
DEFINE_IID!(IID_IGattValueChangedEventArgs, 3525040980, 1763, 20184, 162, 99, 172, 250, 200, 186, 115, 19);
RT_INTERFACE!{interface IGattValueChangedEventArgs(IGattValueChangedEventArgsVtbl, IGattValueChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattValueChangedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_CharacteristicValue(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IGattValueChangedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_characteristic_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacteristicValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattValueChangedEventArgs: IGattValueChangedEventArgs}
RT_ENUM! { enum GattWriteOption: i32 {
    WriteWithResponse = 0, WriteWithoutResponse = 1,
}}
DEFINE_IID!(IID_IGattWriteRequest, 2931206637, 56879, 20418, 169, 168, 148, 234, 120, 68, 241, 61);
RT_INTERFACE!{interface IGattWriteRequest(IGattWriteRequestVtbl, IGattWriteRequest_Abi): IInspectable(IInspectableVtbl) [IID_IGattWriteRequest] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Offset(&self, out: *mut u32) -> HRESULT,
    fn get_Option(&self, out: *mut GattWriteOption) -> HRESULT,
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<GattWriteRequest, GattRequestStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Respond(&self) -> HRESULT,
    fn RespondWithProtocolError(&self, protocolError: u8) -> HRESULT
}}
impl IGattWriteRequest {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Offset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_option(&self) -> Result<GattWriteOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Option)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<GattWriteRequest, GattRequestStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Respond)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond_with_protocol_error(&self, protocolError: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RespondWithProtocolError)(self.0.as_abi() as *const _ as *mut _, protocolError);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteRequest: IGattWriteRequest}
DEFINE_IID!(IID_IGattWriteRequestedEventArgs, 770476990, 42810, 18202, 148, 213, 3, 125, 234, 221, 8, 6);
RT_INTERFACE!{interface IGattWriteRequestedEventArgs(IGattWriteRequestedEventArgsVtbl, IGattWriteRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGattWriteRequestedEventArgs] {
    fn get_Session(&self, out: *mut <GattSession as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT,
    fn GetRequestAsync(&self, out: *mut <foundation::IAsyncOperation<GattWriteRequest> as RtType>::Abi) -> HRESULT
}}
impl IGattWriteRequestedEventArgs {
    #[inline] pub fn get_session(&self) -> Result<Option<GattSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GattSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_request_async(&self) -> Result<foundation::IAsyncOperation<GattWriteRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRequestAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteRequestedEventArgs: IGattWriteRequestedEventArgs}
DEFINE_IID!(IID_IGattWriteResult, 1234296241, 52011, 17655, 153, 252, 210, 154, 40, 113, 220, 155);
RT_INTERFACE!{interface IGattWriteResult(IGattWriteResultVtbl, IGattWriteResult_Abi): IInspectable(IInspectableVtbl) [IID_IGattWriteResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT
}}
impl IGattWriteResult {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteResult: IGattWriteResult}
} // Windows.Devices.Bluetooth.GenericAttributeProfile
pub mod rfcomm { // Windows.Devices.Bluetooth.Rfcomm
use crate::prelude::*;
DEFINE_IID!(IID_IRfcommDeviceService, 2927755039, 50593, 19520, 140, 40, 243, 239, 214, 144, 98, 243);
RT_INTERFACE!{interface IRfcommDeviceService(IRfcommDeviceServiceVtbl, IRfcommDeviceService_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_ConnectionHostName(&self, out: *mut <crate::windows::networking::HostName as RtType>::Abi) -> HRESULT,
    fn get_ConnectionServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceId(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_ProtectionLevel(&self, out: *mut crate::windows::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_MaxProtectionLevel(&self, out: *mut crate::windows::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetSdpRawAttributesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetSdpRawAttributesWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut <foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>> as RtType>::Abi) -> HRESULT
}}
impl IRfcommDeviceService {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_host_name(&self) -> Result<Option<crate::windows::networking::HostName>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionHostName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::networking::HostName::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionServiceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_id(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_protection_level(&self) -> Result<crate::windows::networking::sockets::SocketProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_max_protection_level(&self) -> Result<crate::windows::networking::sockets::SocketProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSdpRawAttributesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSdpRawAttributesWithCacheModeAsync)(self.0.as_abi() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommDeviceService: IRfcommDeviceService}
impl RtActivatable<IRfcommDeviceServiceStatics> for RfcommDeviceService {}
impl RtActivatable<IRfcommDeviceServiceStatics2> for RfcommDeviceService {}
impl RfcommDeviceService {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<RfcommDeviceService>> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector(serviceId: &RfcommServiceId) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics>>::get_activation_factory().get_device_selector(serviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device(bluetoothDevice: &super::BluetoothDevice) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device(bluetoothDevice)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_with_cache_mode(bluetoothDevice: &super::BluetoothDevice, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_with_cache_mode(bluetoothDevice, cacheMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id(bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_and_service_id(bluetoothDevice, serviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(bluetoothDevice, serviceId, cacheMode)
    }
}
DEFINE_CLSID!(RfcommDeviceService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,68,101,118,105,99,101,83,101,114,118,105,99,101,0]) [CLSID_RfcommDeviceService]);
DEFINE_IID!(IID_IRfcommDeviceService2, 1399647508, 60365, 18942, 191, 159, 64, 239, 198, 137, 178, 13);
RT_INTERFACE!{interface IRfcommDeviceService2(IRfcommDeviceService2Vtbl, IRfcommDeviceService2_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService2] {
    fn get_Device(&self, out: *mut <super::BluetoothDevice as RtType>::Abi) -> HRESULT
}}
impl IRfcommDeviceService2 {
    #[inline] pub fn get_device(&self) -> Result<Option<super::BluetoothDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BluetoothDevice::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceService3, 472034534, 56644, 19747, 134, 109, 143, 52, 134, 238, 100, 144);
RT_INTERFACE!{interface IRfcommDeviceService3(IRfcommDeviceService3Vtbl, IRfcommDeviceService3_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService3] {
    fn get_DeviceAccessInformation(&self, out: *mut <super::super::enumeration::DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IRfcommDeviceService3 {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<super::super::enumeration::DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceAccessInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::enumeration::DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceServicesResult, 994588812, 31951, 18574, 150, 37, 210, 89, 165, 115, 45, 85);
RT_INTERFACE!{interface IRfcommDeviceServicesResult(IRfcommDeviceServicesResultVtbl, IRfcommDeviceServicesResult_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServicesResult] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Services(&self, out: *mut <foundation::collections::IVectorView<RfcommDeviceService> as RtType>::Abi) -> HRESULT
}}
impl IRfcommDeviceServicesResult {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_services(&self) -> Result<Option<foundation::collections::IVectorView<RfcommDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Services)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommDeviceServicesResult: IRfcommDeviceServicesResult}
DEFINE_IID!(IID_IRfcommDeviceServiceStatics, 2762033647, 25197, 16812, 178, 83, 135, 172, 92, 39, 226, 138);
RT_INTERFACE!{static interface IRfcommDeviceServiceStatics(IRfcommDeviceServiceStaticsVtbl, IRfcommDeviceServiceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<RfcommDeviceService> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, serviceId: <RfcommServiceId as RtType>::Abi, out: *mut HSTRING) -> HRESULT
}}
impl IRfcommDeviceServiceStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<RfcommDeviceService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self, serviceId: &RfcommServiceId) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceServiceStatics2, 2861347273, 59277, 19428, 128, 118, 10, 61, 135, 160, 160, 95);
RT_INTERFACE!{static interface IRfcommDeviceServiceStatics2(IRfcommDeviceServiceStatics2Vtbl, IRfcommDeviceServiceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics2] {
    fn GetDeviceSelectorForBluetoothDevice(&self, bluetoothDevice: <super::BluetoothDevice as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceWithCacheMode(&self, bluetoothDevice: <super::BluetoothDevice as RtType>::Abi, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceAndServiceId(&self, bluetoothDevice: <super::BluetoothDevice as RtType>::Abi, serviceId: <RfcommServiceId as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode(&self, bluetoothDevice: <super::BluetoothDevice as RtType>::Abi, serviceId: <RfcommServiceId as RtType>::Abi, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT
}}
impl IRfcommDeviceServiceStatics2 {
    #[inline] pub fn get_device_selector_for_bluetooth_device(&self, bluetoothDevice: &super::BluetoothDevice) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDevice) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_with_cache_mode(&self, bluetoothDevice: &super::BluetoothDevice, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceWithCacheMode)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDevice) as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id(&self, bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceId)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDevice) as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(&self, bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode)(self.0.as_abi() as *const _ as *mut _, get_abi(bluetoothDevice) as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceId, 576885252, 32258, 16407, 129, 54, 218, 27, 106, 27, 155, 191);
RT_INTERFACE!{interface IRfcommServiceId(IRfcommServiceIdVtbl, IRfcommServiceId_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommServiceId] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn AsShortId(&self, out: *mut u32) -> HRESULT,
    fn AsString(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRfcommServiceId {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uuid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn as_short_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).AsShortId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn as_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AsString)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommServiceId: IRfcommServiceId}
impl RtActivatable<IRfcommServiceIdStatics> for RfcommServiceId {}
impl RfcommServiceId {
    #[inline] pub fn from_uuid(uuid: Guid) -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().from_uuid(uuid)
    }
    #[inline] pub fn from_short_id(shortId: u32) -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().from_short_id(shortId)
    }
    #[inline] pub fn get_serial_port() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_serial_port()
    }
    #[inline] pub fn get_obex_object_push() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_obex_object_push()
    }
    #[inline] pub fn get_obex_file_transfer() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_obex_file_transfer()
    }
    #[inline] pub fn get_phone_book_access_pce() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_phone_book_access_pce()
    }
    #[inline] pub fn get_phone_book_access_pse() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_phone_book_access_pse()
    }
    #[inline] pub fn get_generic_file_transfer() -> Result<Option<RfcommServiceId>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_generic_file_transfer()
    }
}
DEFINE_CLSID!(RfcommServiceId(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,73,100,0]) [CLSID_RfcommServiceId]);
DEFINE_IID!(IID_IRfcommServiceIdStatics, 706191034, 43381, 18147, 181, 107, 8, 255, 215, 131, 165, 254);
RT_INTERFACE!{static interface IRfcommServiceIdStatics(IRfcommServiceIdStaticsVtbl, IRfcommServiceIdStatics_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommServiceIdStatics] {
    fn FromUuid(&self, uuid: Guid, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn FromShortId(&self, shortId: u32, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_SerialPort(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_ObexObjectPush(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_ObexFileTransfer(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_PhoneBookAccessPce(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_PhoneBookAccessPse(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    fn get_GenericFileTransfer(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT
}}
impl IRfcommServiceIdStatics {
    #[inline] pub fn from_uuid(&self, uuid: Guid) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromUuid)(self.0.as_abi() as *const _ as *mut _, uuid, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_short_id(&self, shortId: u32) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromShortId)(self.0.as_abi() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_port(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SerialPort)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_obex_object_push(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ObexObjectPush)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_obex_file_transfer(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ObexFileTransfer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_book_access_pce(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhoneBookAccessPce)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_book_access_pse(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhoneBookAccessPse)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_file_transfer(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_GenericFileTransfer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceProvider, 3940285892, 45558, 17663, 159, 124, 231, 168, 42, 184, 104, 33);
RT_INTERFACE!{interface IRfcommServiceProvider(IRfcommServiceProviderVtbl, IRfcommServiceProvider_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider] {
    fn get_ServiceId(&self, out: *mut <RfcommServiceId as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRawAttributes(&self, out: *mut <foundation::collections::IMap<u32, crate::windows::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-networking")] fn StartAdvertising(&self, listener: <crate::windows::networking::sockets::StreamSocketListener as RtType>::Abi) -> HRESULT,
    fn StopAdvertising(&self) -> HRESULT
}}
impl IRfcommServiceProvider {
    #[inline] pub fn get_service_id(&self) -> Result<Option<RfcommServiceId>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(RfcommServiceId::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes(&self) -> Result<Option<foundation::collections::IMap<u32, crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SdpRawAttributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn start_advertising(&self, listener: &crate::windows::networking::sockets::StreamSocketListener) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartAdvertising)(self.0.as_abi() as *const _ as *mut _, get_abi(listener) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopAdvertising)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommServiceProvider: IRfcommServiceProvider}
impl RtActivatable<IRfcommServiceProviderStatics> for RfcommServiceProvider {}
impl RfcommServiceProvider {
    #[inline] pub fn create_async(serviceId: &RfcommServiceId) -> Result<foundation::IAsyncOperation<RfcommServiceProvider>> {
        <Self as RtActivatable<IRfcommServiceProviderStatics>>::get_activation_factory().create_async(serviceId)
    }
}
DEFINE_CLSID!(RfcommServiceProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,0]) [CLSID_RfcommServiceProvider]);
DEFINE_IID!(IID_IRfcommServiceProvider2, 1936449478, 15489, 19742, 186, 242, 221, 187, 129, 40, 69, 18);
RT_INTERFACE!{interface IRfcommServiceProvider2(IRfcommServiceProvider2Vtbl, IRfcommServiceProvider2_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider2] {
    #[cfg(feature="windows-networking")] fn StartAdvertisingWithRadioDiscoverability(&self, listener: <crate::windows::networking::sockets::StreamSocketListener as RtType>::Abi, radioDiscoverable: bool) -> HRESULT
}}
impl IRfcommServiceProvider2 {
    #[cfg(feature="windows-networking")] #[inline] pub fn start_advertising_with_radio_discoverability(&self, listener: &crate::windows::networking::sockets::StreamSocketListener, radioDiscoverable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartAdvertisingWithRadioDiscoverability)(self.0.as_abi() as *const _ as *mut _, get_abi(listener) as *const _ as *mut _, radioDiscoverable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceProviderStatics, 2559083267, 27082, 16698, 132, 247, 67, 68, 199, 41, 41, 151);
RT_INTERFACE!{static interface IRfcommServiceProviderStatics(IRfcommServiceProviderStaticsVtbl, IRfcommServiceProviderStatics_Abi): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProviderStatics] {
    fn CreateAsync(&self, serviceId: <RfcommServiceId as RtType>::Abi, out: *mut <foundation::IAsyncOperation<RfcommServiceProvider> as RtType>::Abi) -> HRESULT
}}
impl IRfcommServiceProviderStatics {
    #[inline] pub fn create_async(&self, serviceId: &RfcommServiceId) -> Result<foundation::IAsyncOperation<RfcommServiceProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(serviceId) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Bluetooth.Rfcomm
} // Windows.Devices.Bluetooth
pub mod custom { // Windows.Devices.Custom
use crate::prelude::*;
DEFINE_IID!(IID_ICustomDevice, 3710919967, 50315, 17341, 188, 177, 222, 200, 143, 21, 20, 62);
RT_INTERFACE!{interface ICustomDevice(ICustomDeviceVtbl, ICustomDevice_Abi): IInspectable(IInspectableVtbl) [IID_ICustomDevice] {
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut <super::super::storage::streams::IInputStream as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut <super::super::storage::streams::IOutputStream as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SendIOControlAsync(&self, ioControlCode: <IIOControlCode as RtType>::Abi, inputBuffer: <super::super::storage::streams::IBuffer as RtType>::Abi, outputBuffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TrySendIOControlAsync(&self, ioControlCode: <IIOControlCode as RtType>::Abi, inputBuffer: <super::super::storage::streams::IBuffer as RtType>::Abi, outputBuffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ICustomDevice {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<super::super::storage::streams::IInputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IInputStream::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<super::super::storage::streams::IOutputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IOutputStream::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_io_control_async(&self, ioControlCode: &IIOControlCode, inputBuffer: &super::super::storage::streams::IBuffer, outputBuffer: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendIOControlAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(ioControlCode) as *const _ as *mut _, get_abi(inputBuffer) as *const _ as *mut _, get_abi(outputBuffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_send_io_control_async(&self, ioControlCode: &IIOControlCode, inputBuffer: &super::super::storage::streams::IBuffer, outputBuffer: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySendIOControlAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(ioControlCode) as *const _ as *mut _, get_abi(inputBuffer) as *const _ as *mut _, get_abi(outputBuffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomDevice: ICustomDevice}
impl RtActivatable<ICustomDeviceStatics> for CustomDevice {}
impl CustomDevice {
    #[inline] pub fn get_device_selector(classGuid: Guid) -> Result<HString> {
        <Self as RtActivatable<ICustomDeviceStatics>>::get_activation_factory().get_device_selector(classGuid)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode) -> Result<foundation::IAsyncOperation<CustomDevice>> {
        <Self as RtActivatable<ICustomDeviceStatics>>::get_activation_factory().from_id_async(deviceId, desiredAccess, sharingMode)
    }
}
DEFINE_CLSID!(CustomDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,68,101,118,105,99,101,0]) [CLSID_CustomDevice]);
DEFINE_IID!(IID_ICustomDeviceStatics, 3357672210, 61260, 18097, 165, 142, 238, 179, 8, 220, 137, 23);
RT_INTERFACE!{static interface ICustomDeviceStatics(ICustomDeviceStaticsVtbl, ICustomDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICustomDeviceStatics] {
    fn GetDeviceSelector(&self, classGuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode, out: *mut <foundation::IAsyncOperation<CustomDevice> as RtType>::Abi) -> HRESULT
}}
impl ICustomDeviceStatics {
    #[inline] pub fn get_device_selector(&self, classGuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, classGuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode) -> Result<foundation::IAsyncOperation<CustomDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), desiredAccess, sharingMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DeviceAccessMode: i32 {
    Read = 0, Write = 1, ReadWrite = 2,
}}
RT_ENUM! { enum DeviceSharingMode: i32 {
    Shared = 0, Exclusive = 1,
}}
DEFINE_IID!(IID_IIOControlCode, 244668903, 24776, 17269, 167, 97, 127, 136, 8, 6, 108, 96);
RT_INTERFACE!{interface IIOControlCode(IIOControlCodeVtbl, IIOControlCode_Abi): IInspectable(IInspectableVtbl) [IID_IIOControlCode] {
    fn get_AccessMode(&self, out: *mut IOControlAccessMode) -> HRESULT,
    fn get_BufferingMethod(&self, out: *mut IOControlBufferingMethod) -> HRESULT,
    fn get_Function(&self, out: *mut u16) -> HRESULT,
    fn get_DeviceType(&self, out: *mut u16) -> HRESULT,
    fn get_ControlCode(&self, out: *mut u32) -> HRESULT
}}
impl IIOControlCode {
    #[inline] pub fn get_access_mode(&self) -> Result<IOControlAccessMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccessMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buffering_method(&self) -> Result<IOControlBufferingMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BufferingMethod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_function(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Function)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_type(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IIOControlCodeFactory, 2238348528, 19473, 17582, 175, 198, 184, 212, 162, 18, 120, 143);
RT_INTERFACE!{static interface IIOControlCodeFactory(IIOControlCodeFactoryVtbl, IIOControlCodeFactory_Abi): IInspectable(IInspectableVtbl) [IID_IIOControlCodeFactory] {
    fn CreateIOControlCode(&self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod, out: *mut <IOControlCode as RtType>::Abi) -> HRESULT
}}
impl IIOControlCodeFactory {
    #[inline] pub fn create_io_control_code(&self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod) -> Result<IOControlCode> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateIOControlCode)(self.0.as_abi() as *const _ as *mut _, deviceType, function, accessMode, bufferingMethod, &mut out);
        if hr == S_OK { Ok(IOControlCode::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownDeviceTypes}
impl RtActivatable<IKnownDeviceTypesStatics> for KnownDeviceTypes {}
impl KnownDeviceTypes {
    #[inline] pub fn get_unknown() -> Result<u16> {
        <Self as RtActivatable<IKnownDeviceTypesStatics>>::get_activation_factory().get_unknown()
    }
}
DEFINE_CLSID!(KnownDeviceTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,75,110,111,119,110,68,101,118,105,99,101,84,121,112,101,115,0]) [CLSID_KnownDeviceTypes]);
DEFINE_IID!(IID_IKnownDeviceTypesStatics, 3998513602, 21576, 17882, 173, 27, 36, 148, 140, 35, 144, 148);
RT_INTERFACE!{static interface IKnownDeviceTypesStatics(IKnownDeviceTypesStaticsVtbl, IKnownDeviceTypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownDeviceTypesStatics] {
    fn get_Unknown(&self, out: *mut u16) -> HRESULT
}}
impl IKnownDeviceTypesStatics {
    #[inline] pub fn get_unknown(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Unknown)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum IOControlAccessMode: i32 {
    Any = 0, Read = 1, Write = 2, ReadWrite = 3,
}}
RT_ENUM! { enum IOControlBufferingMethod: i32 {
    Buffered = 0, DirectInput = 1, DirectOutput = 2, Neither = 3,
}}
RT_CLASS!{class IOControlCode: IIOControlCode}
impl RtActivatable<IIOControlCodeFactory> for IOControlCode {}
impl IOControlCode {
    #[inline] pub fn create_io_control_code(deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod) -> Result<IOControlCode> {
        <Self as RtActivatable<IIOControlCodeFactory>>::get_activation_factory().create_io_control_code(deviceType, function, accessMode, bufferingMethod)
    }
}
DEFINE_CLSID!(IOControlCode(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,73,79,67,111,110,116,114,111,108,67,111,100,101,0]) [CLSID_IOControlCode]);
} // Windows.Devices.Custom
pub mod display { // Windows.Devices.Display
use crate::prelude::*;
DEFINE_IID!(IID_IDisplayMonitor, 527111636, 7425, 19537, 135, 226, 111, 149, 74, 119, 43, 89);
RT_INTERFACE!{interface IDisplayMonitor(IDisplayMonitorVtbl, IDisplayMonitor_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayMonitor] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionKind(&self, out: *mut DisplayMonitorConnectionKind) -> HRESULT,
    fn get_PhysicalConnector(&self, out: *mut DisplayMonitorPhysicalConnectorKind) -> HRESULT,
    fn get_DisplayAdapterDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_DisplayAdapterId(&self, out: *mut super::super::graphics::DisplayAdapterId) -> HRESULT,
    fn get_DisplayAdapterTargetId(&self, out: *mut u32) -> HRESULT,
    fn get_UsageKind(&self, out: *mut DisplayMonitorUsageKind) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_NativeResolutionInRawPixels(&self, out: *mut super::super::graphics::SizeInt32) -> HRESULT,
    fn get_PhysicalSizeInInches(&self, out: *mut <foundation::IReference<foundation::Size> as RtType>::Abi) -> HRESULT,
    fn get_RawDpiX(&self, out: *mut f32) -> HRESULT,
    fn get_RawDpiY(&self, out: *mut f32) -> HRESULT,
    fn get_RedPrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_GreenPrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_BluePrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_WhitePoint(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_MaxLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn get_MinLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn get_MaxAverageFullFrameLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn GetDescriptor(&self, descriptorKind: DisplayMonitorDescriptorKind, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl IDisplayMonitor {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_kind(&self) -> Result<DisplayMonitorConnectionKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_connector(&self) -> Result<DisplayMonitorPhysicalConnectorKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalConnector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_adapter_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayAdapterDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_display_adapter_id(&self) -> Result<super::super::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayAdapterId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_adapter_target_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayAdapterTargetId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_kind(&self) -> Result<DisplayMonitorUsageKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_native_resolution_in_raw_pixels(&self) -> Result<super::super::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NativeResolutionInRawPixels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_size_in_inches(&self) -> Result<Option<foundation::IReference<foundation::Size>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalSizeInInches)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_dpi_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawDpiX)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_dpi_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawDpiY)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedPrimary)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GreenPrimary)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BluePrimary)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_white_point(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WhitePoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxLuminanceInNits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinLuminanceInNits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_average_full_frame_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxAverageFullFrameLuminanceInNits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptor(&self, descriptorKind: DisplayMonitorDescriptorKind) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDescriptor)(self.0.as_abi() as *const _ as *mut _, descriptorKind, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayMonitor: IDisplayMonitor}
impl RtActivatable<IDisplayMonitorStatics> for DisplayMonitor {}
impl DisplayMonitor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DisplayMonitor>> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn from_interface_id_async(deviceInterfaceId: &HStringArg) -> Result<foundation::IAsyncOperation<DisplayMonitor>> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().from_interface_id_async(deviceInterfaceId)
    }
}
DEFINE_CLSID!(DisplayMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,68,105,115,112,108,97,121,77,111,110,105,116,111,114,0]) [CLSID_DisplayMonitor]);
RT_ENUM! { enum DisplayMonitorConnectionKind: i32 {
    Internal = 0, Wired = 1, Wireless = 2, Virtual = 3,
}}
RT_ENUM! { enum DisplayMonitorDescriptorKind: i32 {
    Edid = 0, DisplayId = 1,
}}
RT_ENUM! { enum DisplayMonitorPhysicalConnectorKind: i32 {
    Unknown = 0, HD15 = 1, AnalogTV = 2, Dvi = 3, Hdmi = 4, Lvds = 5, Sdi = 6, DisplayPort = 7,
}}
DEFINE_IID!(IID_IDisplayMonitorStatics, 1856924047, 41512, 19461, 130, 29, 182, 149, 214, 103, 222, 142);
RT_INTERFACE!{static interface IDisplayMonitorStatics(IDisplayMonitorStaticsVtbl, IDisplayMonitorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayMonitorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<DisplayMonitor> as RtType>::Abi) -> HRESULT,
    fn FromInterfaceIdAsync(&self, deviceInterfaceId: HSTRING, out: *mut <foundation::IAsyncOperation<DisplayMonitor> as RtType>::Abi) -> HRESULT
}}
impl IDisplayMonitorStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DisplayMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_interface_id_async(&self, deviceInterfaceId: &HStringArg) -> Result<foundation::IAsyncOperation<DisplayMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromInterfaceIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceInterfaceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayMonitorUsageKind: i32 {
    Standard = 0, HeadMounted = 1, SpecialPurpose = 2,
}}
pub mod core { // Windows.Devices.Display.Core
use crate::prelude::*;
DEFINE_IID!(IID_IDisplayAdapter, 2775536263, 61440, 24366, 181, 172, 55, 131, 162, 182, 154, 245);
RT_INTERFACE!{interface IDisplayAdapter(IDisplayAdapterVtbl, IDisplayAdapter_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayAdapter] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Id(&self, out: *mut crate::windows::graphics::DisplayAdapterId) -> HRESULT,
    fn get_DeviceInterfacePath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SourceCount(&self, out: *mut u32) -> HRESULT,
    fn get_PciVendorId(&self, out: *mut u32) -> HRESULT,
    fn get_PciDeviceId(&self, out: *mut u32) -> HRESULT,
    fn get_PciSubSystemId(&self, out: *mut u32) -> HRESULT,
    fn get_PciRevision(&self, out: *mut u32) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayAdapter {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_id(&self) -> Result<crate::windows::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_interface_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInterfacePath)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_vendor_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PciVendorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_device_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PciDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_sub_system_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PciSubSystemId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_revision(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PciRevision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayAdapter: IDisplayAdapter}
impl RtActivatable<IDisplayAdapterStatics> for DisplayAdapter {}
impl DisplayAdapter {
    #[cfg(feature="windows-graphics")] #[inline] pub fn from_id(id: crate::windows::graphics::DisplayAdapterId) -> Result<Option<DisplayAdapter>> {
        <Self as RtActivatable<IDisplayAdapterStatics>>::get_activation_factory().from_id(id)
    }
}
DEFINE_CLSID!(DisplayAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,65,100,97,112,116,101,114,0]) [CLSID_DisplayAdapter]);
DEFINE_IID!(IID_IDisplayAdapterStatics, 497827034, 18463, 21609, 132, 112, 130, 196, 186, 104, 10, 40);
RT_INTERFACE!{static interface IDisplayAdapterStatics(IDisplayAdapterStaticsVtbl, IDisplayAdapterStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayAdapterStatics] {
    #[cfg(feature="windows-graphics")] fn FromId(&self, id: crate::windows::graphics::DisplayAdapterId, out: *mut <DisplayAdapter as RtType>::Abi) -> HRESULT
}}
impl IDisplayAdapterStatics {
    #[cfg(feature="windows-graphics")] #[inline] pub fn from_id(&self, id: crate::windows::graphics::DisplayAdapterId) -> Result<Option<DisplayAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, id, &mut out);
        if hr == S_OK { Ok(DisplayAdapter::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayBitsPerChannel: u32 {
    None = 0, Bpc6 = 1, Bpc8 = 2, Bpc10 = 4, Bpc12 = 8, Bpc14 = 16, Bpc16 = 32,
}}
DEFINE_IID!(IID_IDisplayDevice, 2764682796, 13151, 22321, 140, 180, 193, 204, 212, 115, 16, 112);
RT_INTERFACE!{interface IDisplayDevice(IDisplayDeviceVtbl, IDisplayDevice_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayDevice] {
    fn CreateScanoutSource(&self, target: <DisplayTarget as RtType>::Abi, out: *mut <DisplaySource as RtType>::Abi) -> HRESULT,
    fn CreatePrimary(&self, target: <DisplayTarget as RtType>::Abi, desc: <DisplayPrimaryDescription as RtType>::Abi, out: *mut <DisplaySurface as RtType>::Abi) -> HRESULT,
    fn CreateTaskPool(&self, out: *mut <DisplayTaskPool as RtType>::Abi) -> HRESULT,
    fn CreatePeriodicFence(&self, target: <DisplayTarget as RtType>::Abi, offsetFromVBlank: foundation::TimeSpan, out: *mut <DisplayFence as RtType>::Abi) -> HRESULT,
    fn WaitForVBlank(&self, source: <DisplaySource as RtType>::Abi) -> HRESULT,
    fn CreateSimpleScanout(&self, pSource: <DisplaySource as RtType>::Abi, pSurface: <DisplaySurface as RtType>::Abi, subResourceIndex: u32, syncInterval: u32, out: *mut <DisplayScanout as RtType>::Abi) -> HRESULT,
    fn IsCapabilitySupported(&self, capability: DisplayDeviceCapability, out: *mut bool) -> HRESULT
}}
impl IDisplayDevice {
    #[inline] pub fn create_scanout_source(&self, target: &DisplayTarget) -> Result<Option<DisplaySource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateScanoutSource)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplaySource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_primary(&self, target: &DisplayTarget, desc: &DisplayPrimaryDescription) -> Result<Option<DisplaySurface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreatePrimary)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, get_abi(desc) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplaySurface::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_task_pool(&self) -> Result<Option<DisplayTaskPool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateTaskPool)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayTaskPool::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_periodic_fence(&self, target: &DisplayTarget, offsetFromVBlank: foundation::TimeSpan) -> Result<Option<DisplayFence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreatePeriodicFence)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, offsetFromVBlank, &mut out);
        if hr == S_OK { Ok(DisplayFence::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn wait_for_v_blank(&self, source: &DisplaySource) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).WaitForVBlank)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_simple_scanout(&self, pSource: &DisplaySource, pSurface: &DisplaySurface, subResourceIndex: u32, syncInterval: u32) -> Result<Option<DisplayScanout>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateSimpleScanout)(self.0.as_abi() as *const _ as *mut _, get_abi(pSource) as *const _ as *mut _, get_abi(pSurface) as *const _ as *mut _, subResourceIndex, syncInterval, &mut out);
        if hr == S_OK { Ok(DisplayScanout::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_capability_supported(&self, capability: DisplayDeviceCapability) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsCapabilitySupported)(self.0.as_abi() as *const _ as *mut _, capability, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayDevice: IDisplayDevice}
RT_ENUM! { enum DisplayDeviceCapability: i32 {
    FlipOverride = 0,
}}
DEFINE_IID!(IID_IDisplayFence, 81590767, 13318, 22272, 143, 236, 119, 235, 164, 197, 167, 75);
RT_INTERFACE!{interface IDisplayFence(IDisplayFenceVtbl, IDisplayFence_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayFence] {
    
}}
RT_CLASS!{class DisplayFence: IDisplayFence}
DEFINE_IID!(IID_IDisplayManager, 1322853467, 5612, 22242, 144, 114, 127, 229, 8, 74, 49, 167);
RT_INTERFACE!{interface IDisplayManager(IDisplayManagerVtbl, IDisplayManager_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManager] {
    fn GetCurrentTargets(&self, out: *mut <foundation::collections::IVectorView<DisplayTarget> as RtType>::Abi) -> HRESULT,
    fn GetCurrentAdapters(&self, out: *mut <foundation::collections::IVectorView<DisplayAdapter> as RtType>::Abi) -> HRESULT,
    fn TryAcquireTarget(&self, target: <DisplayTarget as RtType>::Abi, out: *mut DisplayManagerResult) -> HRESULT,
    fn ReleaseTarget(&self, target: <DisplayTarget as RtType>::Abi) -> HRESULT,
    fn TryReadCurrentStateForAllTargets(&self, out: *mut <DisplayManagerResultWithState as RtType>::Abi) -> HRESULT,
    fn TryAcquireTargetsAndReadCurrentState(&self, targets: <foundation::collections::IIterable<DisplayTarget> as RtType>::Abi, out: *mut <DisplayManagerResultWithState as RtType>::Abi) -> HRESULT,
    fn TryAcquireTargetsAndCreateEmptyState(&self, targets: <foundation::collections::IIterable<DisplayTarget> as RtType>::Abi, out: *mut <DisplayManagerResultWithState as RtType>::Abi) -> HRESULT,
    fn TryAcquireTargetsAndCreateSubstate(&self, existingState: <DisplayState as RtType>::Abi, targets: <foundation::collections::IIterable<DisplayTarget> as RtType>::Abi, out: *mut <DisplayManagerResultWithState as RtType>::Abi) -> HRESULT,
    fn CreateDisplayDevice(&self, adapter: <DisplayAdapter as RtType>::Abi, out: *mut <DisplayDevice as RtType>::Abi) -> HRESULT,
    fn add_Enabled(&self, handler: <foundation::TypedEventHandler<DisplayManager, DisplayManagerEnabledEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Enabled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Disabled(&self, handler: <foundation::TypedEventHandler<DisplayManager, DisplayManagerDisabledEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Disabled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Changed(&self, handler: <foundation::TypedEventHandler<DisplayManager, DisplayManagerChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Changed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PathsFailedOrInvalidated(&self, handler: <foundation::TypedEventHandler<DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PathsFailedOrInvalidated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IDisplayManager {
    #[inline] pub fn get_current_targets(&self) -> Result<Option<foundation::collections::IVectorView<DisplayTarget>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentTargets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_adapters(&self) -> Result<Option<foundation::collections::IVectorView<DisplayAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentAdapters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_target(&self, target: &DisplayTarget) -> Result<DisplayManagerResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn release_target(&self, target: &DisplayTarget) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReleaseTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_current_state_for_all_targets(&self) -> Result<Option<DisplayManagerResultWithState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryReadCurrentStateForAllTargets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayManagerResultWithState::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_read_current_state(&self, targets: &foundation::collections::IIterable<DisplayTarget>) -> Result<Option<DisplayManagerResultWithState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireTargetsAndReadCurrentState)(self.0.as_abi() as *const _ as *mut _, get_abi(targets) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayManagerResultWithState::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_create_empty_state(&self, targets: &foundation::collections::IIterable<DisplayTarget>) -> Result<Option<DisplayManagerResultWithState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireTargetsAndCreateEmptyState)(self.0.as_abi() as *const _ as *mut _, get_abi(targets) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayManagerResultWithState::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_create_substate(&self, existingState: &DisplayState, targets: &foundation::collections::IIterable<DisplayTarget>) -> Result<Option<DisplayManagerResultWithState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireTargetsAndCreateSubstate)(self.0.as_abi() as *const _ as *mut _, get_abi(existingState) as *const _ as *mut _, get_abi(targets) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayManagerResultWithState::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_display_device(&self, adapter: &DisplayAdapter) -> Result<Option<DisplayDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDisplayDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(adapter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayDevice::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_enabled(&self, handler: &foundation::TypedEventHandler<DisplayManager, DisplayManagerEnabledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Enabled)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enabled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Enabled)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disabled(&self, handler: &foundation::TypedEventHandler<DisplayManager, DisplayManagerDisabledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Disabled)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disabled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Disabled)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_changed(&self, handler: &foundation::TypedEventHandler<DisplayManager, DisplayManagerChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Changed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Changed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_paths_failed_or_invalidated(&self, handler: &foundation::TypedEventHandler<DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PathsFailedOrInvalidated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_paths_failed_or_invalidated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PathsFailedOrInvalidated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManager: IDisplayManager}
impl RtActivatable<IDisplayManagerStatics> for DisplayManager {}
impl DisplayManager {
    #[inline] pub fn create(options: DisplayManagerOptions) -> Result<Option<DisplayManager>> {
        <Self as RtActivatable<IDisplayManagerStatics>>::get_activation_factory().create(options)
    }
}
DEFINE_CLSID!(DisplayManager(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,77,97,110,97,103,101,114,0]) [CLSID_DisplayManager]);
DEFINE_IID!(IID_IDisplayManagerChangedEventArgs, 1790943877, 27850, 22321, 188, 220, 66, 229, 210, 245, 197, 15);
RT_INTERFACE!{interface IDisplayManagerChangedEventArgs(IDisplayManagerChangedEventArgsVtbl, IDisplayManagerChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerChangedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerChangedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerChangedEventArgs: IDisplayManagerChangedEventArgs}
DEFINE_IID!(IID_IDisplayManagerDisabledEventArgs, 2267471332, 26515, 22899, 161, 31, 95, 251, 201, 63, 219, 144);
RT_INTERFACE!{interface IDisplayManagerDisabledEventArgs(IDisplayManagerDisabledEventArgsVtbl, IDisplayManagerDisabledEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerDisabledEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerDisabledEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerDisabledEventArgs: IDisplayManagerDisabledEventArgs}
DEFINE_IID!(IID_IDisplayManagerEnabledEventArgs, 4040114031, 17146, 22946, 178, 151, 38, 225, 113, 61, 232, 72);
RT_INTERFACE!{interface IDisplayManagerEnabledEventArgs(IDisplayManagerEnabledEventArgsVtbl, IDisplayManagerEnabledEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerEnabledEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerEnabledEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerEnabledEventArgs: IDisplayManagerEnabledEventArgs}
RT_ENUM! { enum DisplayManagerOptions: u32 {
    None = 0, EnforceSourceOwnership = 1,
}}
DEFINE_IID!(IID_IDisplayManagerPathsFailedOrInvalidatedEventArgs, 61232729, 7660, 23573, 178, 162, 143, 233, 18, 152, 105, 254);
RT_INTERFACE!{interface IDisplayManagerPathsFailedOrInvalidatedEventArgs(IDisplayManagerPathsFailedOrInvalidatedEventArgsVtbl, IDisplayManagerPathsFailedOrInvalidatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerPathsFailedOrInvalidatedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerPathsFailedOrInvalidatedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerPathsFailedOrInvalidatedEventArgs: IDisplayManagerPathsFailedOrInvalidatedEventArgs}
RT_ENUM! { enum DisplayManagerResult: i32 {
    Success = 0, UnknownFailure = 1, TargetAccessDenied = 2, TargetStale = 3, RemoteSessionNotSupported = 4,
}}
DEFINE_IID!(IID_IDisplayManagerResultWithState, 2389011110, 26132, 21694, 191, 239, 73, 148, 84, 127, 123, 225);
RT_INTERFACE!{interface IDisplayManagerResultWithState(IDisplayManagerResultWithStateVtbl, IDisplayManagerResultWithState_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerResultWithState] {
    fn get_ErrorCode(&self, out: *mut DisplayManagerResult) -> HRESULT,
    fn get_ExtendedErrorCode(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_State(&self, out: *mut <DisplayState as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerResultWithState {
    #[inline] pub fn get_error_code(&self) -> Result<DisplayManagerResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<Option<DisplayState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayState::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerResultWithState: IDisplayManagerResultWithState}
DEFINE_IID!(IID_IDisplayManagerStatics, 728470598, 47513, 21813, 157, 105, 83, 240, 146, 199, 128, 161);
RT_INTERFACE!{static interface IDisplayManagerStatics(IDisplayManagerStaticsVtbl, IDisplayManagerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayManagerStatics] {
    fn Create(&self, options: DisplayManagerOptions, out: *mut <DisplayManager as RtType>::Abi) -> HRESULT
}}
impl IDisplayManagerStatics {
    #[inline] pub fn create(&self, options: DisplayManagerOptions) -> Result<Option<DisplayManager>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(DisplayManager::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDisplayModeInfo, 1221923744, 63387, 23156, 160, 94, 218, 130, 31, 71, 8, 104);
RT_INTERFACE!{interface IDisplayModeInfo(IDisplayModeInfoVtbl, IDisplayModeInfo_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayModeInfo] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourceResolution(&self, out: *mut crate::windows::graphics::SizeInt32) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourcePixelFormat(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_TargetResolution(&self, out: *mut crate::windows::graphics::SizeInt32) -> HRESULT,
    fn get_PresentationRate(&self, out: *mut DisplayPresentationRate) -> HRESULT,
    fn get_IsInterlaced(&self, out: *mut bool) -> HRESULT,
    fn GetWireFormatSupportedBitsPerChannel(&self, encoding: DisplayWireFormatPixelEncoding, out: *mut DisplayBitsPerChannel) -> HRESULT,
    fn IsWireFormatSupported(&self, wireFormat: <DisplayWireFormat as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayModeInfo {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_resolution(&self) -> Result<crate::windows::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStereo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_pixel_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourcePixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_target_resolution(&self) -> Result<crate::windows::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TargetResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_rate(&self) -> Result<DisplayPresentationRate> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interlaced(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsInterlaced)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_wire_format_supported_bits_per_channel(&self, encoding: DisplayWireFormatPixelEncoding) -> Result<DisplayBitsPerChannel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetWireFormatSupportedBitsPerChannel)(self.0.as_abi() as *const _ as *mut _, encoding, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_wire_format_supported(&self, wireFormat: &DisplayWireFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsWireFormatSupported)(self.0.as_abi() as *const _ as *mut _, get_abi(wireFormat) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayModeInfo: IDisplayModeInfo}
RT_ENUM! { enum DisplayModeQueryOptions: u32 {
    None = 0, OnlyPreferredResolution = 1,
}}
DEFINE_IID!(IID_IDisplayPath, 3017791050, 29792, 23774, 129, 27, 213, 174, 159, 61, 159, 132);
RT_INTERFACE!{interface IDisplayPath(IDisplayPathVtbl, IDisplayPath_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayPath] {
    fn get_View(&self, out: *mut <DisplayView as RtType>::Abi) -> HRESULT,
    fn get_Target(&self, out: *mut <DisplayTarget as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut DisplayPathStatus) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourceResolution(&self, out: *mut <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_SourceResolution(&self, value: <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourcePixelFormat(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_SourcePixelFormat(&self, value: crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    fn put_IsStereo(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_TargetResolution(&self, out: *mut <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_TargetResolution(&self, value: <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    fn get_PresentationRate(&self, out: *mut <foundation::IReference<DisplayPresentationRate> as RtType>::Abi) -> HRESULT,
    fn put_PresentationRate(&self, value: <foundation::IReference<DisplayPresentationRate> as RtType>::Abi) -> HRESULT,
    fn get_IsInterlaced(&self, out: *mut <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn put_IsInterlaced(&self, value: <foundation::IReference<bool> as RtType>::Abi) -> HRESULT,
    fn get_WireFormat(&self, out: *mut <DisplayWireFormat as RtType>::Abi) -> HRESULT,
    fn put_WireFormat(&self, value: <DisplayWireFormat as RtType>::Abi) -> HRESULT,
    fn get_Rotation(&self, out: *mut DisplayRotation) -> HRESULT,
    fn put_Rotation(&self, value: DisplayRotation) -> HRESULT,
    fn get_Scaling(&self, out: *mut DisplayPathScaling) -> HRESULT,
    fn put_Scaling(&self, value: DisplayPathScaling) -> HRESULT,
    fn FindModes(&self, flags: DisplayModeQueryOptions, out: *mut <foundation::collections::IVectorView<DisplayModeInfo> as RtType>::Abi) -> HRESULT,
    fn ApplyPropertiesFromMode(&self, modeResult: <DisplayModeInfo as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMap<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayPath {
    #[inline] pub fn get_view(&self) -> Result<Option<DisplayView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_View)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_target(&self) -> Result<Option<DisplayTarget>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Target)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayTarget::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<DisplayPathStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_resolution(&self) -> Result<Option<foundation::IReference<crate::windows::graphics::SizeInt32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_source_resolution(&self, value: &foundation::IReference<crate::windows::graphics::SizeInt32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SourceResolution)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_pixel_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourcePixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_source_pixel_format(&self, value: crate::windows::graphics::directx::DirectXPixelFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SourcePixelFormat)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStereo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_stereo(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsStereo)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_target_resolution(&self) -> Result<Option<foundation::IReference<crate::windows::graphics::SizeInt32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TargetResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_target_resolution(&self, value: &foundation::IReference<crate::windows::graphics::SizeInt32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TargetResolution)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_rate(&self) -> Result<Option<foundation::IReference<DisplayPresentationRate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PresentationRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_presentation_rate(&self, value: &foundation::IReference<DisplayPresentationRate>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PresentationRate)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interlaced(&self) -> Result<Option<foundation::IReference<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsInterlaced)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_interlaced(&self, value: &foundation::IReference<bool>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsInterlaced)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wire_format(&self) -> Result<Option<DisplayWireFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WireFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayWireFormat::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_wire_format(&self, value: &DisplayWireFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WireFormat)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation(&self) -> Result<DisplayRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rotation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation(&self, value: DisplayRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Rotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scaling(&self) -> Result<DisplayPathScaling> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Scaling)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scaling(&self, value: DisplayPathScaling) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Scaling)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn find_modes(&self, flags: DisplayModeQueryOptions) -> Result<Option<foundation::collections::IVectorView<DisplayModeInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindModes)(self.0.as_abi() as *const _ as *mut _, flags, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_properties_from_mode(&self, modeResult: &DisplayModeInfo) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ApplyPropertiesFromMode)(self.0.as_abi() as *const _ as *mut _, get_abi(modeResult) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMap<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayPath: IDisplayPath}
RT_ENUM! { enum DisplayPathScaling: i32 {
    Identity = 0, Centered = 1, Stretched = 2, AspectRatioStretched = 3, Custom = 4, DriverPreferred = 5,
}}
RT_ENUM! { enum DisplayPathStatus: i32 {
    Unknown = 0, Succeeded = 1, Pending = 2, Failed = 3, FailedAsync = 4, InvalidatedAsync = 5,
}}
RT_STRUCT! { struct DisplayPresentationRate {
    VerticalSyncRate: foundation::numerics::Rational, VerticalSyncsPerPresentation: i32,
}}
DEFINE_IID!(IID_IDisplayPrimaryDescription, 2267386322, 54579, 20735, 168, 94, 6, 105, 97, 148, 183, 124);
RT_INTERFACE!{interface IDisplayPrimaryDescription(IDisplayPrimaryDescriptionVtbl, IDisplayPrimaryDescription_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescription] {
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Format(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ColorSpace(&self, out: *mut crate::windows::graphics::directx::DirectXColorSpace) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_MultisampleDescription(&self, out: *mut crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayPrimaryDescription {
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_color_space(&self) -> Result<crate::windows::graphics::directx::DirectXColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ColorSpace)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStereo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_multisample_description(&self) -> Result<crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MultisampleDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayPrimaryDescription: IDisplayPrimaryDescription}
impl RtActivatable<IDisplayPrimaryDescriptionFactory> for DisplayPrimaryDescription {}
impl RtActivatable<IDisplayPrimaryDescriptionStatics> for DisplayPrimaryDescription {}
impl DisplayPrimaryDescription {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_instance(width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<DisplayPrimaryDescription> {
        <Self as RtActivatable<IDisplayPrimaryDescriptionFactory>>::get_activation_factory().create_instance(width, height, pixelFormat, colorSpace, isStereo, multisampleDescription)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_properties(extraProperties: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<Option<DisplayPrimaryDescription>> {
        <Self as RtActivatable<IDisplayPrimaryDescriptionStatics>>::get_activation_factory().create_with_properties(extraProperties, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription)
    }
}
DEFINE_CLSID!(DisplayPrimaryDescription(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,80,114,105,109,97,114,121,68,101,115,99,114,105,112,116,105,111,110,0]) [CLSID_DisplayPrimaryDescription]);
DEFINE_IID!(IID_IDisplayPrimaryDescriptionFactory, 443219835, 13879, 23622, 180, 121, 118, 213, 118, 33, 110, 101);
RT_INTERFACE!{static interface IDisplayPrimaryDescriptionFactory(IDisplayPrimaryDescriptionFactoryVtbl, IDisplayPrimaryDescriptionFactory_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescriptionFactory] {
    #[cfg(feature="windows-graphics")] fn CreateInstance(&self, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription, out: *mut <DisplayPrimaryDescription as RtType>::Abi) -> HRESULT
}}
impl IDisplayPrimaryDescriptionFactory {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_instance(&self, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<DisplayPrimaryDescription> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, &mut out);
        if hr == S_OK { Ok(DisplayPrimaryDescription::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDisplayPrimaryDescriptionStatics, 3859696891, 14025, 22237, 143, 161, 111, 248, 196, 224, 255, 7);
RT_INTERFACE!{static interface IDisplayPrimaryDescriptionStatics(IDisplayPrimaryDescriptionStaticsVtbl, IDisplayPrimaryDescriptionStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescriptionStatics] {
    #[cfg(feature="windows-graphics")] fn CreateWithProperties(&self, extraProperties: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>> as RtType>::Abi, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription, out: *mut <DisplayPrimaryDescription as RtType>::Abi) -> HRESULT
}}
impl IDisplayPrimaryDescriptionStatics {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_properties(&self, extraProperties: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<Option<DisplayPrimaryDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(extraProperties) as *const _ as *mut _, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, &mut out);
        if hr == S_OK { Ok(DisplayPrimaryDescription::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayRotation: i32 {
    None = 0, Clockwise90Degrees = 1, Clockwise180Degrees = 2, Clockwise270Degrees = 3,
}}
DEFINE_IID!(IID_IDisplayScanout, 3808761896, 7077, 20711, 138, 57, 187, 31, 210, 244, 248, 185);
RT_INTERFACE!{interface IDisplayScanout(IDisplayScanoutVtbl, IDisplayScanout_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayScanout] {
    
}}
RT_CLASS!{class DisplayScanout: IDisplayScanout}
DEFINE_IID!(IID_IDisplaySource, 3973144513, 60124, 20924, 151, 29, 59, 198, 40, 219, 45, 212);
RT_INTERFACE!{interface IDisplaySource(IDisplaySourceVtbl, IDisplaySource_Abi): IInspectable(IInspectableVtbl) [IID_IDisplaySource] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_AdapterId(&self, out: *mut crate::windows::graphics::DisplayAdapterId) -> HRESULT,
    fn get_SourceId(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetMetadata(&self, key: Guid, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IDisplaySource {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_adapter_id(&self) -> Result<crate::windows::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdapterId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_metadata(&self, key: Guid) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetMetadata)(self.0.as_abi() as *const _ as *mut _, key, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplaySource: IDisplaySource}
DEFINE_IID!(IID_IDisplayState, 135435041, 4533, 23730, 153, 248, 233, 11, 71, 154, 138, 29);
RT_INTERFACE!{interface IDisplayState(IDisplayStateVtbl, IDisplayState_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayState] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_IsStale(&self, out: *mut bool) -> HRESULT,
    fn get_Targets(&self, out: *mut <foundation::collections::IVectorView<DisplayTarget> as RtType>::Abi) -> HRESULT,
    fn get_Views(&self, out: *mut <foundation::collections::IVectorView<DisplayView> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMap<Guid, IInspectable> as RtType>::Abi) -> HRESULT,
    fn ConnectTarget(&self, target: <DisplayTarget as RtType>::Abi, out: *mut <DisplayPath as RtType>::Abi) -> HRESULT,
    fn ConnectTargetToView(&self, target: <DisplayTarget as RtType>::Abi, view: <DisplayView as RtType>::Abi, out: *mut <DisplayPath as RtType>::Abi) -> HRESULT,
    fn CanConnectTargetToView(&self, target: <DisplayTarget as RtType>::Abi, view: <DisplayView as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn GetViewForTarget(&self, target: <DisplayTarget as RtType>::Abi, out: *mut <DisplayView as RtType>::Abi) -> HRESULT,
    fn GetPathForTarget(&self, target: <DisplayTarget as RtType>::Abi, out: *mut <DisplayPath as RtType>::Abi) -> HRESULT,
    fn DisconnectTarget(&self, target: <DisplayTarget as RtType>::Abi) -> HRESULT,
    fn TryFunctionalize(&self, options: DisplayStateFunctionalizeOptions, out: *mut <DisplayStateOperationResult as RtType>::Abi) -> HRESULT,
    fn TryApply(&self, options: DisplayStateApplyOptions, out: *mut <DisplayStateOperationResult as RtType>::Abi) -> HRESULT,
    fn Clone(&self, out: *mut <DisplayState as RtType>::Abi) -> HRESULT
}}
impl IDisplayState {
    #[inline] pub fn get_is_read_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReadOnly)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStale)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_targets(&self) -> Result<Option<foundation::collections::IVectorView<DisplayTarget>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Targets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_views(&self) -> Result<Option<foundation::collections::IVectorView<DisplayView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Views)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMap<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_target(&self, target: &DisplayTarget) -> Result<Option<DisplayPath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayPath::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_target_to_view(&self, target: &DisplayTarget, view: &DisplayView) -> Result<Option<DisplayPath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectTargetToView)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, get_abi(view) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayPath::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_connect_target_to_view(&self, target: &DisplayTarget, view: &DisplayView) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CanConnectTargetToView)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, get_abi(view) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_view_for_target(&self, target: &DisplayTarget) -> Result<Option<DisplayView>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetViewForTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_path_for_target(&self, target: &DisplayTarget) -> Result<Option<DisplayPath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPathForTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayPath::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disconnect_target(&self, target: &DisplayTarget) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DisconnectTarget)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_functionalize(&self, options: DisplayStateFunctionalizeOptions) -> Result<Option<DisplayStateOperationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryFunctionalize)(self.0.as_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(DisplayStateOperationResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_apply(&self, options: DisplayStateApplyOptions) -> Result<Option<DisplayStateOperationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryApply)(self.0.as_abi() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(DisplayStateOperationResult::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<DisplayState>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Clone)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayState::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayState: IDisplayState}
RT_ENUM! { enum DisplayStateApplyOptions: u32 {
    None = 0, FailIfStateChanged = 1, ForceReapply = 2, ForceModeEnumeration = 4,
}}
RT_ENUM! { enum DisplayStateFunctionalizeOptions: u32 {
    None = 0, FailIfStateChanged = 1, ValidateTopologyOnly = 2,
}}
DEFINE_IID!(IID_IDisplayStateOperationResult, 4239245279, 56359, 22072, 183, 242, 235, 223, 164, 247, 234, 147);
RT_INTERFACE!{interface IDisplayStateOperationResult(IDisplayStateOperationResultVtbl, IDisplayStateOperationResult_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayStateOperationResult] {
    fn get_Status(&self, out: *mut DisplayStateOperationStatus) -> HRESULT,
    fn get_ExtendedErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IDisplayStateOperationResult {
    #[inline] pub fn get_status(&self) -> Result<DisplayStateOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayStateOperationResult: IDisplayStateOperationResult}
RT_ENUM! { enum DisplayStateOperationStatus: i32 {
    Success = 0, PartialFailure = 1, UnknownFailure = 2, TargetOwnershipLost = 3, SystemStateChanged = 4, TooManyPathsForAdapter = 5, ModesNotSupported = 6, RemoteSessionNotSupported = 7,
}}
DEFINE_IID!(IID_IDisplaySurface, 1498377414, 5018, 22230, 164, 177, 21, 254, 44, 183, 106, 219);
RT_INTERFACE!{interface IDisplaySurface(IDisplaySurfaceVtbl, IDisplaySurface_Abi): IInspectable(IInspectableVtbl) [IID_IDisplaySurface] {
    
}}
RT_CLASS!{class DisplaySurface: IDisplaySurface}
DEFINE_IID!(IID_IDisplayTarget, 2932178031, 18356, 21611, 152, 124, 231, 63, 167, 145, 254, 58);
RT_INTERFACE!{interface IDisplayTarget(IDisplayTargetVtbl, IDisplayTarget_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayTarget] {
    fn get_Adapter(&self, out: *mut <DisplayAdapter as RtType>::Abi) -> HRESULT,
    fn get_DeviceInterfacePath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AdapterRelativeId(&self, out: *mut u32) -> HRESULT,
    fn get_IsConnected(&self, out: *mut bool) -> HRESULT,
    fn get_IsVirtualModeEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsVirtualTopologyEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_UsageKind(&self, out: *mut super::DisplayMonitorUsageKind) -> HRESULT,
    fn get_MonitorPersistence(&self, out: *mut DisplayTargetPersistence) -> HRESULT,
    fn get_StableMonitorId(&self, out: *mut HSTRING) -> HRESULT,
    fn TryGetMonitor(&self, out: *mut <super::DisplayMonitor as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_IsStale(&self, out: *mut bool) -> HRESULT,
    fn IsSame(&self, otherTarget: <DisplayTarget as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn IsEqual(&self, otherTarget: <DisplayTarget as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl IDisplayTarget {
    #[inline] pub fn get_adapter(&self) -> Result<Option<DisplayAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Adapter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayAdapter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_interface_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInterfacePath)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_adapter_relative_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdapterRelativeId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsConnected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_virtual_mode_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVirtualModeEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_virtual_topology_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVirtualTopologyEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_kind(&self) -> Result<super::DisplayMonitorUsageKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_monitor_persistence(&self) -> Result<DisplayTargetPersistence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MonitorPersistence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stable_monitor_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StableMonitorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_monitor(&self) -> Result<Option<super::DisplayMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetMonitor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::DisplayMonitor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStale)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_same(&self, otherTarget: &DisplayTarget) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSame)(self.0.as_abi() as *const _ as *mut _, get_abi(otherTarget) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, otherTarget: &DisplayTarget) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsEqual)(self.0.as_abi() as *const _ as *mut _, get_abi(otherTarget) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTarget: IDisplayTarget}
RT_ENUM! { enum DisplayTargetPersistence: i32 {
    None = 0, BootPersisted = 1, TemporaryPersisted = 2, PathPersisted = 3,
}}
DEFINE_IID!(IID_IDisplayTask, 1577612360, 4955, 23472, 191, 99, 99, 127, 132, 34, 124, 122);
RT_INTERFACE!{interface IDisplayTask(IDisplayTaskVtbl, IDisplayTask_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayTask] {
    fn SetScanout(&self, scanout: <DisplayScanout as RtType>::Abi) -> HRESULT,
    fn SetWait(&self, readyFence: <DisplayFence as RtType>::Abi, readyFenceValue: u64) -> HRESULT
}}
impl IDisplayTask {
    #[inline] pub fn set_scanout(&self, scanout: &DisplayScanout) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetScanout)(self.0.as_abi() as *const _ as *mut _, get_abi(scanout) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_wait(&self, readyFence: &DisplayFence, readyFenceValue: u64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetWait)(self.0.as_abi() as *const _ as *mut _, get_abi(readyFence) as *const _ as *mut _, readyFenceValue);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTask: IDisplayTask}
DEFINE_IID!(IID_IDisplayTaskPool, 3329631549, 9085, 21832, 170, 250, 62, 81, 127, 239, 239, 28);
RT_INTERFACE!{interface IDisplayTaskPool(IDisplayTaskPoolVtbl, IDisplayTaskPool_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayTaskPool] {
    fn CreateTask(&self, out: *mut <DisplayTask as RtType>::Abi) -> HRESULT,
    fn ExecuteTask(&self, task: <DisplayTask as RtType>::Abi) -> HRESULT
}}
impl IDisplayTaskPool {
    #[inline] pub fn create_task(&self) -> Result<Option<DisplayTask>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateTask)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DisplayTask::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn execute_task(&self, task: &DisplayTask) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ExecuteTask)(self.0.as_abi() as *const _ as *mut _, get_abi(task) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTaskPool: IDisplayTaskPool}
RT_ENUM! { enum DisplayTaskSignalKind: i32 {
    OnPresentFlipAway = 0,
}}
DEFINE_IID!(IID_IDisplayView, 2965998753, 46937, 23385, 177, 173, 240, 120, 106, 169, 229, 61);
RT_INTERFACE!{interface IDisplayView(IDisplayViewVtbl, IDisplayView_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayView] {
    fn get_Paths(&self, out: *mut <foundation::collections::IVectorView<DisplayPath> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ContentResolution(&self, out: *mut <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ContentResolution(&self, value: <foundation::IReference<crate::windows::graphics::SizeInt32> as RtType>::Abi) -> HRESULT,
    fn SetPrimaryPath(&self, path: <DisplayPath as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMap<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayView {
    #[inline] pub fn get_paths(&self) -> Result<Option<foundation::collections::IVectorView<DisplayPath>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Paths)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_content_resolution(&self) -> Result<Option<foundation::IReference<crate::windows::graphics::SizeInt32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_content_resolution(&self, value: &foundation::IReference<crate::windows::graphics::SizeInt32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ContentResolution)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_primary_path(&self, path: &DisplayPath) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPrimaryPath)(self.0.as_abi() as *const _ as *mut _, get_abi(path) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMap<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayView: IDisplayView}
DEFINE_IID!(IID_IDisplayWireFormat, 449615485, 34604, 23096, 187, 185, 29, 72, 114, 183, 98, 85);
RT_INTERFACE!{interface IDisplayWireFormat(IDisplayWireFormatVtbl, IDisplayWireFormat_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormat] {
    fn get_PixelEncoding(&self, out: *mut DisplayWireFormatPixelEncoding) -> HRESULT,
    fn get_BitsPerChannel(&self, out: *mut i32) -> HRESULT,
    fn get_ColorSpace(&self, out: *mut DisplayWireFormatColorSpace) -> HRESULT,
    fn get_Eotf(&self, out: *mut DisplayWireFormatEotf) -> HRESULT,
    fn get_HdrMetadata(&self, out: *mut DisplayWireFormatHdrMetadata) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<Guid, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDisplayWireFormat {
    #[inline] pub fn get_pixel_encoding(&self) -> Result<DisplayWireFormatPixelEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PixelEncoding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bits_per_channel(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitsPerChannel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_space(&self) -> Result<DisplayWireFormatColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ColorSpace)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eotf(&self) -> Result<DisplayWireFormatEotf> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Eotf)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hdr_metadata(&self) -> Result<DisplayWireFormatHdrMetadata> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HdrMetadata)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<Guid, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayWireFormat: IDisplayWireFormat}
impl RtActivatable<IDisplayWireFormatFactory> for DisplayWireFormat {}
impl RtActivatable<IDisplayWireFormatStatics> for DisplayWireFormat {}
impl DisplayWireFormat {
    #[inline] pub fn create_instance(pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<DisplayWireFormat> {
        <Self as RtActivatable<IDisplayWireFormatFactory>>::get_activation_factory().create_instance(pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata)
    }
    #[inline] pub fn create_with_properties(extraProperties: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<Option<DisplayWireFormat>> {
        <Self as RtActivatable<IDisplayWireFormatStatics>>::get_activation_factory().create_with_properties(extraProperties, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata)
    }
}
DEFINE_CLSID!(DisplayWireFormat(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,87,105,114,101,70,111,114,109,97,116,0]) [CLSID_DisplayWireFormat]);
RT_ENUM! { enum DisplayWireFormatColorSpace: i32 {
    BT709 = 0, BT2020 = 1, ProfileDefinedWideColorGamut = 2,
}}
RT_ENUM! { enum DisplayWireFormatEotf: i32 {
    Sdr = 0, HdrSmpte2084 = 1,
}}
DEFINE_IID!(IID_IDisplayWireFormatFactory, 3002058965, 2518, 21990, 173, 34, 144, 20, 179, 210, 82, 41);
RT_INTERFACE!{static interface IDisplayWireFormatFactory(IDisplayWireFormatFactoryVtbl, IDisplayWireFormatFactory_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormatFactory] {
    fn CreateInstance(&self, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata, out: *mut <DisplayWireFormat as RtType>::Abi) -> HRESULT
}}
impl IDisplayWireFormatFactory {
    #[inline] pub fn create_instance(&self, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<DisplayWireFormat> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, &mut out);
        if hr == S_OK { Ok(DisplayWireFormat::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayWireFormatHdrMetadata: i32 {
    None = 0, Hdr10 = 1, Hdr10Plus = 2, DolbyVisionLowLatency = 3,
}}
RT_ENUM! { enum DisplayWireFormatPixelEncoding: i32 {
    Rgb444 = 0, Ycc444 = 1, Ycc422 = 2, Ycc420 = 3, Intensity = 4,
}}
DEFINE_IID!(IID_IDisplayWireFormatStatics, 3312820781, 50150, 24442, 189, 251, 135, 198, 171, 134, 97, 213);
RT_INTERFACE!{static interface IDisplayWireFormatStatics(IDisplayWireFormatStaticsVtbl, IDisplayWireFormatStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormatStatics] {
    fn CreateWithProperties(&self, extraProperties: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>> as RtType>::Abi, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata, out: *mut <DisplayWireFormat as RtType>::Abi) -> HRESULT
}}
impl IDisplayWireFormatStatics {
    #[inline] pub fn create_with_properties(&self, extraProperties: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<Option<DisplayWireFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithProperties)(self.0.as_abi() as *const _ as *mut _, get_abi(extraProperties) as *const _ as *mut _, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, &mut out);
        if hr == S_OK { Ok(DisplayWireFormat::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Display.Core
} // Windows.Devices.Display
pub mod enumeration { // Windows.Devices.Enumeration
use crate::prelude::*;
DEFINE_IID!(IID_IDeviceAccessChangedEventArgs, 3738831820, 20381, 20312, 157, 186, 169, 188, 128, 4, 8, 213);
RT_INTERFACE!{interface IDeviceAccessChangedEventArgs(IDeviceAccessChangedEventArgsVtbl, IDeviceAccessChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs] {
    fn get_Status(&self, out: *mut DeviceAccessStatus) -> HRESULT
}}
impl IDeviceAccessChangedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<DeviceAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceAccessChangedEventArgs: IDeviceAccessChangedEventArgs}
DEFINE_IID!(IID_IDeviceAccessChangedEventArgs2, 2186424930, 37707, 19248, 161, 120, 173, 195, 159, 47, 43, 227);
RT_INTERFACE!{interface IDeviceAccessChangedEventArgs2(IDeviceAccessChangedEventArgs2Vtbl, IDeviceAccessChangedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDeviceAccessChangedEventArgs2 {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceAccessInformation, 195730035, 28133, 18709, 141, 221, 154, 5, 84, 166, 245, 69);
RT_INTERFACE!{interface IDeviceAccessInformation(IDeviceAccessInformationVtbl, IDeviceAccessInformation_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformation] {
    fn add_AccessChanged(&self, handler: <foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CurrentStatus(&self, out: *mut DeviceAccessStatus) -> HRESULT
}}
impl IDeviceAccessInformation {
    #[inline] pub fn add_access_changed(&self, handler: &foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AccessChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_access_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AccessChanged)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_status(&self) -> Result<DeviceAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceAccessInformation: IDeviceAccessInformation}
impl RtActivatable<IDeviceAccessInformationStatics> for DeviceAccessInformation {}
impl DeviceAccessInformation {
    #[inline] pub fn create_from_id(deviceId: &HStringArg) -> Result<Option<DeviceAccessInformation>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_id(deviceId)
    }
    #[inline] pub fn create_from_device_class_id(deviceClassId: Guid) -> Result<Option<DeviceAccessInformation>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_device_class_id(deviceClassId)
    }
    #[inline] pub fn create_from_device_class(deviceClass: DeviceClass) -> Result<Option<DeviceAccessInformation>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_device_class(deviceClass)
    }
}
DEFINE_CLSID!(DeviceAccessInformation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,65,99,99,101,115,115,73,110,102,111,114,109,97,116,105,111,110,0]) [CLSID_DeviceAccessInformation]);
DEFINE_IID!(IID_IDeviceAccessInformationStatics, 1464587219, 24368, 17869, 138, 148, 114, 79, 229, 151, 48, 132);
RT_INTERFACE!{static interface IDeviceAccessInformationStatics(IDeviceAccessInformationStaticsVtbl, IDeviceAccessInformationStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformationStatics] {
    fn CreateFromId(&self, deviceId: HSTRING, out: *mut <DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn CreateFromDeviceClassId(&self, deviceClassId: Guid, out: *mut <DeviceAccessInformation as RtType>::Abi) -> HRESULT,
    fn CreateFromDeviceClass(&self, deviceClass: DeviceClass, out: *mut <DeviceAccessInformation as RtType>::Abi) -> HRESULT
}}
impl IDeviceAccessInformationStatics {
    #[inline] pub fn create_from_id(&self, deviceId: &HStringArg) -> Result<Option<DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_class_id(&self, deviceClassId: Guid) -> Result<Option<DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDeviceClassId)(self.0.as_abi() as *const _ as *mut _, deviceClassId, &mut out);
        if hr == S_OK { Ok(DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_class(&self, deviceClass: DeviceClass) -> Result<Option<DeviceAccessInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDeviceClass)(self.0.as_abi() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(DeviceAccessInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DeviceAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
RT_ENUM! { enum DeviceClass: i32 {
    All = 0, AudioCapture = 1, AudioRender = 2, PortableStorageDevice = 3, VideoCapture = 4, ImageScanner = 5, Location = 6,
}}
DEFINE_IID!(IID_IDeviceConnectionChangeTriggerDetails, 3092745228, 48065, 18507, 191, 250, 123, 49, 220, 194, 0, 178);
RT_INTERFACE!{interface IDeviceConnectionChangeTriggerDetails(IDeviceConnectionChangeTriggerDetailsVtbl, IDeviceConnectionChangeTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceConnectionChangeTriggerDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDeviceConnectionChangeTriggerDetails {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceConnectionChangeTriggerDetails: IDeviceConnectionChangeTriggerDetails}
DEFINE_IID!(IID_IDeviceDisconnectButtonClickedEventArgs, 2386867565, 63746, 18944, 181, 54, 243, 121, 146, 230, 162, 167);
RT_INTERFACE!{interface IDeviceDisconnectButtonClickedEventArgs(IDeviceDisconnectButtonClickedEventArgsVtbl, IDeviceDisconnectButtonClickedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceDisconnectButtonClickedEventArgs] {
    fn get_Device(&self, out: *mut <DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IDeviceDisconnectButtonClickedEventArgs {
    #[inline] pub fn get_device(&self) -> Result<Option<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceDisconnectButtonClickedEventArgs: IDeviceDisconnectButtonClickedEventArgs}
DEFINE_IID!(IID_IDeviceInformation, 2879454101, 17304, 18589, 142, 68, 230, 19, 9, 39, 1, 31);
RT_INTERFACE!{interface IDeviceInformation(IDeviceInformationVtbl, IDeviceInformation_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_EnclosureLocation(&self, out: *mut <EnclosureLocation as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn Update(&self, updateInfo: <DeviceInformationUpdate as RtType>::Abi) -> HRESULT,
    fn GetThumbnailAsync(&self, out: *mut <foundation::IAsyncOperation<DeviceThumbnail> as RtType>::Abi) -> HRESULT,
    fn GetGlyphThumbnailAsync(&self, out: *mut <foundation::IAsyncOperation<DeviceThumbnail> as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformation {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enclosure_location(&self) -> Result<Option<EnclosureLocation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EnclosureLocation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(EnclosureLocation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update(&self, updateInfo: &DeviceInformationUpdate) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Update)(self.0.as_abi() as *const _ as *mut _, get_abi(updateInfo) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_async(&self) -> Result<foundation::IAsyncOperation<DeviceThumbnail>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetThumbnailAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_glyph_thumbnail_async(&self) -> Result<foundation::IAsyncOperation<DeviceThumbnail>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGlyphThumbnailAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformation: IDeviceInformation}
impl RtActivatable<IDeviceInformationStatics> for DeviceInformation {}
impl RtActivatable<IDeviceInformationStatics2> for DeviceInformation {}
impl DeviceInformation {
    #[inline] pub fn create_from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceInformation>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_from_id_async(deviceId)
    }
    #[inline] pub fn create_from_id_async_additional_properties(deviceId: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<DeviceInformation>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_from_id_async_additional_properties(deviceId, additionalProperties)
    }
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn find_all_async_device_class(deviceClass: DeviceClass) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_device_class(deviceClass)
    }
    #[inline] pub fn find_all_async_aqs_filter(aqsFilter: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_aqs_filter(aqsFilter)
    }
    #[inline] pub fn find_all_async_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_aqs_filter_and_additional_properties(aqsFilter, additionalProperties)
    }
    #[inline] pub fn create_watcher() -> Result<Option<DeviceWatcher>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn create_watcher_device_class(deviceClass: DeviceClass) -> Result<Option<DeviceWatcher>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_device_class(deviceClass)
    }
    #[inline] pub fn create_watcher_aqs_filter(aqsFilter: &HStringArg) -> Result<Option<DeviceWatcher>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_aqs_filter(aqsFilter)
    }
    #[inline] pub fn create_watcher_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<Option<DeviceWatcher>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_aqs_filter_and_additional_properties(aqsFilter, additionalProperties)
    }
    #[inline] pub fn get_aqs_filter_from_device_class(deviceClass: DeviceClass) -> Result<HString> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().get_aqs_filter_from_device_class(deviceClass)
    }
    #[inline] pub fn create_from_id_async_with_kind_and_additional_properties(deviceId: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<foundation::IAsyncOperation<DeviceInformation>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().create_from_id_async_with_kind_and_additional_properties(deviceId, additionalProperties, kind)
    }
    #[inline] pub fn find_all_async_with_kind_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().find_all_async_with_kind_aqs_filter_and_additional_properties(aqsFilter, additionalProperties, kind)
    }
    #[inline] pub fn create_watcher_with_kind_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<Option<DeviceWatcher>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().create_watcher_with_kind_aqs_filter_and_additional_properties(aqsFilter, additionalProperties, kind)
    }
}
DEFINE_CLSID!(DeviceInformation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,0]) [CLSID_DeviceInformation]);
DEFINE_IID!(IID_IDeviceInformation2, 4048987704, 31127, 18649, 161, 12, 38, 157, 70, 83, 63, 72);
RT_INTERFACE!{interface IDeviceInformation2(IDeviceInformation2Vtbl, IDeviceInformation2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformation2] {
    fn get_Kind(&self, out: *mut DeviceInformationKind) -> HRESULT,
    fn get_Pairing(&self, out: *mut <DeviceInformationPairing as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformation2 {
    #[inline] pub fn get_kind(&self) -> Result<DeviceInformationKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pairing(&self) -> Result<Option<DeviceInformationPairing>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pairing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformationPairing::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationCollection: foundation::collections::IVectorView<DeviceInformation>}
DEFINE_IID!(IID_IDeviceInformationCustomPairing, 2232650754, 20198, 18708, 131, 112, 16, 122, 57, 20, 76, 14);
RT_INTERFACE!{interface IDeviceInformationCustomPairing(IDeviceInformationCustomPairingVtbl, IDeviceInformationCustomPairing_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationCustomPairing] {
    fn PairAsync(&self, pairingKindsSupported: DevicePairingKinds, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT,
    fn PairWithProtectionLevelAsync(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT,
    fn PairWithProtectionLevelAndSettingsAsync(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: <IDevicePairingSettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT,
    fn add_PairingRequested(&self, handler: <foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PairingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IDeviceInformationCustomPairing {
    #[inline] pub fn pair_async(&self, pairingKindsSupported: DevicePairingKinds) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairAsync)(self.0.as_abi() as *const _ as *mut _, pairingKindsSupported, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_async(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairWithProtectionLevelAsync)(self.0.as_abi() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_and_settings_async(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &IDevicePairingSettings) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self.0.as_abi() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, get_abi(devicePairingSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_pairing_requested(&self, handler: &foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PairingRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pairing_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PairingRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationCustomPairing: IDeviceInformationCustomPairing}
RT_ENUM! { enum DeviceInformationKind: i32 {
    Unknown = 0, DeviceInterface = 1, DeviceContainer = 2, Device = 3, DeviceInterfaceClass = 4, AssociationEndpoint = 5, AssociationEndpointContainer = 6, AssociationEndpointService = 7, DevicePanel = 8,
}}
DEFINE_IID!(IID_IDeviceInformationPairing, 742877685, 63108, 16597, 132, 105, 232, 219, 170, 183, 4, 133);
RT_INTERFACE!{interface IDeviceInformationPairing(IDeviceInformationPairingVtbl, IDeviceInformationPairing_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing] {
    fn get_IsPaired(&self, out: *mut bool) -> HRESULT,
    fn get_CanPair(&self, out: *mut bool) -> HRESULT,
    fn PairAsync(&self, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT,
    fn PairWithProtectionLevelAsync(&self, minProtectionLevel: DevicePairingProtectionLevel, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformationPairing {
    #[inline] pub fn get_is_paired(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaired)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_pair(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanPair)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn pair_async(&self) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_async(&self, minProtectionLevel: DevicePairingProtectionLevel) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairWithProtectionLevelAsync)(self.0.as_abi() as *const _ as *mut _, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationPairing: IDeviceInformationPairing}
impl RtActivatable<IDeviceInformationPairingStatics> for DeviceInformationPairing {}
impl RtActivatable<IDeviceInformationPairingStatics2> for DeviceInformationPairing {}
impl DeviceInformationPairing {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests(pairingKindsSupported: DevicePairingKinds) -> Result<bool> {
        <Self as RtActivatable<IDeviceInformationPairingStatics>>::get_activation_factory().try_register_for_all_inbound_pairing_requests(pairingKindsSupported)
    }
    #[inline] pub fn try_register_for_all_inbound_pairing_requests_with_protection_level(pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<bool> {
        <Self as RtActivatable<IDeviceInformationPairingStatics2>>::get_activation_factory().try_register_for_all_inbound_pairing_requests_with_protection_level(pairingKindsSupported, minProtectionLevel)
    }
}
DEFINE_CLSID!(DeviceInformationPairing(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,80,97,105,114,105,110,103,0]) [CLSID_DeviceInformationPairing]);
DEFINE_IID!(IID_IDeviceInformationPairing2, 4135981821, 2798, 17192, 133, 204, 28, 116, 43, 177, 121, 13);
RT_INTERFACE!{interface IDeviceInformationPairing2(IDeviceInformationPairing2Vtbl, IDeviceInformationPairing2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing2] {
    fn get_ProtectionLevel(&self, out: *mut DevicePairingProtectionLevel) -> HRESULT,
    fn get_Custom(&self, out: *mut <DeviceInformationCustomPairing as RtType>::Abi) -> HRESULT,
    fn PairWithProtectionLevelAndSettingsAsync(&self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: <IDevicePairingSettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<DevicePairingResult> as RtType>::Abi) -> HRESULT,
    fn UnpairAsync(&self, out: *mut <foundation::IAsyncOperation<DeviceUnpairingResult> as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformationPairing2 {
    #[inline] pub fn get_protection_level(&self) -> Result<DevicePairingProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_custom(&self) -> Result<Option<DeviceInformationCustomPairing>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Custom)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformationCustomPairing::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_and_settings_async(&self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &IDevicePairingSettings) -> Result<foundation::IAsyncOperation<DevicePairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self.0.as_abi() as *const _ as *mut _, minProtectionLevel, get_abi(devicePairingSettings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unpair_async(&self) -> Result<foundation::IAsyncOperation<DeviceUnpairingResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UnpairAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationPairingStatics, 3910517768, 14036, 18849, 191, 19, 81, 65, 115, 121, 155, 107);
RT_INTERFACE!{static interface IDeviceInformationPairingStatics(IDeviceInformationPairingStaticsVtbl, IDeviceInformationPairingStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairingStatics] {
    fn TryRegisterForAllInboundPairingRequests(&self, pairingKindsSupported: DevicePairingKinds, out: *mut bool) -> HRESULT
}}
impl IDeviceInformationPairingStatics {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests(&self, pairingKindsSupported: DevicePairingKinds) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryRegisterForAllInboundPairingRequests)(self.0.as_abi() as *const _ as *mut _, pairingKindsSupported, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationPairingStatics2, 81679218, 47031, 18283, 167, 79, 197, 131, 106, 112, 77, 152);
RT_INTERFACE!{static interface IDeviceInformationPairingStatics2(IDeviceInformationPairingStatics2Vtbl, IDeviceInformationPairingStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairingStatics2] {
    fn TryRegisterForAllInboundPairingRequestsWithProtectionLevel(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, out: *mut bool) -> HRESULT
}}
impl IDeviceInformationPairingStatics2 {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests_with_protection_level(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryRegisterForAllInboundPairingRequestsWithProtectionLevel)(self.0.as_abi() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationStatics, 3246329870, 14918, 19064, 128, 19, 118, 157, 201, 185, 115, 144);
RT_INTERFACE!{static interface IDeviceInformationStatics(IDeviceInformationStaticsVtbl, IDeviceInformationStatics_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics] {
    fn CreateFromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceInformation> as RtType>::Abi) -> HRESULT,
    fn CreateFromIdAsyncAdditionalProperties(&self, deviceId: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<DeviceInformation> as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<DeviceInformationCollection> as RtType>::Abi) -> HRESULT,
    fn FindAllAsyncDeviceClass(&self, deviceClass: DeviceClass, out: *mut <foundation::IAsyncOperation<DeviceInformationCollection> as RtType>::Abi) -> HRESULT,
    fn FindAllAsyncAqsFilter(&self, aqsFilter: HSTRING, out: *mut <foundation::IAsyncOperation<DeviceInformationCollection> as RtType>::Abi) -> HRESULT,
    fn FindAllAsyncAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<DeviceInformationCollection> as RtType>::Abi) -> HRESULT,
    fn CreateWatcher(&self, out: *mut <DeviceWatcher as RtType>::Abi) -> HRESULT,
    fn CreateWatcherDeviceClass(&self, deviceClass: DeviceClass, out: *mut <DeviceWatcher as RtType>::Abi) -> HRESULT,
    fn CreateWatcherAqsFilter(&self, aqsFilter: HSTRING, out: *mut <DeviceWatcher as RtType>::Abi) -> HRESULT,
    fn CreateWatcherAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <DeviceWatcher as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformationStatics {
    #[inline] pub fn create_from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_id_async_additional_properties(&self, deviceId: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromIdAsyncAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), get_abi(additionalProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_device_class(&self, deviceClass: DeviceClass) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsyncDeviceClass)(self.0.as_abi() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter(&self, aqsFilter: &HStringArg) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsyncAqsFilter)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsyncAqsFilterAndAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), get_abi(additionalProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self) -> Result<Option<DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_device_class(&self, deviceClass: DeviceClass) -> Result<Option<DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcherDeviceClass)(self.0.as_abi() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter(&self, aqsFilter: &HStringArg) -> Result<Option<DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcherAqsFilter)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>) -> Result<Option<DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcherAqsFilterAndAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), get_abi(additionalProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationStatics2, 1228623668, 43087, 17917, 145, 103, 21, 209, 203, 27, 209, 249);
RT_INTERFACE!{static interface IDeviceInformationStatics2(IDeviceInformationStatics2Vtbl, IDeviceInformationStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics2] {
    fn GetAqsFilterFromDeviceClass(&self, deviceClass: DeviceClass, out: *mut HSTRING) -> HRESULT,
    fn CreateFromIdAsyncWithKindAndAdditionalProperties(&self, deviceId: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, kind: DeviceInformationKind, out: *mut <foundation::IAsyncOperation<DeviceInformation> as RtType>::Abi) -> HRESULT,
    fn FindAllAsyncWithKindAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, kind: DeviceInformationKind, out: *mut <foundation::IAsyncOperation<DeviceInformationCollection> as RtType>::Abi) -> HRESULT,
    fn CreateWatcherWithKindAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, kind: DeviceInformationKind, out: *mut <DeviceWatcher as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformationStatics2 {
    #[inline] pub fn get_aqs_filter_from_device_class(&self, deviceClass: DeviceClass) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAqsFilterFromDeviceClass)(self.0.as_abi() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_id_async_with_kind_and_additional_properties(&self, deviceId: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<foundation::IAsyncOperation<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromIdAsyncWithKindAndAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), get_abi(additionalProperties) as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_with_kind_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<foundation::IAsyncOperation<DeviceInformationCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsyncWithKindAqsFilterAndAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), get_abi(additionalProperties) as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_with_kind_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> Result<Option<DeviceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcherWithKindAqsFilterAndAdditionalProperties)(self.0.as_abi() as *const _ as *mut _, aqsFilter.get(), get_abi(additionalProperties) as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(DeviceWatcher::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationUpdate, 2402374405, 55666, 17591, 163, 126, 158, 130, 44, 120, 33, 59);
RT_INTERFACE!{interface IDeviceInformationUpdate(IDeviceInformationUpdateVtbl, IDeviceInformationUpdate_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IDeviceInformationUpdate {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationUpdate: IDeviceInformationUpdate}
DEFINE_IID!(IID_IDeviceInformationUpdate2, 1570575500, 43123, 18526, 186, 166, 170, 98, 7, 136, 227, 204);
RT_INTERFACE!{interface IDeviceInformationUpdate2(IDeviceInformationUpdate2Vtbl, IDeviceInformationUpdate2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate2] {
    fn get_Kind(&self, out: *mut DeviceInformationKind) -> HRESULT
}}
impl IDeviceInformationUpdate2 {
    #[inline] pub fn get_kind(&self) -> Result<DeviceInformationKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum DevicePairingKinds: u32 {
    None = 0, ConfirmOnly = 1, DisplayPin = 2, ProvidePin = 4, ConfirmPinMatch = 8,
}}
RT_ENUM! { enum DevicePairingProtectionLevel: i32 {
    Default = 0, None = 1, Encryption = 2, EncryptionAndAuthentication = 3,
}}
DEFINE_IID!(IID_IDevicePairingRequestedEventArgs, 4145544278, 56939, 18559, 131, 118, 1, 128, 172, 166, 153, 99);
RT_INTERFACE!{interface IDevicePairingRequestedEventArgs(IDevicePairingRequestedEventArgsVtbl, IDevicePairingRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePairingRequestedEventArgs] {
    fn get_DeviceInformation(&self, out: *mut <DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_PairingKind(&self, out: *mut DevicePairingKinds) -> HRESULT,
    fn get_Pin(&self, out: *mut HSTRING) -> HRESULT,
    fn Accept(&self) -> HRESULT,
    fn AcceptWithPin(&self, pin: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IDevicePairingRequestedEventArgs {
    #[inline] pub fn get_device_information(&self) -> Result<Option<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pairing_kind(&self) -> Result<DevicePairingKinds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PairingKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pin(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pin)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Accept)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_with_pin(&self, pin: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AcceptWithPin)(self.0.as_abi() as *const _ as *mut _, pin.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePairingRequestedEventArgs: IDevicePairingRequestedEventArgs}
DEFINE_IID!(IID_IDevicePairingResult, 120259263, 56725, 16421, 155, 55, 222, 81, 173, 186, 55, 183);
RT_INTERFACE!{interface IDevicePairingResult(IDevicePairingResultVtbl, IDevicePairingResult_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePairingResult] {
    fn get_Status(&self, out: *mut DevicePairingResultStatus) -> HRESULT,
    fn get_ProtectionLevelUsed(&self, out: *mut DevicePairingProtectionLevel) -> HRESULT
}}
impl IDevicePairingResult {
    #[inline] pub fn get_status(&self) -> Result<DevicePairingResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_level_used(&self) -> Result<DevicePairingProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionLevelUsed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePairingResult: IDevicePairingResult}
RT_ENUM! { enum DevicePairingResultStatus: i32 {
    Paired = 0, NotReadyToPair = 1, NotPaired = 2, AlreadyPaired = 3, ConnectionRejected = 4, TooManyConnections = 5, HardwareFailure = 6, AuthenticationTimeout = 7, AuthenticationNotAllowed = 8, AuthenticationFailure = 9, NoSupportedProfiles = 10, ProtectionLevelCouldNotBeMet = 11, AccessDenied = 12, InvalidCeremonyData = 13, PairingCanceled = 14, OperationAlreadyInProgress = 15, RequiredHandlerNotRegistered = 16, RejectedByHandler = 17, RemoteDeviceHasAssociation = 18, Failed = 19,
}}
DEFINE_IID!(IID_IDevicePairingSettings, 1210888828, 33723, 16910, 190, 81, 102, 2, 178, 34, 222, 84);
RT_INTERFACE!{interface IDevicePairingSettings(IDevicePairingSettingsVtbl, IDevicePairingSettings_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePairingSettings] {
    
}}
DEFINE_IID!(IID_IDevicePicker, 2224650914, 842, 17472, 136, 19, 125, 11, 212, 121, 191, 90);
RT_INTERFACE!{interface IDevicePicker(IDevicePickerVtbl, IDevicePicker_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePicker] {
    fn get_Filter(&self, out: *mut <DevicePickerFilter as RtType>::Abi) -> HRESULT,
    fn get_Appearance(&self, out: *mut <DevicePickerAppearance as RtType>::Abi) -> HRESULT,
    fn get_RequestedProperties(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn add_DeviceSelected(&self, handler: <foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeviceSelected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DisconnectButtonClicked(&self, handler: <foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DisconnectButtonClicked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DevicePickerDismissed(&self, handler: <foundation::TypedEventHandler<DevicePicker, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DevicePickerDismissed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Show(&self, selection: foundation::Rect) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowWithPlacement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> HRESULT,
    fn PickSingleDeviceAsync(&self, selection: foundation::Rect, out: *mut <foundation::IAsyncOperation<DeviceInformation> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-ui")] fn PickSingleDeviceAsyncWithPlacement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement, out: *mut <foundation::IAsyncOperation<DeviceInformation> as RtType>::Abi) -> HRESULT,
    fn Hide(&self) -> HRESULT,
    fn SetDisplayStatus(&self, device: <DeviceInformation as RtType>::Abi, status: HSTRING, options: DevicePickerDisplayStatusOptions) -> HRESULT
}}
impl IDevicePicker {
    #[inline] pub fn get_filter(&self) -> Result<Option<DevicePickerFilter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Filter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DevicePickerFilter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<Option<DevicePickerAppearance>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Appearance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DevicePickerAppearance::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_properties(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestedProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_device_selected(&self, handler: &foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DeviceSelected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_selected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DeviceSelected)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disconnect_button_clicked(&self, handler: &foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DisconnectButtonClicked)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disconnect_button_clicked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DisconnectButtonClicked)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_device_picker_dismissed(&self, handler: &foundation::TypedEventHandler<DevicePicker, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_picker_dismissed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DevicePickerDismissed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show(&self, selection: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Show)(self.0.as_abi() as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_with_placement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ShowWithPlacement)(self.0.as_abi() as *const _ as *mut _, selection, placement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pick_single_device_async(&self, selection: foundation::Rect) -> Result<foundation::IAsyncOperation<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PickSingleDeviceAsync)(self.0.as_abi() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn pick_single_device_async_with_placement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> Result<foundation::IAsyncOperation<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).PickSingleDeviceAsyncWithPlacement)(self.0.as_abi() as *const _ as *mut _, selection, placement, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn hide(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Hide)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_display_status(&self, device: &DeviceInformation, status: &HStringArg, options: DevicePickerDisplayStatusOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDisplayStatus)(self.0.as_abi() as *const _ as *mut _, get_abi(device) as *const _ as *mut _, status.get(), options);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePicker: IDevicePicker}
impl RtActivatable<IActivationFactory> for DevicePicker {}
DEFINE_CLSID!(DevicePicker(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,80,105,99,107,101,114,0]) [CLSID_DevicePicker]);
DEFINE_IID!(IID_IDevicePickerAppearance, 3868857030, 58919, 20184, 155, 108, 70, 10, 244, 69, 229, 109);
RT_INTERFACE!{interface IDevicePickerAppearance(IDevicePickerAppearanceVtbl, IDevicePickerAppearance_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePickerAppearance] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_ForegroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_ForegroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_BackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_AccentColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_AccentColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedForegroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedForegroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedBackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedAccentColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedAccentColor(&self, value: super::super::ui::Color) -> HRESULT
}}
impl IDevicePickerAppearance {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Title)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_foreground_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ForegroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_foreground_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ForegroundColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BackgroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BackgroundColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_accent_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccentColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_accent_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AccentColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_foreground_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedForegroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_foreground_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedForegroundColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedBackgroundColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedBackgroundColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_accent_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedAccentColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_accent_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedAccentColor)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePickerAppearance: IDevicePickerAppearance}
RT_ENUM! { enum DevicePickerDisplayStatusOptions: u32 {
    None = 0, ShowProgress = 1, ShowDisconnectButton = 2, ShowRetryButton = 4,
}}
DEFINE_IID!(IID_IDevicePickerFilter, 2447086242, 22475, 18673, 155, 89, 165, 155, 122, 31, 2, 162);
RT_INTERFACE!{interface IDevicePickerFilter(IDevicePickerFilterVtbl, IDevicePickerFilter_Abi): IInspectable(IInspectableVtbl) [IID_IDevicePickerFilter] {
    fn get_SupportedDeviceClasses(&self, out: *mut <foundation::collections::IVector<DeviceClass> as RtType>::Abi) -> HRESULT,
    fn get_SupportedDeviceSelectors(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT
}}
impl IDevicePickerFilter {
    #[inline] pub fn get_supported_device_classes(&self) -> Result<Option<foundation::collections::IVector<DeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedDeviceClasses)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_device_selectors(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedDeviceSelectors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePickerFilter: IDevicePickerFilter}
DEFINE_IID!(IID_IDeviceSelectedEventArgs, 647944926, 7471, 18752, 132, 2, 65, 86, 184, 29, 60, 119);
RT_INTERFACE!{interface IDeviceSelectedEventArgs(IDeviceSelectedEventArgsVtbl, IDeviceSelectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceSelectedEventArgs] {
    fn get_SelectedDevice(&self, out: *mut <DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IDeviceSelectedEventArgs {
    #[inline] pub fn get_selected_device(&self) -> Result<Option<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceSelectedEventArgs: IDeviceSelectedEventArgs}
#[cfg(feature="windows-storage")] RT_CLASS!{class DeviceThumbnail: super::super::storage::streams::IRandomAccessStreamWithContentType}
#[cfg(not(feature="windows-storage"))] RT_CLASS!{class DeviceThumbnail: IInspectable}
DEFINE_IID!(IID_IDeviceUnpairingResult, 1727285971, 31193, 17483, 146, 207, 169, 46, 247, 37, 113, 199);
RT_INTERFACE!{interface IDeviceUnpairingResult(IDeviceUnpairingResultVtbl, IDeviceUnpairingResult_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceUnpairingResult] {
    fn get_Status(&self, out: *mut DeviceUnpairingResultStatus) -> HRESULT
}}
impl IDeviceUnpairingResult {
    #[inline] pub fn get_status(&self) -> Result<DeviceUnpairingResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceUnpairingResult: IDeviceUnpairingResult}
RT_ENUM! { enum DeviceUnpairingResultStatus: i32 {
    Unpaired = 0, AlreadyUnpaired = 1, OperationAlreadyInProgress = 2, AccessDenied = 3, Failed = 4,
}}
DEFINE_IID!(IID_IDeviceWatcher, 3387603325, 36715, 20374, 169, 244, 171, 200, 20, 226, 34, 113);
RT_INTERFACE!{interface IDeviceWatcher(IDeviceWatcherVtbl, IDeviceWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher] {
    fn add_Added(&self, handler: <foundation::TypedEventHandler<DeviceWatcher, DeviceInformation> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: <foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: <foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<DeviceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<DeviceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IDeviceWatcher {
    #[inline] pub fn add_added(&self, handler: &foundation::TypedEventHandler<DeviceWatcher, DeviceInformation>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Added)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Added)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Updated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Updated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Removed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Removed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<DeviceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<DeviceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcher: IDeviceWatcher}
DEFINE_IID!(IID_IDeviceWatcher2, 4278732142, 60692, 18921, 154, 105, 129, 23, 197, 74, 233, 113);
RT_INTERFACE!{interface IDeviceWatcher2(IDeviceWatcher2Vtbl, IDeviceWatcher2_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher2] {
    #[cfg(feature="windows-applicationmodel")] fn GetBackgroundTrigger(&self, requestedEventKinds: <foundation::collections::IIterable<DeviceWatcherEventKind> as RtType>::Abi, out: *mut <super::super::applicationmodel::background::DeviceWatcherTrigger as RtType>::Abi) -> HRESULT
}}
impl IDeviceWatcher2 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn get_background_trigger(&self, requestedEventKinds: &foundation::collections::IIterable<DeviceWatcherEventKind>) -> Result<Option<super::super::applicationmodel::background::DeviceWatcherTrigger>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBackgroundTrigger)(self.0.as_abi() as *const _ as *mut _, get_abi(requestedEventKinds) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::applicationmodel::background::DeviceWatcherTrigger::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceWatcherEvent, 1957338123, 7613, 18429, 182, 53, 60, 197, 86, 208, 255, 139);
RT_INTERFACE!{interface IDeviceWatcherEvent(IDeviceWatcherEventVtbl, IDeviceWatcherEvent_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherEvent] {
    fn get_Kind(&self, out: *mut DeviceWatcherEventKind) -> HRESULT,
    fn get_DeviceInformation(&self, out: *mut <DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_DeviceInformationUpdate(&self, out: *mut <DeviceInformationUpdate as RtType>::Abi) -> HRESULT
}}
impl IDeviceWatcherEvent {
    #[inline] pub fn get_kind(&self) -> Result<DeviceWatcherEventKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information(&self) -> Result<Option<DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information_update(&self) -> Result<Option<DeviceInformationUpdate>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformationUpdate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(DeviceInformationUpdate::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcherEvent: IDeviceWatcherEvent}
RT_ENUM! { enum DeviceWatcherEventKind: i32 {
    Add = 0, Update = 1, Remove = 2,
}}
RT_ENUM! { enum DeviceWatcherStatus: i32 {
    Created = 0, Started = 1, EnumerationCompleted = 2, Stopping = 3, Stopped = 4, Aborted = 5,
}}
DEFINE_IID!(IID_IDeviceWatcherTriggerDetails, 947945753, 19639, 20055, 165, 109, 119, 109, 7, 203, 254, 249);
RT_INTERFACE!{interface IDeviceWatcherTriggerDetails(IDeviceWatcherTriggerDetailsVtbl, IDeviceWatcherTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherTriggerDetails] {
    fn get_DeviceWatcherEvents(&self, out: *mut <foundation::collections::IVectorView<DeviceWatcherEvent> as RtType>::Abi) -> HRESULT
}}
impl IDeviceWatcherTriggerDetails {
    #[inline] pub fn get_device_watcher_events(&self) -> Result<Option<foundation::collections::IVectorView<DeviceWatcherEvent>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceWatcherEvents)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcherTriggerDetails: IDeviceWatcherTriggerDetails}
DEFINE_IID!(IID_IEnclosureLocation, 1110706727, 22544, 17820, 170, 187, 198, 94, 31, 129, 62, 207);
RT_INTERFACE!{interface IEnclosureLocation(IEnclosureLocationVtbl, IEnclosureLocation_Abi): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation] {
    fn get_InDock(&self, out: *mut bool) -> HRESULT,
    fn get_InLid(&self, out: *mut bool) -> HRESULT,
    fn get_Panel(&self, out: *mut Panel) -> HRESULT
}}
impl IEnclosureLocation {
    #[inline] pub fn get_in_dock(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InDock)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_in_lid(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InLid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_panel(&self) -> Result<Panel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Panel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EnclosureLocation: IEnclosureLocation}
DEFINE_IID!(IID_IEnclosureLocation2, 679844187, 57469, 18525, 138, 158, 189, 242, 154, 239, 79, 102);
RT_INTERFACE!{interface IEnclosureLocation2(IEnclosureLocation2Vtbl, IEnclosureLocation2_Abi): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation2] {
    fn get_RotationAngleInDegreesClockwise(&self, out: *mut u32) -> HRESULT
}}
impl IEnclosureLocation2 {
    #[inline] pub fn get_rotation_angle_in_degrees_clockwise(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RotationAngleInDegreesClockwise)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum Panel: i32 {
    Unknown = 0, Front = 1, Back = 2, Top = 3, Bottom = 4, Left = 5, Right = 6,
}}
pub mod pnp { // Windows.Devices.Enumeration.Pnp
use crate::prelude::*;
DEFINE_IID!(IID_IPnpObject, 2512806488, 29499, 19087, 147, 163, 219, 7, 138, 200, 112, 193);
RT_INTERFACE!{interface IPnpObject(IPnpObjectVtbl, IPnpObject_Abi): IInspectable(IInspectableVtbl) [IID_IPnpObject] {
    fn get_Type(&self, out: *mut PnpObjectType) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn Update(&self, updateInfo: <PnpObjectUpdate as RtType>::Abi) -> HRESULT
}}
impl IPnpObject {
    #[inline] pub fn get_type(&self) -> Result<PnpObjectType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update(&self, updateInfo: &PnpObjectUpdate) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Update)(self.0.as_abi() as *const _ as *mut _, get_abi(updateInfo) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObject: IPnpObject}
impl RtActivatable<IPnpObjectStatics> for PnpObject {}
impl PnpObject {
    #[inline] pub fn create_from_id_async(type_: PnpObjectType, id: &HStringArg, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<PnpObject>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_from_id_async(type_, id, requestedProperties)
    }
    #[inline] pub fn find_all_async(type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<PnpObjectCollection>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().find_all_async(type_, requestedProperties)
    }
    #[inline] pub fn find_all_async_aqs_filter(type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> Result<foundation::IAsyncOperation<PnpObjectCollection>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().find_all_async_aqs_filter(type_, requestedProperties, aqsFilter)
    }
    #[inline] pub fn create_watcher(type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<Option<PnpObjectWatcher>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_watcher(type_, requestedProperties)
    }
    #[inline] pub fn create_watcher_aqs_filter(type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> Result<Option<PnpObjectWatcher>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_watcher_aqs_filter(type_, requestedProperties, aqsFilter)
    }
}
DEFINE_CLSID!(PnpObject(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,80,110,112,46,80,110,112,79,98,106,101,99,116,0]) [CLSID_PnpObject]);
RT_CLASS!{class PnpObjectCollection: foundation::collections::IVectorView<PnpObject>}
DEFINE_IID!(IID_IPnpObjectStatics, 3015911997, 53608, 18016, 187, 243, 167, 51, 177, 75, 110, 1);
RT_INTERFACE!{static interface IPnpObjectStatics(IPnpObjectStaticsVtbl, IPnpObjectStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPnpObjectStatics] {
    fn CreateFromIdAsync(&self, type_: PnpObjectType, id: HSTRING, requestedProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PnpObject> as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, type_: PnpObjectType, requestedProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PnpObjectCollection> as RtType>::Abi) -> HRESULT,
    fn FindAllAsyncAqsFilter(&self, type_: PnpObjectType, requestedProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, aqsFilter: HSTRING, out: *mut <foundation::IAsyncOperation<PnpObjectCollection> as RtType>::Abi) -> HRESULT,
    fn CreateWatcher(&self, type_: PnpObjectType, requestedProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <PnpObjectWatcher as RtType>::Abi) -> HRESULT,
    fn CreateWatcherAqsFilter(&self, type_: PnpObjectType, requestedProperties: <foundation::collections::IIterable<HString> as RtType>::Abi, aqsFilter: HSTRING, out: *mut <PnpObjectWatcher as RtType>::Abi) -> HRESULT
}}
impl IPnpObjectStatics {
    #[inline] pub fn create_from_id_async(&self, type_: PnpObjectType, id: &HStringArg, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<PnpObject>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromIdAsync)(self.0.as_abi() as *const _ as *mut _, type_, id.get(), get_abi(requestedProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self, type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<PnpObjectCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, type_, get_abi(requestedProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter(&self, type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> Result<foundation::IAsyncOperation<PnpObjectCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsyncAqsFilter)(self.0.as_abi() as *const _ as *mut _, type_, get_abi(requestedProperties) as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self, type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>) -> Result<Option<PnpObjectWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, type_, get_abi(requestedProperties) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PnpObjectWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter(&self, type_: PnpObjectType, requestedProperties: &foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> Result<Option<PnpObjectWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcherAqsFilter)(self.0.as_abi() as *const _ as *mut _, type_, get_abi(requestedProperties) as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(PnpObjectWatcher::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PnpObjectType: i32 {
    Unknown = 0, DeviceInterface = 1, DeviceContainer = 2, Device = 3, DeviceInterfaceClass = 4, AssociationEndpoint = 5, AssociationEndpointContainer = 6, AssociationEndpointService = 7, DevicePanel = 8,
}}
DEFINE_IID!(IID_IPnpObjectUpdate, 1868163090, 30, 18500, 188, 198, 67, 40, 134, 133, 106, 23);
RT_INTERFACE!{interface IPnpObjectUpdate(IPnpObjectUpdateVtbl, IPnpObjectUpdate_Abi): IInspectable(IInspectableVtbl) [IID_IPnpObjectUpdate] {
    fn get_Type(&self, out: *mut PnpObjectType) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IPnpObjectUpdate {
    #[inline] pub fn get_type(&self) -> Result<PnpObjectType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObjectUpdate: IPnpObjectUpdate}
DEFINE_IID!(IID_IPnpObjectWatcher, 2211011752, 18290, 19066, 172, 168, 228, 140, 66, 168, 156, 68);
RT_INTERFACE!{interface IPnpObjectWatcher(IPnpObjectWatcherVtbl, IPnpObjectWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IPnpObjectWatcher] {
    fn add_Added(&self, handler: <foundation::TypedEventHandler<PnpObjectWatcher, PnpObject> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: <foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: <foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<PnpObjectWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<PnpObjectWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IPnpObjectWatcher {
    #[inline] pub fn add_added(&self, handler: &foundation::TypedEventHandler<PnpObjectWatcher, PnpObject>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Added)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Added)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Updated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Updated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Removed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Removed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObjectWatcher: IPnpObjectWatcher}
} // Windows.Devices.Enumeration.Pnp
} // Windows.Devices.Enumeration
pub mod geolocation { // Windows.Devices.Geolocation
use crate::prelude::*;
RT_ENUM! { enum AltitudeReferenceSystem: i32 {
    Unspecified = 0, Terrain = 1, Ellipsoid = 2, Geoid = 3, Surface = 4,
}}
RT_STRUCT! { struct BasicGeoposition {
    Latitude: f64, Longitude: f64, Altitude: f64,
}}
DEFINE_IID!(IID_ICivicAddress, 2824239642, 25844, 19784, 188, 234, 246, 176, 8, 236, 163, 76);
RT_INTERFACE!{interface ICivicAddress(ICivicAddressVtbl, ICivicAddress_Abi): IInspectable(IInspectableVtbl) [IID_ICivicAddress] {
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ICivicAddress {
    #[inline] pub fn get_country(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Country)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_City)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PostalCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CivicAddress: ICivicAddress}
DEFINE_IID!(IID_IGeoboundingBox, 144099339, 10063, 17370, 154, 6, 203, 252, 218, 235, 78, 194);
RT_INTERFACE!{interface IGeoboundingBox(IGeoboundingBoxVtbl, IGeoboundingBox_Abi): IInspectable(IInspectableVtbl) [IID_IGeoboundingBox] {
    fn get_NorthwestCorner(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_SoutheastCorner(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_Center(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_MinAltitude(&self, out: *mut f64) -> HRESULT,
    fn get_MaxAltitude(&self, out: *mut f64) -> HRESULT
}}
impl IGeoboundingBox {
    #[inline] pub fn get_northwest_corner(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NorthwestCorner)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_southeast_corner(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SoutheastCorner)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_center(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Center)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_altitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinAltitude)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_altitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxAltitude)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GeoboundingBox: IGeoboundingBox}
impl RtActivatable<IGeoboundingBoxFactory> for GeoboundingBox {}
impl RtActivatable<IGeoboundingBoxStatics> for GeoboundingBox {}
impl GeoboundingBox {
    #[inline] pub fn create(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition) -> Result<GeoboundingBox> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create(northwestCorner, southeastCorner)
    }
    #[inline] pub fn create_with_altitude_reference(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<GeoboundingBox> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create_with_altitude_reference(northwestCorner, southeastCorner, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<GeoboundingBox> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create_with_altitude_reference_and_spatial_reference(northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId)
    }
    #[inline] pub fn try_compute(positions: &foundation::collections::IIterable<BasicGeoposition>) -> Result<Option<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute(positions)
    }
    #[inline] pub fn try_compute_with_altitude_reference(positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem) -> Result<Option<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute_with_altitude_reference(positions, altitudeRefSystem)
    }
    #[inline] pub fn try_compute_with_altitude_reference_and_spatial_reference(positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Option<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute_with_altitude_reference_and_spatial_reference(positions, altitudeRefSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(GeoboundingBox(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,98,111,117,110,100,105,110,103,66,111,120,0]) [CLSID_GeoboundingBox]);
DEFINE_IID!(IID_IGeoboundingBoxFactory, 1308337545, 1041, 19132, 179, 181, 91, 188, 203, 87, 217, 140);
RT_INTERFACE!{static interface IGeoboundingBoxFactory(IGeoboundingBoxFactoryVtbl, IGeoboundingBoxFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxFactory] {
    fn Create(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceAndSpatialReference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT
}}
impl IGeoboundingBoxFactory {
    #[inline] pub fn create(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition) -> Result<GeoboundingBox> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, northwestCorner, southeastCorner, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<GeoboundingBox> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReference)(self.0.as_abi() as *const _ as *mut _, northwestCorner, southeastCorner, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<GeoboundingBox> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self.0.as_abi() as *const _ as *mut _, northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoboundingBoxStatics, 1740113672, 58906, 19664, 132, 27, 147, 35, 55, 146, 181, 202);
RT_INTERFACE!{static interface IGeoboundingBoxStatics(IGeoboundingBoxStaticsVtbl, IGeoboundingBoxStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxStatics] {
    fn TryCompute(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT,
    fn TryComputeWithAltitudeReference(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, altitudeRefSystem: AltitudeReferenceSystem, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT,
    fn TryComputeWithAltitudeReferenceAndSpatialReference(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut <GeoboundingBox as RtType>::Abi) -> HRESULT
}}
impl IGeoboundingBoxStatics {
    #[inline] pub fn try_compute(&self, positions: &foundation::collections::IIterable<BasicGeoposition>) -> Result<Option<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryCompute)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_compute_with_altitude_reference(&self, positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem) -> Result<Option<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryComputeWithAltitudeReference)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, altitudeRefSystem, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_compute_with_altitude_reference_and_spatial_reference(&self, positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Option<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryComputeWithAltitudeReferenceAndSpatialReference)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, altitudeRefSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(GeoboundingBox::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocircle, 971266115, 43001, 20067, 146, 167, 186, 12, 40, 209, 36, 177);
RT_INTERFACE!{interface IGeocircle(IGeocircleVtbl, IGeocircle_Abi): IInspectable(IInspectableVtbl) [IID_IGeocircle] {
    fn get_Center(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_Radius(&self, out: *mut f64) -> HRESULT
}}
impl IGeocircle {
    #[inline] pub fn get_center(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Center)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_radius(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Radius)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geocircle: IGeocircle}
impl RtActivatable<IGeocircleFactory> for Geocircle {}
impl Geocircle {
    #[inline] pub fn create(position: BasicGeoposition, radius: f64) -> Result<Geocircle> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create(position, radius)
    }
    #[inline] pub fn create_with_altitude_reference_system(position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geocircle> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create_with_altitude_reference_system(position, radius, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geocircle> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create_with_altitude_reference_system_and_spatial_reference_id(position, radius, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geocircle(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,99,105,114,99,108,101,0]) [CLSID_Geocircle]);
DEFINE_IID!(IID_IGeocircleFactory, 2950058783, 29361, 20349, 135, 204, 78, 212, 201, 132, 156, 5);
RT_INTERFACE!{static interface IGeocircleFactory(IGeocircleFactoryVtbl, IGeocircleFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGeocircleFactory] {
    fn Create(&self, position: BasicGeoposition, radius: f64, out: *mut <Geocircle as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceSystem(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut <Geocircle as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut <Geocircle as RtType>::Abi) -> HRESULT
}}
impl IGeocircleFactory {
    #[inline] pub fn create(&self, position: BasicGeoposition, radius: f64) -> Result<Geocircle> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, position, radius, &mut out);
        if hr == S_OK { Ok(Geocircle::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geocircle> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceSystem)(self.0.as_abi() as *const _ as *mut _, position, radius, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(Geocircle::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geocircle> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self.0.as_abi() as *const _ as *mut _, position, radius, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(Geocircle::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinate, 3995181994, 38762, 19568, 128, 61, 8, 62, 165, 91, 203, 196);
RT_INTERFACE!{interface IGeocoordinate(IGeocoordinateVtbl, IGeocoordinate_Abi): IInspectable(IInspectableVtbl) [IID_IGeocoordinate] {
    fn get_Latitude(&self, out: *mut f64) -> HRESULT,
    fn get_Longitude(&self, out: *mut f64) -> HRESULT,
    fn get_Altitude(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_Accuracy(&self, out: *mut f64) -> HRESULT,
    fn get_AltitudeAccuracy(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_Heading(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_Speed(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IGeocoordinate {
    #[inline] pub fn get_latitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Latitude)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_longitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Longitude)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Altitude)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_accuracy(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Accuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_accuracy(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AltitudeAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_heading(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Heading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_speed(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Speed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geocoordinate: IGeocoordinate}
DEFINE_IID!(IID_IGeocoordinateSatelliteData, 3274339545, 9736, 18252, 145, 44, 6, 221, 73, 15, 74, 247);
RT_INTERFACE!{interface IGeocoordinateSatelliteData(IGeocoordinateSatelliteDataVtbl, IGeocoordinateSatelliteData_Abi): IInspectable(IInspectableVtbl) [IID_IGeocoordinateSatelliteData] {
    fn get_PositionDilutionOfPrecision(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_HorizontalDilutionOfPrecision(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT,
    fn get_VerticalDilutionOfPrecision(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT
}}
impl IGeocoordinateSatelliteData {
    #[inline] pub fn get_position_dilution_of_precision(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionDilutionOfPrecision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_dilution_of_precision(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HorizontalDilutionOfPrecision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_dilution_of_precision(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VerticalDilutionOfPrecision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeocoordinateSatelliteData: IGeocoordinateSatelliteData}
DEFINE_IID!(IID_IGeocoordinateWithPoint, 4276749605, 53804, 19782, 181, 39, 11, 150, 6, 111, 199, 219);
RT_INTERFACE!{interface IGeocoordinateWithPoint(IGeocoordinateWithPointVtbl, IGeocoordinateWithPoint_Abi): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPoint] {
    fn get_Point(&self, out: *mut <Geopoint as RtType>::Abi) -> HRESULT
}}
impl IGeocoordinateWithPoint {
    #[inline] pub fn get_point(&self) -> Result<Option<Geopoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Point)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geopoint::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinateWithPositionData, 2514891966, 56278, 16556, 184, 242, 166, 92, 3, 64, 217, 166);
RT_INTERFACE!{interface IGeocoordinateWithPositionData(IGeocoordinateWithPositionDataVtbl, IGeocoordinateWithPositionData_Abi): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionData] {
    fn get_PositionSource(&self, out: *mut PositionSource) -> HRESULT,
    fn get_SatelliteData(&self, out: *mut <GeocoordinateSatelliteData as RtType>::Abi) -> HRESULT
}}
impl IGeocoordinateWithPositionData {
    #[inline] pub fn get_position_source(&self) -> Result<PositionSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satellite_data(&self) -> Result<Option<GeocoordinateSatelliteData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SatelliteData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GeocoordinateSatelliteData::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinateWithPositionSourceTimestamp, 2235825154, 51697, 17936, 175, 224, 139, 195, 166, 168, 112, 54);
RT_INTERFACE!{interface IGeocoordinateWithPositionSourceTimestamp(IGeocoordinateWithPositionSourceTimestampVtbl, IGeocoordinateWithPositionSourceTimestamp_Abi): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionSourceTimestamp] {
    fn get_PositionSourceTimestamp(&self, out: *mut <foundation::IReference<foundation::DateTime> as RtType>::Abi) -> HRESULT
}}
impl IGeocoordinateWithPositionSourceTimestamp {
    #[inline] pub fn get_position_source_timestamp(&self) -> Result<Option<foundation::IReference<foundation::DateTime>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PositionSourceTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeolocationAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, Denied = 2,
}}
DEFINE_IID!(IID_IGeolocator, 2848178018, 17700, 18825, 138, 169, 222, 1, 157, 46, 85, 31);
RT_INTERFACE!{interface IGeolocator(IGeolocatorVtbl, IGeolocator_Abi): IInspectable(IInspectableVtbl) [IID_IGeolocator] {
    fn get_DesiredAccuracy(&self, out: *mut PositionAccuracy) -> HRESULT,
    fn put_DesiredAccuracy(&self, value: PositionAccuracy) -> HRESULT,
    fn get_MovementThreshold(&self, out: *mut f64) -> HRESULT,
    fn put_MovementThreshold(&self, value: f64) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_LocationStatus(&self, out: *mut PositionStatus) -> HRESULT,
    fn GetGeopositionAsync(&self, out: *mut <foundation::IAsyncOperation<Geoposition> as RtType>::Abi) -> HRESULT,
    fn GetGeopositionAsyncWithAgeAndTimeout(&self, maximumAge: foundation::TimeSpan, timeout: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<Geoposition> as RtType>::Abi) -> HRESULT,
    fn add_PositionChanged(&self, handler: <foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PositionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StatusChanged(&self, handler: <foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGeolocator {
    #[inline] pub fn get_desired_accuracy(&self) -> Result<PositionAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_accuracy(&self, value: PositionAccuracy) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredAccuracy)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_movement_threshold(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MovementThreshold)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_movement_threshold(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MovementThreshold)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_location_status(&self) -> Result<PositionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LocationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_async(&self) -> Result<foundation::IAsyncOperation<Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGeopositionAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_async_with_age_and_timeout(&self, maximumAge: foundation::TimeSpan, timeout: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGeopositionAsyncWithAgeAndTimeout)(self.0.as_abi() as *const _ as *mut _, maximumAge, timeout, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_position_changed(&self, handler: &foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PositionChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_position_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PositionChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Geolocator: IGeolocator}
impl RtActivatable<IGeolocatorStatics> for Geolocator {}
impl RtActivatable<IGeolocatorStatics2> for Geolocator {}
impl RtActivatable<IActivationFactory> for Geolocator {}
impl Geolocator {
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<GeolocationAccessStatus>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn get_geoposition_history_async(startTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().get_geoposition_history_async(startTime)
    }
    #[inline] pub fn get_geoposition_history_with_duration_async(startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().get_geoposition_history_with_duration_async(startTime, duration)
    }
    #[inline] pub fn get_is_default_geoposition_recommended() -> Result<bool> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().get_is_default_geoposition_recommended()
    }
    #[inline] pub fn set_default_geoposition(value: &foundation::IReference<BasicGeoposition>) -> Result<()> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().set_default_geoposition(value)
    }
    #[inline] pub fn get_default_geoposition() -> Result<Option<foundation::IReference<BasicGeoposition>>> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().get_default_geoposition()
    }
}
DEFINE_CLSID!(Geolocator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,108,111,99,97,116,111,114,0]) [CLSID_Geolocator]);
DEFINE_IID!(IID_IGeolocator2, 3518246509, 34961, 17332, 173, 54, 39, 198, 254, 154, 151, 177);
RT_INTERFACE!{interface IGeolocator2(IGeolocator2Vtbl, IGeolocator2_Abi): IInspectable(IInspectableVtbl) [IID_IGeolocator2] {
    fn AllowFallbackToConsentlessPositions(&self) -> HRESULT
}}
impl IGeolocator2 {
    #[inline] pub fn allow_fallback_to_consentless_positions(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AllowFallbackToConsentlessPositions)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorStatics, 2593027441, 11765, 17809, 159, 135, 235, 95, 216, 148, 233, 183);
RT_INTERFACE!{static interface IGeolocatorStatics(IGeolocatorStaticsVtbl, IGeolocatorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics] {
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<GeolocationAccessStatus> as RtType>::Abi) -> HRESULT,
    fn GetGeopositionHistoryAsync(&self, startTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>> as RtType>::Abi) -> HRESULT,
    fn GetGeopositionHistoryWithDurationAsync(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>> as RtType>::Abi) -> HRESULT
}}
impl IGeolocatorStatics {
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<GeolocationAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_history_async(&self, startTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGeopositionHistoryAsync)(self.0.as_abi() as *const _ as *mut _, startTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_history_with_duration_async(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetGeopositionHistoryWithDurationAsync)(self.0.as_abi() as *const _ as *mut _, startTime, duration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorStatics2, 2570064290, 64028, 17969, 167, 29, 13, 190, 177, 37, 13, 156);
RT_INTERFACE!{static interface IGeolocatorStatics2(IGeolocatorStatics2Vtbl, IGeolocatorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics2] {
    fn get_IsDefaultGeopositionRecommended(&self, out: *mut bool) -> HRESULT,
    fn put_DefaultGeoposition(&self, value: <foundation::IReference<BasicGeoposition> as RtType>::Abi) -> HRESULT,
    fn get_DefaultGeoposition(&self, out: *mut <foundation::IReference<BasicGeoposition> as RtType>::Abi) -> HRESULT
}}
impl IGeolocatorStatics2 {
    #[inline] pub fn get_is_default_geoposition_recommended(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDefaultGeopositionRecommended)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_geoposition(&self, value: &foundation::IReference<BasicGeoposition>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DefaultGeoposition)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_geoposition(&self) -> Result<Option<foundation::IReference<BasicGeoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultGeoposition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorWithScalarAccuracy, 2532692929, 47119, 17930, 153, 77, 169, 108, 71, 165, 26, 164);
RT_INTERFACE!{interface IGeolocatorWithScalarAccuracy(IGeolocatorWithScalarAccuracyVtbl, IGeolocatorWithScalarAccuracy_Abi): IInspectable(IInspectableVtbl) [IID_IGeolocatorWithScalarAccuracy] {
    fn get_DesiredAccuracyInMeters(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_DesiredAccuracyInMeters(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IGeolocatorWithScalarAccuracy {
    #[inline] pub fn get_desired_accuracy_in_meters(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredAccuracyInMeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_accuracy_in_meters(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredAccuracyInMeters)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeopath, 3846166457, 11684, 18196, 166, 82, 222, 133, 147, 40, 152, 152);
RT_INTERFACE!{interface IGeopath(IGeopathVtbl, IGeopath_Abi): IInspectable(IInspectableVtbl) [IID_IGeopath] {
    fn get_Positions(&self, out: *mut <foundation::collections::IVectorView<BasicGeoposition> as RtType>::Abi) -> HRESULT
}}
impl IGeopath {
    #[inline] pub fn get_positions(&self) -> Result<Option<foundation::collections::IVectorView<BasicGeoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Positions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Geopath: IGeopath}
impl RtActivatable<IGeopathFactory> for Geopath {}
impl Geopath {
    #[inline] pub fn create(positions: &foundation::collections::IIterable<BasicGeoposition>) -> Result<Geopath> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create(positions)
    }
    #[inline] pub fn create_with_altitude_reference(positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geopath> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create_with_altitude_reference(positions, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geopath> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create_with_altitude_reference_and_spatial_reference(positions, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geopath(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,97,116,104,0]) [CLSID_Geopath]);
DEFINE_IID!(IID_IGeopathFactory, 666806728, 51175, 17241, 155, 155, 252, 163, 224, 94, 245, 147);
RT_INTERFACE!{static interface IGeopathFactory(IGeopathFactoryVtbl, IGeopathFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGeopathFactory] {
    fn Create(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, out: *mut <Geopath as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReference(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut <Geopath as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceAndSpatialReference(&self, positions: <foundation::collections::IIterable<BasicGeoposition> as RtType>::Abi, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut <Geopath as RtType>::Abi) -> HRESULT
}}
impl IGeopathFactory {
    #[inline] pub fn create(&self, positions: &foundation::collections::IIterable<BasicGeoposition>) -> Result<Geopath> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geopath::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference(&self, positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geopath> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReference)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(Geopath::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(&self, positions: &foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geopath> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self.0.as_abi() as *const _ as *mut _, get_abi(positions) as *const _ as *mut _, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(Geopath::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeopoint, 1811546347, 58734, 18875, 156, 175, 203, 170, 120, 168, 188, 239);
RT_INTERFACE!{interface IGeopoint(IGeopointVtbl, IGeopoint_Abi): IInspectable(IInspectableVtbl) [IID_IGeopoint] {
    fn get_Position(&self, out: *mut BasicGeoposition) -> HRESULT
}}
impl IGeopoint {
    #[inline] pub fn get_position(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geopoint: IGeopoint}
impl RtActivatable<IGeopointFactory> for Geopoint {}
impl Geopoint {
    #[inline] pub fn create(position: BasicGeoposition) -> Result<Geopoint> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create(position)
    }
    #[inline] pub fn create_with_altitude_reference_system(position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geopoint> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create_with_altitude_reference_system(position, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geopoint> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create_with_altitude_reference_system_and_spatial_reference_id(position, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geopoint(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,111,105,110,116,0]) [CLSID_Geopoint]);
DEFINE_IID!(IID_IGeopointFactory, 3681258803, 30397, 20016, 138, 247, 168, 68, 220, 55, 183, 160);
RT_INTERFACE!{static interface IGeopointFactory(IGeopointFactoryVtbl, IGeopointFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGeopointFactory] {
    fn Create(&self, position: BasicGeoposition, out: *mut <Geopoint as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceSystem(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut <Geopoint as RtType>::Abi) -> HRESULT,
    fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut <Geopoint as RtType>::Abi) -> HRESULT
}}
impl IGeopointFactory {
    #[inline] pub fn create(&self, position: BasicGeoposition) -> Result<Geopoint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, position, &mut out);
        if hr == S_OK { Ok(Geopoint::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<Geopoint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceSystem)(self.0.as_abi() as *const _ as *mut _, position, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(Geopoint::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Geopoint> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self.0.as_abi() as *const _ as *mut _, position, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(Geopoint::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoposition, 3247244372, 32065, 20471, 169, 87, 157, 255, 180, 239, 127, 91);
RT_INTERFACE!{interface IGeoposition(IGeopositionVtbl, IGeoposition_Abi): IInspectable(IInspectableVtbl) [IID_IGeoposition] {
    fn get_Coordinate(&self, out: *mut <Geocoordinate as RtType>::Abi) -> HRESULT,
    fn get_CivicAddress(&self, out: *mut <CivicAddress as RtType>::Abi) -> HRESULT
}}
impl IGeoposition {
    #[inline] pub fn get_coordinate(&self) -> Result<Option<Geocoordinate>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Coordinate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geocoordinate::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_civic_address(&self) -> Result<Option<CivicAddress>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CivicAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CivicAddress::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Geoposition: IGeoposition}
DEFINE_IID!(IID_IGeoposition2, 2137192087, 34417, 19213, 134, 248, 71, 74, 132, 150, 24, 124);
RT_INTERFACE!{interface IGeoposition2(IGeoposition2Vtbl, IGeoposition2_Abi): IInspectable(IInspectableVtbl) [IID_IGeoposition2] {
    fn get_VenueData(&self, out: *mut <VenueData as RtType>::Abi) -> HRESULT
}}
impl IGeoposition2 {
    #[inline] pub fn get_venue_data(&self) -> Result<Option<VenueData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VenueData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(VenueData::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoshape, 3382485679, 50985, 17345, 143, 171, 214, 222, 201, 20, 223, 126);
RT_INTERFACE!{interface IGeoshape(IGeoshapeVtbl, IGeoshape_Abi): IInspectable(IInspectableVtbl) [IID_IGeoshape] {
    fn get_GeoshapeType(&self, out: *mut GeoshapeType) -> HRESULT,
    fn get_SpatialReferenceId(&self, out: *mut u32) -> HRESULT,
    fn get_AltitudeReferenceSystem(&self, out: *mut AltitudeReferenceSystem) -> HRESULT
}}
impl IGeoshape {
    #[inline] pub fn get_geoshape_type(&self) -> Result<GeoshapeType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GeoshapeType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_spatial_reference_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpatialReferenceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_reference_system(&self) -> Result<AltitudeReferenceSystem> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AltitudeReferenceSystem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeoshapeType: i32 {
    Geopoint = 0, Geocircle = 1, Geopath = 2, GeoboundingBox = 3,
}}
DEFINE_IID!(IID_IGeovisit, 2978445942, 40694, 16811, 160, 221, 121, 62, 206, 118, 226, 222);
RT_INTERFACE!{interface IGeovisit(IGeovisitVtbl, IGeovisit_Abi): IInspectable(IInspectableVtbl) [IID_IGeovisit] {
    fn get_Position(&self, out: *mut <Geoposition as RtType>::Abi) -> HRESULT,
    fn get_StateChange(&self, out: *mut VisitStateChange) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IGeovisit {
    #[inline] pub fn get_position(&self) -> Result<Option<Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geoposition::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state_change(&self) -> Result<VisitStateChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StateChange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geovisit: IGeovisit}
DEFINE_IID!(IID_IGeovisitMonitor, 2148633263, 22852, 17809, 131, 193, 57, 102, 71, 245, 79, 44);
RT_INTERFACE!{interface IGeovisitMonitor(IGeovisitMonitorVtbl, IGeovisitMonitor_Abi): IInspectable(IInspectableVtbl) [IID_IGeovisitMonitor] {
    fn get_MonitoringScope(&self, out: *mut VisitMonitoringScope) -> HRESULT,
    fn Start(&self, value: VisitMonitoringScope) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_VisitStateChanged(&self, handler: <foundation::TypedEventHandler<GeovisitMonitor, GeovisitStateChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisitStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGeovisitMonitor {
    #[inline] pub fn get_monitoring_scope(&self) -> Result<VisitMonitoringScope> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MonitoringScope)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self, value: VisitMonitoringScope) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_visit_state_changed(&self, handler: &foundation::TypedEventHandler<GeovisitMonitor, GeovisitStateChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VisitStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visit_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VisitStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitMonitor: IGeovisitMonitor}
impl RtActivatable<IGeovisitMonitorStatics> for GeovisitMonitor {}
impl RtActivatable<IActivationFactory> for GeovisitMonitor {}
impl GeovisitMonitor {
    #[inline] pub fn get_last_report_async() -> Result<foundation::IAsyncOperation<Geovisit>> {
        <Self as RtActivatable<IGeovisitMonitorStatics>>::get_activation_factory().get_last_report_async()
    }
}
DEFINE_CLSID!(GeovisitMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,118,105,115,105,116,77,111,110,105,116,111,114,0]) [CLSID_GeovisitMonitor]);
DEFINE_IID!(IID_IGeovisitMonitorStatics, 3170465447, 48114, 19677, 149, 207, 85, 76, 130, 237, 251, 135);
RT_INTERFACE!{static interface IGeovisitMonitorStatics(IGeovisitMonitorStaticsVtbl, IGeovisitMonitorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGeovisitMonitorStatics] {
    fn GetLastReportAsync(&self, out: *mut <foundation::IAsyncOperation<Geovisit> as RtType>::Abi) -> HRESULT
}}
impl IGeovisitMonitorStatics {
    #[inline] pub fn get_last_report_async(&self) -> Result<foundation::IAsyncOperation<Geovisit>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetLastReportAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeovisitStateChangedEventArgs, 3467956735, 35667, 18792, 190, 237, 76, 236, 208, 41, 206, 21);
RT_INTERFACE!{interface IGeovisitStateChangedEventArgs(IGeovisitStateChangedEventArgsVtbl, IGeovisitStateChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGeovisitStateChangedEventArgs] {
    fn get_Visit(&self, out: *mut <Geovisit as RtType>::Abi) -> HRESULT
}}
impl IGeovisitStateChangedEventArgs {
    #[inline] pub fn get_visit(&self) -> Result<Option<Geovisit>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Visit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geovisit::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitStateChangedEventArgs: IGeovisitStateChangedEventArgs}
DEFINE_IID!(IID_IGeovisitTriggerDetails, 3933670814, 53705, 17739, 153, 183, 178, 248, 205, 210, 72, 47);
RT_INTERFACE!{interface IGeovisitTriggerDetails(IGeovisitTriggerDetailsVtbl, IGeovisitTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IGeovisitTriggerDetails] {
    fn ReadReports(&self, out: *mut <foundation::collections::IVectorView<Geovisit> as RtType>::Abi) -> HRESULT
}}
impl IGeovisitTriggerDetails {
    #[inline] pub fn read_reports(&self) -> Result<Option<foundation::collections::IVectorView<Geovisit>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadReports)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitTriggerDetails: IGeovisitTriggerDetails}
RT_ENUM! { enum PositionAccuracy: i32 {
    Default = 0, High = 1,
}}
DEFINE_IID!(IID_IPositionChangedEventArgs, 931503333, 40222, 18117, 191, 59, 106, 216, 202, 193, 160, 147);
RT_INTERFACE!{interface IPositionChangedEventArgs(IPositionChangedEventArgsVtbl, IPositionChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPositionChangedEventArgs] {
    fn get_Position(&self, out: *mut <Geoposition as RtType>::Abi) -> HRESULT
}}
impl IPositionChangedEventArgs {
    #[inline] pub fn get_position(&self) -> Result<Option<Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geoposition::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PositionChangedEventArgs: IPositionChangedEventArgs}
RT_ENUM! { enum PositionSource: i32 {
    Cellular = 0, Satellite = 1, WiFi = 2, IPAddress = 3, Unknown = 4, Default = 5, Obfuscated = 6,
}}
RT_ENUM! { enum PositionStatus: i32 {
    Ready = 0, Initializing = 1, NoData = 2, Disabled = 3, NotInitialized = 4, NotAvailable = 5,
}}
DEFINE_IID!(IID_IStatusChangedEventArgs, 877908698, 35987, 16657, 162, 5, 154, 236, 252, 155, 229, 192);
RT_INTERFACE!{interface IStatusChangedEventArgs(IStatusChangedEventArgsVtbl, IStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut PositionStatus) -> HRESULT
}}
impl IStatusChangedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<PositionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class StatusChangedEventArgs: IStatusChangedEventArgs}
DEFINE_IID!(IID_IVenueData, 1727238535, 24803, 19247, 181, 39, 79, 83, 241, 195, 198, 119);
RT_INTERFACE!{interface IVenueData(IVenueDataVtbl, IVenueData_Abi): IInspectable(IInspectableVtbl) [IID_IVenueData] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Level(&self, out: *mut HSTRING) -> HRESULT
}}
impl IVenueData {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_level(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Level)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VenueData: IVenueData}
RT_ENUM! { enum VisitMonitoringScope: i32 {
    Venue = 0, City = 1,
}}
RT_ENUM! { enum VisitStateChange: i32 {
    TrackingLost = 0, Arrived = 1, Departed = 2, OtherMovement = 3,
}}
pub mod geofencing { // Windows.Devices.Geolocation.Geofencing
use crate::prelude::*;
DEFINE_IID!(IID_IGeofence, 2617837603, 60856, 18400, 130, 69, 91, 246, 29, 50, 31, 45);
RT_INTERFACE!{interface IGeofence(IGeofenceVtbl, IGeofence_Abi): IInspectable(IInspectableVtbl) [IID_IGeofence] {
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_DwellTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MonitoredStates(&self, out: *mut MonitoredGeofenceStates) -> HRESULT,
    fn get_Geoshape(&self, out: *mut <super::IGeoshape as RtType>::Abi) -> HRESULT,
    fn get_SingleUse(&self, out: *mut bool) -> HRESULT
}}
impl IGeofence {
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dwell_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DwellTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_monitored_states(&self) -> Result<MonitoredGeofenceStates> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MonitoredStates)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geoshape(&self) -> Result<Option<super::IGeoshape>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Geoshape)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::IGeoshape::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_single_use(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SingleUse)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geofence: IGeofence}
impl RtActivatable<IGeofenceFactory> for Geofence {}
impl Geofence {
    #[inline] pub fn create(id: &HStringArg, geoshape: &super::IGeoshape) -> Result<Geofence> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create(id, geoshape)
    }
    #[inline] pub fn create_with_monitor_states(id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool) -> Result<Geofence> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states(id, geoshape, monitoredStates, singleUse)
    }
    #[inline] pub fn create_with_monitor_states_and_dwell_time(id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan) -> Result<Geofence> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states_and_dwell_time(id, geoshape, monitoredStates, singleUse, dwellTime)
    }
    #[inline] pub fn create_with_monitor_states_dwell_time_start_time_and_duration(id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<Geofence> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states_dwell_time_start_time_and_duration(id, geoshape, monitoredStates, singleUse, dwellTime, startTime, duration)
    }
}
DEFINE_CLSID!(Geofence(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,0]) [CLSID_Geofence]);
DEFINE_IID!(IID_IGeofenceFactory, 2216649291, 12895, 19344, 188, 167, 43, 128, 34, 169, 55, 150);
RT_INTERFACE!{static interface IGeofenceFactory(IGeofenceFactoryVtbl, IGeofenceFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGeofenceFactory] {
    fn Create(&self, id: HSTRING, geoshape: <super::IGeoshape as RtType>::Abi, out: *mut <Geofence as RtType>::Abi) -> HRESULT,
    fn CreateWithMonitorStates(&self, id: HSTRING, geoshape: <super::IGeoshape as RtType>::Abi, monitoredStates: MonitoredGeofenceStates, singleUse: bool, out: *mut <Geofence as RtType>::Abi) -> HRESULT,
    fn CreateWithMonitorStatesAndDwellTime(&self, id: HSTRING, geoshape: <super::IGeoshape as RtType>::Abi, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, out: *mut <Geofence as RtType>::Abi) -> HRESULT,
    fn CreateWithMonitorStatesDwellTimeStartTimeAndDuration(&self, id: HSTRING, geoshape: <super::IGeoshape as RtType>::Abi, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <Geofence as RtType>::Abi) -> HRESULT
}}
impl IGeofenceFactory {
    #[inline] pub fn create(&self, id: &HStringArg, geoshape: &super::IGeoshape) -> Result<Geofence> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, id.get(), get_abi(geoshape) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geofence::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states(&self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool) -> Result<Geofence> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithMonitorStates)(self.0.as_abi() as *const _ as *mut _, id.get(), get_abi(geoshape) as *const _ as *mut _, monitoredStates, singleUse, &mut out);
        if hr == S_OK { Ok(Geofence::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states_and_dwell_time(&self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan) -> Result<Geofence> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithMonitorStatesAndDwellTime)(self.0.as_abi() as *const _ as *mut _, id.get(), get_abi(geoshape) as *const _ as *mut _, monitoredStates, singleUse, dwellTime, &mut out);
        if hr == S_OK { Ok(Geofence::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states_dwell_time_start_time_and_duration(&self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<Geofence> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithMonitorStatesDwellTimeStartTimeAndDuration)(self.0.as_abi() as *const _ as *mut _, id.get(), get_abi(geoshape) as *const _ as *mut _, monitoredStates, singleUse, dwellTime, startTime, duration, &mut out);
        if hr == S_OK { Ok(Geofence::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeofenceMonitor, 1276075896, 7199, 17953, 187, 189, 131, 59, 146, 36, 114, 38);
RT_INTERFACE!{interface IGeofenceMonitor(IGeofenceMonitorVtbl, IGeofenceMonitor_Abi): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitor] {
    fn get_Status(&self, out: *mut GeofenceMonitorStatus) -> HRESULT,
    fn get_Geofences(&self, out: *mut <foundation::collections::IVector<Geofence> as RtType>::Abi) -> HRESULT,
    fn get_LastKnownGeoposition(&self, out: *mut <super::Geoposition as RtType>::Abi) -> HRESULT,
    fn add_GeofenceStateChanged(&self, eventHandler: <foundation::TypedEventHandler<GeofenceMonitor, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GeofenceStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn ReadReports(&self, out: *mut <foundation::collections::IVectorView<GeofenceStateChangeReport> as RtType>::Abi) -> HRESULT,
    fn add_StatusChanged(&self, eventHandler: <foundation::TypedEventHandler<GeofenceMonitor, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGeofenceMonitor {
    #[inline] pub fn get_status(&self) -> Result<GeofenceMonitorStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geofences(&self) -> Result<Option<foundation::collections::IVector<Geofence>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Geofences)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_last_known_geoposition(&self) -> Result<Option<super::Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LastKnownGeoposition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Geoposition::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_geofence_state_changed(&self, eventHandler: &foundation::TypedEventHandler<GeofenceMonitor, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GeofenceStateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_geofence_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GeofenceStateChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_reports(&self) -> Result<Option<foundation::collections::IVectorView<GeofenceStateChangeReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadReports)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, eventHandler: &foundation::TypedEventHandler<GeofenceMonitor, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GeofenceMonitor: IGeofenceMonitor}
impl RtActivatable<IGeofenceMonitorStatics> for GeofenceMonitor {}
impl GeofenceMonitor {
    #[inline] pub fn get_current() -> Result<Option<GeofenceMonitor>> {
        <Self as RtActivatable<IGeofenceMonitorStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(GeofenceMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,77,111,110,105,116,111,114,0]) [CLSID_GeofenceMonitor]);
DEFINE_IID!(IID_IGeofenceMonitorStatics, 768815055, 32373, 18585, 172, 227, 43, 208, 166, 92, 206, 6);
RT_INTERFACE!{static interface IGeofenceMonitorStatics(IGeofenceMonitorStaticsVtbl, IGeofenceMonitorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitorStatics] {
    fn get_Current(&self, out: *mut <GeofenceMonitor as RtType>::Abi) -> HRESULT
}}
impl IGeofenceMonitorStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<GeofenceMonitor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Current)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GeofenceMonitor::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeofenceMonitorStatus: i32 {
    Ready = 0, Initializing = 1, NoData = 2, Disabled = 3, NotInitialized = 4, NotAvailable = 5,
}}
RT_ENUM! { enum GeofenceRemovalReason: i32 {
    Used = 0, Expired = 1,
}}
RT_ENUM! { enum GeofenceState: u32 {
    None = 0, Entered = 1, Exited = 2, Removed = 4,
}}
DEFINE_IID!(IID_IGeofenceStateChangeReport, 2586065944, 9316, 19593, 190, 5, 179, 255, 255, 91, 171, 197);
RT_INTERFACE!{interface IGeofenceStateChangeReport(IGeofenceStateChangeReportVtbl, IGeofenceStateChangeReport_Abi): IInspectable(IInspectableVtbl) [IID_IGeofenceStateChangeReport] {
    fn get_NewState(&self, out: *mut GeofenceState) -> HRESULT,
    fn get_Geofence(&self, out: *mut <Geofence as RtType>::Abi) -> HRESULT,
    fn get_Geoposition(&self, out: *mut <super::Geoposition as RtType>::Abi) -> HRESULT,
    fn get_RemovalReason(&self, out: *mut GeofenceRemovalReason) -> HRESULT
}}
impl IGeofenceStateChangeReport {
    #[inline] pub fn get_new_state(&self) -> Result<GeofenceState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geofence(&self) -> Result<Option<Geofence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Geofence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Geofence::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition(&self) -> Result<Option<super::Geoposition>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Geoposition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::Geoposition::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_removal_reason(&self) -> Result<GeofenceRemovalReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemovalReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GeofenceStateChangeReport: IGeofenceStateChangeReport}
RT_ENUM! { enum MonitoredGeofenceStates: u32 {
    None = 0, Entered = 1, Exited = 2, Removed = 4,
}}
} // Windows.Devices.Geolocation.Geofencing
} // Windows.Devices.Geolocation
pub mod gpio { // Windows.Devices.Gpio
use crate::prelude::*;
RT_STRUCT! { struct GpioChangeCount {
    Count: u64, RelativeTime: foundation::TimeSpan,
}}
DEFINE_IID!(IID_IGpioChangeCounter, 3411984606, 26625, 17407, 128, 61, 69, 118, 98, 138, 139, 38);
RT_INTERFACE!{interface IGpioChangeCounter(IGpioChangeCounterVtbl, IGpioChangeCounter_Abi): IInspectable(IInspectableVtbl) [IID_IGpioChangeCounter] {
    fn put_Polarity(&self, value: GpioChangePolarity) -> HRESULT,
    fn get_Polarity(&self, out: *mut GpioChangePolarity) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Read(&self, out: *mut GpioChangeCount) -> HRESULT,
    fn Reset(&self, out: *mut GpioChangeCount) -> HRESULT
}}
impl IGpioChangeCounter {
    #[inline] pub fn set_polarity(&self, value: GpioChangePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Polarity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<GpioChangePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Polarity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStarted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<GpioChangeCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<GpioChangeCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).Reset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioChangeCounter: IGpioChangeCounter}
impl RtActivatable<IGpioChangeCounterFactory> for GpioChangeCounter {}
impl GpioChangeCounter {
    #[inline] pub fn create(pin: &GpioPin) -> Result<GpioChangeCounter> {
        <Self as RtActivatable<IGpioChangeCounterFactory>>::get_activation_factory().create(pin)
    }
}
DEFINE_CLSID!(GpioChangeCounter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,104,97,110,103,101,67,111,117,110,116,101,114,0]) [CLSID_GpioChangeCounter]);
DEFINE_IID!(IID_IGpioChangeCounterFactory, 343774390, 2718, 16652, 180, 250, 248, 159, 64, 82, 8, 77);
RT_INTERFACE!{static interface IGpioChangeCounterFactory(IGpioChangeCounterFactoryVtbl, IGpioChangeCounterFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGpioChangeCounterFactory] {
    fn Create(&self, pin: <GpioPin as RtType>::Abi, out: *mut <GpioChangeCounter as RtType>::Abi) -> HRESULT
}}
impl IGpioChangeCounterFactory {
    #[inline] pub fn create(&self, pin: &GpioPin) -> Result<GpioChangeCounter> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(pin) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GpioChangeCounter::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GpioChangePolarity: i32 {
    Falling = 0, Rising = 1, Both = 2,
}}
DEFINE_IID!(IID_IGpioChangeReader, 180127839, 57393, 18664, 133, 144, 112, 222, 120, 54, 60, 109);
RT_INTERFACE!{interface IGpioChangeReader(IGpioChangeReaderVtbl, IGpioChangeReader_Abi): IInspectable(IInspectableVtbl) [IID_IGpioChangeReader] {
    fn get_Capacity(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT,
    fn get_IsEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsOverflowed(&self, out: *mut bool) -> HRESULT,
    fn put_Polarity(&self, value: GpioChangePolarity) -> HRESULT,
    fn get_Polarity(&self, out: *mut GpioChangePolarity) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn GetNextItem(&self, out: *mut GpioChangeRecord) -> HRESULT,
    fn PeekNextItem(&self, out: *mut GpioChangeRecord) -> HRESULT,
    fn GetAllItems(&self, out: *mut <foundation::collections::IVector<GpioChangeRecord> as RtType>::Abi) -> HRESULT,
    fn WaitForItemsAsync(&self, count: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IGpioChangeReader {
    #[inline] pub fn get_capacity(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capacity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEmpty)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_overflowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsOverflowed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_polarity(&self, value: GpioChangePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Polarity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<GpioChangePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Polarity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStarted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Clear)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_next_item(&self) -> Result<GpioChangeRecord> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetNextItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn peek_next_item(&self) -> Result<GpioChangeRecord> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).PeekNextItem)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_all_items(&self) -> Result<Option<foundation::collections::IVector<GpioChangeRecord>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllItems)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn wait_for_items_async(&self, count: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).WaitForItemsAsync)(self.0.as_abi() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioChangeReader: IGpioChangeReader}
impl RtActivatable<IGpioChangeReaderFactory> for GpioChangeReader {}
impl GpioChangeReader {
    #[inline] pub fn create(pin: &GpioPin) -> Result<GpioChangeReader> {
        <Self as RtActivatable<IGpioChangeReaderFactory>>::get_activation_factory().create(pin)
    }
    #[inline] pub fn create_with_capacity(pin: &GpioPin, minCapacity: i32) -> Result<GpioChangeReader> {
        <Self as RtActivatable<IGpioChangeReaderFactory>>::get_activation_factory().create_with_capacity(pin, minCapacity)
    }
}
DEFINE_CLSID!(GpioChangeReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,104,97,110,103,101,82,101,97,100,101,114,0]) [CLSID_GpioChangeReader]);
DEFINE_IID!(IID_IGpioChangeReaderFactory, 2841218803, 14606, 17434, 157, 28, 232, 222, 11, 45, 240, 223);
RT_INTERFACE!{static interface IGpioChangeReaderFactory(IGpioChangeReaderFactoryVtbl, IGpioChangeReaderFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGpioChangeReaderFactory] {
    fn Create(&self, pin: <GpioPin as RtType>::Abi, out: *mut <GpioChangeReader as RtType>::Abi) -> HRESULT,
    fn CreateWithCapacity(&self, pin: <GpioPin as RtType>::Abi, minCapacity: i32, out: *mut <GpioChangeReader as RtType>::Abi) -> HRESULT
}}
impl IGpioChangeReaderFactory {
    #[inline] pub fn create(&self, pin: &GpioPin) -> Result<GpioChangeReader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(pin) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GpioChangeReader::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_capacity(&self, pin: &GpioPin, minCapacity: i32) -> Result<GpioChangeReader> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithCapacity)(self.0.as_abi() as *const _ as *mut _, get_abi(pin) as *const _ as *mut _, minCapacity, &mut out);
        if hr == S_OK { Ok(GpioChangeReader::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_STRUCT! { struct GpioChangeRecord {
    RelativeTime: foundation::TimeSpan, Edge: GpioPinEdge,
}}
DEFINE_IID!(IID_IGpioController, 675287779, 29793, 18076, 168, 188, 97, 214, 157, 8, 165, 60);
RT_INTERFACE!{interface IGpioController(IGpioControllerVtbl, IGpioController_Abi): IInspectable(IInspectableVtbl) [IID_IGpioController] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn OpenPin(&self, pinNumber: i32, out: *mut <GpioPin as RtType>::Abi) -> HRESULT,
    fn OpenPinWithSharingMode(&self, pinNumber: i32, sharingMode: GpioSharingMode, out: *mut <GpioPin as RtType>::Abi) -> HRESULT,
    fn TryOpenPin(&self, pinNumber: i32, sharingMode: GpioSharingMode, pin: *mut <GpioPin as RtType>::Abi, openStatus: *mut GpioOpenStatus, out: *mut bool) -> HRESULT
}}
impl IGpioController {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin(&self, pinNumber: i32) -> Result<Option<GpioPin>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenPin)(self.0.as_abi() as *const _ as *mut _, pinNumber, &mut out);
        if hr == S_OK { Ok(GpioPin::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_pin_with_sharing_mode(&self, pinNumber: i32, sharingMode: GpioSharingMode) -> Result<Option<GpioPin>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenPinWithSharingMode)(self.0.as_abi() as *const _ as *mut _, pinNumber, sharingMode, &mut out);
        if hr == S_OK { Ok(GpioPin::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_open_pin(&self, pinNumber: i32, sharingMode: GpioSharingMode) -> Result<(Option<GpioPin>, GpioOpenStatus, bool)> { unsafe { 
        let mut pin = null_mut(); let mut openStatus = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryOpenPin)(self.0.as_abi() as *const _ as *mut _, pinNumber, sharingMode, &mut pin, &mut openStatus, &mut out);
        if hr == S_OK { Ok((GpioPin::wrap(pin), openStatus, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioController: IGpioController}
impl RtActivatable<IGpioControllerStatics> for GpioController {}
impl RtActivatable<IGpioControllerStatics2> for GpioController {}
impl GpioController {
    #[inline] pub fn get_default() -> Result<Option<GpioController>> {
        <Self as RtActivatable<IGpioControllerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_controllers_async(provider: &provider::IGpioProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>>> {
        <Self as RtActivatable<IGpioControllerStatics2>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<GpioController>> {
        <Self as RtActivatable<IGpioControllerStatics2>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(GpioController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_GpioController]);
DEFINE_IID!(IID_IGpioControllerStatics, 785839150, 31479, 16662, 149, 51, 196, 61, 153, 161, 251, 100);
RT_INTERFACE!{static interface IGpioControllerStatics(IGpioControllerStaticsVtbl, IGpioControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics] {
    fn GetDefault(&self, out: *mut <GpioController as RtType>::Abi) -> HRESULT
}}
impl IGpioControllerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<GpioController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GpioController::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioControllerStatics2, 2435546400, 27812, 16646, 163, 115, 255, 253, 52, 107, 14, 91);
RT_INTERFACE!{static interface IGpioControllerStatics2(IGpioControllerStatics2Vtbl, IGpioControllerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics2] {
    fn GetControllersAsync(&self, provider: <provider::IGpioProvider as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<GpioController> as RtType>::Abi) -> HRESULT
}}
impl IGpioControllerStatics2 {
    #[inline] pub fn get_controllers_async(&self, provider: &provider::IGpioProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<GpioController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GpioOpenStatus: i32 {
    PinOpened = 0, PinUnavailable = 1, SharingViolation = 2, MuxingConflict = 3, UnknownError = 4,
}}
DEFINE_IID!(IID_IGpioPin, 299479175, 44974, 18320, 158, 233, 224, 234, 201, 66, 210, 1);
RT_INTERFACE!{interface IGpioPin(IGpioPinVtbl, IGpioPin_Abi): IInspectable(IInspectableVtbl) [IID_IGpioPin] {
    fn add_ValueChanged(&self, handler: <foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DebounceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DebounceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PinNumber(&self, out: *mut i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut GpioSharingMode) -> HRESULT,
    fn IsDriveModeSupported(&self, driveMode: GpioPinDriveMode, out: *mut bool) -> HRESULT,
    fn GetDriveMode(&self, out: *mut GpioPinDriveMode) -> HRESULT,
    fn SetDriveMode(&self, value: GpioPinDriveMode) -> HRESULT,
    fn Write(&self, value: GpioPinValue) -> HRESULT,
    fn Read(&self, out: *mut GpioPinValue) -> HRESULT
}}
impl IGpioPin {
    #[inline] pub fn add_value_changed(&self, handler: &foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ValueChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ValueChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_debounce_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DebounceTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_debounce_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DebounceTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<GpioSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_drive_mode_supported(&self, driveMode: GpioPinDriveMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsDriveModeSupported)(self.0.as_abi() as *const _ as *mut _, driveMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drive_mode(&self) -> Result<GpioPinDriveMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetDriveMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_drive_mode(&self, value: GpioPinDriveMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDriveMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, value: GpioPinValue) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<GpioPinValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPin: IGpioPin}
RT_ENUM! { enum GpioPinDriveMode: i32 {
    Input = 0, Output = 1, InputPullUp = 2, InputPullDown = 3, OutputOpenDrain = 4, OutputOpenDrainPullUp = 5, OutputOpenSource = 6, OutputOpenSourcePullDown = 7,
}}
RT_ENUM! { enum GpioPinEdge: i32 {
    FallingEdge = 0, RisingEdge = 1,
}}
RT_ENUM! { enum GpioPinValue: i32 {
    Low = 0, High = 1,
}}
DEFINE_IID!(IID_IGpioPinValueChangedEventArgs, 825731809, 28733, 16473, 189, 36, 181, 178, 93, 255, 184, 78);
RT_INTERFACE!{interface IGpioPinValueChangedEventArgs(IGpioPinValueChangedEventArgsVtbl, IGpioPinValueChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGpioPinValueChangedEventArgs] {
    fn get_Edge(&self, out: *mut GpioPinEdge) -> HRESULT
}}
impl IGpioPinValueChangedEventArgs {
    #[inline] pub fn get_edge(&self) -> Result<GpioPinEdge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Edge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPinValueChangedEventArgs: IGpioPinValueChangedEventArgs}
RT_ENUM! { enum GpioSharingMode: i32 {
    Exclusive = 0, SharedReadOnly = 1,
}}
pub mod provider { // Windows.Devices.Gpio.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IGpioControllerProvider, 2903625415, 6634, 19233, 135, 79, 185, 26, 237, 74, 37, 219);
RT_INTERFACE!{interface IGpioControllerProvider(IGpioControllerProviderVtbl, IGpioControllerProvider_Abi): IInspectable(IInspectableVtbl) [IID_IGpioControllerProvider] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn OpenPinProvider(&self, pin: i32, sharingMode: ProviderGpioSharingMode, out: *mut <IGpioPinProvider as RtType>::Abi) -> HRESULT
}}
impl IGpioControllerProvider {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin_provider(&self, pin: i32, sharingMode: ProviderGpioSharingMode) -> Result<Option<IGpioPinProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenPinProvider)(self.0.as_abi() as *const _ as *mut _, pin, sharingMode, &mut out);
        if hr == S_OK { Ok(IGpioPinProvider::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioPinProvider, 1110723767, 27324, 16639, 156, 231, 115, 184, 83, 1, 185, 0);
RT_INTERFACE!{interface IGpioPinProvider(IGpioPinProviderVtbl, IGpioPinProvider_Abi): IInspectable(IInspectableVtbl) [IID_IGpioPinProvider] {
    fn add_ValueChanged(&self, handler: <foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DebounceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DebounceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PinNumber(&self, out: *mut i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderGpioSharingMode) -> HRESULT,
    fn IsDriveModeSupported(&self, driveMode: ProviderGpioPinDriveMode, out: *mut bool) -> HRESULT,
    fn GetDriveMode(&self, out: *mut ProviderGpioPinDriveMode) -> HRESULT,
    fn SetDriveMode(&self, value: ProviderGpioPinDriveMode) -> HRESULT,
    fn Write(&self, value: ProviderGpioPinValue) -> HRESULT,
    fn Read(&self, out: *mut ProviderGpioPinValue) -> HRESULT
}}
impl IGpioPinProvider {
    #[inline] pub fn add_value_changed(&self, handler: &foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ValueChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ValueChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_debounce_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DebounceTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_debounce_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DebounceTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderGpioSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_drive_mode_supported(&self, driveMode: ProviderGpioPinDriveMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsDriveModeSupported)(self.0.as_abi() as *const _ as *mut _, driveMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drive_mode(&self) -> Result<ProviderGpioPinDriveMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetDriveMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_drive_mode(&self, value: ProviderGpioPinDriveMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetDriveMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, value: ProviderGpioPinValue) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<ProviderGpioPinValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgs, 849794802, 15707, 17613, 143, 190, 19, 166, 159, 46, 219, 36);
RT_INTERFACE!{interface IGpioPinProviderValueChangedEventArgs(IGpioPinProviderValueChangedEventArgsVtbl, IGpioPinProviderValueChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgs] {
    fn get_Edge(&self, out: *mut ProviderGpioPinEdge) -> HRESULT
}}
impl IGpioPinProviderValueChangedEventArgs {
    #[inline] pub fn get_edge(&self) -> Result<ProviderGpioPinEdge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Edge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPinProviderValueChangedEventArgs: IGpioPinProviderValueChangedEventArgs}
impl RtActivatable<IGpioPinProviderValueChangedEventArgsFactory> for GpioPinProviderValueChangedEventArgs {}
impl GpioPinProviderValueChangedEventArgs {
    #[inline] pub fn create(edge: ProviderGpioPinEdge) -> Result<GpioPinProviderValueChangedEventArgs> {
        <Self as RtActivatable<IGpioPinProviderValueChangedEventArgsFactory>>::get_activation_factory().create(edge)
    }
}
DEFINE_CLSID!(GpioPinProviderValueChangedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,80,114,111,118,105,100,101,114,46,71,112,105,111,80,105,110,80,114,111,118,105,100,101,114,86,97,108,117,101,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_GpioPinProviderValueChangedEventArgs]);
DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgsFactory, 1053494105, 22156, 17298, 178, 74, 138, 89, 169, 2, 177, 241);
RT_INTERFACE!{static interface IGpioPinProviderValueChangedEventArgsFactory(IGpioPinProviderValueChangedEventArgsFactoryVtbl, IGpioPinProviderValueChangedEventArgsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgsFactory] {
    fn Create(&self, edge: ProviderGpioPinEdge, out: *mut <GpioPinProviderValueChangedEventArgs as RtType>::Abi) -> HRESULT
}}
impl IGpioPinProviderValueChangedEventArgsFactory {
    #[inline] pub fn create(&self, edge: ProviderGpioPinEdge) -> Result<GpioPinProviderValueChangedEventArgs> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, edge, &mut out);
        if hr == S_OK { Ok(GpioPinProviderValueChangedEventArgs::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioProvider, 1156065031, 2250, 17226, 175, 224, 214, 21, 128, 68, 111, 126);
RT_INTERFACE!{interface IGpioProvider(IGpioProviderVtbl, IGpioProvider_Abi): IInspectable(IInspectableVtbl) [IID_IGpioProvider] {
    fn GetControllers(&self, out: *mut <foundation::collections::IVectorView<IGpioControllerProvider> as RtType>::Abi) -> HRESULT
}}
impl IGpioProvider {
    #[inline] pub fn get_controllers(&self) -> Result<Option<foundation::collections::IVectorView<IGpioControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderGpioPinDriveMode: i32 {
    Input = 0, Output = 1, InputPullUp = 2, InputPullDown = 3, OutputOpenDrain = 4, OutputOpenDrainPullUp = 5, OutputOpenSource = 6, OutputOpenSourcePullDown = 7,
}}
RT_ENUM! { enum ProviderGpioPinEdge: i32 {
    FallingEdge = 0, RisingEdge = 1,
}}
RT_ENUM! { enum ProviderGpioPinValue: i32 {
    Low = 0, High = 1,
}}
RT_ENUM! { enum ProviderGpioSharingMode: i32 {
    Exclusive = 0, SharedReadOnly = 1,
}}
} // Windows.Devices.Gpio.Provider
} // Windows.Devices.Gpio
pub mod haptics { // Windows.Devices.Haptics
use crate::prelude::*;
RT_CLASS!{static class KnownSimpleHapticsControllerWaveforms}
impl RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics> for KnownSimpleHapticsControllerWaveforms {}
impl KnownSimpleHapticsControllerWaveforms {
    #[inline] pub fn get_click() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_click()
    }
    #[inline] pub fn get_buzz_continuous() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_buzz_continuous()
    }
    #[inline] pub fn get_rumble_continuous() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_rumble_continuous()
    }
    #[inline] pub fn get_press() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_press()
    }
    #[inline] pub fn get_release() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_release()
    }
}
DEFINE_CLSID!(KnownSimpleHapticsControllerWaveforms(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,97,112,116,105,99,115,46,75,110,111,119,110,83,105,109,112,108,101,72,97,112,116,105,99,115,67,111,110,116,114,111,108,108,101,114,87,97,118,101,102,111,114,109,115,0]) [CLSID_KnownSimpleHapticsControllerWaveforms]);
DEFINE_IID!(IID_IKnownSimpleHapticsControllerWaveformsStatics, 1029144311, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{static interface IKnownSimpleHapticsControllerWaveformsStatics(IKnownSimpleHapticsControllerWaveformsStaticsVtbl, IKnownSimpleHapticsControllerWaveformsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownSimpleHapticsControllerWaveformsStatics] {
    fn get_Click(&self, out: *mut u16) -> HRESULT,
    fn get_BuzzContinuous(&self, out: *mut u16) -> HRESULT,
    fn get_RumbleContinuous(&self, out: *mut u16) -> HRESULT,
    fn get_Press(&self, out: *mut u16) -> HRESULT,
    fn get_Release(&self, out: *mut u16) -> HRESULT
}}
impl IKnownSimpleHapticsControllerWaveformsStatics {
    #[inline] pub fn get_click(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Click)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buzz_continuous(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BuzzContinuous)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rumble_continuous(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RumbleContinuous)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_press(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Press)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_release(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Release)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleHapticsController, 1029144313, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface ISimpleHapticsController(ISimpleHapticsControllerVtbl, ISimpleHapticsController_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleHapticsController] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedFeedback(&self, out: *mut <foundation::collections::IVectorView<SimpleHapticsControllerFeedback> as RtType>::Abi) -> HRESULT,
    fn get_IsIntensitySupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlayCountSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlayDurationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsReplayPauseIntervalSupported(&self, out: *mut bool) -> HRESULT,
    fn StopFeedback(&self) -> HRESULT,
    fn SendHapticFeedback(&self, feedback: <SimpleHapticsControllerFeedback as RtType>::Abi) -> HRESULT,
    fn SendHapticFeedbackWithIntensity(&self, feedback: <SimpleHapticsControllerFeedback as RtType>::Abi, intensity: f64) -> HRESULT,
    fn SendHapticFeedbackForDuration(&self, feedback: <SimpleHapticsControllerFeedback as RtType>::Abi, intensity: f64, playDuration: foundation::TimeSpan) -> HRESULT,
    fn SendHapticFeedbackForPlayCount(&self, feedback: <SimpleHapticsControllerFeedback as RtType>::Abi, intensity: f64, playCount: i32, replayPauseInterval: foundation::TimeSpan) -> HRESULT
}}
impl ISimpleHapticsController {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_feedback(&self) -> Result<Option<foundation::collections::IVectorView<SimpleHapticsControllerFeedback>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedFeedback)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_intensity_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsIntensitySupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_count_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlayCountSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_duration_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPlayDurationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_replay_pause_interval_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReplayPauseIntervalSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn stop_feedback(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopFeedback)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback(&self, feedback: &SimpleHapticsControllerFeedback) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendHapticFeedback)(self.0.as_abi() as *const _ as *mut _, get_abi(feedback) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_with_intensity(&self, feedback: &SimpleHapticsControllerFeedback, intensity: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendHapticFeedbackWithIntensity)(self.0.as_abi() as *const _ as *mut _, get_abi(feedback) as *const _ as *mut _, intensity);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_for_duration(&self, feedback: &SimpleHapticsControllerFeedback, intensity: f64, playDuration: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendHapticFeedbackForDuration)(self.0.as_abi() as *const _ as *mut _, get_abi(feedback) as *const _ as *mut _, intensity, playDuration);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_for_play_count(&self, feedback: &SimpleHapticsControllerFeedback, intensity: f64, playCount: i32, replayPauseInterval: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendHapticFeedbackForPlayCount)(self.0.as_abi() as *const _ as *mut _, get_abi(feedback) as *const _ as *mut _, intensity, playCount, replayPauseInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleHapticsController: ISimpleHapticsController}
DEFINE_IID!(IID_ISimpleHapticsControllerFeedback, 1029144312, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface ISimpleHapticsControllerFeedback(ISimpleHapticsControllerFeedbackVtbl, ISimpleHapticsControllerFeedback_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleHapticsControllerFeedback] {
    fn get_Waveform(&self, out: *mut u16) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ISimpleHapticsControllerFeedback {
    #[inline] pub fn get_waveform(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Waveform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleHapticsControllerFeedback: ISimpleHapticsControllerFeedback}
RT_ENUM! { enum VibrationAccessStatus: i32 {
    Allowed = 0, DeniedByUser = 1, DeniedBySystem = 2, DeniedByEnergySaver = 3,
}}
DEFINE_IID!(IID_IVibrationDevice, 1089608254, 34884, 18431, 179, 18, 6, 24, 90, 56, 68, 218);
RT_INTERFACE!{interface IVibrationDevice(IVibrationDeviceVtbl, IVibrationDevice_Abi): IInspectable(IInspectableVtbl) [IID_IVibrationDevice] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SimpleHapticsController(&self, out: *mut <SimpleHapticsController as RtType>::Abi) -> HRESULT
}}
impl IVibrationDevice {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<SimpleHapticsController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SimpleHapticsController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SimpleHapticsController::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VibrationDevice: IVibrationDevice}
impl RtActivatable<IVibrationDeviceStatics> for VibrationDevice {}
impl VibrationDevice {
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<VibrationAccessStatus>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<VibrationDevice>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<VibrationDevice>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().find_all_async()
    }
}
DEFINE_CLSID!(VibrationDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,97,112,116,105,99,115,46,86,105,98,114,97,116,105,111,110,68,101,118,105,99,101,0]) [CLSID_VibrationDevice]);
DEFINE_IID!(IID_IVibrationDeviceStatics, 1407380973, 8848, 19145, 142, 179, 26, 132, 18, 46, 183, 28);
RT_INTERFACE!{static interface IVibrationDeviceStatics(IVibrationDeviceStaticsVtbl, IVibrationDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IVibrationDeviceStatics] {
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<VibrationAccessStatus> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<VibrationDevice> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<VibrationDevice> as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>> as RtType>::Abi) -> HRESULT
}}
impl IVibrationDeviceStatics {
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<VibrationAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<VibrationDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<VibrationDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Haptics
pub mod humaninterfacedevice { // Windows.Devices.HumanInterfaceDevice
use crate::prelude::*;
DEFINE_IID!(IID_IHidBooleanControl, 1380840586, 13973, 16524, 187, 162, 226, 235, 90, 191, 188, 32);
RT_INTERFACE!{interface IHidBooleanControl(IHidBooleanControlVtbl, IHidBooleanControl_Abi): IInspectable(IInspectableVtbl) [IID_IHidBooleanControl] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn put_IsActive(&self, value: bool) -> HRESULT,
    fn get_ControlDescription(&self, out: *mut <HidBooleanControlDescription as RtType>::Abi) -> HRESULT
}}
impl IHidBooleanControl {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsActive)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_active(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsActive)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_description(&self) -> Result<Option<HidBooleanControlDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidBooleanControlDescription::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidBooleanControl: IHidBooleanControl}
DEFINE_IID!(IID_IHidBooleanControlDescription, 1637279043, 10712, 18986, 134, 131, 132, 158, 32, 123, 190, 49);
RT_INTERFACE!{interface IHidBooleanControlDescription(IHidBooleanControlDescriptionVtbl, IHidBooleanControlDescription_Abi): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_ReportId(&self, out: *mut u16) -> HRESULT,
    fn get_ReportType(&self, out: *mut HidReportType) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_ParentCollections(&self, out: *mut <foundation::collections::IVectorView<HidCollection> as RtType>::Abi) -> HRESULT
}}
impl IHidBooleanControlDescription {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_type(&self) -> Result<HidReportType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_collections(&self) -> Result<Option<foundation::collections::IVectorView<HidCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ParentCollections)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidBooleanControlDescription: IHidBooleanControlDescription}
DEFINE_IID!(IID_IHidBooleanControlDescription2, 3371094762, 35447, 19510, 170, 0, 95, 240, 68, 157, 62, 115);
RT_INTERFACE!{interface IHidBooleanControlDescription2(IHidBooleanControlDescription2Vtbl, IHidBooleanControlDescription2_Abi): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription2] {
    fn get_IsAbsolute(&self, out: *mut bool) -> HRESULT
}}
impl IHidBooleanControlDescription2 {
    #[inline] pub fn get_is_absolute(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAbsolute)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHidCollection, 1904866723, 13041, 18147, 190, 253, 68, 210, 102, 59, 126, 106);
RT_INTERFACE!{interface IHidCollection(IHidCollectionVtbl, IHidCollection_Abi): IInspectable(IInspectableVtbl) [IID_IHidCollection] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_Type(&self, out: *mut HidCollectionType) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u32) -> HRESULT,
    fn get_UsageId(&self, out: *mut u32) -> HRESULT
}}
impl IHidCollection {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<HidCollectionType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class HidCollection: IHidCollection}
RT_ENUM! { enum HidCollectionType: i32 {
    Physical = 0, Application = 1, Logical = 2, Report = 3, NamedArray = 4, UsageSwitch = 5, UsageModifier = 6, Other = 7,
}}
DEFINE_IID!(IID_IHidDevice, 1602884839, 8704, 17198, 149, 218, 208, 155, 135, 213, 116, 168);
RT_INTERFACE!{interface IHidDevice(IHidDeviceVtbl, IHidDevice_Abi): IInspectable(IInspectableVtbl) [IID_IHidDevice] {
    fn get_VendorId(&self, out: *mut u16) -> HRESULT,
    fn get_ProductId(&self, out: *mut u16) -> HRESULT,
    fn get_Version(&self, out: *mut u16) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn GetInputReportAsync(&self, out: *mut <foundation::IAsyncOperation<HidInputReport> as RtType>::Abi) -> HRESULT,
    fn GetInputReportByIdAsync(&self, reportId: u16, out: *mut <foundation::IAsyncOperation<HidInputReport> as RtType>::Abi) -> HRESULT,
    fn GetFeatureReportAsync(&self, out: *mut <foundation::IAsyncOperation<HidFeatureReport> as RtType>::Abi) -> HRESULT,
    fn GetFeatureReportByIdAsync(&self, reportId: u16, out: *mut <foundation::IAsyncOperation<HidFeatureReport> as RtType>::Abi) -> HRESULT,
    fn CreateOutputReport(&self, out: *mut <HidOutputReport as RtType>::Abi) -> HRESULT,
    fn CreateOutputReportById(&self, reportId: u16, out: *mut <HidOutputReport as RtType>::Abi) -> HRESULT,
    fn CreateFeatureReport(&self, out: *mut <HidFeatureReport as RtType>::Abi) -> HRESULT,
    fn CreateFeatureReportById(&self, reportId: u16, out: *mut <HidFeatureReport as RtType>::Abi) -> HRESULT,
    fn SendOutputReportAsync(&self, outputReport: <HidOutputReport as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn SendFeatureReportAsync(&self, featureReport: <HidFeatureReport as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn GetBooleanControlDescriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut <foundation::collections::IVectorView<HidBooleanControlDescription> as RtType>::Abi) -> HRESULT,
    fn GetNumericControlDescriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut <foundation::collections::IVectorView<HidNumericControlDescription> as RtType>::Abi) -> HRESULT,
    fn add_InputReportReceived(&self, reportHandler: <foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InputReportReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IHidDevice {
    #[inline] pub fn get_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VendorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProductId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Version)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_input_report_async(&self) -> Result<foundation::IAsyncOperation<HidInputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetInputReportAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_input_report_by_id_async(&self, reportId: u16) -> Result<foundation::IAsyncOperation<HidInputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetInputReportByIdAsync)(self.0.as_abi() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feature_report_async(&self) -> Result<foundation::IAsyncOperation<HidFeatureReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFeatureReportAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feature_report_by_id_async(&self, reportId: u16) -> Result<foundation::IAsyncOperation<HidFeatureReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFeatureReportByIdAsync)(self.0.as_abi() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_output_report(&self) -> Result<Option<HidOutputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateOutputReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidOutputReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_output_report_by_id(&self, reportId: u16) -> Result<Option<HidOutputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateOutputReportById)(self.0.as_abi() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(HidOutputReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_feature_report(&self) -> Result<Option<HidFeatureReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFeatureReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidFeatureReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_feature_report_by_id(&self, reportId: u16) -> Result<Option<HidFeatureReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFeatureReportById)(self.0.as_abi() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(HidFeatureReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_output_report_async(&self, outputReport: &HidOutputReport) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendOutputReportAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(outputReport) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_feature_report_async(&self, featureReport: &HidFeatureReport) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendFeatureReportAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(featureReport) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_descriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16) -> Result<Option<foundation::collections::IVectorView<HidBooleanControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControlDescriptions)(self.0.as_abi() as *const _ as *mut _, reportType, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_descriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16) -> Result<Option<foundation::collections::IVectorView<HidNumericControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControlDescriptions)(self.0.as_abi() as *const _ as *mut _, reportType, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_input_report_received(&self, reportHandler: &foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_InputReportReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(reportHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_input_report_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_InputReportReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HidDevice: IHidDevice}
impl RtActivatable<IHidDeviceStatics> for HidDevice {}
impl HidDevice {
    #[inline] pub fn get_device_selector(usagePage: u16, usageId: u16) -> Result<HString> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().get_device_selector(usagePage, usageId)
    }
    #[inline] pub fn get_device_selector_vid_pid(usagePage: u16, usageId: u16, vendorId: u16, productId: u16) -> Result<HString> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().get_device_selector_vid_pid(usagePage, usageId, vendorId, productId)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id_async(deviceId: &HStringArg, accessMode: super::super::storage::FileAccessMode) -> Result<foundation::IAsyncOperation<HidDevice>> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().from_id_async(deviceId, accessMode)
    }
}
DEFINE_CLSID!(HidDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,117,109,97,110,73,110,116,101,114,102,97,99,101,68,101,118,105,99,101,46,72,105,100,68,101,118,105,99,101,0]) [CLSID_HidDevice]);
DEFINE_IID!(IID_IHidDeviceStatics, 2656666084, 38998, 16780, 159, 115, 119, 222, 12, 216, 87, 84);
RT_INTERFACE!{static interface IHidDeviceStatics(IHidDeviceStaticsVtbl, IHidDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IHidDeviceStatics] {
    fn GetDeviceSelector(&self, usagePage: u16, usageId: u16, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorVidPid(&self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn FromIdAsync(&self, deviceId: HSTRING, accessMode: super::super::storage::FileAccessMode, out: *mut <foundation::IAsyncOperation<HidDevice> as RtType>::Abi) -> HRESULT
}}
impl IHidDeviceStatics {
    #[inline] pub fn get_device_selector(&self, usagePage: u16, usageId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_vid_pid(&self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorVidPid)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, accessMode: super::super::storage::FileAccessMode) -> Result<foundation::IAsyncOperation<HidDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), accessMode, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHidFeatureReport, 2216532857, 23269, 18147, 130, 239, 31, 236, 92, 137, 66, 244);
RT_INTERFACE!{interface IHidFeatureReport(IHidFeatureReportVtbl, IHidFeatureReport_Abi): IInspectable(IInspectableVtbl) [IID_IHidFeatureReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: <HidBooleanControlDescription as RtType>::Abi, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: <HidNumericControlDescription as RtType>::Abi, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT
}}
impl IHidFeatureReport {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &HidBooleanControlDescription) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &HidNumericControlDescription) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidFeatureReport: IHidFeatureReport}
DEFINE_IID!(IID_IHidInputReport, 3277655632, 63463, 20109, 178, 62, 202, 187, 229, 107, 144, 233);
RT_INTERFACE!{interface IHidInputReport(IHidInputReportVtbl, IHidInputReport_Abi): IInspectable(IInspectableVtbl) [IID_IHidInputReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ActivatedBooleanControls(&self, out: *mut <foundation::collections::IVectorView<HidBooleanControl> as RtType>::Abi) -> HRESULT,
    fn get_TransitionedBooleanControls(&self, out: *mut <foundation::collections::IVectorView<HidBooleanControl> as RtType>::Abi) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: <HidBooleanControlDescription as RtType>::Abi, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: <HidNumericControlDescription as RtType>::Abi, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT
}}
impl IHidInputReport {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_activated_boolean_controls(&self) -> Result<Option<foundation::collections::IVectorView<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActivatedBooleanControls)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transitioned_boolean_controls(&self) -> Result<Option<foundation::collections::IVectorView<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TransitionedBooleanControls)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &HidBooleanControlDescription) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &HidNumericControlDescription) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidInputReport: IHidInputReport}
DEFINE_IID!(IID_IHidInputReportReceivedEventArgs, 1884931531, 22962, 19906, 152, 92, 10, 220, 97, 54, 250, 45);
RT_INTERFACE!{interface IHidInputReportReceivedEventArgs(IHidInputReportReceivedEventArgsVtbl, IHidInputReportReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IHidInputReportReceivedEventArgs] {
    fn get_Report(&self, out: *mut <HidInputReport as RtType>::Abi) -> HRESULT
}}
impl IHidInputReportReceivedEventArgs {
    #[inline] pub fn get_report(&self) -> Result<Option<HidInputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidInputReport::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidInputReportReceivedEventArgs: IHidInputReportReceivedEventArgs}
DEFINE_IID!(IID_IHidNumericControl, 3817476773, 13735, 19317, 137, 200, 251, 31, 40, 177, 8, 35);
RT_INTERFACE!{interface IHidNumericControl(IHidNumericControlVtbl, IHidNumericControl_Abi): IInspectable(IInspectableVtbl) [IID_IHidNumericControl] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_IsGrouped(&self, out: *mut bool) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_Value(&self, out: *mut i64) -> HRESULT,
    fn put_Value(&self, value: i64) -> HRESULT,
    fn get_ScaledValue(&self, out: *mut i64) -> HRESULT,
    fn put_ScaledValue(&self, value: i64) -> HRESULT,
    fn get_ControlDescription(&self, out: *mut <HidNumericControlDescription as RtType>::Abi) -> HRESULT
}}
impl IHidNumericControl {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_grouped(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGrouped)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<i64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: i64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scaled_value(&self) -> Result<i64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScaledValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scaled_value(&self, value: i64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScaledValue)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_description(&self) -> Result<Option<HidNumericControlDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidNumericControlDescription::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidNumericControl: IHidNumericControl}
DEFINE_IID!(IID_IHidNumericControlDescription, 1670209158, 7575, 19573, 146, 127, 95, 245, 139, 160, 94, 50);
RT_INTERFACE!{interface IHidNumericControlDescription(IHidNumericControlDescriptionVtbl, IHidNumericControlDescription_Abi): IInspectable(IInspectableVtbl) [IID_IHidNumericControlDescription] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_ReportId(&self, out: *mut u16) -> HRESULT,
    fn get_ReportType(&self, out: *mut HidReportType) -> HRESULT,
    fn get_ReportSize(&self, out: *mut u32) -> HRESULT,
    fn get_ReportCount(&self, out: *mut u32) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_LogicalMinimum(&self, out: *mut i32) -> HRESULT,
    fn get_LogicalMaximum(&self, out: *mut i32) -> HRESULT,
    fn get_PhysicalMinimum(&self, out: *mut i32) -> HRESULT,
    fn get_PhysicalMaximum(&self, out: *mut i32) -> HRESULT,
    fn get_UnitExponent(&self, out: *mut u32) -> HRESULT,
    fn get_Unit(&self, out: *mut u32) -> HRESULT,
    fn get_IsAbsolute(&self, out: *mut bool) -> HRESULT,
    fn get_HasNull(&self, out: *mut bool) -> HRESULT,
    fn get_ParentCollections(&self, out: *mut <foundation::collections::IVectorView<HidCollection> as RtType>::Abi) -> HRESULT
}}
impl IHidNumericControlDescription {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_type(&self) -> Result<HidReportType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsagePage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsageId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_logical_minimum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LogicalMinimum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_logical_maximum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LogicalMaximum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_minimum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalMinimum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_maximum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalMaximum)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit_exponent(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnitExponent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Unit)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_absolute(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAbsolute)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_null(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasNull)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_collections(&self) -> Result<Option<foundation::collections::IVectorView<HidCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ParentCollections)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidNumericControlDescription: IHidNumericControlDescription}
DEFINE_IID!(IID_IHidOutputReport, 1657480516, 51350, 17507, 147, 193, 223, 157, 176, 83, 196, 80);
RT_INTERFACE!{interface IHidOutputReport(IHidOutputReportVtbl, IHidOutputReport_Abi): IInspectable(IInspectableVtbl) [IID_IHidOutputReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: <HidBooleanControlDescription as RtType>::Abi, out: *mut <HidBooleanControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: <HidNumericControlDescription as RtType>::Abi, out: *mut <HidNumericControl as RtType>::Abi) -> HRESULT
}}
impl IHidOutputReport {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Data)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &HidBooleanControlDescription) -> Result<Option<HidBooleanControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidBooleanControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControl)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &HidNumericControlDescription) -> Result<Option<HidNumericControl>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControlByDescription)(self.0.as_abi() as *const _ as *mut _, get_abi(controlDescription) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HidNumericControl::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidOutputReport: IHidOutputReport}
RT_ENUM! { enum HidReportType: i32 {
    Input = 0, Output = 1, Feature = 2,
}}
} // Windows.Devices.HumanInterfaceDevice
pub mod i2c { // Windows.Devices.I2c
use crate::prelude::*;
RT_ENUM! { enum I2cBusSpeed: i32 {
    StandardMode = 0, FastMode = 1,
}}
DEFINE_IID!(IID_II2cConnectionSettings, 4074443527, 43887, 17977, 167, 103, 84, 83, 109, 195, 70, 15);
RT_INTERFACE!{interface II2cConnectionSettings(II2cConnectionSettingsVtbl, II2cConnectionSettings_Abi): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettings] {
    fn get_SlaveAddress(&self, out: *mut i32) -> HRESULT,
    fn put_SlaveAddress(&self, value: i32) -> HRESULT,
    fn get_BusSpeed(&self, out: *mut I2cBusSpeed) -> HRESULT,
    fn put_BusSpeed(&self, value: I2cBusSpeed) -> HRESULT,
    fn get_SharingMode(&self, out: *mut I2cSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: I2cSharingMode) -> HRESULT
}}
impl II2cConnectionSettings {
    #[inline] pub fn get_slave_address(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SlaveAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_slave_address(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SlaveAddress)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_speed(&self) -> Result<I2cBusSpeed> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BusSpeed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bus_speed(&self, value: I2cBusSpeed) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BusSpeed)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<I2cSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: I2cSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SharingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cConnectionSettings: II2cConnectionSettings}
impl RtActivatable<II2cConnectionSettingsFactory> for I2cConnectionSettings {}
impl I2cConnectionSettings {
    #[inline] pub fn create(slaveAddress: i32) -> Result<I2cConnectionSettings> {
        <Self as RtActivatable<II2cConnectionSettingsFactory>>::get_activation_factory().create(slaveAddress)
    }
}
DEFINE_CLSID!(I2cConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_I2cConnectionSettings]);
DEFINE_IID!(IID_II2cConnectionSettingsFactory, 2176157363, 38547, 16817, 162, 67, 222, 212, 246, 230, 105, 38);
RT_INTERFACE!{static interface II2cConnectionSettingsFactory(II2cConnectionSettingsFactoryVtbl, II2cConnectionSettingsFactory_Abi): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettingsFactory] {
    fn Create(&self, slaveAddress: i32, out: *mut <I2cConnectionSettings as RtType>::Abi) -> HRESULT
}}
impl II2cConnectionSettingsFactory {
    #[inline] pub fn create(&self, slaveAddress: i32) -> Result<I2cConnectionSettings> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, slaveAddress, &mut out);
        if hr == S_OK { Ok(I2cConnectionSettings::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cController, 3297423794, 34720, 16742, 142, 62, 180, 184, 249, 124, 215, 41);
RT_INTERFACE!{interface II2cController(II2cControllerVtbl, II2cController_Abi): IInspectable(IInspectableVtbl) [IID_II2cController] {
    fn GetDevice(&self, settings: <I2cConnectionSettings as RtType>::Abi, out: *mut <I2cDevice as RtType>::Abi) -> HRESULT
}}
impl II2cController {
    #[inline] pub fn get_device(&self, settings: &I2cConnectionSettings) -> Result<Option<I2cDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(I2cDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cController: II2cController}
impl RtActivatable<II2cControllerStatics> for I2cController {}
impl I2cController {
    #[inline] pub fn get_controllers_async(provider: &provider::II2cProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>>> {
        <Self as RtActivatable<II2cControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<I2cController>> {
        <Self as RtActivatable<II2cControllerStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(I2cController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_I2cController]);
DEFINE_IID!(IID_II2cControllerStatics, 1090257765, 24325, 20094, 132, 189, 16, 13, 184, 224, 174, 197);
RT_INTERFACE!{static interface II2cControllerStatics(II2cControllerStaticsVtbl, II2cControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_II2cControllerStatics] {
    fn GetControllersAsync(&self, provider: <provider::II2cProvider as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<I2cController> as RtType>::Abi) -> HRESULT
}}
impl II2cControllerStatics {
    #[inline] pub fn get_controllers_async(&self, provider: &provider::II2cProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<I2cController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cDevice, 2251735350, 47557, 20336, 148, 73, 204, 70, 220, 111, 87, 235);
RT_INTERFACE!{interface II2cDevice(II2cDeviceVtbl, II2cDevice_Abi): IInspectable(IInspectableVtbl) [IID_II2cDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut <I2cConnectionSettings as RtType>::Abi) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn WritePartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn ReadPartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT,
    fn WriteRead(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn WriteReadPartial(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT
}}
impl II2cDevice {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<I2cConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(I2cConnectionSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_partial(&self, buffer: &[u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).WritePartial)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_partial(&self, buffer: &mut [u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ReadPartial)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn write_read(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).WriteRead)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_read_partial(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).WriteReadPartial)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cDevice: II2cDevice}
impl RtActivatable<II2cDeviceStatics> for I2cDevice {}
impl I2cDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg, settings: &I2cConnectionSettings) -> Result<foundation::IAsyncOperation<I2cDevice>> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().from_id_async(deviceId, settings)
    }
}
DEFINE_CLSID!(I2cDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,68,101,118,105,99,101,0]) [CLSID_I2cDevice]);
DEFINE_IID!(IID_II2cDeviceStatics, 2443394019, 29492, 17682, 150, 188, 251, 174, 148, 89, 245, 246);
RT_INTERFACE!{static interface II2cDeviceStatics(II2cDeviceStaticsVtbl, II2cDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_II2cDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, settings: <I2cConnectionSettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<I2cDevice> as RtType>::Abi) -> HRESULT
}}
impl II2cDeviceStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, settings: &I2cConnectionSettings) -> Result<foundation::IAsyncOperation<I2cDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum I2cSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
RT_STRUCT! { struct I2cTransferResult {
    Status: I2cTransferStatus, BytesTransferred: u32,
}}
RT_ENUM! { enum I2cTransferStatus: i32 {
    FullTransfer = 0, PartialTransfer = 1, SlaveAddressNotAcknowledged = 2, ClockStretchTimeout = 3, UnknownError = 4,
}}
pub mod provider { // Windows.Devices.I2c.Provider
use crate::prelude::*;
DEFINE_IID!(IID_II2cControllerProvider, 1640151938, 17680, 16739, 168, 124, 78, 21, 169, 85, 137, 128);
RT_INTERFACE!{interface II2cControllerProvider(II2cControllerProviderVtbl, II2cControllerProvider_Abi): IInspectable(IInspectableVtbl) [IID_II2cControllerProvider] {
    fn GetDeviceProvider(&self, settings: <ProviderI2cConnectionSettings as RtType>::Abi, out: *mut <II2cDeviceProvider as RtType>::Abi) -> HRESULT
}}
impl II2cControllerProvider {
    #[inline] pub fn get_device_provider(&self, settings: &ProviderI2cConnectionSettings) -> Result<Option<II2cDeviceProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(II2cDeviceProvider::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cDeviceProvider, 2905876052, 22504, 17726, 131, 41, 209, 228, 71, 209, 3, 169);
RT_INTERFACE!{interface II2cDeviceProvider(II2cDeviceProviderVtbl, II2cDeviceProvider_Abi): IInspectable(IInspectableVtbl) [IID_II2cDeviceProvider] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn WritePartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn ReadPartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT,
    fn WriteRead(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn WriteReadPartial(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT
}}
impl II2cDeviceProvider {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_partial(&self, buffer: &[u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).WritePartial)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_partial(&self, buffer: &mut [u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ReadPartial)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn write_read(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).WriteRead)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_read_partial(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).WriteReadPartial)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cProvider, 1863518270, 48994, 20450, 169, 90, 240, 137, 153, 102, 152, 24);
RT_INTERFACE!{interface II2cProvider(II2cProviderVtbl, II2cProvider_Abi): IInspectable(IInspectableVtbl) [IID_II2cProvider] {
    fn GetControllersAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<II2cControllerProvider>> as RtType>::Abi) -> HRESULT
}}
impl II2cProvider {
    #[inline] pub fn get_controllers_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<II2cControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderI2cBusSpeed: i32 {
    StandardMode = 0, FastMode = 1,
}}
DEFINE_IID!(IID_IProviderI2cConnectionSettings, 3923463732, 58640, 17591, 128, 157, 242, 248, 91, 85, 83, 57);
RT_INTERFACE!{interface IProviderI2cConnectionSettings(IProviderI2cConnectionSettingsVtbl, IProviderI2cConnectionSettings_Abi): IInspectable(IInspectableVtbl) [IID_IProviderI2cConnectionSettings] {
    fn get_SlaveAddress(&self, out: *mut i32) -> HRESULT,
    fn put_SlaveAddress(&self, value: i32) -> HRESULT,
    fn get_BusSpeed(&self, out: *mut ProviderI2cBusSpeed) -> HRESULT,
    fn put_BusSpeed(&self, value: ProviderI2cBusSpeed) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderI2cSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: ProviderI2cSharingMode) -> HRESULT
}}
impl IProviderI2cConnectionSettings {
    #[inline] pub fn get_slave_address(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SlaveAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_slave_address(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SlaveAddress)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_speed(&self) -> Result<ProviderI2cBusSpeed> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BusSpeed)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bus_speed(&self, value: ProviderI2cBusSpeed) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BusSpeed)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderI2cSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: ProviderI2cSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SharingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ProviderI2cConnectionSettings: IProviderI2cConnectionSettings}
RT_ENUM! { enum ProviderI2cSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
RT_STRUCT! { struct ProviderI2cTransferResult {
    Status: ProviderI2cTransferStatus, BytesTransferred: u32,
}}
RT_ENUM! { enum ProviderI2cTransferStatus: i32 {
    FullTransfer = 0, PartialTransfer = 1, SlaveAddressNotAcknowledged = 2,
}}
} // Windows.Devices.I2c.Provider
} // Windows.Devices.I2c
pub mod input { // Windows.Devices.Input
use crate::prelude::*;
DEFINE_IID!(IID_IKeyboardCapabilities, 977247062, 26520, 19388, 131, 62, 15, 52, 177, 124, 101, 255);
RT_INTERFACE!{interface IKeyboardCapabilities(IKeyboardCapabilitiesVtbl, IKeyboardCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IKeyboardCapabilities] {
    fn get_KeyboardPresent(&self, out: *mut i32) -> HRESULT
}}
impl IKeyboardCapabilities {
    #[inline] pub fn get_keyboard_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_KeyboardPresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class KeyboardCapabilities: IKeyboardCapabilities}
impl RtActivatable<IActivationFactory> for KeyboardCapabilities {}
DEFINE_CLSID!(KeyboardCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,75,101,121,98,111,97,114,100,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_KeyboardCapabilities]);
DEFINE_IID!(IID_IMouseCapabilities, 3164987427, 32217, 19307, 154, 146, 85, 212, 60, 179, 143, 115);
RT_INTERFACE!{interface IMouseCapabilities(IMouseCapabilitiesVtbl, IMouseCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IMouseCapabilities] {
    fn get_MousePresent(&self, out: *mut i32) -> HRESULT,
    fn get_VerticalWheelPresent(&self, out: *mut i32) -> HRESULT,
    fn get_HorizontalWheelPresent(&self, out: *mut i32) -> HRESULT,
    fn get_SwapButtons(&self, out: *mut i32) -> HRESULT,
    fn get_NumberOfButtons(&self, out: *mut u32) -> HRESULT
}}
impl IMouseCapabilities {
    #[inline] pub fn get_mouse_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MousePresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_wheel_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VerticalWheelPresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_wheel_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HorizontalWheelPresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_swap_buttons(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SwapButtons)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_number_of_buttons(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NumberOfButtons)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseCapabilities: IMouseCapabilities}
impl RtActivatable<IActivationFactory> for MouseCapabilities {}
DEFINE_CLSID!(MouseCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,77,111,117,115,101,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_MouseCapabilities]);
RT_STRUCT! { struct MouseDelta {
    X: i32, Y: i32,
}}
DEFINE_IID!(IID_IMouseDevice, 2297295960, 62152, 18932, 190, 31, 194, 86, 179, 136, 188, 17);
RT_INTERFACE!{interface IMouseDevice(IMouseDeviceVtbl, IMouseDevice_Abi): IInspectable(IInspectableVtbl) [IID_IMouseDevice] {
    fn add_MouseMoved(&self, handler: <foundation::TypedEventHandler<MouseDevice, MouseEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MouseMoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMouseDevice {
    #[inline] pub fn add_mouse_moved(&self, handler: &foundation::TypedEventHandler<MouseDevice, MouseEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MouseMoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mouse_moved(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MouseMoved)(self.0.as_abi() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseDevice: IMouseDevice}
impl RtActivatable<IMouseDeviceStatics> for MouseDevice {}
impl MouseDevice {
    #[inline] pub fn get_for_current_view() -> Result<Option<MouseDevice>> {
        <Self as RtActivatable<IMouseDeviceStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(MouseDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,77,111,117,115,101,68,101,118,105,99,101,0]) [CLSID_MouseDevice]);
DEFINE_IID!(IID_IMouseDeviceStatics, 1212846149, 28016, 18907, 142, 104, 70, 255, 189, 23, 211, 141);
RT_INTERFACE!{static interface IMouseDeviceStatics(IMouseDeviceStaticsVtbl, IMouseDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMouseDeviceStatics] {
    fn GetForCurrentView(&self, out: *mut <MouseDevice as RtType>::Abi) -> HRESULT
}}
impl IMouseDeviceStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<MouseDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForCurrentView)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MouseDevice::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMouseEventArgs, 4129663581, 9044, 19655, 146, 48, 150, 148, 28, 150, 159, 222);
RT_INTERFACE!{interface IMouseEventArgs(IMouseEventArgsVtbl, IMouseEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMouseEventArgs] {
    fn get_MouseDelta(&self, out: *mut MouseDelta) -> HRESULT
}}
impl IMouseEventArgs {
    #[inline] pub fn get_mouse_delta(&self) -> Result<MouseDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MouseDelta)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseEventArgs: IMouseEventArgs}
DEFINE_IID!(IID_IPointerDevice, 2479471356, 60363, 18046, 130, 198, 39, 111, 234, 227, 107, 90);
RT_INTERFACE!{interface IPointerDevice(IPointerDeviceVtbl, IPointerDevice_Abi): IInspectable(IInspectableVtbl) [IID_IPointerDevice] {
    fn get_PointerDeviceType(&self, out: *mut PointerDeviceType) -> HRESULT,
    fn get_IsIntegrated(&self, out: *mut bool) -> HRESULT,
    fn get_MaxContacts(&self, out: *mut u32) -> HRESULT,
    fn get_PhysicalDeviceRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_ScreenRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_SupportedUsages(&self, out: *mut <foundation::collections::IVectorView<PointerDeviceUsage> as RtType>::Abi) -> HRESULT
}}
impl IPointerDevice {
    #[inline] pub fn get_pointer_device_type(&self) -> Result<PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PointerDeviceType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_integrated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsIntegrated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_contacts(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxContacts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceRect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_screen_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScreenRect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_usages(&self) -> Result<Option<foundation::collections::IVectorView<PointerDeviceUsage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedUsages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerDevice: IPointerDevice}
impl RtActivatable<IPointerDeviceStatics> for PointerDevice {}
impl PointerDevice {
    #[inline] pub fn get_pointer_device(pointerId: u32) -> Result<Option<PointerDevice>> {
        <Self as RtActivatable<IPointerDeviceStatics>>::get_activation_factory().get_pointer_device(pointerId)
    }
    #[inline] pub fn get_pointer_devices() -> Result<Option<foundation::collections::IVectorView<PointerDevice>>> {
        <Self as RtActivatable<IPointerDeviceStatics>>::get_activation_factory().get_pointer_devices()
    }
}
DEFINE_CLSID!(PointerDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,80,111,105,110,116,101,114,68,101,118,105,99,101,0]) [CLSID_PointerDevice]);
DEFINE_IID!(IID_IPointerDevice2, 4171682464, 50308, 18591, 174, 62, 48, 210, 238, 31, 253, 62);
RT_INTERFACE!{interface IPointerDevice2(IPointerDevice2Vtbl, IPointerDevice2_Abi): IInspectable(IInspectableVtbl) [IID_IPointerDevice2] {
    fn get_MaxPointersWithZDistance(&self, out: *mut u32) -> HRESULT
}}
impl IPointerDevice2 {
    #[inline] pub fn get_max_pointers_with_z_distance(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPointersWithZDistance)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointerDeviceStatics, 3635976865, 53702, 16750, 189, 141, 87, 144, 145, 77, 197, 99);
RT_INTERFACE!{static interface IPointerDeviceStatics(IPointerDeviceStaticsVtbl, IPointerDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPointerDeviceStatics] {
    fn GetPointerDevice(&self, pointerId: u32, out: *mut <PointerDevice as RtType>::Abi) -> HRESULT,
    fn GetPointerDevices(&self, out: *mut <foundation::collections::IVectorView<PointerDevice> as RtType>::Abi) -> HRESULT
}}
impl IPointerDeviceStatics {
    #[inline] pub fn get_pointer_device(&self, pointerId: u32) -> Result<Option<PointerDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPointerDevice)(self.0.as_abi() as *const _ as *mut _, pointerId, &mut out);
        if hr == S_OK { Ok(PointerDevice::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_devices(&self) -> Result<Option<foundation::collections::IVectorView<PointerDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPointerDevices)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PointerDeviceType: i32 {
    Touch = 0, Pen = 1, Mouse = 2,
}}
RT_STRUCT! { struct PointerDeviceUsage {
    UsagePage: u32, Usage: u32, MinLogical: i32, MaxLogical: i32, MinPhysical: i32, MaxPhysical: i32, Unit: u32, PhysicalMultiplier: f32,
}}
DEFINE_IID!(IID_ITouchCapabilities, 551376377, 5105, 18120, 146, 133, 44, 5, 250, 62, 218, 111);
RT_INTERFACE!{interface ITouchCapabilities(ITouchCapabilitiesVtbl, ITouchCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ITouchCapabilities] {
    fn get_TouchPresent(&self, out: *mut i32) -> HRESULT,
    fn get_Contacts(&self, out: *mut u32) -> HRESULT
}}
impl ITouchCapabilities {
    #[inline] pub fn get_touch_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TouchPresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contacts(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Contacts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TouchCapabilities: ITouchCapabilities}
impl RtActivatable<IActivationFactory> for TouchCapabilities {}
DEFINE_CLSID!(TouchCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,84,111,117,99,104,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_TouchCapabilities]);
pub mod preview { // Windows.Devices.Input.Preview
use crate::prelude::*;
RT_ENUM! { enum GazeDeviceConfigurationStatePreview: i32 {
    Unknown = 0, Ready = 1, Configuring = 2, ScreenSetupNeeded = 3, UserCalibrationNeeded = 4,
}}
DEFINE_IID!(IID_IGazeDevicePreview, 3885924073, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDevicePreview(IGazeDevicePreviewVtbl, IGazeDevicePreview_Abi): IInspectable(IInspectableVtbl) [IID_IGazeDevicePreview] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_CanTrackEyes(&self, out: *mut bool) -> HRESULT,
    fn get_CanTrackHead(&self, out: *mut bool) -> HRESULT,
    fn get_ConfigurationState(&self, out: *mut GazeDeviceConfigurationStatePreview) -> HRESULT,
    fn RequestCalibrationAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn GetNumericControlDescriptions(&self, usagePage: u16, usageId: u16, out: *mut <foundation::collections::IVectorView<super::super::humaninterfacedevice::HidNumericControlDescription> as RtType>::Abi) -> HRESULT,
    fn GetBooleanControlDescriptions(&self, usagePage: u16, usageId: u16, out: *mut <foundation::collections::IVectorView<super::super::humaninterfacedevice::HidBooleanControlDescription> as RtType>::Abi) -> HRESULT
}}
impl IGazeDevicePreview {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_track_eyes(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanTrackEyes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_track_head(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanTrackHead)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration_state(&self) -> Result<GazeDeviceConfigurationStatePreview> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConfigurationState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_calibration_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestCalibrationAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_descriptions(&self, usagePage: u16, usageId: u16) -> Result<Option<foundation::collections::IVectorView<super::super::humaninterfacedevice::HidNumericControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNumericControlDescriptions)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_descriptions(&self, usagePage: u16, usageId: u16) -> Result<Option<foundation::collections::IVectorView<super::super::humaninterfacedevice::HidBooleanControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBooleanControlDescriptions)(self.0.as_abi() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDevicePreview: IGazeDevicePreview}
DEFINE_IID!(IID_IGazeDeviceWatcherAddedPreviewEventArgs, 3885924077, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDeviceWatcherAddedPreviewEventArgs(IGazeDeviceWatcherAddedPreviewEventArgsVtbl, IGazeDeviceWatcherAddedPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherAddedPreviewEventArgs] {
    fn get_Device(&self, out: *mut <GazeDevicePreview as RtType>::Abi) -> HRESULT
}}
impl IGazeDeviceWatcherAddedPreviewEventArgs {
    #[inline] pub fn get_device(&self) -> Result<Option<GazeDevicePreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeDevicePreview::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherAddedPreviewEventArgs: IGazeDeviceWatcherAddedPreviewEventArgs}
DEFINE_IID!(IID_IGazeDeviceWatcherPreview, 3885924071, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDeviceWatcherPreview(IGazeDeviceWatcherPreviewVtbl, IGazeDeviceWatcherPreview_Abi): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherPreview] {
    fn add_Added(&self, handler: <foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherAddedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: <foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherRemovedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: <foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherUpdatedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<GazeDeviceWatcherPreview, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IGazeDeviceWatcherPreview {
    #[inline] pub fn add_added(&self, handler: &foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherAddedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Added)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Added)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherRemovedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Removed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Removed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherUpdatedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Updated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Updated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<GazeDeviceWatcherPreview, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherPreview: IGazeDeviceWatcherPreview}
DEFINE_IID!(IID_IGazeDeviceWatcherRemovedPreviewEventArgs, 4066582280, 3647, 17183, 166, 6, 80, 179, 90, 249, 74, 28);
RT_INTERFACE!{interface IGazeDeviceWatcherRemovedPreviewEventArgs(IGazeDeviceWatcherRemovedPreviewEventArgsVtbl, IGazeDeviceWatcherRemovedPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherRemovedPreviewEventArgs] {
    fn get_Device(&self, out: *mut <GazeDevicePreview as RtType>::Abi) -> HRESULT
}}
impl IGazeDeviceWatcherRemovedPreviewEventArgs {
    #[inline] pub fn get_device(&self) -> Result<Option<GazeDevicePreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeDevicePreview::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherRemovedPreviewEventArgs: IGazeDeviceWatcherRemovedPreviewEventArgs}
DEFINE_IID!(IID_IGazeDeviceWatcherUpdatedPreviewEventArgs, 2145923311, 32520, 18231, 136, 225, 74, 131, 174, 78, 72, 133);
RT_INTERFACE!{interface IGazeDeviceWatcherUpdatedPreviewEventArgs(IGazeDeviceWatcherUpdatedPreviewEventArgsVtbl, IGazeDeviceWatcherUpdatedPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherUpdatedPreviewEventArgs] {
    fn get_Device(&self, out: *mut <GazeDevicePreview as RtType>::Abi) -> HRESULT
}}
impl IGazeDeviceWatcherUpdatedPreviewEventArgs {
    #[inline] pub fn get_device(&self) -> Result<Option<GazeDevicePreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Device)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeDevicePreview::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherUpdatedPreviewEventArgs: IGazeDeviceWatcherUpdatedPreviewEventArgs}
DEFINE_IID!(IID_IGazeEnteredPreviewEventArgs, 627556163, 4645, 18591, 157, 209, 218, 167, 197, 15, 191, 75);
RT_INTERFACE!{interface IGazeEnteredPreviewEventArgs(IGazeEnteredPreviewEventArgsVtbl, IGazeEnteredPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeEnteredPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut <GazePointPreview as RtType>::Abi) -> HRESULT
}}
impl IGazeEnteredPreviewEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<GazePointPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazePointPreview::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeEnteredPreviewEventArgs: IGazeEnteredPreviewEventArgs}
DEFINE_IID!(IID_IGazeExitedPreviewEventArgs, 1560998014, 32131, 16623, 159, 10, 251, 193, 187, 220, 197, 172);
RT_INTERFACE!{interface IGazeExitedPreviewEventArgs(IGazeExitedPreviewEventArgsVtbl, IGazeExitedPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeExitedPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut <GazePointPreview as RtType>::Abi) -> HRESULT
}}
impl IGazeExitedPreviewEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<GazePointPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazePointPreview::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeExitedPreviewEventArgs: IGazeExitedPreviewEventArgs}
DEFINE_IID!(IID_IGazeInputSourcePreview, 3885924072, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeInputSourcePreview(IGazeInputSourcePreviewVtbl, IGazeInputSourcePreview_Abi): IInspectable(IInspectableVtbl) [IID_IGazeInputSourcePreview] {
    fn add_GazeMoved(&self, handler: <foundation::TypedEventHandler<GazeInputSourcePreview, GazeMovedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeMoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GazeEntered(&self, handler: <foundation::TypedEventHandler<GazeInputSourcePreview, GazeEnteredPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeEntered(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GazeExited(&self, handler: <foundation::TypedEventHandler<GazeInputSourcePreview, GazeExitedPreviewEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeExited(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGazeInputSourcePreview {
    #[inline] pub fn add_gaze_moved(&self, handler: &foundation::TypedEventHandler<GazeInputSourcePreview, GazeMovedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GazeMoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_moved(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GazeMoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gaze_entered(&self, handler: &foundation::TypedEventHandler<GazeInputSourcePreview, GazeEnteredPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GazeEntered)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_entered(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GazeEntered)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gaze_exited(&self, handler: &foundation::TypedEventHandler<GazeInputSourcePreview, GazeExitedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GazeExited)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_exited(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GazeExited)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeInputSourcePreview: IGazeInputSourcePreview}
impl RtActivatable<IGazeInputSourcePreviewStatics> for GazeInputSourcePreview {}
impl GazeInputSourcePreview {
    #[inline] pub fn get_for_current_view() -> Result<Option<GazeInputSourcePreview>> {
        <Self as RtActivatable<IGazeInputSourcePreviewStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn create_watcher() -> Result<Option<GazeDeviceWatcherPreview>> {
        <Self as RtActivatable<IGazeInputSourcePreviewStatics>>::get_activation_factory().create_watcher()
    }
}
DEFINE_CLSID!(GazeInputSourcePreview(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,71,97,122,101,73,110,112,117,116,83,111,117,114,99,101,80,114,101,118,105,101,119,0]) [CLSID_GazeInputSourcePreview]);
DEFINE_IID!(IID_IGazeInputSourcePreviewStatics, 3885924070, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{static interface IGazeInputSourcePreviewStatics(IGazeInputSourcePreviewStaticsVtbl, IGazeInputSourcePreviewStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGazeInputSourcePreviewStatics] {
    fn GetForCurrentView(&self, out: *mut <GazeInputSourcePreview as RtType>::Abi) -> HRESULT,
    fn CreateWatcher(&self, out: *mut <GazeDeviceWatcherPreview as RtType>::Abi) -> HRESULT
}}
impl IGazeInputSourcePreviewStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<GazeInputSourcePreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetForCurrentView)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeInputSourcePreview::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self) -> Result<Option<GazeDeviceWatcherPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeDeviceWatcherPreview::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGazeMovedPreviewEventArgs, 3885924075, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeMovedPreviewEventArgs(IGazeMovedPreviewEventArgsVtbl, IGazeMovedPreviewEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGazeMovedPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut <GazePointPreview as RtType>::Abi) -> HRESULT,
    fn GetIntermediatePoints(&self, out: *mut <foundation::collections::IVector<GazePointPreview> as RtType>::Abi) -> HRESULT
}}
impl IGazeMovedPreviewEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<GazePointPreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazePointPreview::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_points(&self) -> Result<Option<foundation::collections::IVector<GazePointPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIntermediatePoints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeMovedPreviewEventArgs: IGazeMovedPreviewEventArgs}
DEFINE_IID!(IID_IGazePointPreview, 3885924074, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazePointPreview(IGazePointPreviewVtbl, IGazePointPreview_Abi): IInspectable(IInspectableVtbl) [IID_IGazePointPreview] {
    fn get_SourceDevice(&self, out: *mut <GazeDevicePreview as RtType>::Abi) -> HRESULT,
    fn get_EyeGazePosition(&self, out: *mut <foundation::IReference<foundation::Point> as RtType>::Abi) -> HRESULT,
    fn get_HeadGazePosition(&self, out: *mut <foundation::IReference<foundation::Point> as RtType>::Abi) -> HRESULT,
    fn get_Timestamp(&self, out: *mut u64) -> HRESULT,
    fn get_HidInputReport(&self, out: *mut <super::super::humaninterfacedevice::HidInputReport as RtType>::Abi) -> HRESULT
}}
impl IGazePointPreview {
    #[inline] pub fn get_source_device(&self) -> Result<Option<GazeDevicePreview>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GazeDevicePreview::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_gaze_position(&self) -> Result<Option<foundation::IReference<foundation::Point>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EyeGazePosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_head_gaze_position(&self) -> Result<Option<foundation::IReference<foundation::Point>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeadGazePosition)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_input_report(&self) -> Result<Option<super::super::humaninterfacedevice::HidInputReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HidInputReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::humaninterfacedevice::HidInputReport::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazePointPreview: IGazePointPreview}
} // Windows.Devices.Input.Preview
} // Windows.Devices.Input
pub mod lights { // Windows.Devices.Lights
use crate::prelude::*;
DEFINE_IID!(IID_ILamp, 75324314, 59973, 19243, 177, 162, 20, 223, 240, 11, 222, 123);
RT_INTERFACE!{interface ILamp(ILampVtbl, ILamp_Abi): IInspectable(IInspectableVtbl) [IID_ILamp] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_BrightnessLevel(&self, out: *mut f32) -> HRESULT,
    fn put_BrightnessLevel(&self, value: f32) -> HRESULT,
    fn get_IsColorSettable(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: super::super::ui::Color) -> HRESULT,
    fn add_AvailabilityChanged(&self, handler: <foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailabilityChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILamp {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_level(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BrightnessLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness_level(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BrightnessLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_color_settable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsColorSettable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Color)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Color)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_availability_changed(&self, handler: &foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AvailabilityChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_availability_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AvailabilityChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Lamp: ILamp}
impl RtActivatable<ILampStatics> for Lamp {}
impl Lamp {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Lamp>> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<Lamp>> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(Lamp(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,76,97,109,112,0]) [CLSID_Lamp]);
DEFINE_IID!(IID_ILampArray, 2060359559, 51360, 20117, 161, 224, 213, 134, 118, 83, 134, 73);
RT_INTERFACE!{interface ILampArray(ILampArrayVtbl, ILampArray_Abi): IInspectable(IInspectableVtbl) [IID_ILampArray] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HardwareVendorId(&self, out: *mut u16) -> HRESULT,
    fn get_HardwareProductId(&self, out: *mut u16) -> HRESULT,
    fn get_HardwareVersion(&self, out: *mut u16) -> HRESULT,
    fn get_LampArrayKind(&self, out: *mut LampArrayKind) -> HRESULT,
    fn get_LampCount(&self, out: *mut i32) -> HRESULT,
    fn get_MinUpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_BoundingBox(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_BrightnessLevel(&self, out: *mut f64) -> HRESULT,
    fn put_BrightnessLevel(&self, value: f64) -> HRESULT,
    fn get_IsConnected(&self, out: *mut bool) -> HRESULT,
    fn get_SupportsVirtualKeys(&self, out: *mut bool) -> HRESULT,
    fn GetLampInfo(&self, lampIndex: i32, out: *mut <LampInfo as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIndicesForKey(&self, key: super::super::system::VirtualKey, outSize: *mut u32, out: *mut *mut i32) -> HRESULT,
    fn GetIndicesForPurposes(&self, purposes: LampPurposes, outSize: *mut u32, out: *mut *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColor(&self, desiredColor: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorForIndex(&self, lampIndex: i32, desiredColor: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetSingleColorForIndices(&self, desiredColor: super::super::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorsForIndices(&self, desiredColorsSize: u32, desiredColors: *mut super::super::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(not(all(feature="windows-system",feature="windows-ui")))] fn __Dummy21(&self) -> (),
    #[cfg(all(feature="windows-system",feature="windows-ui"))] fn SetColorsForKey(&self, desiredColor: super::super::ui::Color, key: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(not(all(feature="windows-system",feature="windows-ui")))] fn __Dummy22(&self) -> (),
    #[cfg(all(feature="windows-system",feature="windows-ui"))] fn SetColorsForKeys(&self, desiredColorsSize: u32, desiredColors: *mut super::super::ui::Color, keysSize: u32, keys: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy23(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorsForPurposes(&self, desiredColor: super::super::ui::Color, purposes: LampPurposes) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SendMessageAsync(&self, messageId: i32, message: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn RequestMessageAsync(&self, messageId: i32, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT
}}
impl ILampArray {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareVendorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareProductId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_version(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HardwareVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_array_kind(&self) -> Result<LampArrayKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LampArrayKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LampCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinUpdateInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_box(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BoundingBox)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_level(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BrightnessLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness_level(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BrightnessLevel)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsConnected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_virtual_keys(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportsVirtualKeys)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_info(&self, lampIndex: i32) -> Result<Option<LampInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetLampInfo)(self.0.as_abi() as *const _ as *mut _, lampIndex, &mut out);
        if hr == S_OK { Ok(LampInfo::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_indices_for_key(&self, key: super::super::system::VirtualKey) -> Result<ComArray<i32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIndicesForKey)(self.0.as_abi() as *const _ as *mut _, key, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_indices_for_purposes(&self, purposes: LampPurposes) -> Result<ComArray<i32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIndicesForPurposes)(self.0.as_abi() as *const _ as *mut _, purposes, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, desiredColor: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColor)(self.0.as_abi() as *const _ as *mut _, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color_for_index(&self, lampIndex: i32, desiredColor: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorForIndex)(self.0.as_abi() as *const _ as *mut _, lampIndex, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_single_color_for_indices(&self, desiredColor: super::super::ui::Color, lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSingleColorForIndices)(self.0.as_abi() as *const _ as *mut _, desiredColor, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_indices(&self, desiredColors: &[super::super::ui::Color], lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorsForIndices)(self.0.as_abi() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-system",feature="windows-ui"))] #[inline] pub fn set_colors_for_key(&self, desiredColor: super::super::ui::Color, key: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorsForKey)(self.0.as_abi() as *const _ as *mut _, desiredColor, key);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-system",feature="windows-ui"))] #[inline] pub fn set_colors_for_keys(&self, desiredColors: &[super::super::ui::Color], keys: &[super::super::system::VirtualKey]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorsForKeys)(self.0.as_abi() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, keys.len() as u32, keys.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_purposes(&self, desiredColor: super::super::ui::Color, purposes: LampPurposes) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorsForPurposes)(self.0.as_abi() as *const _ as *mut _, desiredColor, purposes);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_message_async(&self, messageId: i32, message: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendMessageAsync)(self.0.as_abi() as *const _ as *mut _, messageId, get_abi(message) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_message_async(&self, messageId: i32) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestMessageAsync)(self.0.as_abi() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArray: ILampArray}
impl RtActivatable<ILampArrayStatics> for LampArray {}
impl LampArray {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILampArrayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LampArray>> {
        <Self as RtActivatable<ILampArrayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(LampArray(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,76,97,109,112,65,114,114,97,121,0]) [CLSID_LampArray]);
RT_ENUM! { enum LampArrayKind: i32 {
    Undefined = 0, Keyboard = 1, Mouse = 2, GameController = 3, Peripheral = 4, Scene = 5, Notification = 6, Chassis = 7, Wearable = 8, Furniture = 9, Art = 10,
}}
DEFINE_IID!(IID_ILampArrayStatics, 2075707789, 24513, 17709, 187, 31, 74, 212, 16, 211, 152, 255);
RT_INTERFACE!{static interface ILampArrayStatics(ILampArrayStaticsVtbl, ILampArrayStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<LampArray> as RtType>::Abi) -> HRESULT
}}
impl ILampArrayStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LampArray>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampAvailabilityChangedEventArgs, 1332624877, 1954, 18845, 146, 96, 103, 227, 4, 83, 43, 164);
RT_INTERFACE!{interface ILampAvailabilityChangedEventArgs(ILampAvailabilityChangedEventArgsVtbl, ILampAvailabilityChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ILampAvailabilityChangedEventArgs] {
    fn get_IsAvailable(&self, out: *mut bool) -> HRESULT
}}
impl ILampAvailabilityChangedEventArgs {
    #[inline] pub fn get_is_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAvailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LampAvailabilityChangedEventArgs: ILampAvailabilityChangedEventArgs}
DEFINE_IID!(IID_ILampInfo, 817582620, 2767, 18906, 140, 16, 21, 11, 156, 246, 39, 19);
RT_INTERFACE!{interface ILampInfo(ILampInfoVtbl, ILampInfo_Abi): IInspectable(IInspectableVtbl) [IID_ILampInfo] {
    fn get_Index(&self, out: *mut i32) -> HRESULT,
    fn get_Purposes(&self, out: *mut LampPurposes) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_RedLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_GreenLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_BlueLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_GainLevelCount(&self, out: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FixedColor(&self, out: *mut <foundation::IReference<super::super::ui::Color> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn GetNearestSupportedColor(&self, desiredColor: super::super::ui::Color, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_UpdateLatency(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ILampInfo {
    #[inline] pub fn get_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Index)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_purposes(&self) -> Result<LampPurposes> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Purposes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RedLevelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GreenLevelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BlueLevelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gain_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GainLevelCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_fixed_color(&self) -> Result<Option<foundation::IReference<super::super::ui::Color>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FixedColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_nearest_supported_color(&self, desiredColor: super::super::ui::Color) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetNearestSupportedColor)(self.0.as_abi() as *const _ as *mut _, desiredColor, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_update_latency(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpdateLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LampInfo: ILampInfo}
RT_ENUM! { enum LampPurposes: u32 {
    Undefined = 0, Control = 1, Accent = 2, Branding = 4, Status = 8, Illumination = 16, Presentation = 32,
}}
DEFINE_IID!(IID_ILampStatics, 2820817260, 34949, 16414, 184, 33, 142, 139, 56, 168, 232, 236);
RT_INTERFACE!{static interface ILampStatics(ILampStaticsVtbl, ILampStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILampStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Lamp> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<Lamp> as RtType>::Abi) -> HRESULT
}}
impl ILampStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Lamp>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<Lamp>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
pub mod effects { // Windows.Devices.Lights.Effects
use crate::prelude::*;
DEFINE_IID!(IID_ILampArrayBitmapEffect, 842588261, 55415, 17959, 137, 229, 42, 136, 247, 5, 47, 166);
RT_INTERFACE!{interface ILampArrayBitmapEffect(ILampArrayBitmapEffectVtbl, ILampArrayBitmapEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapEffect] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_UpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_UpdateInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_SuggestedBitmapSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn add_BitmapRequested(&self, handler: <foundation::TypedEventHandler<LampArrayBitmapEffect, LampArrayBitmapRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BitmapRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILampArrayBitmapEffect {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpdateInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_update_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_UpdateInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suggested_bitmap_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SuggestedBitmapSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_bitmap_requested(&self, handler: &foundation::TypedEventHandler<LampArrayBitmapEffect, LampArrayBitmapRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BitmapRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_bitmap_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BitmapRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBitmapEffect: ILampArrayBitmapEffect}
impl RtActivatable<ILampArrayBitmapEffectFactory> for LampArrayBitmapEffect {}
impl LampArrayBitmapEffect {
    #[inline] pub fn create_instance(lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayBitmapEffect> {
        <Self as RtActivatable<ILampArrayBitmapEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayBitmapEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,66,105,116,109,97,112,69,102,102,101,99,116,0]) [CLSID_LampArrayBitmapEffect]);
DEFINE_IID!(IID_ILampArrayBitmapEffectFactory, 325091472, 58166, 19599, 144, 83, 169, 36, 7, 202, 123, 29);
RT_INTERFACE!{static interface ILampArrayBitmapEffectFactory(ILampArrayBitmapEffectFactoryVtbl, ILampArrayBitmapEffectFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapEffectFactory] {
    fn CreateInstance(&self, lampArray: <super::LampArray as RtType>::Abi, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut <LampArrayBitmapEffect as RtType>::Abi) -> HRESULT
}}
impl ILampArrayBitmapEffectFactory {
    #[inline] pub fn create_instance(&self, lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayBitmapEffect> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(lampArray) as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(LampArrayBitmapEffect::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayBitmapRequestedEventArgs, 3367284638, 65123, 19793, 186, 189, 97, 157, 239, 180, 84, 186);
RT_INTERFACE!{interface ILampArrayBitmapRequestedEventArgs(ILampArrayBitmapRequestedEventArgsVtbl, ILampArrayBitmapRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapRequestedEventArgs] {
    fn get_SinceStarted(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn UpdateBitmap(&self, bitmap: <crate::windows::graphics::imaging::SoftwareBitmap as RtType>::Abi) -> HRESULT
}}
impl ILampArrayBitmapRequestedEventArgs {
    #[inline] pub fn get_since_started(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SinceStarted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn update_bitmap(&self, bitmap: &crate::windows::graphics::imaging::SoftwareBitmap) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UpdateBitmap)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBitmapRequestedEventArgs: ILampArrayBitmapRequestedEventArgs}
DEFINE_IID!(IID_ILampArrayBlinkEffect, 3955176950, 12229, 19379, 179, 195, 98, 33, 167, 104, 13, 19);
RT_INTERFACE!{interface ILampArrayBlinkEffect(ILampArrayBlinkEffectVtbl, ILampArrayBlinkEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayBlinkEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_AttackDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_AttackDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_SustainDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_SustainDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_DecayDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DecayDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_RepetitionDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RepetitionDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Occurrences(&self, out: *mut i32) -> HRESULT,
    fn put_Occurrences(&self, value: i32) -> HRESULT,
    fn get_RepetitionMode(&self, out: *mut LampArrayRepetitionMode) -> HRESULT,
    fn put_RepetitionMode(&self, value: LampArrayRepetitionMode) -> HRESULT
}}
impl ILampArrayBlinkEffect {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Color)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Color)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_attack_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttackDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_attack_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AttackDuration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sustain_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SustainDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sustain_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SustainDuration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decay_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecayDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decay_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecayDuration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RepetitionDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RepetitionDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Occurrences)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Occurrences)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_mode(&self) -> Result<LampArrayRepetitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RepetitionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_mode(&self, value: LampArrayRepetitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RepetitionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBlinkEffect: ILampArrayBlinkEffect}
impl RtActivatable<ILampArrayBlinkEffectFactory> for LampArrayBlinkEffect {}
impl LampArrayBlinkEffect {
    #[inline] pub fn create_instance(lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayBlinkEffect> {
        <Self as RtActivatable<ILampArrayBlinkEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayBlinkEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,66,108,105,110,107,69,102,102,101,99,116,0]) [CLSID_LampArrayBlinkEffect]);
DEFINE_IID!(IID_ILampArrayBlinkEffectFactory, 2275351959, 40784, 18866, 165, 111, 1, 58, 160, 141, 85, 224);
RT_INTERFACE!{static interface ILampArrayBlinkEffectFactory(ILampArrayBlinkEffectFactoryVtbl, ILampArrayBlinkEffectFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayBlinkEffectFactory] {
    fn CreateInstance(&self, lampArray: <super::LampArray as RtType>::Abi, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut <LampArrayBlinkEffect as RtType>::Abi) -> HRESULT
}}
impl ILampArrayBlinkEffectFactory {
    #[inline] pub fn create_instance(&self, lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayBlinkEffect> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(lampArray) as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(LampArrayBlinkEffect::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayColorRampEffect, 721437751, 16551, 17198, 160, 185, 13, 87, 12, 33, 83, 255);
RT_INTERFACE!{interface ILampArrayColorRampEffect(ILampArrayColorRampEffectVtbl, ILampArrayColorRampEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayColorRampEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_RampDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RampDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_CompletionBehavior(&self, out: *mut LampArrayEffectCompletionBehavior) -> HRESULT,
    fn put_CompletionBehavior(&self, value: LampArrayEffectCompletionBehavior) -> HRESULT
}}
impl ILampArrayColorRampEffect {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Color)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Color)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ramp_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RampDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ramp_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RampDuration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completion_behavior(&self) -> Result<LampArrayEffectCompletionBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompletionBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completion_behavior(&self, value: LampArrayEffectCompletionBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CompletionBehavior)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayColorRampEffect: ILampArrayColorRampEffect}
impl RtActivatable<ILampArrayColorRampEffectFactory> for LampArrayColorRampEffect {}
impl LampArrayColorRampEffect {
    #[inline] pub fn create_instance(lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayColorRampEffect> {
        <Self as RtActivatable<ILampArrayColorRampEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayColorRampEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,67,111,108,111,114,82,97,109,112,69,102,102,101,99,116,0]) [CLSID_LampArrayColorRampEffect]);
DEFINE_IID!(IID_ILampArrayColorRampEffectFactory, 1376506163, 3188, 19957, 190, 167, 72, 153, 224, 38, 107, 15);
RT_INTERFACE!{static interface ILampArrayColorRampEffectFactory(ILampArrayColorRampEffectFactoryVtbl, ILampArrayColorRampEffectFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayColorRampEffectFactory] {
    fn CreateInstance(&self, lampArray: <super::LampArray as RtType>::Abi, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut <LampArrayColorRampEffect as RtType>::Abi) -> HRESULT
}}
impl ILampArrayColorRampEffectFactory {
    #[inline] pub fn create_instance(&self, lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayColorRampEffect> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(lampArray) as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(LampArrayColorRampEffect::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayCustomEffect, 3965161840, 15412, 18550, 129, 139, 87, 101, 247, 139, 14, 228);
RT_INTERFACE!{interface ILampArrayCustomEffect(ILampArrayCustomEffectVtbl, ILampArrayCustomEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayCustomEffect] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_UpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_UpdateInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn add_UpdateRequested(&self, handler: <foundation::TypedEventHandler<LampArrayCustomEffect, LampArrayUpdateRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILampArrayCustomEffect {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpdateInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_update_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_UpdateInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_update_requested(&self, handler: &foundation::TypedEventHandler<LampArrayCustomEffect, LampArrayUpdateRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_UpdateRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_UpdateRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayCustomEffect: ILampArrayCustomEffect}
impl RtActivatable<ILampArrayCustomEffectFactory> for LampArrayCustomEffect {}
impl LampArrayCustomEffect {
    #[inline] pub fn create_instance(lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayCustomEffect> {
        <Self as RtActivatable<ILampArrayCustomEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayCustomEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,67,117,115,116,111,109,69,102,102,101,99,116,0]) [CLSID_LampArrayCustomEffect]);
DEFINE_IID!(IID_ILampArrayCustomEffectFactory, 1756657485, 25573, 19184, 165, 139, 62, 83, 91, 148, 232, 201);
RT_INTERFACE!{static interface ILampArrayCustomEffectFactory(ILampArrayCustomEffectFactoryVtbl, ILampArrayCustomEffectFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayCustomEffectFactory] {
    fn CreateInstance(&self, lampArray: <super::LampArray as RtType>::Abi, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut <LampArrayCustomEffect as RtType>::Abi) -> HRESULT
}}
impl ILampArrayCustomEffectFactory {
    #[inline] pub fn create_instance(&self, lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArrayCustomEffect> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(lampArray) as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(LampArrayCustomEffect::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayEffect, 299128208, 22523, 17734, 177, 206, 134, 49, 7, 247, 64, 223);
RT_INTERFACE!{interface ILampArrayEffect(ILampArrayEffectVtbl, ILampArrayEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayEffect] {
    fn get_ZIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ZIndex(&self, value: i32) -> HRESULT
}}
impl ILampArrayEffect {
    #[inline] pub fn get_z_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ZIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_z_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ZIndex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum LampArrayEffectCompletionBehavior: i32 {
    ClearState = 0, KeepState = 1,
}}
DEFINE_IID!(IID_ILampArrayEffectPlaylist, 2112195582, 28513, 16643, 152, 199, 214, 99, 47, 123, 145, 105);
RT_INTERFACE!{interface ILampArrayEffectPlaylist(ILampArrayEffectPlaylistVtbl, ILampArrayEffectPlaylist_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayEffectPlaylist] {
    fn Append(&self, effect: <ILampArrayEffect as RtType>::Abi) -> HRESULT,
    fn OverrideZIndex(&self, zIndex: i32) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn get_EffectStartMode(&self, out: *mut LampArrayEffectStartMode) -> HRESULT,
    fn put_EffectStartMode(&self, value: LampArrayEffectStartMode) -> HRESULT,
    fn get_Occurrences(&self, out: *mut i32) -> HRESULT,
    fn put_Occurrences(&self, value: i32) -> HRESULT,
    fn get_RepetitionMode(&self, out: *mut LampArrayRepetitionMode) -> HRESULT,
    fn put_RepetitionMode(&self, value: LampArrayRepetitionMode) -> HRESULT
}}
impl ILampArrayEffectPlaylist {
    #[inline] pub fn append(&self, effect: &ILampArrayEffect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Append)(self.0.as_abi() as *const _ as *mut _, get_abi(effect) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn override_z_index(&self, zIndex: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OverrideZIndex)(self.0.as_abi() as *const _ as *mut _, zIndex);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Pause)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_effect_start_mode(&self) -> Result<LampArrayEffectStartMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EffectStartMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_effect_start_mode(&self, value: LampArrayEffectStartMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EffectStartMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Occurrences)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Occurrences)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_mode(&self) -> Result<LampArrayRepetitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RepetitionMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_mode(&self, value: LampArrayRepetitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RepetitionMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayEffectPlaylist: ILampArrayEffectPlaylist}
impl RtActivatable<ILampArrayEffectPlaylistStatics> for LampArrayEffectPlaylist {}
impl RtActivatable<IActivationFactory> for LampArrayEffectPlaylist {}
impl LampArrayEffectPlaylist {
    #[inline] pub fn start_all(value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().start_all(value)
    }
    #[inline] pub fn stop_all(value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().stop_all(value)
    }
    #[inline] pub fn pause_all(value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().pause_all(value)
    }
}
DEFINE_CLSID!(LampArrayEffectPlaylist(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,69,102,102,101,99,116,80,108,97,121,108,105,115,116,0]) [CLSID_LampArrayEffectPlaylist]);
DEFINE_IID!(IID_ILampArrayEffectPlaylistStatics, 4212466524, 59957, 19583, 160, 22, 243, 191, 198, 166, 196, 125);
RT_INTERFACE!{static interface ILampArrayEffectPlaylistStatics(ILampArrayEffectPlaylistStaticsVtbl, ILampArrayEffectPlaylistStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayEffectPlaylistStatics] {
    fn StartAll(&self, value: <foundation::collections::IIterable<LampArrayEffectPlaylist> as RtType>::Abi) -> HRESULT,
    fn StopAll(&self, value: <foundation::collections::IIterable<LampArrayEffectPlaylist> as RtType>::Abi) -> HRESULT,
    fn PauseAll(&self, value: <foundation::collections::IIterable<LampArrayEffectPlaylist> as RtType>::Abi) -> HRESULT
}}
impl ILampArrayEffectPlaylistStatics {
    #[inline] pub fn start_all(&self, value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StartAll)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_all(&self, value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).StopAll)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause_all(&self, value: &foundation::collections::IIterable<LampArrayEffectPlaylist>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PauseAll)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum LampArrayEffectStartMode: i32 {
    Sequential = 0, Simultaneous = 1,
}}
RT_ENUM! { enum LampArrayRepetitionMode: i32 {
    Occurrences = 0, Forever = 1,
}}
DEFINE_IID!(IID_ILampArraySolidEffect, 1142915603, 17356, 19251, 128, 235, 198, 221, 222, 125, 200, 237);
RT_INTERFACE!{interface ILampArraySolidEffect(ILampArraySolidEffectVtbl, ILampArraySolidEffect_Abi): IInspectable(IInspectableVtbl) [IID_ILampArraySolidEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_CompletionBehavior(&self, out: *mut LampArrayEffectCompletionBehavior) -> HRESULT,
    fn put_CompletionBehavior(&self, value: LampArrayEffectCompletionBehavior) -> HRESULT
}}
impl ILampArraySolidEffect {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Color)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Color)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StartDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StartDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completion_behavior(&self) -> Result<LampArrayEffectCompletionBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompletionBehavior)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completion_behavior(&self, value: LampArrayEffectCompletionBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CompletionBehavior)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArraySolidEffect: ILampArraySolidEffect}
impl RtActivatable<ILampArraySolidEffectFactory> for LampArraySolidEffect {}
impl LampArraySolidEffect {
    #[inline] pub fn create_instance(lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArraySolidEffect> {
        <Self as RtActivatable<ILampArraySolidEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArraySolidEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,83,111,108,105,100,69,102,102,101,99,116,0]) [CLSID_LampArraySolidEffect]);
DEFINE_IID!(IID_ILampArraySolidEffectFactory, 4167213868, 21878, 17217, 150, 27, 174, 225, 241, 60, 249, 221);
RT_INTERFACE!{static interface ILampArraySolidEffectFactory(ILampArraySolidEffectFactoryVtbl, ILampArraySolidEffectFactory_Abi): IInspectable(IInspectableVtbl) [IID_ILampArraySolidEffectFactory] {
    fn CreateInstance(&self, lampArray: <super::LampArray as RtType>::Abi, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut <LampArraySolidEffect as RtType>::Abi) -> HRESULT
}}
impl ILampArraySolidEffectFactory {
    #[inline] pub fn create_instance(&self, lampArray: &super::LampArray, lampIndexes: &[i32]) -> Result<LampArraySolidEffect> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, get_abi(lampArray) as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(LampArraySolidEffect::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayUpdateRequestedEventArgs, 1935019370, 22378, 18607, 133, 57, 103, 255, 160, 171, 53, 22);
RT_INTERFACE!{interface ILampArrayUpdateRequestedEventArgs(ILampArrayUpdateRequestedEventArgsVtbl, ILampArrayUpdateRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ILampArrayUpdateRequestedEventArgs] {
    fn get_SinceStarted(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColor(&self, desiredColor: crate::windows::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColorForIndex(&self, lampIndex: i32, desiredColor: crate::windows::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetSingleColorForIndices(&self, desiredColor: crate::windows::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColorsForIndices(&self, desiredColorsSize: u32, desiredColors: *mut crate::windows::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT
}}
impl ILampArrayUpdateRequestedEventArgs {
    #[inline] pub fn get_since_started(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SinceStarted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, desiredColor: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColor)(self.0.as_abi() as *const _ as *mut _, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color_for_index(&self, lampIndex: i32, desiredColor: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorForIndex)(self.0.as_abi() as *const _ as *mut _, lampIndex, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_single_color_for_indices(&self, desiredColor: crate::windows::ui::Color, lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSingleColorForIndices)(self.0.as_abi() as *const _ as *mut _, desiredColor, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_indices(&self, desiredColors: &[crate::windows::ui::Color], lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetColorsForIndices)(self.0.as_abi() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayUpdateRequestedEventArgs: ILampArrayUpdateRequestedEventArgs}
} // Windows.Devices.Lights.Effects
} // Windows.Devices.Lights
pub mod midi { // Windows.Devices.Midi
use crate::prelude::*;
RT_CLASS!{class MidiActiveSensingMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiActiveSensingMessage {}
DEFINE_CLSID!(MidiActiveSensingMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,65,99,116,105,118,101,83,101,110,115,105,110,103,77,101,115,115,97,103,101,0]) [CLSID_MidiActiveSensingMessage]);
DEFINE_IID!(IID_IMidiChannelPressureMessage, 3189745760, 25268, 19794, 163, 126, 146, 229, 77, 53, 185, 9);
RT_INTERFACE!{interface IMidiChannelPressureMessage(IMidiChannelPressureMessageVtbl, IMidiChannelPressureMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Pressure(&self, out: *mut u8) -> HRESULT
}}
impl IMidiChannelPressureMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pressure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiChannelPressureMessage: IMidiChannelPressureMessage}
impl RtActivatable<IMidiChannelPressureMessageFactory> for MidiChannelPressureMessage {}
impl MidiChannelPressureMessage {
    #[inline] pub fn create_midi_channel_pressure_message(channel: u8, pressure: u8) -> Result<MidiChannelPressureMessage> {
        <Self as RtActivatable<IMidiChannelPressureMessageFactory>>::get_activation_factory().create_midi_channel_pressure_message(channel, pressure)
    }
}
DEFINE_CLSID!(MidiChannelPressureMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,104,97,110,110,101,108,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]) [CLSID_MidiChannelPressureMessage]);
DEFINE_IID!(IID_IMidiChannelPressureMessageFactory, 1645800751, 8836, 16682, 148, 207, 16, 251, 4, 132, 44, 108);
RT_INTERFACE!{static interface IMidiChannelPressureMessageFactory(IMidiChannelPressureMessageFactoryVtbl, IMidiChannelPressureMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessageFactory] {
    fn CreateMidiChannelPressureMessage(&self, channel: u8, pressure: u8, out: *mut <MidiChannelPressureMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiChannelPressureMessageFactory {
    #[inline] pub fn create_midi_channel_pressure_message(&self, channel: u8, pressure: u8) -> Result<MidiChannelPressureMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiChannelPressureMessage)(self.0.as_abi() as *const _ as *mut _, channel, pressure, &mut out);
        if hr == S_OK { Ok(MidiChannelPressureMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiContinueMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiContinueMessage {}
DEFINE_CLSID!(MidiContinueMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,111,110,116,105,110,117,101,77,101,115,115,97,103,101,0]) [CLSID_MidiContinueMessage]);
DEFINE_IID!(IID_IMidiControlChangeMessage, 3085000579, 30733, 16479, 183, 129, 62, 21, 152, 201, 127, 64);
RT_INTERFACE!{interface IMidiControlChangeMessage(IMidiControlChangeMessageVtbl, IMidiControlChangeMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Controller(&self, out: *mut u8) -> HRESULT,
    fn get_ControlValue(&self, out: *mut u8) -> HRESULT
}}
impl IMidiControlChangeMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_controller(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Controller)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control_value(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiControlChangeMessage: IMidiControlChangeMessage}
impl RtActivatable<IMidiControlChangeMessageFactory> for MidiControlChangeMessage {}
impl MidiControlChangeMessage {
    #[inline] pub fn create_midi_control_change_message(channel: u8, controller: u8, controlValue: u8) -> Result<MidiControlChangeMessage> {
        <Self as RtActivatable<IMidiControlChangeMessageFactory>>::get_activation_factory().create_midi_control_change_message(channel, controller, controlValue)
    }
}
DEFINE_CLSID!(MidiControlChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,111,110,116,114,111,108,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiControlChangeMessage]);
DEFINE_IID!(IID_IMidiControlChangeMessageFactory, 716260129, 38252, 18093, 151, 82, 248, 127, 85, 5, 47, 227);
RT_INTERFACE!{static interface IMidiControlChangeMessageFactory(IMidiControlChangeMessageFactoryVtbl, IMidiControlChangeMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessageFactory] {
    fn CreateMidiControlChangeMessage(&self, channel: u8, controller: u8, controlValue: u8, out: *mut <MidiControlChangeMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiControlChangeMessageFactory {
    #[inline] pub fn create_midi_control_change_message(&self, channel: u8, controller: u8, controlValue: u8) -> Result<MidiControlChangeMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiControlChangeMessage)(self.0.as_abi() as *const _ as *mut _, channel, controller, controlValue, &mut out);
        if hr == S_OK { Ok(MidiControlChangeMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiInPort, 3586251227, 38682, 20143, 162, 61, 234, 25, 254, 96, 127, 249);
RT_INTERFACE!{interface IMidiInPort(IMidiInPortVtbl, IMidiInPort_Abi): IInspectable(IInspectableVtbl) [IID_IMidiInPort] {
    fn add_MessageReceived(&self, handler: <foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMidiInPort {
    #[inline] pub fn add_message_received(&self, handler: &foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MessageReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MessageReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiInPort: IMidiInPort}
impl RtActivatable<IMidiInPortStatics> for MidiInPort {}
impl MidiInPort {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<MidiInPort>> {
        <Self as RtActivatable<IMidiInPortStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMidiInPortStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(MidiInPort(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,73,110,80,111,114,116,0]) [CLSID_MidiInPort]);
DEFINE_IID!(IID_IMidiInPortStatics, 1153710556, 26623, 19054, 139, 172, 253, 182, 97, 12, 242, 150);
RT_INTERFACE!{static interface IMidiInPortStatics(IMidiInPortStaticsVtbl, IMidiInPortStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMidiInPortStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<MidiInPort> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMidiInPortStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<MidiInPort>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiMessage, 2037807429, 4244, 17027, 155, 224, 40, 159, 192, 238, 131, 52);
RT_INTERFACE!{interface IMidiMessage(IMidiMessageVtbl, IMidiMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiMessage] {
    fn get_Timestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_RawData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Type(&self, out: *mut MidiMessageType) -> HRESULT
}}
impl IMidiMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_raw_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RawData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<MidiMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Type)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiMessageReceivedEventArgs, 1985375830, 62248, 19281, 144, 125, 179, 168, 206, 150, 191, 128);
RT_INTERFACE!{interface IMidiMessageReceivedEventArgs(IMidiMessageReceivedEventArgsVtbl, IMidiMessageReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMidiMessageReceivedEventArgs] {
    fn get_Message(&self, out: *mut <IMidiMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiMessageReceivedEventArgs {
    #[inline] pub fn get_message(&self) -> Result<Option<IMidiMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Message)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IMidiMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiMessageReceivedEventArgs: IMidiMessageReceivedEventArgs}
RT_ENUM! { enum MidiMessageType: i32 {
    None = 0, NoteOff = 128, NoteOn = 144, PolyphonicKeyPressure = 160, ControlChange = 176, ProgramChange = 192, ChannelPressure = 208, PitchBendChange = 224, SystemExclusive = 240, MidiTimeCode = 241, SongPositionPointer = 242, SongSelect = 243, TuneRequest = 246, EndSystemExclusive = 247, TimingClock = 248, Start = 250, Continue = 251, Stop = 252, ActiveSensing = 254, SystemReset = 255,
}}
DEFINE_IID!(IID_IMidiNoteOffMessage, 385714932, 6542, 19855, 166, 84, 211, 5, 162, 147, 84, 143);
RT_INTERFACE!{interface IMidiNoteOffMessage(IMidiNoteOffMessageVtbl, IMidiNoteOffMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Velocity(&self, out: *mut u8) -> HRESULT
}}
impl IMidiNoteOffMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Note)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocity(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Velocity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiNoteOffMessage: IMidiNoteOffMessage}
impl RtActivatable<IMidiNoteOffMessageFactory> for MidiNoteOffMessage {}
impl MidiNoteOffMessage {
    #[inline] pub fn create_midi_note_off_message(channel: u8, note: u8, velocity: u8) -> Result<MidiNoteOffMessage> {
        <Self as RtActivatable<IMidiNoteOffMessageFactory>>::get_activation_factory().create_midi_note_off_message(channel, note, velocity)
    }
}
DEFINE_CLSID!(MidiNoteOffMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,102,102,77,101,115,115,97,103,101,0]) [CLSID_MidiNoteOffMessage]);
DEFINE_IID!(IID_IMidiNoteOffMessageFactory, 2796699872, 42825, 16991, 138, 244, 164, 217, 121, 204, 21, 181);
RT_INTERFACE!{static interface IMidiNoteOffMessageFactory(IMidiNoteOffMessageFactoryVtbl, IMidiNoteOffMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessageFactory] {
    fn CreateMidiNoteOffMessage(&self, channel: u8, note: u8, velocity: u8, out: *mut <MidiNoteOffMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiNoteOffMessageFactory {
    #[inline] pub fn create_midi_note_off_message(&self, channel: u8, note: u8, velocity: u8) -> Result<MidiNoteOffMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiNoteOffMessage)(self.0.as_abi() as *const _ as *mut _, channel, note, velocity, &mut out);
        if hr == S_OK { Ok(MidiNoteOffMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiNoteOnMessage, 3760343797, 24961, 18141, 175, 162, 65, 0, 4, 192, 87, 170);
RT_INTERFACE!{interface IMidiNoteOnMessage(IMidiNoteOnMessageVtbl, IMidiNoteOnMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Velocity(&self, out: *mut u8) -> HRESULT
}}
impl IMidiNoteOnMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Note)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocity(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Velocity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiNoteOnMessage: IMidiNoteOnMessage}
impl RtActivatable<IMidiNoteOnMessageFactory> for MidiNoteOnMessage {}
impl MidiNoteOnMessage {
    #[inline] pub fn create_midi_note_on_message(channel: u8, note: u8, velocity: u8) -> Result<MidiNoteOnMessage> {
        <Self as RtActivatable<IMidiNoteOnMessageFactory>>::get_activation_factory().create_midi_note_on_message(channel, note, velocity)
    }
}
DEFINE_CLSID!(MidiNoteOnMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,110,77,101,115,115,97,103,101,0]) [CLSID_MidiNoteOnMessage]);
DEFINE_IID!(IID_IMidiNoteOnMessageFactory, 2604826784, 22977, 16910, 181, 23, 21, 161, 10, 169, 96, 107);
RT_INTERFACE!{static interface IMidiNoteOnMessageFactory(IMidiNoteOnMessageFactoryVtbl, IMidiNoteOnMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessageFactory] {
    fn CreateMidiNoteOnMessage(&self, channel: u8, note: u8, velocity: u8, out: *mut <MidiNoteOnMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiNoteOnMessageFactory {
    #[inline] pub fn create_midi_note_on_message(&self, channel: u8, note: u8, velocity: u8) -> Result<MidiNoteOnMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiNoteOnMessage)(self.0.as_abi() as *const _ as *mut _, channel, note, velocity, &mut out);
        if hr == S_OK { Ok(MidiNoteOnMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiOutPort, 2468179359, 22434, 19002, 173, 184, 70, 64, 136, 111, 102, 147);
RT_INTERFACE!{interface IMidiOutPort(IMidiOutPortVtbl, IMidiOutPort_Abi): IInspectable(IInspectableVtbl) [IID_IMidiOutPort] {
    fn SendMessage(&self, midiMessage: <IMidiMessage as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendBuffer(&self, midiData: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMidiOutPort {
    #[inline] pub fn send_message(&self, midiMessage: &IMidiMessage) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendMessage)(self.0.as_abi() as *const _ as *mut _, get_abi(midiMessage) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_buffer(&self, midiData: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SendBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(midiData) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiOutPort: IMidiOutPort}
impl RtActivatable<IMidiOutPortStatics> for MidiOutPort {}
impl MidiOutPort {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<IMidiOutPort>> {
        <Self as RtActivatable<IMidiOutPortStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMidiOutPortStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(MidiOutPort(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,79,117,116,80,111,114,116,0]) [CLSID_MidiOutPort]);
DEFINE_IID!(IID_IMidiOutPortStatics, 106742761, 3976, 17547, 155, 100, 169, 88, 38, 198, 91, 143);
RT_INTERFACE!{static interface IMidiOutPortStatics(IMidiOutPortStaticsVtbl, IMidiOutPortStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMidiOutPortStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<IMidiOutPort> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMidiOutPortStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<IMidiOutPort>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiPitchBendChangeMessage, 702500017, 11935, 20399, 140, 43, 156, 184, 42, 144, 121, 202);
RT_INTERFACE!{interface IMidiPitchBendChangeMessage(IMidiPitchBendChangeMessageVtbl, IMidiPitchBendChangeMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Bend(&self, out: *mut u16) -> HRESULT
}}
impl IMidiPitchBendChangeMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bend(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bend)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiPitchBendChangeMessage: IMidiPitchBendChangeMessage}
impl RtActivatable<IMidiPitchBendChangeMessageFactory> for MidiPitchBendChangeMessage {}
impl MidiPitchBendChangeMessage {
    #[inline] pub fn create_midi_pitch_bend_change_message(channel: u8, bend: u16) -> Result<MidiPitchBendChangeMessage> {
        <Self as RtActivatable<IMidiPitchBendChangeMessageFactory>>::get_activation_factory().create_midi_pitch_bend_change_message(channel, bend)
    }
}
DEFINE_CLSID!(MidiPitchBendChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,105,116,99,104,66,101,110,100,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiPitchBendChangeMessage]);
DEFINE_IID!(IID_IMidiPitchBendChangeMessageFactory, 4126072661, 53192, 18726, 179, 14, 163, 98, 35, 147, 48, 108);
RT_INTERFACE!{static interface IMidiPitchBendChangeMessageFactory(IMidiPitchBendChangeMessageFactoryVtbl, IMidiPitchBendChangeMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessageFactory] {
    fn CreateMidiPitchBendChangeMessage(&self, channel: u8, bend: u16, out: *mut <MidiPitchBendChangeMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiPitchBendChangeMessageFactory {
    #[inline] pub fn create_midi_pitch_bend_change_message(&self, channel: u8, bend: u16) -> Result<MidiPitchBendChangeMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiPitchBendChangeMessage)(self.0.as_abi() as *const _ as *mut _, channel, bend, &mut out);
        if hr == S_OK { Ok(MidiPitchBendChangeMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessage, 527644670, 44264, 18592, 134, 142, 124, 219, 242, 15, 4, 214);
RT_INTERFACE!{interface IMidiPolyphonicKeyPressureMessage(IMidiPolyphonicKeyPressureMessageVtbl, IMidiPolyphonicKeyPressureMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Pressure(&self, out: *mut u8) -> HRESULT
}}
impl IMidiPolyphonicKeyPressureMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Note)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pressure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiPolyphonicKeyPressureMessage: IMidiPolyphonicKeyPressureMessage}
impl RtActivatable<IMidiPolyphonicKeyPressureMessageFactory> for MidiPolyphonicKeyPressureMessage {}
impl MidiPolyphonicKeyPressureMessage {
    #[inline] pub fn create_midi_polyphonic_key_pressure_message(channel: u8, note: u8, pressure: u8) -> Result<MidiPolyphonicKeyPressureMessage> {
        <Self as RtActivatable<IMidiPolyphonicKeyPressureMessageFactory>>::get_activation_factory().create_midi_polyphonic_key_pressure_message(channel, note, pressure)
    }
}
DEFINE_CLSID!(MidiPolyphonicKeyPressureMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,111,108,121,112,104,111,110,105,99,75,101,121,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]) [CLSID_MidiPolyphonicKeyPressureMessage]);
DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessageFactory, 3918481470, 50355, 19922, 145, 124, 227, 73, 129, 90, 27, 59);
RT_INTERFACE!{static interface IMidiPolyphonicKeyPressureMessageFactory(IMidiPolyphonicKeyPressureMessageFactoryVtbl, IMidiPolyphonicKeyPressureMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessageFactory] {
    fn CreateMidiPolyphonicKeyPressureMessage(&self, channel: u8, note: u8, pressure: u8, out: *mut <MidiPolyphonicKeyPressureMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiPolyphonicKeyPressureMessageFactory {
    #[inline] pub fn create_midi_polyphonic_key_pressure_message(&self, channel: u8, note: u8, pressure: u8) -> Result<MidiPolyphonicKeyPressureMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiPolyphonicKeyPressureMessage)(self.0.as_abi() as *const _ as *mut _, channel, note, pressure, &mut out);
        if hr == S_OK { Ok(MidiPolyphonicKeyPressureMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiProgramChangeMessage, 2629516408, 31294, 17191, 170, 152, 32, 184, 228, 72, 90, 248);
RT_INTERFACE!{interface IMidiProgramChangeMessage(IMidiProgramChangeMessageVtbl, IMidiProgramChangeMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Program(&self, out: *mut u8) -> HRESULT
}}
impl IMidiProgramChangeMessage {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_program(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Program)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiProgramChangeMessage: IMidiProgramChangeMessage}
impl RtActivatable<IMidiProgramChangeMessageFactory> for MidiProgramChangeMessage {}
impl MidiProgramChangeMessage {
    #[inline] pub fn create_midi_program_change_message(channel: u8, program: u8) -> Result<MidiProgramChangeMessage> {
        <Self as RtActivatable<IMidiProgramChangeMessageFactory>>::get_activation_factory().create_midi_program_change_message(channel, program)
    }
}
DEFINE_CLSID!(MidiProgramChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,114,111,103,114,97,109,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiProgramChangeMessage]);
DEFINE_IID!(IID_IMidiProgramChangeMessageFactory, 3601875847, 21067, 16644, 156, 153, 101, 114, 191, 210, 226, 97);
RT_INTERFACE!{static interface IMidiProgramChangeMessageFactory(IMidiProgramChangeMessageFactoryVtbl, IMidiProgramChangeMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessageFactory] {
    fn CreateMidiProgramChangeMessage(&self, channel: u8, program: u8, out: *mut <MidiProgramChangeMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiProgramChangeMessageFactory {
    #[inline] pub fn create_midi_program_change_message(&self, channel: u8, program: u8) -> Result<MidiProgramChangeMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiProgramChangeMessage)(self.0.as_abi() as *const _ as *mut _, channel, program, &mut out);
        if hr == S_OK { Ok(MidiProgramChangeMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiSongPositionPointerMessage, 1285885014, 60510, 19172, 161, 21, 136, 220, 87, 204, 43, 121);
RT_INTERFACE!{interface IMidiSongPositionPointerMessage(IMidiSongPositionPointerMessageVtbl, IMidiSongPositionPointerMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessage] {
    fn get_Beats(&self, out: *mut u16) -> HRESULT
}}
impl IMidiSongPositionPointerMessage {
    #[inline] pub fn get_beats(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Beats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSongPositionPointerMessage: IMidiSongPositionPointerMessage}
impl RtActivatable<IMidiSongPositionPointerMessageFactory> for MidiSongPositionPointerMessage {}
impl MidiSongPositionPointerMessage {
    #[inline] pub fn create_midi_song_position_pointer_message(beats: u16) -> Result<MidiSongPositionPointerMessage> {
        <Self as RtActivatable<IMidiSongPositionPointerMessageFactory>>::get_activation_factory().create_midi_song_position_pointer_message(beats)
    }
}
DEFINE_CLSID!(MidiSongPositionPointerMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,80,111,115,105,116,105,111,110,80,111,105,110,116,101,114,77,101,115,115,97,103,101,0]) [CLSID_MidiSongPositionPointerMessage]);
DEFINE_IID!(IID_IMidiSongPositionPointerMessageFactory, 2617305494, 61707, 20458, 179, 149, 245, 214, 207, 128, 246, 78);
RT_INTERFACE!{static interface IMidiSongPositionPointerMessageFactory(IMidiSongPositionPointerMessageFactoryVtbl, IMidiSongPositionPointerMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessageFactory] {
    fn CreateMidiSongPositionPointerMessage(&self, beats: u16, out: *mut <MidiSongPositionPointerMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiSongPositionPointerMessageFactory {
    #[inline] pub fn create_midi_song_position_pointer_message(&self, beats: u16) -> Result<MidiSongPositionPointerMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiSongPositionPointerMessage)(self.0.as_abi() as *const _ as *mut _, beats, &mut out);
        if hr == S_OK { Ok(MidiSongPositionPointerMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiSongSelectMessage, 1240527487, 28035, 18241, 165, 191, 70, 41, 246, 190, 151, 79);
RT_INTERFACE!{interface IMidiSongSelectMessage(IMidiSongSelectMessageVtbl, IMidiSongSelectMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessage] {
    fn get_Song(&self, out: *mut u8) -> HRESULT
}}
impl IMidiSongSelectMessage {
    #[inline] pub fn get_song(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Song)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSongSelectMessage: IMidiSongSelectMessage}
impl RtActivatable<IMidiSongSelectMessageFactory> for MidiSongSelectMessage {}
impl MidiSongSelectMessage {
    #[inline] pub fn create_midi_song_select_message(song: u8) -> Result<MidiSongSelectMessage> {
        <Self as RtActivatable<IMidiSongSelectMessageFactory>>::get_activation_factory().create_midi_song_select_message(song)
    }
}
DEFINE_CLSID!(MidiSongSelectMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,83,101,108,101,99,116,77,101,115,115,97,103,101,0]) [CLSID_MidiSongSelectMessage]);
DEFINE_IID!(IID_IMidiSongSelectMessageFactory, 2223536356, 34632, 16681, 166, 108, 160, 84, 147, 247, 93, 170);
RT_INTERFACE!{static interface IMidiSongSelectMessageFactory(IMidiSongSelectMessageFactoryVtbl, IMidiSongSelectMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessageFactory] {
    fn CreateMidiSongSelectMessage(&self, song: u8, out: *mut <MidiSongSelectMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiSongSelectMessageFactory {
    #[inline] pub fn create_midi_song_select_message(&self, song: u8) -> Result<MidiSongSelectMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiSongSelectMessage)(self.0.as_abi() as *const _ as *mut _, song, &mut out);
        if hr == S_OK { Ok(MidiSongSelectMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiStartMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiStartMessage {}
DEFINE_CLSID!(MidiStartMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,116,97,114,116,77,101,115,115,97,103,101,0]) [CLSID_MidiStartMessage]);
RT_CLASS!{class MidiStopMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiStopMessage {}
DEFINE_CLSID!(MidiStopMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,116,111,112,77,101,115,115,97,103,101,0]) [CLSID_MidiStopMessage]);
DEFINE_IID!(IID_IMidiSynthesizer, 4040824158, 56208, 16479, 184, 174, 33, 210, 225, 127, 46, 69);
RT_INTERFACE!{interface IMidiSynthesizer(IMidiSynthesizerVtbl, IMidiSynthesizer_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizer] {
    fn get_AudioDevice(&self, out: *mut <super::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT
}}
impl IMidiSynthesizer {
    #[inline] pub fn get_audio_device(&self) -> Result<Option<super::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AudioDevice)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Volume)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Volume)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSynthesizer: IMidiSynthesizer}
impl RtActivatable<IMidiSynthesizerStatics> for MidiSynthesizer {}
impl MidiSynthesizer {
    #[inline] pub fn create_async() -> Result<foundation::IAsyncOperation<MidiSynthesizer>> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().create_async()
    }
    #[inline] pub fn create_from_audio_device_async(audioDevice: &super::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<MidiSynthesizer>> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().create_from_audio_device_async(audioDevice)
    }
    #[inline] pub fn is_synthesizer(midiDevice: &super::enumeration::DeviceInformation) -> Result<bool> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().is_synthesizer(midiDevice)
    }
}
DEFINE_CLSID!(MidiSynthesizer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,110,116,104,101,115,105,122,101,114,0]) [CLSID_MidiSynthesizer]);
DEFINE_IID!(IID_IMidiSynthesizerStatics, 1109715624, 26153, 19819, 170, 143, 212, 82, 26, 90, 49, 206);
RT_INTERFACE!{static interface IMidiSynthesizerStatics(IMidiSynthesizerStaticsVtbl, IMidiSynthesizerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizerStatics] {
    fn CreateAsync(&self, out: *mut <foundation::IAsyncOperation<MidiSynthesizer> as RtType>::Abi) -> HRESULT,
    fn CreateFromAudioDeviceAsync(&self, audioDevice: <super::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<MidiSynthesizer> as RtType>::Abi) -> HRESULT,
    fn IsSynthesizer(&self, midiDevice: <super::enumeration::DeviceInformation as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl IMidiSynthesizerStatics {
    #[inline] pub fn create_async(&self) -> Result<foundation::IAsyncOperation<MidiSynthesizer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_audio_device_async(&self, audioDevice: &super::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<MidiSynthesizer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromAudioDeviceAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(audioDevice) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_synthesizer(&self, midiDevice: &super::enumeration::DeviceInformation) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSynthesizer)(self.0.as_abi() as *const _ as *mut _, get_abi(midiDevice) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSystemExclusiveMessage: IMidiMessage}
impl RtActivatable<IMidiSystemExclusiveMessageFactory> for MidiSystemExclusiveMessage {}
impl MidiSystemExclusiveMessage {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_midi_system_exclusive_message(rawData: &super::super::storage::streams::IBuffer) -> Result<MidiSystemExclusiveMessage> {
        <Self as RtActivatable<IMidiSystemExclusiveMessageFactory>>::get_activation_factory().create_midi_system_exclusive_message(rawData)
    }
}
DEFINE_CLSID!(MidiSystemExclusiveMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,115,116,101,109,69,120,99,108,117,115,105,118,101,77,101,115,115,97,103,101,0]) [CLSID_MidiSystemExclusiveMessage]);
DEFINE_IID!(IID_IMidiSystemExclusiveMessageFactory, 138273314, 15220, 17184, 155, 66, 12, 168, 84, 95, 138, 36);
RT_INTERFACE!{static interface IMidiSystemExclusiveMessageFactory(IMidiSystemExclusiveMessageFactoryVtbl, IMidiSystemExclusiveMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiSystemExclusiveMessageFactory] {
    #[cfg(feature="windows-storage")] fn CreateMidiSystemExclusiveMessage(&self, rawData: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <MidiSystemExclusiveMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiSystemExclusiveMessageFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_midi_system_exclusive_message(&self, rawData: &super::super::storage::streams::IBuffer) -> Result<MidiSystemExclusiveMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiSystemExclusiveMessage)(self.0.as_abi() as *const _ as *mut _, get_abi(rawData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MidiSystemExclusiveMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSystemResetMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiSystemResetMessage {}
DEFINE_CLSID!(MidiSystemResetMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,115,116,101,109,82,101,115,101,116,77,101,115,115,97,103,101,0]) [CLSID_MidiSystemResetMessage]);
DEFINE_IID!(IID_IMidiTimeCodeMessage, 200738941, 64099, 18972, 141, 235, 192, 232, 119, 150, 166, 215);
RT_INTERFACE!{interface IMidiTimeCodeMessage(IMidiTimeCodeMessageVtbl, IMidiTimeCodeMessage_Abi): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessage] {
    fn get_FrameType(&self, out: *mut u8) -> HRESULT,
    fn get_Values(&self, out: *mut u8) -> HRESULT
}}
impl IMidiTimeCodeMessage {
    #[inline] pub fn get_frame_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_values(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Values)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiTimeCodeMessage: IMidiTimeCodeMessage}
impl RtActivatable<IMidiTimeCodeMessageFactory> for MidiTimeCodeMessage {}
impl MidiTimeCodeMessage {
    #[inline] pub fn create_midi_time_code_message(frameType: u8, values: u8) -> Result<MidiTimeCodeMessage> {
        <Self as RtActivatable<IMidiTimeCodeMessageFactory>>::get_activation_factory().create_midi_time_code_message(frameType, values)
    }
}
DEFINE_CLSID!(MidiTimeCodeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,105,109,101,67,111,100,101,77,101,115,115,97,103,101,0]) [CLSID_MidiTimeCodeMessage]);
DEFINE_IID!(IID_IMidiTimeCodeMessageFactory, 3945830853, 30492, 16606, 185, 97, 23, 90, 116, 137, 168, 94);
RT_INTERFACE!{static interface IMidiTimeCodeMessageFactory(IMidiTimeCodeMessageFactoryVtbl, IMidiTimeCodeMessageFactory_Abi): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessageFactory] {
    fn CreateMidiTimeCodeMessage(&self, frameType: u8, values: u8, out: *mut <MidiTimeCodeMessage as RtType>::Abi) -> HRESULT
}}
impl IMidiTimeCodeMessageFactory {
    #[inline] pub fn create_midi_time_code_message(&self, frameType: u8, values: u8) -> Result<MidiTimeCodeMessage> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateMidiTimeCodeMessage)(self.0.as_abi() as *const _ as *mut _, frameType, values, &mut out);
        if hr == S_OK { Ok(MidiTimeCodeMessage::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiTimingClockMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiTimingClockMessage {}
DEFINE_CLSID!(MidiTimingClockMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,105,109,105,110,103,67,108,111,99,107,77,101,115,115,97,103,101,0]) [CLSID_MidiTimingClockMessage]);
RT_CLASS!{class MidiTuneRequestMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiTuneRequestMessage {}
DEFINE_CLSID!(MidiTuneRequestMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,117,110,101,82,101,113,117,101,115,116,77,101,115,115,97,103,101,0]) [CLSID_MidiTuneRequestMessage]);
} // Windows.Devices.Midi
pub mod perception { // Windows.Devices.Perception
use crate::prelude::*;
RT_CLASS!{static class KnownCameraIntrinsicsProperties}
impl RtActivatable<IKnownCameraIntrinsicsPropertiesStatics> for KnownCameraIntrinsicsProperties {}
impl KnownCameraIntrinsicsProperties {
    #[inline] pub fn get_focal_length() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_focal_length()
    }
    #[inline] pub fn get_principal_point() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_principal_point()
    }
    #[inline] pub fn get_radial_distortion() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_radial_distortion()
    }
    #[inline] pub fn get_tangential_distortion() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_tangential_distortion()
    }
}
DEFINE_CLSID!(KnownCameraIntrinsicsProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,67,97,109,101,114,97,73,110,116,114,105,110,115,105,99,115,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownCameraIntrinsicsProperties]);
DEFINE_IID!(IID_IKnownCameraIntrinsicsPropertiesStatics, 146815352, 17274, 19863, 166, 99, 253, 49, 149, 96, 2, 73);
RT_INTERFACE!{static interface IKnownCameraIntrinsicsPropertiesStatics(IKnownCameraIntrinsicsPropertiesStaticsVtbl, IKnownCameraIntrinsicsPropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownCameraIntrinsicsPropertiesStatics] {
    fn get_FocalLength(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PrincipalPoint(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RadialDistortion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TangentialDistortion(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownCameraIntrinsicsPropertiesStatics {
    #[inline] pub fn get_focal_length(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FocalLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_principal_point(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrincipalPoint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_radial_distortion(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RadialDistortion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tangential_distortion(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TangentialDistortion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionColorFrameSourceProperties}
impl RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics> for KnownPerceptionColorFrameSourceProperties {}
impl KnownPerceptionColorFrameSourceProperties {
    #[inline] pub fn get_exposure() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure()
    }
    #[inline] pub fn get_auto_exposure_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_auto_exposure_enabled()
    }
    #[inline] pub fn get_exposure_compensation() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure_compensation()
    }
}
DEFINE_CLSID!(KnownPerceptionColorFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionColorFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionColorFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 75);
RT_INTERFACE!{static interface IKnownPerceptionColorFrameSourcePropertiesStatics(IKnownPerceptionColorFrameSourcePropertiesStaticsVtbl, IKnownPerceptionColorFrameSourcePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionColorFrameSourcePropertiesStatics] {
    fn get_Exposure(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoExposureEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionColorFrameSourcePropertiesStatics {
    #[inline] pub fn get_exposure(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exposure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoExposureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionDepthFrameSourceProperties}
impl RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics> for KnownPerceptionDepthFrameSourceProperties {}
impl KnownPerceptionDepthFrameSourceProperties {
    #[inline] pub fn get_min_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics>>::get_activation_factory().get_min_depth()
    }
    #[inline] pub fn get_max_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics>>::get_activation_factory().get_max_depth()
    }
}
DEFINE_CLSID!(KnownPerceptionDepthFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionDepthFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionDepthFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 74);
RT_INTERFACE!{static interface IKnownPerceptionDepthFrameSourcePropertiesStatics(IKnownPerceptionDepthFrameSourcePropertiesStaticsVtbl, IKnownPerceptionDepthFrameSourcePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionDepthFrameSourcePropertiesStatics] {
    fn get_MinDepth(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxDepth(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionDepthFrameSourcePropertiesStatics {
    #[inline] pub fn get_min_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinDepth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxDepth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionFrameSourceProperties}
impl RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics> for KnownPerceptionFrameSourceProperties {}
impl RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics2> for KnownPerceptionFrameSourceProperties {}
impl KnownPerceptionFrameSourceProperties {
    #[inline] pub fn get_id() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_id()
    }
    #[inline] pub fn get_physical_device_ids() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_physical_device_ids()
    }
    #[inline] pub fn get_frame_kind() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_frame_kind()
    }
    #[inline] pub fn get_device_model_version() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_device_model_version()
    }
    #[inline] pub fn get_enclosure_location() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_enclosure_location()
    }
    #[inline] pub fn get_device_id() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics2>>::get_activation_factory().get_device_id()
    }
}
DEFINE_CLSID!(KnownPerceptionFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics(IKnownPerceptionFrameSourcePropertiesStaticsVtbl, IKnownPerceptionFrameSourcePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceIds(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FrameKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceModelVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EnclosureLocation(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionFrameSourcePropertiesStatics {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_ids(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_model_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceModelVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_enclosure_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EnclosureLocation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics2, 2848483441, 1500, 19021, 138, 92, 164, 236, 242, 107, 188, 70);
RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics2(IKnownPerceptionFrameSourcePropertiesStatics2Vtbl, IKnownPerceptionFrameSourcePropertiesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionFrameSourcePropertiesStatics2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionInfraredFrameSourceProperties}
impl RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics> for KnownPerceptionInfraredFrameSourceProperties {}
impl KnownPerceptionInfraredFrameSourceProperties {
    #[inline] pub fn get_exposure() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure()
    }
    #[inline] pub fn get_auto_exposure_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_auto_exposure_enabled()
    }
    #[inline] pub fn get_exposure_compensation() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure_compensation()
    }
    #[inline] pub fn get_active_illumination_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_active_illumination_enabled()
    }
    #[inline] pub fn get_ambient_subtraction_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_ambient_subtraction_enabled()
    }
    #[inline] pub fn get_structure_light_pattern_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_structure_light_pattern_enabled()
    }
    #[inline] pub fn get_interleaved_illumination_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_interleaved_illumination_enabled()
    }
}
DEFINE_CLSID!(KnownPerceptionInfraredFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionInfraredFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
RT_INTERFACE!{static interface IKnownPerceptionInfraredFrameSourcePropertiesStatics(IKnownPerceptionInfraredFrameSourcePropertiesStaticsVtbl, IKnownPerceptionInfraredFrameSourcePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics] {
    fn get_Exposure(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoExposureEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ActiveIlluminationEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AmbientSubtractionEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StructureLightPatternEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InterleavedIlluminationEnabled(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionInfraredFrameSourcePropertiesStatics {
    #[inline] pub fn get_exposure(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Exposure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoExposureEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExposureCompensation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_illumination_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActiveIlluminationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ambient_subtraction_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AmbientSubtractionEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_structure_light_pattern_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StructureLightPatternEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interleaved_illumination_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterleavedIlluminationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionVideoFrameSourceProperties}
impl RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics> for KnownPerceptionVideoFrameSourceProperties {}
impl KnownPerceptionVideoFrameSourceProperties {
    #[inline] pub fn get_video_profile() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_video_profile()
    }
    #[inline] pub fn get_supported_video_profiles() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_supported_video_profiles()
    }
    #[inline] pub fn get_available_video_profiles() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_available_video_profiles()
    }
    #[inline] pub fn get_is_mirrored() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_is_mirrored()
    }
    #[inline] pub fn get_camera_intrinsics() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_camera_intrinsics()
    }
}
DEFINE_CLSID!(KnownPerceptionVideoFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionVideoFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionVideoFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
RT_INTERFACE!{static interface IKnownPerceptionVideoFrameSourcePropertiesStatics(IKnownPerceptionVideoFrameSourcePropertiesStaticsVtbl, IKnownPerceptionVideoFrameSourcePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoFrameSourcePropertiesStatics] {
    fn get_VideoProfile(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsMirrored(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CameraIntrinsics(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionVideoFrameSourcePropertiesStatics {
    #[inline] pub fn get_video_profile(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_mirrored(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsMirrored)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_intrinsics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionVideoProfileProperties}
impl RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics> for KnownPerceptionVideoProfileProperties {}
impl KnownPerceptionVideoProfileProperties {
    #[inline] pub fn get_bitmap_pixel_format() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_bitmap_pixel_format()
    }
    #[inline] pub fn get_bitmap_alpha_mode() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_bitmap_alpha_mode()
    }
    #[inline] pub fn get_width() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_width()
    }
    #[inline] pub fn get_height() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_height()
    }
    #[inline] pub fn get_frame_duration() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_frame_duration()
    }
}
DEFINE_CLSID!(KnownPerceptionVideoProfileProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,80,114,111,102,105,108,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionVideoProfileProperties]);
DEFINE_IID!(IID_IKnownPerceptionVideoProfilePropertiesStatics, 2399724263, 23158, 17379, 161, 58, 218, 61, 145, 169, 239, 152);
RT_INTERFACE!{static interface IKnownPerceptionVideoProfilePropertiesStatics(IKnownPerceptionVideoProfilePropertiesStaticsVtbl, IKnownPerceptionVideoProfilePropertiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoProfilePropertiesStatics] {
    fn get_BitmapPixelFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BitmapAlphaMode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Width(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Height(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FrameDuration(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionVideoProfilePropertiesStatics {
    #[inline] pub fn get_bitmap_pixel_format(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitmapPixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bitmap_alpha_mode(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitmapAlphaMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_duration(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrame, 4267840841, 11455, 20372, 152, 97, 248, 23, 234, 49, 119, 71);
RT_INTERFACE!{interface IPerceptionColorFrame(IPerceptionColorFrameVtbl, IPerceptionColorFrame_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut <super::super::media::VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrame {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<super::super::media::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrame: IPerceptionColorFrame}
DEFINE_IID!(IID_IPerceptionColorFrameArrivedEventArgs, 2410480341, 34551, 19853, 185, 102, 90, 55, 97, 186, 159, 89);
RT_INTERFACE!{interface IPerceptionColorFrameArrivedEventArgs(IPerceptionColorFrameArrivedEventArgsVtbl, IPerceptionColorFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut <PerceptionColorFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameArrivedEventArgs {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<PerceptionColorFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryOpenFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameArrivedEventArgs: IPerceptionColorFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameReader, 1985017198, 47605, 17947, 131, 173, 242, 34, 175, 42, 170, 220);
RT_INTERFACE!{interface IPerceptionColorFrameReader(IPerceptionColorFrameReaderVtbl, IPerceptionColorFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameReader] {
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut <PerceptionColorFrameSource as RtType>::Abi) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut <PerceptionColorFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameReader {
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<PerceptionColorFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrameSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaused)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPaused)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<PerceptionColorFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryReadLatestFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameReader: IPerceptionColorFrameReader}
DEFINE_IID!(IID_IPerceptionColorFrameSource, 3698178684, 2904, 18061, 156, 161, 109, 176, 76, 192, 71, 124);
RT_INTERFACE!{interface IPerceptionColorFrameSource(IPerceptionColorFrameSourceVtbl, IPerceptionColorFrameSource_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource] {
    fn add_AvailableChanged(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut <PerceptionVideoProfile as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut <super::super::media::devices::core::CameraIntrinsics as RtType>::Abi) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut <PerceptionControlSession as RtType>::Abi) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, correlatedDepthFrameSource: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics> as RtType>::Abi) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetSourceId: HSTRING, correlatedDepthFrameSource: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper> as RtType>::Abi) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: <PerceptionControlSession as RtType>::Abi, profile: <PerceptionVideoProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult> as RtType>::Abi) -> HRESULT,
    fn OpenReader(&self, out: *mut <PerceptionColorFrameReader as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameSource {
    #[inline] pub fn add_available_changed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Available)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Active)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsControlled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<PerceptionVideoProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionVideoProfile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<super::super::media::devices::core::CameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::devices::core::CameraIntrinsics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<PerceptionControlSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AcquireControlSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionControlSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CanControlIndependentlyFrom)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsCorrelatedWith)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetTransformTo)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, correlatedDepthFrameSource: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(correlatedDepthFrameSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetSourceId: &HStringArg, correlatedDepthFrameSource: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.0.as_abi() as *const _ as *mut _, targetSourceId.get(), get_abi(correlatedDepthFrameSource) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> Result<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetVideoProfileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(controlSession) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<PerceptionColorFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrameReader::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSource: IPerceptionColorFrameSource}
impl RtActivatable<IPerceptionColorFrameSourceStatics> for PerceptionColorFrameSource {}
impl PerceptionColorFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<PerceptionColorFrameSourceWatcher>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionColorFrameSource>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionColorFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionColorFrameSource]);
DEFINE_IID!(IID_IPerceptionColorFrameSource2, 4169140453, 22065, 17901, 173, 152, 140, 106, 160, 76, 251, 145);
RT_INTERFACE!{interface IPerceptionColorFrameSource2(IPerceptionColorFrameSource2Vtbl, IPerceptionColorFrameSource2_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPerceptionColorFrameSource2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrameSourceAddedEventArgs, 3513513190, 55844, 17452, 187, 213, 85, 84, 155, 91, 148, 243);
RT_INTERFACE!{interface IPerceptionColorFrameSourceAddedEventArgs(IPerceptionColorFrameSourceAddedEventArgsVtbl, IPerceptionColorFrameSourceAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionColorFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameSourceAddedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionColorFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceAddedEventArgs: IPerceptionColorFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameSourceRemovedEventArgs, 3531078249, 60236, 17135, 186, 79, 40, 143, 97, 92, 147, 193);
RT_INTERFACE!{interface IPerceptionColorFrameSourceRemovedEventArgs(IPerceptionColorFrameSourceRemovedEventArgsVtbl, IPerceptionColorFrameSourceRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionColorFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameSourceRemovedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionColorFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceRemovedEventArgs: IPerceptionColorFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
RT_INTERFACE!{static interface IPerceptionColorFrameSourceStatics(IPerceptionColorFrameSourceStaticsVtbl, IPerceptionColorFrameSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut <PerceptionColorFrameSourceWatcher as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<PerceptionColorFrameSource> as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionColorFrameSourceStatics {
    #[inline] pub fn create_watcher(&self) -> Result<Option<PerceptionColorFrameSourceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionColorFrameSourceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionColorFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrameSourceWatcher, 2528973714, 58983, 16580, 137, 249, 20, 98, 222, 166, 169, 204);
RT_INTERFACE!{interface IPerceptionColorFrameSourceWatcher(IPerceptionColorFrameSourceWatcherVtbl, IPerceptionColorFrameSourceWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IPerceptionColorFrameSourceWatcher {
    #[inline] pub fn add_source_added(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceWatcher: IPerceptionColorFrameSourceWatcher}
DEFINE_IID!(IID_IPerceptionControlSession, 2576975443, 23101, 16767, 146, 57, 241, 136, 158, 84, 139, 72);
RT_INTERFACE!{interface IPerceptionControlSession(IPerceptionControlSessionVtbl, IPerceptionControlSession_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionControlSession] {
    fn add_ControlLost(&self, handler: <foundation::TypedEventHandler<PerceptionControlSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ControlLost(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TrySetPropertyAsync(&self, name: HSTRING, value: <IInspectable as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionControlSession {
    #[inline] pub fn add_control_lost(&self, handler: &foundation::TypedEventHandler<PerceptionControlSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ControlLost)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_control_lost(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ControlLost)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_set_property_async(&self, name: &HStringArg, value: &IInspectable) -> Result<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetPropertyAsync)(self.0.as_abi() as *const _ as *mut _, name.get(), get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionControlSession: IPerceptionControlSession}
DEFINE_IID!(IID_IPerceptionDepthCorrelatedCameraIntrinsics, 1699269121, 34526, 23521, 101, 130, 128, 127, 207, 76, 149, 207);
RT_INTERFACE!{interface IPerceptionDepthCorrelatedCameraIntrinsics(IPerceptionDepthCorrelatedCameraIntrinsicsVtbl, IPerceptionDepthCorrelatedCameraIntrinsics_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCameraIntrinsics] {
    fn UnprojectPixelAtCorrelatedDepth(&self, pixelCoordinate: foundation::Point, depthFrame: <PerceptionDepthFrame as RtType>::Abi, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn UnprojectPixelsAtCorrelatedDepth(&self, sourceCoordinatesSize: u32, sourceCoordinates: *mut foundation::Point, depthFrame: <PerceptionDepthFrame as RtType>::Abi, resultsSize: u32, results: *mut foundation::numerics::Vector3) -> HRESULT,
    fn UnprojectRegionPixelsAtCorrelatedDepthAsync(&self, region: foundation::Rect, depthFrame: <PerceptionDepthFrame as RtType>::Abi, resultsSize: u32, results: *mut foundation::numerics::Vector3, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UnprojectAllPixelsAtCorrelatedDepthAsync(&self, depthFrame: <PerceptionDepthFrame as RtType>::Abi, resultsSize: u32, results: *mut foundation::numerics::Vector3, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthCorrelatedCameraIntrinsics {
    #[inline] pub fn unproject_pixel_at_correlated_depth(&self, pixelCoordinate: foundation::Point, depthFrame: &PerceptionDepthFrame) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectPixelAtCorrelatedDepth)(self.0.as_abi() as *const _ as *mut _, pixelCoordinate, get_abi(depthFrame) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn unproject_pixels_at_correlated_depth(&self, sourceCoordinates: &[foundation::Point], depthFrame: &PerceptionDepthFrame, results: &mut [foundation::numerics::Vector3]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectPixelsAtCorrelatedDepth)(self.0.as_abi() as *const _ as *mut _, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, get_abi(depthFrame) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unproject_region_pixels_at_correlated_depth_async(&self, region: foundation::Rect, depthFrame: &PerceptionDepthFrame, results: &mut [foundation::numerics::Vector3]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectRegionPixelsAtCorrelatedDepthAsync)(self.0.as_abi() as *const _ as *mut _, region, get_abi(depthFrame) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unproject_all_pixels_at_correlated_depth_async(&self, depthFrame: &PerceptionDepthFrame, results: &mut [foundation::numerics::Vector3]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UnprojectAllPixelsAtCorrelatedDepthAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(depthFrame) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthCorrelatedCameraIntrinsics: IPerceptionDepthCorrelatedCameraIntrinsics}
DEFINE_IID!(IID_IPerceptionDepthCorrelatedCoordinateMapper, 1531813149, 46582, 18076, 184, 194, 185, 122, 69, 230, 134, 59);
RT_INTERFACE!{interface IPerceptionDepthCorrelatedCoordinateMapper(IPerceptionDepthCorrelatedCoordinateMapperVtbl, IPerceptionDepthCorrelatedCoordinateMapper_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCoordinateMapper] {
    fn MapPixelToTarget(&self, sourcePixelCoordinate: foundation::Point, depthFrame: <PerceptionDepthFrame as RtType>::Abi, out: *mut foundation::Point) -> HRESULT,
    fn MapPixelsToTarget(&self, sourceCoordinatesSize: u32, sourceCoordinates: *mut foundation::Point, depthFrame: <PerceptionDepthFrame as RtType>::Abi, resultsSize: u32, results: *mut foundation::Point) -> HRESULT,
    fn MapRegionOfPixelsToTargetAsync(&self, region: foundation::Rect, depthFrame: <PerceptionDepthFrame as RtType>::Abi, targetCoordinatesSize: u32, targetCoordinates: *mut foundation::Point, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn MapAllPixelsToTargetAsync(&self, depthFrame: <PerceptionDepthFrame as RtType>::Abi, targetCoordinatesSize: u32, targetCoordinates: *mut foundation::Point, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthCorrelatedCoordinateMapper {
    #[inline] pub fn map_pixel_to_target(&self, sourcePixelCoordinate: foundation::Point, depthFrame: &PerceptionDepthFrame) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).MapPixelToTarget)(self.0.as_abi() as *const _ as *mut _, sourcePixelCoordinate, get_abi(depthFrame) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn map_pixels_to_target(&self, sourceCoordinates: &[foundation::Point], depthFrame: &PerceptionDepthFrame, results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).MapPixelsToTarget)(self.0.as_abi() as *const _ as *mut _, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, get_abi(depthFrame) as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn map_region_of_pixels_to_target_async(&self, region: foundation::Rect, depthFrame: &PerceptionDepthFrame, targetCoordinates: &mut [foundation::Point]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MapRegionOfPixelsToTargetAsync)(self.0.as_abi() as *const _ as *mut _, region, get_abi(depthFrame) as *const _ as *mut _, targetCoordinates.len() as u32, targetCoordinates.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn map_all_pixels_to_target_async(&self, depthFrame: &PerceptionDepthFrame, targetCoordinates: &mut [foundation::Point]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MapAllPixelsToTargetAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(depthFrame) as *const _ as *mut _, targetCoordinates.len() as u32, targetCoordinates.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthCorrelatedCoordinateMapper: IPerceptionDepthCorrelatedCoordinateMapper}
DEFINE_IID!(IID_IPerceptionDepthFrame, 2742780412, 39174, 20477, 145, 97, 0, 36, 179, 96, 182, 87);
RT_INTERFACE!{interface IPerceptionDepthFrame(IPerceptionDepthFrameVtbl, IPerceptionDepthFrame_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut <super::super::media::VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrame {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<super::super::media::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrame: IPerceptionDepthFrame}
DEFINE_IID!(IID_IPerceptionDepthFrameArrivedEventArgs, 1144858034, 45698, 17975, 145, 115, 172, 151, 132, 53, 201, 133);
RT_INTERFACE!{interface IPerceptionDepthFrameArrivedEventArgs(IPerceptionDepthFrameArrivedEventArgsVtbl, IPerceptionDepthFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut <PerceptionDepthFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameArrivedEventArgs {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<PerceptionDepthFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryOpenFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameArrivedEventArgs: IPerceptionDepthFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameReader, 2980298911, 10651, 17938, 164, 247, 39, 15, 37, 160, 150, 236);
RT_INTERFACE!{interface IPerceptionDepthFrameReader(IPerceptionDepthFrameReaderVtbl, IPerceptionDepthFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameReader] {
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut <PerceptionDepthFrameSource as RtType>::Abi) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut <PerceptionDepthFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameReader {
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<PerceptionDepthFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrameSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaused)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPaused)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<PerceptionDepthFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryReadLatestFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameReader: IPerceptionDepthFrameReader}
DEFINE_IID!(IID_IPerceptionDepthFrameSource, 2043950038, 18427, 19953, 191, 201, 240, 29, 64, 189, 153, 66);
RT_INTERFACE!{interface IPerceptionDepthFrameSource(IPerceptionDepthFrameSourceVtbl, IPerceptionDepthFrameSource_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource] {
    fn add_AvailableChanged(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut <PerceptionVideoProfile as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut <super::super::media::devices::core::CameraIntrinsics as RtType>::Abi) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut <PerceptionControlSession as RtType>::Abi) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, target: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics> as RtType>::Abi) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetId: HSTRING, depthFrameSourceToMapWith: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper> as RtType>::Abi) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: <PerceptionControlSession as RtType>::Abi, profile: <PerceptionVideoProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult> as RtType>::Abi) -> HRESULT,
    fn OpenReader(&self, out: *mut <PerceptionDepthFrameReader as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameSource {
    #[inline] pub fn add_available_changed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Available)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Active)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsControlled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<PerceptionVideoProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionVideoProfile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<super::super::media::devices::core::CameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::devices::core::CameraIntrinsics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<PerceptionControlSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AcquireControlSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionControlSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CanControlIndependentlyFrom)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsCorrelatedWith)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetTransformTo)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, target: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetId: &HStringArg, depthFrameSourceToMapWith: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.0.as_abi() as *const _ as *mut _, targetId.get(), get_abi(depthFrameSourceToMapWith) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> Result<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetVideoProfileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(controlSession) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<PerceptionDepthFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrameReader::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSource: IPerceptionDepthFrameSource}
impl RtActivatable<IPerceptionDepthFrameSourceStatics> for PerceptionDepthFrameSource {}
impl PerceptionDepthFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<PerceptionDepthFrameSourceWatcher>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionDepthFrameSource>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionDepthFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionDepthFrameSource]);
DEFINE_IID!(IID_IPerceptionDepthFrameSource2, 3822206254, 28204, 20077, 145, 217, 112, 76, 216, 223, 247, 157);
RT_INTERFACE!{interface IPerceptionDepthFrameSource2(IPerceptionDepthFrameSource2Vtbl, IPerceptionDepthFrameSource2_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPerceptionDepthFrameSource2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceAddedEventArgs, 2477031784, 35832, 17874, 162, 248, 74, 192, 147, 28, 199, 166);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceAddedEventArgs(IPerceptionDepthFrameSourceAddedEventArgsVtbl, IPerceptionDepthFrameSourceAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionDepthFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameSourceAddedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionDepthFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceAddedEventArgs: IPerceptionDepthFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceRemovedEventArgs, 2696989773, 59756, 19841, 134, 221, 56, 185, 94, 73, 198, 223);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceRemovedEventArgs(IPerceptionDepthFrameSourceRemovedEventArgsVtbl, IPerceptionDepthFrameSourceRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionDepthFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameSourceRemovedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionDepthFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceRemovedEventArgs: IPerceptionDepthFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
RT_INTERFACE!{static interface IPerceptionDepthFrameSourceStatics(IPerceptionDepthFrameSourceStaticsVtbl, IPerceptionDepthFrameSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut <PerceptionDepthFrameSourceWatcher as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<PerceptionDepthFrameSource> as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionDepthFrameSourceStatics {
    #[inline] pub fn create_watcher(&self) -> Result<Option<PerceptionDepthFrameSourceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionDepthFrameSourceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionDepthFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceWatcher, 2014222033, 36098, 19755, 173, 164, 91, 166, 36, 160, 235, 16);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceWatcher(IPerceptionDepthFrameSourceWatcherVtbl, IPerceptionDepthFrameSourceWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IPerceptionDepthFrameSourceWatcher {
    #[inline] pub fn add_source_added(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceWatcher: IPerceptionDepthFrameSourceWatcher}
RT_ENUM! { enum PerceptionFrameSourceAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
DEFINE_IID!(IID_IPerceptionFrameSourcePropertiesChangedEventArgs, 1818812520, 48369, 20172, 184, 145, 118, 37, 209, 36, 75, 107);
RT_INTERFACE!{interface IPerceptionFrameSourcePropertiesChangedEventArgs(IPerceptionFrameSourcePropertiesChangedEventArgsVtbl, IPerceptionFrameSourcePropertiesChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertiesChangedEventArgs] {
    fn get_CollectionChange(&self, out: *mut foundation::collections::CollectionChange) -> HRESULT,
    fn get_Key(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPerceptionFrameSourcePropertiesChangedEventArgs {
    #[inline] pub fn get_collection_change(&self) -> Result<foundation::collections::CollectionChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CollectionChange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Key)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameSourcePropertiesChangedEventArgs: IPerceptionFrameSourcePropertiesChangedEventArgs}
DEFINE_IID!(IID_IPerceptionFrameSourcePropertyChangeResult, 506673418, 15504, 19746, 184, 152, 244, 43, 186, 100, 24, 255);
RT_INTERFACE!{interface IPerceptionFrameSourcePropertyChangeResult(IPerceptionFrameSourcePropertyChangeResultVtbl, IPerceptionFrameSourcePropertyChangeResult_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertyChangeResult] {
    fn get_Status(&self, out: *mut PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn get_NewValue(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFrameSourcePropertyChangeResult {
    #[inline] pub fn get_status(&self) -> Result<PerceptionFrameSourcePropertyChangeStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_value(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameSourcePropertyChangeResult: IPerceptionFrameSourcePropertyChangeResult}
RT_ENUM! { enum PerceptionFrameSourcePropertyChangeStatus: i32 {
    Unknown = 0, Accepted = 1, LostControl = 2, PropertyNotSupported = 3, PropertyReadOnly = 4, ValueOutOfRange = 5,
}}
DEFINE_IID!(IID_IPerceptionInfraredFrame, 2961728118, 33950, 19578, 138, 230, 181, 96, 100, 83, 33, 83);
RT_INTERFACE!{interface IPerceptionInfraredFrame(IPerceptionInfraredFrameVtbl, IPerceptionInfraredFrame_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut <super::super::media::VideoFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrame {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<super::super::media::VideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::VideoFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrame: IPerceptionInfraredFrame}
DEFINE_IID!(IID_IPerceptionInfraredFrameArrivedEventArgs, 2675440327, 46269, 18519, 157, 80, 190, 142, 240, 117, 218, 239);
RT_INTERFACE!{interface IPerceptionInfraredFrameArrivedEventArgs(IPerceptionInfraredFrameArrivedEventArgsVtbl, IPerceptionInfraredFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut <PerceptionInfraredFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameArrivedEventArgs {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<PerceptionInfraredFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryOpenFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameArrivedEventArgs: IPerceptionInfraredFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameReader, 2036387352, 54171, 20424, 160, 74, 146, 151, 52, 198, 117, 108);
RT_INTERFACE!{interface IPerceptionInfraredFrameReader(IPerceptionInfraredFrameReaderVtbl, IPerceptionInfraredFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameReader] {
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut <PerceptionInfraredFrameSource as RtType>::Abi) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut <PerceptionInfraredFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameReader {
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<PerceptionInfraredFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrameSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaused)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPaused)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<PerceptionInfraredFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryReadLatestFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameReader: IPerceptionInfraredFrameReader}
DEFINE_IID!(IID_IPerceptionInfraredFrameSource, 1437632322, 6152, 18766, 158, 48, 157, 42, 123, 232, 247, 0);
RT_INTERFACE!{interface IPerceptionInfraredFrameSource(IPerceptionInfraredFrameSourceVtbl, IPerceptionInfraredFrameSource_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource] {
    fn add_AvailableChanged(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut <foundation::collections::IVectorView<PerceptionVideoProfile> as RtType>::Abi) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut <PerceptionVideoProfile as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut <super::super::media::devices::core::CameraIntrinsics as RtType>::Abi) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut <PerceptionControlSession as RtType>::Abi) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, target: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics> as RtType>::Abi) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetId: HSTRING, depthFrameSourceToMapWith: <PerceptionDepthFrameSource as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper> as RtType>::Abi) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: <PerceptionControlSession as RtType>::Abi, profile: <PerceptionVideoProfile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult> as RtType>::Abi) -> HRESULT,
    fn OpenReader(&self, out: *mut <PerceptionInfraredFrameReader as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameSource {
    #[inline] pub fn add_available_changed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AvailableChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ActiveChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PropertiesChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VideoProfileChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CameraIntrinsicsChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Available)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Active)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsControlled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableVideoProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<PerceptionVideoProfile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoProfile)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionVideoProfile::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<super::super::media::devices::core::CameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CameraIntrinsics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::media::devices::core::CameraIntrinsics::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<PerceptionControlSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AcquireControlSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionControlSession::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CanControlIndependentlyFrom)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsCorrelatedWith)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetTransformTo)(self.0.as_abi() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, target: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(target) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetId: &HStringArg, depthFrameSourceToMapWith: &PerceptionDepthFrameSource) -> Result<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.0.as_abi() as *const _ as *mut _, targetId.get(), get_abi(depthFrameSourceToMapWith) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> Result<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetVideoProfileAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(controlSession) as *const _ as *mut _, get_abi(profile) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<PerceptionInfraredFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenReader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrameReader::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSource: IPerceptionInfraredFrameSource}
impl RtActivatable<IPerceptionInfraredFrameSourceStatics> for PerceptionInfraredFrameSource {}
impl PerceptionInfraredFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<PerceptionInfraredFrameSourceWatcher>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionInfraredFrameSource>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionInfraredFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionInfraredFrameSource]);
DEFINE_IID!(IID_IPerceptionInfraredFrameSource2, 3704936344, 19211, 17152, 141, 133, 65, 8, 23, 250, 160, 50);
RT_INTERFACE!{interface IPerceptionInfraredFrameSource2(IPerceptionInfraredFrameSource2Vtbl, IPerceptionInfraredFrameSource2_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPerceptionInfraredFrameSource2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceAddedEventArgs, 1832075552, 38350, 18016, 144, 122, 217, 128, 53, 170, 43, 124);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceAddedEventArgs(IPerceptionInfraredFrameSourceAddedEventArgsVtbl, IPerceptionInfraredFrameSourceAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionInfraredFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameSourceAddedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionInfraredFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceAddedEventArgs: IPerceptionInfraredFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceRemovedEventArgs, 3927605361, 31344, 19041, 175, 148, 7, 48, 56, 83, 246, 149);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceRemovedEventArgs(IPerceptionInfraredFrameSourceRemovedEventArgsVtbl, IPerceptionInfraredFrameSourceRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut <PerceptionInfraredFrameSource as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameSourceRemovedEventArgs {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<PerceptionInfraredFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrameSource::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceRemovedEventArgs: IPerceptionInfraredFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
RT_INTERFACE!{static interface IPerceptionInfraredFrameSourceStatics(IPerceptionInfraredFrameSourceStaticsVtbl, IPerceptionInfraredFrameSourceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut <PerceptionInfraredFrameSourceWatcher as RtType>::Abi) -> HRESULT,
    fn FindAllAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut <foundation::IAsyncOperation<PerceptionInfraredFrameSource> as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionInfraredFrameSourceStatics {
    #[inline] pub fn create_watcher(&self) -> Result<Option<PerceptionInfraredFrameSourceWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWatcher)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionInfraredFrameSourceWatcher::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<foundation::IAsyncOperation<PerceptionInfraredFrameSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceWatcher, 943521689, 55052, 17485, 168, 176, 114, 12, 46, 102, 254, 59);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceWatcher(IPerceptionInfraredFrameSourceWatcherVtbl, IPerceptionInfraredFrameSourceWatcher_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: <foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IPerceptionInfraredFrameSourceWatcher {
    #[inline] pub fn add_source_added(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SourceRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Stopped)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Stopped)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnumerationCompleted)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceWatcher: IPerceptionInfraredFrameSourceWatcher}
DEFINE_IID!(IID_IPerceptionVideoProfile, 1970683555, 282, 18190, 130, 37, 111, 5, 173, 226, 86, 72);
RT_INTERFACE!{interface IPerceptionVideoProfile(IPerceptionVideoProfileVtbl, IPerceptionVideoProfile_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoProfile] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapPixelFormat(&self, out: *mut super::super::graphics::imaging::BitmapPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapAlphaMode(&self, out: *mut super::super::graphics::imaging::BitmapAlphaMode) -> HRESULT,
    fn get_Width(&self, out: *mut i32) -> HRESULT,
    fn get_Height(&self, out: *mut i32) -> HRESULT,
    fn get_FrameDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn IsEqual(&self, other: <PerceptionVideoProfile as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl IPerceptionVideoProfile {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_pixel_format(&self) -> Result<super::super::graphics::imaging::BitmapPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitmapPixelFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_alpha_mode(&self) -> Result<super::super::graphics::imaging::BitmapAlphaMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BitmapAlphaMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, other: &PerceptionVideoProfile) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsEqual)(self.0.as_abi() as *const _ as *mut _, get_abi(other) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionVideoProfile: IPerceptionVideoProfile}
pub mod provider { // Windows.Devices.Perception.Provider
use crate::prelude::*;
RT_CLASS!{static class KnownPerceptionFrameKind}
impl RtActivatable<IKnownPerceptionFrameKindStatics> for KnownPerceptionFrameKind {}
impl KnownPerceptionFrameKind {
    #[inline] pub fn get_color() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_color()
    }
    #[inline] pub fn get_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_depth()
    }
    #[inline] pub fn get_infrared() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_infrared()
    }
}
DEFINE_CLSID!(KnownPerceptionFrameKind(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,75,105,110,100,0]) [CLSID_KnownPerceptionFrameKind]);
DEFINE_IID!(IID_IKnownPerceptionFrameKindStatics, 988172758, 38505, 16646, 159, 174, 72, 53, 193, 185, 97, 4);
RT_INTERFACE!{static interface IKnownPerceptionFrameKindStatics(IKnownPerceptionFrameKindStaticsVtbl, IKnownPerceptionFrameKindStatics_Abi): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameKindStatics] {
    fn get_Color(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Depth(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Infrared(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownPerceptionFrameKindStatics {
    #[inline] pub fn get_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Color)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Depth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_infrared(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Infrared)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionControlGroup, 388778114, 12249, 19534, 186, 52, 253, 242, 10, 115, 221, 229);
RT_INTERFACE!{interface IPerceptionControlGroup(IPerceptionControlGroupVtbl, IPerceptionControlGroup_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroup] {
    fn get_FrameProviderIds(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionControlGroup {
    #[inline] pub fn get_frame_provider_ids(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameProviderIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionControlGroup: IPerceptionControlGroup}
impl RtActivatable<IPerceptionControlGroupFactory> for PerceptionControlGroup {}
impl PerceptionControlGroup {
    #[inline] pub fn create(ids: &foundation::collections::IIterable<HString>) -> Result<PerceptionControlGroup> {
        <Self as RtActivatable<IPerceptionControlGroupFactory>>::get_activation_factory().create(ids)
    }
}
DEFINE_CLSID!(PerceptionControlGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,110,116,114,111,108,71,114,111,117,112,0]) [CLSID_PerceptionControlGroup]);
DEFINE_IID!(IID_IPerceptionControlGroupFactory, 790295264, 47857, 17723, 190, 212, 205, 157, 70, 25, 21, 76);
RT_INTERFACE!{static interface IPerceptionControlGroupFactory(IPerceptionControlGroupFactoryVtbl, IPerceptionControlGroupFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroupFactory] {
    fn Create(&self, ids: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <PerceptionControlGroup as RtType>::Abi) -> HRESULT
}}
impl IPerceptionControlGroupFactory {
    #[inline] pub fn create(&self, ids: &foundation::collections::IIterable<HString>) -> Result<PerceptionControlGroup> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(ids) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionControlGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionCorrelation, 3021150850, 57333, 16455, 138, 25, 59, 77, 128, 95, 113, 118);
RT_INTERFACE!{interface IPerceptionCorrelation(IPerceptionCorrelationVtbl, IPerceptionCorrelation_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelation] {
    fn get_TargetId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_Orientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT
}}
impl IPerceptionCorrelation {
    #[inline] pub fn get_target_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TargetId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Orientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionCorrelation: IPerceptionCorrelation}
impl RtActivatable<IPerceptionCorrelationFactory> for PerceptionCorrelation {}
impl PerceptionCorrelation {
    #[inline] pub fn create(targetId: &HStringArg, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion) -> Result<PerceptionCorrelation> {
        <Self as RtActivatable<IPerceptionCorrelationFactory>>::get_activation_factory().create(targetId, position, orientation)
    }
}
DEFINE_CLSID!(PerceptionCorrelation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,0]) [CLSID_PerceptionCorrelation]);
DEFINE_IID!(IID_IPerceptionCorrelationFactory, 3567698981, 10372, 19087, 129, 52, 40, 53, 215, 40, 108, 191);
RT_INTERFACE!{static interface IPerceptionCorrelationFactory(IPerceptionCorrelationFactoryVtbl, IPerceptionCorrelationFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationFactory] {
    fn Create(&self, targetId: HSTRING, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion, out: *mut <PerceptionCorrelation as RtType>::Abi) -> HRESULT
}}
impl IPerceptionCorrelationFactory {
    #[inline] pub fn create(&self, targetId: &HStringArg, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion) -> Result<PerceptionCorrelation> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, targetId.get(), position, orientation, &mut out);
        if hr == S_OK { Ok(PerceptionCorrelation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionCorrelationGroup, 1965689094, 13991, 18363, 155, 121, 86, 204, 107, 116, 103, 112);
RT_INTERFACE!{interface IPerceptionCorrelationGroup(IPerceptionCorrelationGroupVtbl, IPerceptionCorrelationGroup_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroup] {
    fn get_RelativeLocations(&self, out: *mut <foundation::collections::IVectorView<PerceptionCorrelation> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionCorrelationGroup {
    #[inline] pub fn get_relative_locations(&self) -> Result<Option<foundation::collections::IVectorView<PerceptionCorrelation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeLocations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionCorrelationGroup: IPerceptionCorrelationGroup}
impl RtActivatable<IPerceptionCorrelationGroupFactory> for PerceptionCorrelationGroup {}
impl PerceptionCorrelationGroup {
    #[inline] pub fn create(relativeLocations: &foundation::collections::IIterable<PerceptionCorrelation>) -> Result<PerceptionCorrelationGroup> {
        <Self as RtActivatable<IPerceptionCorrelationGroupFactory>>::get_activation_factory().create(relativeLocations)
    }
}
DEFINE_CLSID!(PerceptionCorrelationGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,71,114,111,117,112,0]) [CLSID_PerceptionCorrelationGroup]);
DEFINE_IID!(IID_IPerceptionCorrelationGroupFactory, 2113806472, 25567, 18669, 131, 177, 74, 184, 41, 19, 41, 149);
RT_INTERFACE!{static interface IPerceptionCorrelationGroupFactory(IPerceptionCorrelationGroupFactoryVtbl, IPerceptionCorrelationGroupFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroupFactory] {
    fn Create(&self, relativeLocations: <foundation::collections::IIterable<PerceptionCorrelation> as RtType>::Abi, out: *mut <PerceptionCorrelationGroup as RtType>::Abi) -> HRESULT
}}
impl IPerceptionCorrelationGroupFactory {
    #[inline] pub fn create(&self, relativeLocations: &foundation::collections::IIterable<PerceptionCorrelation>) -> Result<PerceptionCorrelationGroup> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(relativeLocations) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionCorrelationGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroup, 3892418580, 19089, 16816, 131, 166, 136, 26, 23, 117, 53, 62);
RT_INTERFACE!{interface IPerceptionFaceAuthenticationGroup(IPerceptionFaceAuthenticationGroupVtbl, IPerceptionFaceAuthenticationGroup_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroup] {
    fn get_FrameProviderIds(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFaceAuthenticationGroup {
    #[inline] pub fn get_frame_provider_ids(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameProviderIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFaceAuthenticationGroup: IPerceptionFaceAuthenticationGroup}
impl RtActivatable<IPerceptionFaceAuthenticationGroupFactory> for PerceptionFaceAuthenticationGroup {}
impl PerceptionFaceAuthenticationGroup {
    #[inline] pub fn create(ids: &foundation::collections::IIterable<HString>, startHandler: &PerceptionStartFaceAuthenticationHandler, stopHandler: &PerceptionStopFaceAuthenticationHandler) -> Result<PerceptionFaceAuthenticationGroup> {
        <Self as RtActivatable<IPerceptionFaceAuthenticationGroupFactory>>::get_activation_factory().create(ids, startHandler, stopHandler)
    }
}
DEFINE_CLSID!(PerceptionFaceAuthenticationGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,97,99,101,65,117,116,104,101,110,116,105,99,97,116,105,111,110,71,114,111,117,112,0]) [CLSID_PerceptionFaceAuthenticationGroup]);
DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroupFactory, 3867805140, 46604, 16628, 188, 185, 242, 77, 70, 70, 115, 32);
RT_INTERFACE!{static interface IPerceptionFaceAuthenticationGroupFactory(IPerceptionFaceAuthenticationGroupFactoryVtbl, IPerceptionFaceAuthenticationGroupFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroupFactory] {
    fn Create(&self, ids: <foundation::collections::IIterable<HString> as RtType>::Abi, startHandler: <PerceptionStartFaceAuthenticationHandler as RtType>::Abi, stopHandler: <PerceptionStopFaceAuthenticationHandler as RtType>::Abi, out: *mut <PerceptionFaceAuthenticationGroup as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFaceAuthenticationGroupFactory {
    #[inline] pub fn create(&self, ids: &foundation::collections::IIterable<HString>, startHandler: &PerceptionStartFaceAuthenticationHandler, stopHandler: &PerceptionStopFaceAuthenticationHandler) -> Result<PerceptionFaceAuthenticationGroup> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(ids) as *const _ as *mut _, get_abi(startHandler) as *const _ as *mut _, get_abi(stopHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionFaceAuthenticationGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFrame, 2097051685, 21691, 19869, 190, 197, 142, 246, 97, 81, 210, 172);
RT_INTERFACE!{interface IPerceptionFrame(IPerceptionFrameVtbl, IPerceptionFrame_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrame] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RelativeTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn get_FrameData(&self, out: *mut <foundation::IMemoryBuffer as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFrame {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RelativeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relative_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RelativeTime)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_data(&self) -> Result<Option<foundation::IMemoryBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IMemoryBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrame: IPerceptionFrame}
DEFINE_IID!(IID_IPerceptionFrameProvider, 2035251897, 45949, 15155, 161, 13, 48, 98, 100, 25, 206, 101);
RT_INTERFACE!{interface IPerceptionFrameProvider(IPerceptionFrameProviderVtbl, IPerceptionFrameProvider_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProvider] {
    fn get_FrameProviderInfo(&self, out: *mut <PerceptionFrameProviderInfo as RtType>::Abi) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IPropertySet as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn SetProperty(&self, value: <PerceptionPropertyChangeRequest as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFrameProvider {
    #[inline] pub fn get_frame_provider_info(&self) -> Result<Option<PerceptionFrameProviderInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameProviderInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionFrameProviderInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Available)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IPropertySet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IPropertySet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_property(&self, value: &PerceptionPropertyChangeRequest) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetProperty)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFrameProviderInfo, 3433650664, 31102, 20099, 155, 135, 3, 106, 116, 20, 47, 196);
RT_INTERFACE!{interface IPerceptionFrameProviderInfo(IPerceptionFrameProviderInfoVtbl, IPerceptionFrameProviderInfo_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderInfo] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DeviceKind(&self, value: HSTRING) -> HRESULT,
    fn get_FrameKind(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FrameKind(&self, value: HSTRING) -> HRESULT,
    fn get_Hidden(&self, out: *mut bool) -> HRESULT,
    fn put_Hidden(&self, value: bool) -> HRESULT
}}
impl IPerceptionFrameProviderInfo {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Id)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DisplayName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_device_kind(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DeviceKind)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FrameKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_frame_kind(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_FrameKind)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hidden(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Hidden)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_hidden(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Hidden)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameProviderInfo: IPerceptionFrameProviderInfo}
impl RtActivatable<IActivationFactory> for PerceptionFrameProviderInfo {}
DEFINE_CLSID!(PerceptionFrameProviderInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,80,114,111,118,105,100,101,114,73,110,102,111,0]) [CLSID_PerceptionFrameProviderInfo]);
DEFINE_IID!(IID_IPerceptionFrameProviderManager, 2841234951, 60115, 13279, 142, 193, 185, 36, 171, 224, 25, 196);
RT_INTERFACE!{interface IPerceptionFrameProviderManager(IPerceptionFrameProviderManagerVtbl, IPerceptionFrameProviderManager_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManager] {
    fn GetFrameProvider(&self, frameProviderInfo: <PerceptionFrameProviderInfo as RtType>::Abi, out: *mut <IPerceptionFrameProvider as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFrameProviderManager {
    #[inline] pub fn get_frame_provider(&self, frameProviderInfo: &PerceptionFrameProviderInfo) -> Result<Option<IPerceptionFrameProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetFrameProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(frameProviderInfo) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IPerceptionFrameProvider::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class PerceptionFrameProviderManagerService}
impl RtActivatable<IPerceptionFrameProviderManagerServiceStatics> for PerceptionFrameProviderManagerService {}
impl PerceptionFrameProviderManagerService {
    #[inline] pub fn register_frame_provider_info(manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_frame_provider_info(manager, frameProviderInfo)
    }
    #[inline] pub fn unregister_frame_provider_info(manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_frame_provider_info(manager, frameProviderInfo)
    }
    #[inline] pub fn register_face_authentication_group(manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_face_authentication_group(manager, faceAuthenticationGroup)
    }
    #[inline] pub fn unregister_face_authentication_group(manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_face_authentication_group(manager, faceAuthenticationGroup)
    }
    #[inline] pub fn register_control_group(manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_control_group(manager, controlGroup)
    }
    #[inline] pub fn unregister_control_group(manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_control_group(manager, controlGroup)
    }
    #[inline] pub fn register_correlation_group(manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_correlation_group(manager, correlationGroup)
    }
    #[inline] pub fn unregister_correlation_group(manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_correlation_group(manager, correlationGroup)
    }
    #[inline] pub fn update_availability_for_provider(provider: &IPerceptionFrameProvider, available: bool) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().update_availability_for_provider(provider, available)
    }
    #[inline] pub fn publish_frame_for_provider(provider: &IPerceptionFrameProvider, frame: &PerceptionFrame) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().publish_frame_for_provider(provider, frame)
    }
}
DEFINE_CLSID!(PerceptionFrameProviderManagerService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,80,114,111,118,105,100,101,114,77,97,110,97,103,101,114,83,101,114,118,105,99,101,0]) [CLSID_PerceptionFrameProviderManagerService]);
DEFINE_IID!(IID_IPerceptionFrameProviderManagerServiceStatics, 2927855334, 51929, 17241, 143, 150, 142, 174, 81, 129, 5, 38);
RT_INTERFACE!{static interface IPerceptionFrameProviderManagerServiceStatics(IPerceptionFrameProviderManagerServiceStaticsVtbl, IPerceptionFrameProviderManagerServiceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManagerServiceStatics] {
    fn RegisterFrameProviderInfo(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, frameProviderInfo: <PerceptionFrameProviderInfo as RtType>::Abi) -> HRESULT,
    fn UnregisterFrameProviderInfo(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, frameProviderInfo: <PerceptionFrameProviderInfo as RtType>::Abi) -> HRESULT,
    fn RegisterFaceAuthenticationGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, faceAuthenticationGroup: <PerceptionFaceAuthenticationGroup as RtType>::Abi) -> HRESULT,
    fn UnregisterFaceAuthenticationGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, faceAuthenticationGroup: <PerceptionFaceAuthenticationGroup as RtType>::Abi) -> HRESULT,
    fn RegisterControlGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, controlGroup: <PerceptionControlGroup as RtType>::Abi) -> HRESULT,
    fn UnregisterControlGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, controlGroup: <PerceptionControlGroup as RtType>::Abi) -> HRESULT,
    fn RegisterCorrelationGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, correlationGroup: <PerceptionCorrelationGroup as RtType>::Abi) -> HRESULT,
    fn UnregisterCorrelationGroup(&self, manager: <IPerceptionFrameProviderManager as RtType>::Abi, correlationGroup: <PerceptionCorrelationGroup as RtType>::Abi) -> HRESULT,
    fn UpdateAvailabilityForProvider(&self, provider: <IPerceptionFrameProvider as RtType>::Abi, available: bool) -> HRESULT,
    fn PublishFrameForProvider(&self, provider: <IPerceptionFrameProvider as RtType>::Abi, frame: <PerceptionFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionFrameProviderManagerServiceStatics {
    #[inline] pub fn register_frame_provider_info(&self, manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterFrameProviderInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(frameProviderInfo) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_frame_provider_info(&self, manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnregisterFrameProviderInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(frameProviderInfo) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_face_authentication_group(&self, manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterFaceAuthenticationGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(faceAuthenticationGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_face_authentication_group(&self, manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnregisterFaceAuthenticationGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(faceAuthenticationGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_control_group(&self, manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterControlGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(controlGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_control_group(&self, manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnregisterControlGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(controlGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_correlation_group(&self, manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RegisterCorrelationGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(correlationGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_correlation_group(&self, manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UnregisterCorrelationGroup)(self.0.as_abi() as *const _ as *mut _, get_abi(manager) as *const _ as *mut _, get_abi(correlationGroup) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update_availability_for_provider(&self, provider: &IPerceptionFrameProvider, available: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).UpdateAvailabilityForProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, available);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn publish_frame_for_provider(&self, provider: &IPerceptionFrameProvider, frame: &PerceptionFrame) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PublishFrameForProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, get_abi(frame) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionPropertyChangeRequest, 1012591441, 13579, 19960, 148, 20, 89, 224, 152, 21, 81, 11);
RT_INTERFACE!{interface IPerceptionPropertyChangeRequest(IPerceptionPropertyChangeRequestVtbl, IPerceptionPropertyChangeRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionPropertyChangeRequest] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut super::PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn put_Status(&self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IPerceptionPropertyChangeRequest {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::PerceptionFrameSourcePropertyChangeStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_status(&self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Status)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionPropertyChangeRequest: IPerceptionPropertyChangeRequest}
DEFINE_IID!(IID_PerceptionStartFaceAuthenticationHandler, 1954639146, 8336, 18032, 140, 72, 239, 57, 231, 255, 124, 38);
RT_DELEGATE!{delegate PerceptionStartFaceAuthenticationHandler(PerceptionStartFaceAuthenticationHandlerVtbl, PerceptionStartFaceAuthenticationHandler_Abi, PerceptionStartFaceAuthenticationHandlerImpl) [IID_PerceptionStartFaceAuthenticationHandler] {
    fn Invoke(&self, sender: <PerceptionFaceAuthenticationGroup as RtType>::Abi, out: *mut bool) -> HRESULT
}}
impl PerceptionStartFaceAuthenticationHandler {
    #[inline] pub fn invoke(&self, sender: &PerceptionFaceAuthenticationGroup) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_PerceptionStopFaceAuthenticationHandler, 947840682, 35277, 18462, 170, 222, 221, 146, 247, 11, 42, 215);
RT_DELEGATE!{delegate PerceptionStopFaceAuthenticationHandler(PerceptionStopFaceAuthenticationHandlerVtbl, PerceptionStopFaceAuthenticationHandler_Abi, PerceptionStopFaceAuthenticationHandlerImpl) [IID_PerceptionStopFaceAuthenticationHandler] {
    fn Invoke(&self, sender: <PerceptionFaceAuthenticationGroup as RtType>::Abi) -> HRESULT
}}
impl PerceptionStopFaceAuthenticationHandler {
    #[inline] pub fn invoke(&self, sender: &PerceptionFaceAuthenticationGroup) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionVideoFrameAllocator, 1278781402, 64984, 20180, 160, 57, 42, 111, 155, 35, 80, 56);
RT_INTERFACE!{interface IPerceptionVideoFrameAllocator(IPerceptionVideoFrameAllocatorVtbl, IPerceptionVideoFrameAllocator_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocator] {
    fn AllocateFrame(&self, out: *mut <PerceptionFrame as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-media")] fn CopyFromVideoFrame(&self, frame: <crate::windows::media::VideoFrame as RtType>::Abi, out: *mut <PerceptionFrame as RtType>::Abi) -> HRESULT
}}
impl IPerceptionVideoFrameAllocator {
    #[inline] pub fn allocate_frame(&self) -> Result<Option<PerceptionFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AllocateFrame)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionFrame::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn copy_from_video_frame(&self, frame: &crate::windows::media::VideoFrame) -> Result<Option<PerceptionFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CopyFromVideoFrame)(self.0.as_abi() as *const _ as *mut _, get_abi(frame) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PerceptionFrame::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionVideoFrameAllocator: IPerceptionVideoFrameAllocator}
impl RtActivatable<IPerceptionVideoFrameAllocatorFactory> for PerceptionVideoFrameAllocator {}
impl PerceptionVideoFrameAllocator {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode) -> Result<PerceptionVideoFrameAllocator> {
        <Self as RtActivatable<IPerceptionVideoFrameAllocatorFactory>>::get_activation_factory().create(maxOutstandingFrameCountForWrite, format, resolution, alpha)
    }
}
DEFINE_CLSID!(PerceptionVideoFrameAllocator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,65,108,108,111,99,97,116,111,114,0]) [CLSID_PerceptionVideoFrameAllocator]);
DEFINE_IID!(IID_IPerceptionVideoFrameAllocatorFactory, 442020065, 59674, 18462, 184, 118, 168, 158, 43, 188, 107, 51);
RT_INTERFACE!{static interface IPerceptionVideoFrameAllocatorFactory(IPerceptionVideoFrameAllocatorFactoryVtbl, IPerceptionVideoFrameAllocatorFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocatorFactory] {
    #[cfg(feature="windows-graphics")] fn Create(&self, maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode, out: *mut <PerceptionVideoFrameAllocator as RtType>::Abi) -> HRESULT
}}
impl IPerceptionVideoFrameAllocatorFactory {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(&self, maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode) -> Result<PerceptionVideoFrameAllocator> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, maxOutstandingFrameCountForWrite, format, resolution, alpha, &mut out);
        if hr == S_OK { Ok(PerceptionVideoFrameAllocator::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Perception.Provider
} // Windows.Devices.Perception
pub mod pointofservice { // Windows.Devices.PointOfService
use crate::prelude::*;
DEFINE_IID!(IID_IBarcodeScanner, 3198369286, 45668, 20227, 169, 193, 69, 178, 15, 1, 19, 79);
RT_INTERFACE!{interface IBarcodeScanner(IBarcodeScannerVtbl, IBarcodeScanner_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <BarcodeScannerCapabilities as RtType>::Abi) -> HRESULT,
    fn ClaimScannerAsync(&self, out: *mut <foundation::IAsyncOperation<ClaimedBarcodeScanner> as RtType>::Abi) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetSupportedSymbologiesAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<u32>> as RtType>::Abi) -> HRESULT,
    fn IsSymbologySupportedAsync(&self, barcodeSymbology: u32, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn GetSupportedProfiles(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn IsProfileSupported(&self, profile: HSTRING, out: *mut bool) -> HRESULT,
    fn add_StatusUpdated(&self, handler: <foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBarcodeScanner {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<BarcodeScannerCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_scanner_async(&self) -> Result<foundation::IAsyncOperation<ClaimedBarcodeScanner>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClaimScannerAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckHealthAsync)(self.0.as_abi() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_symbologies_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSupportedSymbologiesAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_symbology_supported_async(&self, barcodeSymbology: u32) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).IsSymbologySupportedAsync)(self.0.as_abi() as *const _ as *mut _, barcodeSymbology, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RetrieveStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_profiles(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSupportedProfiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_profile_supported(&self, profile: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsProfileSupported)(self.0.as_abi() as *const _ as *mut _, profile.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScanner: IBarcodeScanner}
impl RtActivatable<IBarcodeScannerStatics> for BarcodeScanner {}
impl RtActivatable<IBarcodeScannerStatics2> for BarcodeScanner {}
impl BarcodeScanner {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<BarcodeScanner>> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BarcodeScanner>> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IBarcodeScannerStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(BarcodeScanner(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,99,97,110,110,101,114,0]) [CLSID_BarcodeScanner]);
DEFINE_IID!(IID_IBarcodeScanner2, 2300662119, 36078, 17261, 137, 171, 141, 251, 67, 187, 66, 134);
RT_INTERFACE!{interface IBarcodeScanner2(IBarcodeScanner2Vtbl, IBarcodeScanner2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner2] {
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBarcodeScanner2 {
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerCapabilities, 3322319332, 62152, 17440, 163, 7, 177, 46, 246, 98, 40, 87);
RT_INTERFACE!{interface IBarcodeScannerCapabilities(IBarcodeScannerCapabilitiesVtbl, IBarcodeScannerCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsImagePreviewSupported(&self, out: *mut bool) -> HRESULT
}}
impl IBarcodeScannerCapabilities {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsUpdatingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_image_preview_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsImagePreviewSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerCapabilities: IBarcodeScannerCapabilities}
DEFINE_IID!(IID_IBarcodeScannerCapabilities1, 2388308969, 3628, 18223, 161, 204, 238, 128, 84, 182, 166, 132);
RT_INTERFACE!{interface IBarcodeScannerCapabilities1(IBarcodeScannerCapabilities1Vtbl, IBarcodeScannerCapabilities1_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities1] {
    fn get_IsSoftwareTriggerSupported(&self, out: *mut bool) -> HRESULT
}}
impl IBarcodeScannerCapabilities1 {
    #[inline] pub fn get_is_software_trigger_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSoftwareTriggerSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerCapabilities2, 4061253612, 57761, 20136, 154, 188, 146, 177, 89, 98, 112, 171);
RT_INTERFACE!{interface IBarcodeScannerCapabilities2(IBarcodeScannerCapabilities2Vtbl, IBarcodeScannerCapabilities2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities2] {
    fn get_IsVideoPreviewSupported(&self, out: *mut bool) -> HRESULT
}}
impl IBarcodeScannerCapabilities2 {
    #[inline] pub fn get_is_video_preview_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVideoPreviewSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerDataReceivedEventArgs, 1110747106, 60823, 18045, 173, 43, 1, 228, 67, 19, 169, 41);
RT_INTERFACE!{interface IBarcodeScannerDataReceivedEventArgs(IBarcodeScannerDataReceivedEventArgsVtbl, IBarcodeScannerDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut <BarcodeScannerReport as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerDataReceivedEventArgs {
    #[inline] pub fn get_report(&self) -> Result<Option<BarcodeScannerReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerReport::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDataReceivedEventArgs: IBarcodeScannerDataReceivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerErrorOccurredEventArgs, 751984687, 53050, 16386, 167, 90, 197, 236, 70, 143, 10, 32);
RT_INTERFACE!{interface IBarcodeScannerErrorOccurredEventArgs(IBarcodeScannerErrorOccurredEventArgsVtbl, IBarcodeScannerErrorOccurredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerErrorOccurredEventArgs] {
    fn get_PartialInputData(&self, out: *mut <BarcodeScannerReport as RtType>::Abi) -> HRESULT,
    fn get_IsRetriable(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorData(&self, out: *mut <UnifiedPosErrorData as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerErrorOccurredEventArgs {
    #[inline] pub fn get_partial_input_data(&self) -> Result<Option<BarcodeScannerReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PartialInputData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_retriable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRetriable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_data(&self) -> Result<Option<UnifiedPosErrorData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UnifiedPosErrorData::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerErrorOccurredEventArgs: IBarcodeScannerErrorOccurredEventArgs}
DEFINE_IID!(IID_IBarcodeScannerImagePreviewReceivedEventArgs, 4088913541, 28299, 17230, 159, 88, 6, 239, 38, 188, 75, 175);
RT_INTERFACE!{interface IBarcodeScannerImagePreviewReceivedEventArgs(IBarcodeScannerImagePreviewReceivedEventArgsVtbl, IBarcodeScannerImagePreviewReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerImagePreviewReceivedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Preview(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerImagePreviewReceivedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_preview(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Preview)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamWithContentType::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerImagePreviewReceivedEventArgs: IBarcodeScannerImagePreviewReceivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerReport, 1558501552, 42121, 19350, 134, 196, 240, 191, 138, 55, 117, 61);
RT_INTERFACE!{interface IBarcodeScannerReport(IBarcodeScannerReportVtbl, IBarcodeScannerReport_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerReport] {
    fn get_ScanDataType(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ScanData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ScanDataLabel(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerReport {
    #[inline] pub fn get_scan_data_type(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanDataType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scan_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scan_data_label(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanDataLabel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerReport: IBarcodeScannerReport}
impl RtActivatable<IBarcodeScannerReportFactory> for BarcodeScannerReport {}
impl BarcodeScannerReport {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_instance(scanDataType: u32, scanData: &super::super::storage::streams::IBuffer, scanDataLabel: &super::super::storage::streams::IBuffer) -> Result<BarcodeScannerReport> {
        <Self as RtActivatable<IBarcodeScannerReportFactory>>::get_activation_factory().create_instance(scanDataType, scanData, scanDataLabel)
    }
}
DEFINE_CLSID!(BarcodeScannerReport(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,99,97,110,110,101,114,82,101,112,111,114,116,0]) [CLSID_BarcodeScannerReport]);
DEFINE_IID!(IID_IBarcodeScannerReportFactory, 2723443494, 8211, 17788, 137, 99, 73, 193, 93, 202, 120, 206);
RT_INTERFACE!{static interface IBarcodeScannerReportFactory(IBarcodeScannerReportFactoryVtbl, IBarcodeScannerReportFactory_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerReportFactory] {
    #[cfg(feature="windows-storage")] fn CreateInstance(&self, scanDataType: u32, scanData: <super::super::storage::streams::IBuffer as RtType>::Abi, scanDataLabel: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <BarcodeScannerReport as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerReportFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_instance(&self, scanDataType: u32, scanData: &super::super::storage::streams::IBuffer, scanDataLabel: &super::super::storage::streams::IBuffer) -> Result<BarcodeScannerReport> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, scanDataType, get_abi(scanData) as *const _ as *mut _, get_abi(scanDataLabel) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerReport::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStatics, 1561419631, 55881, 16872, 140, 140, 240, 203, 98, 169, 196, 252);
RT_INTERFACE!{static interface IBarcodeScannerStatics(IBarcodeScannerStaticsVtbl, IBarcodeScannerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<BarcodeScanner> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<BarcodeScanner> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBarcodeScannerStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<BarcodeScanner>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<BarcodeScanner>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStatics2, 3093636211, 41839, 16391, 177, 208, 39, 158, 190, 146, 166, 86);
RT_INTERFACE!{static interface IBarcodeScannerStatics2(IBarcodeScannerStatics2Vtbl, IBarcodeScannerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl IBarcodeScannerStatics2 {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BarcodeScannerStatus: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_IBarcodeScannerStatusUpdatedEventArgs, 895321478, 40003, 17963, 169, 26, 129, 109, 201, 127, 69, 44);
RT_INTERFACE!{interface IBarcodeScannerStatusUpdatedEventArgs(IBarcodeScannerStatusUpdatedEventArgsVtbl, IBarcodeScannerStatusUpdatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut BarcodeScannerStatus) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl IBarcodeScannerStatusUpdatedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<BarcodeScannerStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStatusUpdatedEventArgs: IBarcodeScannerStatusUpdatedEventArgs}
RT_CLASS!{static class BarcodeSymbologies}
impl RtActivatable<IBarcodeSymbologiesStatics> for BarcodeSymbologies {}
impl RtActivatable<IBarcodeSymbologiesStatics2> for BarcodeSymbologies {}
impl BarcodeSymbologies {
    #[inline] pub fn get_unknown() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_unknown()
    }
    #[inline] pub fn get_ean8() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8()
    }
    #[inline] pub fn get_ean8_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8_add2()
    }
    #[inline] pub fn get_ean8_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8_add5()
    }
    #[inline] pub fn get_eanv() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv()
    }
    #[inline] pub fn get_eanv_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv_add2()
    }
    #[inline] pub fn get_eanv_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv_add5()
    }
    #[inline] pub fn get_ean13() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13()
    }
    #[inline] pub fn get_ean13_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13_add2()
    }
    #[inline] pub fn get_ean13_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13_add5()
    }
    #[inline] pub fn get_isbn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbn()
    }
    #[inline] pub fn get_isbn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbn_add5()
    }
    #[inline] pub fn get_ismn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn()
    }
    #[inline] pub fn get_ismn_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn_add2()
    }
    #[inline] pub fn get_ismn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn_add5()
    }
    #[inline] pub fn get_issn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn()
    }
    #[inline] pub fn get_issn_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn_add2()
    }
    #[inline] pub fn get_issn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn_add5()
    }
    #[inline] pub fn get_ean99() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99()
    }
    #[inline] pub fn get_ean99_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99_add2()
    }
    #[inline] pub fn get_ean99_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99_add5()
    }
    #[inline] pub fn get_upca() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca()
    }
    #[inline] pub fn get_upca_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca_add2()
    }
    #[inline] pub fn get_upca_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca_add5()
    }
    #[inline] pub fn get_upce() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce()
    }
    #[inline] pub fn get_upce_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce_add2()
    }
    #[inline] pub fn get_upce_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce_add5()
    }
    #[inline] pub fn get_upc_coupon() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upc_coupon()
    }
    #[inline] pub fn get_tf_std() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_std()
    }
    #[inline] pub fn get_tf_dis() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_dis()
    }
    #[inline] pub fn get_tf_int() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_int()
    }
    #[inline] pub fn get_tf_ind() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_ind()
    }
    #[inline] pub fn get_tf_mat() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_mat()
    }
    #[inline] pub fn get_tf_iata() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_iata()
    }
    #[inline] pub fn get_gs1_databar_type1() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type1()
    }
    #[inline] pub fn get_gs1_databar_type2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type2()
    }
    #[inline] pub fn get_gs1_databar_type3() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type3()
    }
    #[inline] pub fn get_code_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_39()
    }
    #[inline] pub fn get_code_39_ex() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_39_ex()
    }
    #[inline] pub fn get_trioptic_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_trioptic_39()
    }
    #[inline] pub fn get_code_32() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_32()
    }
    #[inline] pub fn get_pzn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_pzn()
    }
    #[inline] pub fn get_code_93() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_93()
    }
    #[inline] pub fn get_code_93_ex() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_93_ex()
    }
    #[inline] pub fn get_code_128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_128()
    }
    #[inline] pub fn get_gs1128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1128()
    }
    #[inline] pub fn get_gs1128_coupon() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1128_coupon()
    }
    #[inline] pub fn get_ucc_ean128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ucc_ean128()
    }
    #[inline] pub fn get_sisac() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_sisac()
    }
    #[inline] pub fn get_isbt() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbt()
    }
    #[inline] pub fn get_codabar() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codabar()
    }
    #[inline] pub fn get_code_11() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_11()
    }
    #[inline] pub fn get_msi() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_msi()
    }
    #[inline] pub fn get_plessey() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_plessey()
    }
    #[inline] pub fn get_telepen() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_telepen()
    }
    #[inline] pub fn get_code_16k() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_16k()
    }
    #[inline] pub fn get_codablock_a() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_a()
    }
    #[inline] pub fn get_codablock_f() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_f()
    }
    #[inline] pub fn get_codablock_128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_128()
    }
    #[inline] pub fn get_code_49() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_49()
    }
    #[inline] pub fn get_aztec() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_aztec()
    }
    #[inline] pub fn get_data_code() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_data_code()
    }
    #[inline] pub fn get_data_matrix() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_data_matrix()
    }
    #[inline] pub fn get_han_xin() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_han_xin()
    }
    #[inline] pub fn get_maxicode() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_maxicode()
    }
    #[inline] pub fn get_micro_pdf417() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micro_pdf417()
    }
    #[inline] pub fn get_micro_qr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micro_qr()
    }
    #[inline] pub fn get_pdf417() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_pdf417()
    }
    #[inline] pub fn get_qr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_qr()
    }
    #[inline] pub fn get_ms_tag() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ms_tag()
    }
    #[inline] pub fn get_ccab() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ccab()
    }
    #[inline] pub fn get_ccc() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ccc()
    }
    #[inline] pub fn get_tlc39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tlc39()
    }
    #[inline] pub fn get_aus_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_aus_post()
    }
    #[inline] pub fn get_can_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_can_post()
    }
    #[inline] pub fn get_china_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_china_post()
    }
    #[inline] pub fn get_dutch_kix() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_dutch_kix()
    }
    #[inline] pub fn get_info_mail() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_info_mail()
    }
    #[inline] pub fn get_italian_post_25() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_italian_post_25()
    }
    #[inline] pub fn get_italian_post_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_italian_post_39()
    }
    #[inline] pub fn get_japan_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_japan_post()
    }
    #[inline] pub fn get_korean_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_korean_post()
    }
    #[inline] pub fn get_sweden_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_sweden_post()
    }
    #[inline] pub fn get_uk_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_uk_post()
    }
    #[inline] pub fn get_us_intelligent() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_intelligent()
    }
    #[inline] pub fn get_us_intelligent_pkg() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_intelligent_pkg()
    }
    #[inline] pub fn get_us_planet() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_planet()
    }
    #[inline] pub fn get_us_post_net() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_post_net()
    }
    #[inline] pub fn get_us4_state_fics() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us4_state_fics()
    }
    #[inline] pub fn get_ocr_a() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ocr_a()
    }
    #[inline] pub fn get_ocr_b() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ocr_b()
    }
    #[inline] pub fn get_micr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micr()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_extended_base()
    }
    #[inline] pub fn get_name(scanDataType: u32) -> Result<HString> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_name(scanDataType)
    }
    #[inline] pub fn get_gs1dw_code() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics2>>::get_activation_factory().get_gs1dw_code()
    }
}
DEFINE_CLSID!(BarcodeSymbologies(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,121,109,98,111,108,111,103,105,101,115,0]) [CLSID_BarcodeSymbologies]);
DEFINE_IID!(IID_IBarcodeSymbologiesStatics, 3397732795, 1746, 17396, 164, 75, 198, 32, 103, 159, 216, 208);
RT_INTERFACE!{static interface IBarcodeSymbologiesStatics(IBarcodeSymbologiesStaticsVtbl, IBarcodeSymbologiesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologiesStatics] {
    fn get_Unknown(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Eanv(&self, out: *mut u32) -> HRESULT,
    fn get_EanvAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_EanvAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Isbn(&self, out: *mut u32) -> HRESULT,
    fn get_IsbnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ismn(&self, out: *mut u32) -> HRESULT,
    fn get_IsmnAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_IsmnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Issn(&self, out: *mut u32) -> HRESULT,
    fn get_IssnAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_IssnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Upca(&self, out: *mut u32) -> HRESULT,
    fn get_UpcaAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_UpcaAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Upce(&self, out: *mut u32) -> HRESULT,
    fn get_UpceAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_UpceAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_UpcCoupon(&self, out: *mut u32) -> HRESULT,
    fn get_TfStd(&self, out: *mut u32) -> HRESULT,
    fn get_TfDis(&self, out: *mut u32) -> HRESULT,
    fn get_TfInt(&self, out: *mut u32) -> HRESULT,
    fn get_TfInd(&self, out: *mut u32) -> HRESULT,
    fn get_TfMat(&self, out: *mut u32) -> HRESULT,
    fn get_TfIata(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType1(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType2(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType3(&self, out: *mut u32) -> HRESULT,
    fn get_Code39(&self, out: *mut u32) -> HRESULT,
    fn get_Code39Ex(&self, out: *mut u32) -> HRESULT,
    fn get_Trioptic39(&self, out: *mut u32) -> HRESULT,
    fn get_Code32(&self, out: *mut u32) -> HRESULT,
    fn get_Pzn(&self, out: *mut u32) -> HRESULT,
    fn get_Code93(&self, out: *mut u32) -> HRESULT,
    fn get_Code93Ex(&self, out: *mut u32) -> HRESULT,
    fn get_Code128(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1128(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1128Coupon(&self, out: *mut u32) -> HRESULT,
    fn get_UccEan128(&self, out: *mut u32) -> HRESULT,
    fn get_Sisac(&self, out: *mut u32) -> HRESULT,
    fn get_Isbt(&self, out: *mut u32) -> HRESULT,
    fn get_Codabar(&self, out: *mut u32) -> HRESULT,
    fn get_Code11(&self, out: *mut u32) -> HRESULT,
    fn get_Msi(&self, out: *mut u32) -> HRESULT,
    fn get_Plessey(&self, out: *mut u32) -> HRESULT,
    fn get_Telepen(&self, out: *mut u32) -> HRESULT,
    fn get_Code16k(&self, out: *mut u32) -> HRESULT,
    fn get_CodablockA(&self, out: *mut u32) -> HRESULT,
    fn get_CodablockF(&self, out: *mut u32) -> HRESULT,
    fn get_Codablock128(&self, out: *mut u32) -> HRESULT,
    fn get_Code49(&self, out: *mut u32) -> HRESULT,
    fn get_Aztec(&self, out: *mut u32) -> HRESULT,
    fn get_DataCode(&self, out: *mut u32) -> HRESULT,
    fn get_DataMatrix(&self, out: *mut u32) -> HRESULT,
    fn get_HanXin(&self, out: *mut u32) -> HRESULT,
    fn get_Maxicode(&self, out: *mut u32) -> HRESULT,
    fn get_MicroPdf417(&self, out: *mut u32) -> HRESULT,
    fn get_MicroQr(&self, out: *mut u32) -> HRESULT,
    fn get_Pdf417(&self, out: *mut u32) -> HRESULT,
    fn get_Qr(&self, out: *mut u32) -> HRESULT,
    fn get_MsTag(&self, out: *mut u32) -> HRESULT,
    fn get_Ccab(&self, out: *mut u32) -> HRESULT,
    fn get_Ccc(&self, out: *mut u32) -> HRESULT,
    fn get_Tlc39(&self, out: *mut u32) -> HRESULT,
    fn get_AusPost(&self, out: *mut u32) -> HRESULT,
    fn get_CanPost(&self, out: *mut u32) -> HRESULT,
    fn get_ChinaPost(&self, out: *mut u32) -> HRESULT,
    fn get_DutchKix(&self, out: *mut u32) -> HRESULT,
    fn get_InfoMail(&self, out: *mut u32) -> HRESULT,
    fn get_ItalianPost25(&self, out: *mut u32) -> HRESULT,
    fn get_ItalianPost39(&self, out: *mut u32) -> HRESULT,
    fn get_JapanPost(&self, out: *mut u32) -> HRESULT,
    fn get_KoreanPost(&self, out: *mut u32) -> HRESULT,
    fn get_SwedenPost(&self, out: *mut u32) -> HRESULT,
    fn get_UkPost(&self, out: *mut u32) -> HRESULT,
    fn get_UsIntelligent(&self, out: *mut u32) -> HRESULT,
    fn get_UsIntelligentPkg(&self, out: *mut u32) -> HRESULT,
    fn get_UsPlanet(&self, out: *mut u32) -> HRESULT,
    fn get_UsPostNet(&self, out: *mut u32) -> HRESULT,
    fn get_Us4StateFics(&self, out: *mut u32) -> HRESULT,
    fn get_OcrA(&self, out: *mut u32) -> HRESULT,
    fn get_OcrB(&self, out: *mut u32) -> HRESULT,
    fn get_Micr(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT,
    fn GetName(&self, scanDataType: u32, out: *mut HSTRING) -> HRESULT
}}
impl IBarcodeSymbologiesStatics {
    #[inline] pub fn get_unknown(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Unknown)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean8)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean8Add2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean8Add5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Eanv)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EanvAdd2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EanvAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean13)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean13Add2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean13Add5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Isbn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsbnAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ismn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsmnAdd2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsmnAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Issn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IssnAdd2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IssnAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean99)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean99Add2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ean99Add5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Upca)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpcaAdd2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpcaAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Upce)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpceAdd2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpceAdd5)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upc_coupon(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpcCoupon)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_std(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfStd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_dis(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfDis)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_int(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfInt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_ind(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfInd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_mat(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfMat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_iata(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TfIata)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type1(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1DatabarType1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1DatabarType2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type3(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1DatabarType3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code39)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_39_ex(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code39Ex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trioptic_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Trioptic39)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_32(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pzn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pzn)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_93(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code93)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_93_ex(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code93Ex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1128_coupon(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1128Coupon)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ucc_ean128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UccEan128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sisac(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Sisac)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbt(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Isbt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codabar(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Codabar)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_11(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code11)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_msi(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Msi)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_plessey(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Plessey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_telepen(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Telepen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_16k(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code16k)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_a(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CodablockA)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_f(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CodablockF)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Codablock128)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_49(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Code49)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aztec(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Aztec)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_matrix(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataMatrix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_han_xin(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HanXin)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_maxicode(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Maxicode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micro_pdf417(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicroPdf417)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micro_qr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MicroQr)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pdf417(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pdf417)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_qr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Qr)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ms_tag(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MsTag)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ccab(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ccab)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ccc(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ccc)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tlc39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Tlc39)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aus_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AusPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_china_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChinaPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dutch_kix(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DutchKix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_info_mail(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InfoMail)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_italian_post_25(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ItalianPost25)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_italian_post_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ItalianPost39)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_japan_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_JapanPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_korean_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_KoreanPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sweden_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SwedenPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uk_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UkPost)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_intelligent(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsIntelligent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_intelligent_pkg(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsIntelligentPkg)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_planet(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsPlanet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_post_net(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsPostNet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us4_state_fics(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Us4StateFics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ocr_a(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OcrA)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ocr_b(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OcrB)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Micr)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedBase)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self, scanDataType: u32) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetName)(self.0.as_abi() as *const _ as *mut _, scanDataType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeSymbologiesStatics2, 2339707124, 39376, 16575, 148, 36, 185, 29, 109, 212, 198, 224);
RT_INTERFACE!{static interface IBarcodeSymbologiesStatics2(IBarcodeSymbologiesStatics2Vtbl, IBarcodeSymbologiesStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologiesStatics2] {
    fn get_Gs1DWCode(&self, out: *mut u32) -> HRESULT
}}
impl IBarcodeSymbologiesStatics2 {
    #[inline] pub fn get_gs1dw_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gs1DWCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeSymbologyAttributes, 1715550840, 43898, 19162, 142, 206, 147, 96, 20, 178, 234, 215);
RT_INTERFACE!{interface IBarcodeSymbologyAttributes(IBarcodeSymbologyAttributesVtbl, IBarcodeSymbologyAttributes_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologyAttributes] {
    fn get_IsCheckDigitValidationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitValidationEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitValidationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitTransmissionEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_DecodeLength1(&self, out: *mut u32) -> HRESULT,
    fn put_DecodeLength1(&self, value: u32) -> HRESULT,
    fn get_DecodeLength2(&self, out: *mut u32) -> HRESULT,
    fn put_DecodeLength2(&self, value: u32) -> HRESULT,
    fn get_DecodeLengthKind(&self, out: *mut BarcodeSymbologyDecodeLengthKind) -> HRESULT,
    fn put_DecodeLengthKind(&self, value: BarcodeSymbologyDecodeLengthKind) -> HRESULT,
    fn get_IsDecodeLengthSupported(&self, out: *mut bool) -> HRESULT
}}
impl IBarcodeSymbologyAttributes {
    #[inline] pub fn get_is_check_digit_validation_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitValidationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_validation_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCheckDigitValidationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_validation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitValidationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitTransmissionEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_transmission_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCheckDigitTransmissionEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitTransmissionSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length1(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecodeLength1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length1(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecodeLength1)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecodeLength2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length2(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecodeLength2)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length_kind(&self) -> Result<BarcodeSymbologyDecodeLengthKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DecodeLengthKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length_kind(&self, value: BarcodeSymbologyDecodeLengthKind) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DecodeLengthKind)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDecodeLengthSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeSymbologyAttributes: IBarcodeSymbologyAttributes}
RT_ENUM! { enum BarcodeSymbologyDecodeLengthKind: i32 {
    AnyLength = 0, Discrete = 1, Range = 2,
}}
DEFINE_IID!(IID_ICashDrawer, 2676553160, 56916, 19182, 168, 144, 146, 11, 203, 254, 48, 252);
RT_INTERFACE!{interface ICashDrawer(ICashDrawerVtbl, ICashDrawer_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <CashDrawerCapabilities as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut <CashDrawerStatus as RtType>::Abi) -> HRESULT,
    fn get_IsDrawerOpen(&self, out: *mut bool) -> HRESULT,
    fn get_DrawerEventSource(&self, out: *mut <CashDrawerEventSource as RtType>::Abi) -> HRESULT,
    fn ClaimDrawerAsync(&self, out: *mut <foundation::IAsyncOperation<ClaimedCashDrawer> as RtType>::Abi) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn add_StatusUpdated(&self, handler: <foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICashDrawer {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<CashDrawerCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawerCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<Option<CashDrawerStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawerStatus::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDrawerOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drawer_event_source(&self) -> Result<Option<CashDrawerEventSource>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DrawerEventSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawerEventSource::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_drawer_async(&self) -> Result<foundation::IAsyncOperation<ClaimedCashDrawer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClaimDrawerAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckHealthAsync)(self.0.as_abi() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawer: ICashDrawer}
impl RtActivatable<ICashDrawerStatics> for CashDrawer {}
impl RtActivatable<ICashDrawerStatics2> for CashDrawer {}
impl CashDrawer {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<CashDrawer>> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<CashDrawer>> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<ICashDrawerStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(CashDrawer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,67,97,115,104,68,114,97,119,101,114,0]) [CLSID_CashDrawer]);
DEFINE_IID!(IID_ICashDrawerCapabilities, 197582347, 59623, 19231, 177, 209, 62, 80, 26, 208, 130, 71);
RT_INTERFACE!{interface ICashDrawerCapabilities(ICashDrawerCapabilitiesVtbl, ICashDrawerCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatusReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatusMultiDrawerDetectSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDrawerOpenSensorAvailable(&self, out: *mut bool) -> HRESULT
}}
impl ICashDrawerCapabilities {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsUpdatingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_status_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatusReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_status_multi_drawer_detect_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatusMultiDrawerDetectSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open_sensor_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDrawerOpenSensorAvailable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerCapabilities: ICashDrawerCapabilities}
DEFINE_IID!(IID_ICashDrawerCloseAlarm, 1811451079, 28515, 17166, 171, 59, 149, 215, 95, 251, 232, 127);
RT_INTERFACE!{interface ICashDrawerCloseAlarm(ICashDrawerCloseAlarmVtbl, ICashDrawerCloseAlarm_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerCloseAlarm] {
    fn put_AlarmTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_AlarmTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BeepFrequency(&self, value: u32) -> HRESULT,
    fn get_BeepFrequency(&self, out: *mut u32) -> HRESULT,
    fn put_BeepDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BeepDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BeepDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BeepDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn add_AlarmTimeoutExpired(&self, handler: <foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AlarmTimeoutExpired(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn StartAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ICashDrawerCloseAlarm {
    #[inline] pub fn set_alarm_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AlarmTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_alarm_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlarmTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_frequency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BeepFrequency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_frequency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BeepFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BeepDuration)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BeepDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BeepDelay)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BeepDelay)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_alarm_timeout_expired(&self, handler: &foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AlarmTimeoutExpired)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_alarm_timeout_expired(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AlarmTimeoutExpired)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerCloseAlarm: ICashDrawerCloseAlarm}
RT_CLASS!{class CashDrawerClosedEventArgs: ICashDrawerEventSourceEventArgs}
DEFINE_IID!(IID_ICashDrawerEventSource, 3758548076, 62201, 17455, 141, 214, 6, 193, 10, 66, 39, 186);
RT_INTERFACE!{interface ICashDrawerEventSource(ICashDrawerEventSourceVtbl, ICashDrawerEventSource_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSource] {
    fn add_DrawerClosed(&self, handler: <foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DrawerClosed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DrawerOpened(&self, handler: <foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DrawerOpened(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICashDrawerEventSource {
    #[inline] pub fn add_drawer_closed(&self, handler: &foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DrawerClosed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_drawer_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DrawerClosed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_drawer_opened(&self, handler: &foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DrawerOpened)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_drawer_opened(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DrawerOpened)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerEventSource: ICashDrawerEventSource}
DEFINE_IID!(IID_ICashDrawerEventSourceEventArgs, 1774926785, 5247, 16924, 156, 35, 9, 1, 35, 187, 120, 108);
RT_INTERFACE!{interface ICashDrawerEventSourceEventArgs(ICashDrawerEventSourceEventArgsVtbl, ICashDrawerEventSourceEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSourceEventArgs] {
    fn get_CashDrawer(&self, out: *mut <CashDrawer as RtType>::Abi) -> HRESULT
}}
impl ICashDrawerEventSourceEventArgs {
    #[inline] pub fn get_cash_drawer(&self) -> Result<Option<CashDrawer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CashDrawer)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerOpenedEventArgs: ICashDrawerEventSourceEventArgs}
DEFINE_IID!(IID_ICashDrawerStatics, 3751843162, 54327, 20479, 181, 71, 221, 169, 105, 164, 248, 131);
RT_INTERFACE!{static interface ICashDrawerStatics(ICashDrawerStaticsVtbl, ICashDrawerStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<CashDrawer> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<CashDrawer> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICashDrawerStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<CashDrawer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<CashDrawer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICashDrawerStatics2, 1048674593, 35906, 16616, 156, 14, 64, 41, 112, 72, 16, 76);
RT_INTERFACE!{static interface ICashDrawerStatics2(ICashDrawerStatics2Vtbl, ICashDrawerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ICashDrawerStatics2 {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICashDrawerStatus, 1807579327, 56481, 19974, 153, 235, 90, 246, 165, 174, 193, 8);
RT_INTERFACE!{interface ICashDrawerStatus(ICashDrawerStatusVtbl, ICashDrawerStatus_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatus] {
    fn get_StatusKind(&self, out: *mut CashDrawerStatusKind) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl ICashDrawerStatus {
    #[inline] pub fn get_status_kind(&self) -> Result<CashDrawerStatusKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StatusKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerStatus: ICashDrawerStatus}
RT_ENUM! { enum CashDrawerStatusKind: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_ICashDrawerStatusUpdatedEventArgs, 816507274, 3440, 17820, 149, 83, 135, 225, 36, 197, 36, 136);
RT_INTERFACE!{interface ICashDrawerStatusUpdatedEventArgs(ICashDrawerStatusUpdatedEventArgsVtbl, ICashDrawerStatusUpdatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut <CashDrawerStatus as RtType>::Abi) -> HRESULT
}}
impl ICashDrawerStatusUpdatedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<Option<CashDrawerStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawerStatus::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerStatusUpdatedEventArgs: ICashDrawerStatusUpdatedEventArgs}
DEFINE_IID!(IID_IClaimedBarcodeScanner, 1248048284, 36772, 17202, 187, 38, 148, 93, 17, 216, 30, 15);
RT_INTERFACE!{interface IClaimedBarcodeScanner(IClaimedBarcodeScannerVtbl, IClaimedBarcodeScanner_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisabledOnDataReceived(&self, value: bool) -> HRESULT,
    fn get_IsDisabledOnDataReceived(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeDataEnabled(&self, value: bool) -> HRESULT,
    fn get_IsDecodeDataEnabled(&self, out: *mut bool) -> HRESULT,
    fn EnableAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DisableAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn SetActiveSymbologiesAsync(&self, symbologies: <foundation::collections::IIterable<u32> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn SetActiveProfileAsync(&self, profile: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_DataReceived(&self, handler: <foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TriggerPressed(&self, handler: <foundation::EventHandler<ClaimedBarcodeScanner> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TriggerPressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TriggerReleased(&self, handler: <foundation::EventHandler<ClaimedBarcodeScanner> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TriggerReleased(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: <foundation::EventHandler<ClaimedBarcodeScanner> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImagePreviewReceived(&self, handler: <foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImagePreviewReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: <foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedBarcodeScanner {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_disabled_on_data_received(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDisabledOnDataReceived)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_on_data_received(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledOnDataReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_data_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDecodeDataEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_data_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDecodeDataEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).EnableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DisableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RetainDevice)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_active_symbologies_async(&self, symbologies: &foundation::collections::IIterable<u32>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetActiveSymbologiesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(symbologies) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statistics) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_active_profile_async(&self, profile: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetActiveProfileAsync)(self.0.as_abi() as *const _ as *mut _, profile.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_data_received(&self, handler: &foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_trigger_pressed(&self, handler: &foundation::EventHandler<ClaimedBarcodeScanner>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TriggerPressed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_trigger_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TriggerPressed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_trigger_released(&self, handler: &foundation::EventHandler<ClaimedBarcodeScanner>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_TriggerReleased)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_trigger_released(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_TriggerReleased)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &foundation::EventHandler<ClaimedBarcodeScanner>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_image_preview_received(&self, handler: &foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ImagePreviewReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_image_preview_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ImagePreviewReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedBarcodeScanner: IClaimedBarcodeScanner}
DEFINE_IID!(IID_IClaimedBarcodeScanner1, 4128943372, 34129, 17076, 153, 140, 151, 12, 32, 33, 10, 34);
RT_INTERFACE!{interface IClaimedBarcodeScanner1(IClaimedBarcodeScanner1Vtbl, IClaimedBarcodeScanner1_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner1] {
    fn StartSoftwareTriggerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn StopSoftwareTriggerAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IClaimedBarcodeScanner1 {
    #[inline] pub fn start_software_trigger_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartSoftwareTriggerAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_software_trigger_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopSoftwareTriggerAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner2, 3820330636, 11659, 20336, 138, 243, 52, 72, 190, 221, 95, 226);
RT_INTERFACE!{interface IClaimedBarcodeScanner2(IClaimedBarcodeScanner2Vtbl, IClaimedBarcodeScanner2_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner2] {
    fn GetSymbologyAttributesAsync(&self, barcodeSymbology: u32, out: *mut <foundation::IAsyncOperation<BarcodeSymbologyAttributes> as RtType>::Abi) -> HRESULT,
    fn SetSymbologyAttributesAsync(&self, barcodeSymbology: u32, attributes: <BarcodeSymbologyAttributes as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IClaimedBarcodeScanner2 {
    #[inline] pub fn get_symbology_attributes_async(&self, barcodeSymbology: u32) -> Result<foundation::IAsyncOperation<BarcodeSymbologyAttributes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSymbologyAttributesAsync)(self.0.as_abi() as *const _ as *mut _, barcodeSymbology, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_symbology_attributes_async(&self, barcodeSymbology: u32, attributes: &BarcodeSymbologyAttributes) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetSymbologyAttributesAsync)(self.0.as_abi() as *const _ as *mut _, barcodeSymbology, get_abi(attributes) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner3, 3872306224, 28974, 17916, 139, 134, 205, 85, 245, 174, 247, 157);
RT_INTERFACE!{interface IClaimedBarcodeScanner3(IClaimedBarcodeScanner3Vtbl, IClaimedBarcodeScanner3_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner3] {
    fn ShowVideoPreviewAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn HideVideoPreview(&self) -> HRESULT,
    fn put_IsVideoPreviewShownOnEnable(&self, value: bool) -> HRESULT,
    fn get_IsVideoPreviewShownOnEnable(&self, out: *mut bool) -> HRESULT
}}
impl IClaimedBarcodeScanner3 {
    #[inline] pub fn show_video_preview_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ShowVideoPreviewAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn hide_video_preview(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).HideVideoPreview)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_is_video_preview_shown_on_enable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsVideoPreviewShownOnEnable)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_video_preview_shown_on_enable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVideoPreviewShownOnEnable)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner4, 1565532055, 14186, 16808, 162, 48, 47, 55, 193, 148, 157, 222);
RT_INTERFACE!{interface IClaimedBarcodeScanner4(IClaimedBarcodeScanner4Vtbl, IClaimedBarcodeScanner4_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner4] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedBarcodeScanner4 {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScannerClosedEventArgs, 3481097353, 41516, 19557, 169, 1, 136, 215, 125, 131, 57, 84);
RT_INTERFACE!{interface IClaimedBarcodeScannerClosedEventArgs(IClaimedBarcodeScannerClosedEventArgsVtbl, IClaimedBarcodeScannerClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScannerClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedBarcodeScannerClosedEventArgs: IClaimedBarcodeScannerClosedEventArgs}
DEFINE_IID!(IID_IClaimedCashDrawer, 3393165743, 43960, 17089, 138, 132, 92, 102, 81, 47, 90, 117);
RT_INTERFACE!{interface IClaimedCashDrawer(IClaimedCashDrawerVtbl, IClaimedCashDrawer_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDrawerOpen(&self, out: *mut bool) -> HRESULT,
    fn get_CloseAlarm(&self, out: *mut <CashDrawerCloseAlarm as RtType>::Abi) -> HRESULT,
    fn OpenDrawerAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn EnableAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn DisableAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RetainDeviceAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: <foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedCashDrawer {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDrawerOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_close_alarm(&self) -> Result<Option<CashDrawerCloseAlarm>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CloseAlarm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CashDrawerCloseAlarm::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_drawer_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenDrawerAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).EnableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DisableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RetainDeviceAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statistics) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedCashDrawer: IClaimedCashDrawer}
DEFINE_IID!(IID_IClaimedCashDrawer2, 2629481890, 56898, 19803, 176, 193, 155, 87, 162, 186, 137, 195);
RT_INTERFACE!{interface IClaimedCashDrawer2(IClaimedCashDrawer2Vtbl, IClaimedCashDrawer2_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawer2] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedCashDrawer2 {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedCashDrawerClosedEventArgs, 3428269875, 16180, 19548, 186, 174, 222, 173, 241, 108, 215, 250);
RT_INTERFACE!{interface IClaimedCashDrawerClosedEventArgs(IClaimedCashDrawerClosedEventArgsVtbl, IClaimedCashDrawerClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawerClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedCashDrawerClosedEventArgs: IClaimedCashDrawerClosedEventArgs}
DEFINE_IID!(IID_IClaimedJournalPrinter, 1743390256, 20861, 18559, 159, 223, 210, 224, 160, 162, 100, 165);
RT_INTERFACE!{interface IClaimedJournalPrinter(IClaimedJournalPrinterVtbl, IClaimedJournalPrinter_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedJournalPrinter] {
    fn CreateJob(&self, out: *mut <JournalPrintJob as RtType>::Abi) -> HRESULT
}}
impl IClaimedJournalPrinter {
    #[inline] pub fn create_job(&self) -> Result<Option<JournalPrintJob>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateJob)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(JournalPrintJob::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedJournalPrinter: IClaimedJournalPrinter}
DEFINE_IID!(IID_IClaimedLineDisplay, 302696816, 39541, 19151, 170, 231, 9, 151, 43, 207, 135, 148);
RT_INTERFACE!{interface IClaimedLineDisplay(IClaimedLineDisplayVtbl, IClaimedLineDisplay_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <LineDisplayCapabilities as RtType>::Abi) -> HRESULT,
    fn get_PhysicalDeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceServiceVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultWindow(&self, out: *mut <LineDisplayWindow as RtType>::Abi) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: <foundation::TypedEventHandler<ClaimedLineDisplay, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedLineDisplay {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<LineDisplayCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceControlDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceControlVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_service_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceServiceVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_window(&self) -> Result<Option<LineDisplayWindow>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultWindow)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayWindow::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RetainDevice)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &foundation::TypedEventHandler<ClaimedLineDisplay, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedLineDisplay: IClaimedLineDisplay}
impl RtActivatable<IClaimedLineDisplayStatics> for ClaimedLineDisplay {}
impl ClaimedLineDisplay {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ClaimedLineDisplay>> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(ClaimedLineDisplay(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,67,108,97,105,109,101,100,76,105,110,101,68,105,115,112,108,97,121,0]) [CLSID_ClaimedLineDisplay]);
DEFINE_IID!(IID_IClaimedLineDisplay2, 2736551405, 16885, 20086, 160, 116, 121, 94, 71, 164, 110, 151);
RT_INTERFACE!{interface IClaimedLineDisplay2(IClaimedLineDisplay2Vtbl, IClaimedLineDisplay2_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay2] {
    fn GetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn CheckPowerStatusAsync(&self, out: *mut <foundation::IAsyncOperation<LineDisplayPowerStatus> as RtType>::Abi) -> HRESULT,
    fn add_StatusUpdated(&self, handler: <foundation::TypedEventHandler<ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SupportedScreenSizesInCharacters(&self, out: *mut <foundation::collections::IVectorView<foundation::Size> as RtType>::Abi) -> HRESULT,
    fn get_MaxBitmapSizeInPixels(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SupportedCharacterSets(&self, out: *mut <foundation::collections::IVectorView<i32> as RtType>::Abi) -> HRESULT,
    fn get_CustomGlyphs(&self, out: *mut <LineDisplayCustomGlyphs as RtType>::Abi) -> HRESULT,
    fn GetAttributes(&self, out: *mut <LineDisplayAttributes as RtType>::Abi) -> HRESULT,
    fn TryUpdateAttributesAsync(&self, attributes: <LineDisplayAttributes as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TrySetDescriptorAsync(&self, descriptor: u32, descriptorState: LineDisplayDescriptorState, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryClearDescriptorsAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryCreateWindowAsync(&self, viewport: foundation::Rect, windowSize: foundation::Size, out: *mut <foundation::IAsyncOperation<LineDisplayWindow> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<LineDisplayStoredBitmap> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapWithAlignmentAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, out: *mut <foundation::IAsyncOperation<LineDisplayStoredBitmap> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapWithAlignmentAndWidthAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32, out: *mut <foundation::IAsyncOperation<LineDisplayStoredBitmap> as RtType>::Abi) -> HRESULT
}}
impl IClaimedLineDisplay2 {
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckHealthAsync)(self.0.as_abi() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_power_status_async(&self) -> Result<foundation::IAsyncOperation<LineDisplayPowerStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckPowerStatusAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &foundation::TypedEventHandler<ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_screen_sizes_in_characters(&self) -> Result<Option<foundation::collections::IVectorView<foundation::Size>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedScreenSizesInCharacters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_bitmap_size_in_pixels(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBitmapSizeInPixels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_character_sets(&self) -> Result<Option<foundation::collections::IVectorView<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCharacterSets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_glyphs(&self) -> Result<Option<LineDisplayCustomGlyphs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomGlyphs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayCustomGlyphs::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<LineDisplayAttributes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAttributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayAttributes::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_attributes_async(&self, attributes: &LineDisplayAttributes) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryUpdateAttributesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(attributes) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_descriptor_async(&self, descriptor: u32, descriptorState: LineDisplayDescriptorState) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TrySetDescriptorAsync)(self.0.as_abi() as *const _ as *mut _, descriptor, descriptorState, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_clear_descriptors_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryClearDescriptorsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_create_window_async(&self, viewport: foundation::Rect, windowSize: foundation::Size) -> Result<foundation::IAsyncOperation<LineDisplayWindow>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryCreateWindowAsync)(self.0.as_abi() as *const _ as *mut _, viewport, windowSize, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_async(&self, bitmap: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<LineDisplayStoredBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStoreStorageFileBitmapAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_with_alignment_async(&self, bitmap: &super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment) -> Result<foundation::IAsyncOperation<LineDisplayStoredBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStoreStorageFileBitmapWithAlignmentAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, horizontalAlignment, verticalAlignment, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_with_alignment_and_width_async(&self, bitmap: &super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32) -> Result<foundation::IAsyncOperation<LineDisplayStoredBitmap>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStoreStorageFileBitmapWithAlignmentAndWidthAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, horizontalAlignment, verticalAlignment, widthInPixels, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedLineDisplay3, 1680788882, 59860, 20172, 175, 117, 50, 156, 39, 76, 209, 143);
RT_INTERFACE!{interface IClaimedLineDisplay3(IClaimedLineDisplay3Vtbl, IClaimedLineDisplay3_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay3] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedLineDisplay3 {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedLineDisplayClosedEventArgs, 4178965348, 54229, 20240, 181, 17, 144, 147, 158, 223, 172, 216);
RT_INTERFACE!{interface IClaimedLineDisplayClosedEventArgs(IClaimedLineDisplayClosedEventArgsVtbl, IClaimedLineDisplayClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplayClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedLineDisplayClosedEventArgs: IClaimedLineDisplayClosedEventArgs}
DEFINE_IID!(IID_IClaimedLineDisplayStatics, 2026543355, 35691, 18803, 134, 240, 62, 87, 12, 53, 24, 37);
RT_INTERFACE!{static interface IClaimedLineDisplayStatics(IClaimedLineDisplayStaticsVtbl, IClaimedLineDisplayStatics_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplayStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<ClaimedLineDisplay> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl IClaimedLineDisplayStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ClaimedLineDisplay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedMagneticStripeReader, 1197254899, 37911, 18620, 185, 215, 65, 99, 167, 132, 76, 2);
RT_INTERFACE!{interface IClaimedMagneticStripeReader(IClaimedMagneticStripeReaderVtbl, IClaimedMagneticStripeReader_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisabledOnDataReceived(&self, value: bool) -> HRESULT,
    fn get_IsDisabledOnDataReceived(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeDataEnabled(&self, value: bool) -> HRESULT,
    fn get_IsDecodeDataEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDeviceAuthenticated(&self, out: *mut bool) -> HRESULT,
    fn put_DataEncryptionAlgorithm(&self, value: u32) -> HRESULT,
    fn get_DataEncryptionAlgorithm(&self, out: *mut u32) -> HRESULT,
    fn put_TracksToRead(&self, value: MagneticStripeReaderTrackIds) -> HRESULT,
    fn get_TracksToRead(&self, out: *mut MagneticStripeReaderTrackIds) -> HRESULT,
    fn put_IsTransmitSentinelsEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTransmitSentinelsEnabled(&self, out: *mut bool) -> HRESULT,
    fn EnableAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DisableAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn SetErrorReportingType(&self, value: MagneticStripeReaderErrorReportingType) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveDeviceAuthenticationDataAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn AuthenticateDeviceAsync(&self, responseTokenSize: u32, responseToken: *mut u8, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeAuthenticateDeviceAsync(&self, responseTokenSize: u32, responseToken: *mut u8, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UpdateKeyAsync(&self, key: HSTRING, keyName: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_BankCardDataReceived(&self, handler: <foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BankCardDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AamvaCardDataReceived(&self, handler: <foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AamvaCardDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VendorSpecificDataReceived(&self, handler: <foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VendorSpecificDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: <foundation::EventHandler<ClaimedMagneticStripeReader> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: <foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedMagneticStripeReader {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_disabled_on_data_received(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDisabledOnDataReceived)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_on_data_received(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDisabledOnDataReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_data_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDecodeDataEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_data_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDecodeDataEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_device_authenticated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDeviceAuthenticated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_encryption_algorithm(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataEncryptionAlgorithm)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_encryption_algorithm(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataEncryptionAlgorithm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_tracks_to_read(&self, value: MagneticStripeReaderTrackIds) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TracksToRead)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tracks_to_read(&self) -> Result<MagneticStripeReaderTrackIds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TracksToRead)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_transmit_sentinels_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsTransmitSentinelsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transmit_sentinels_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTransmitSentinelsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).EnableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DisableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).RetainDevice)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_error_reporting_type(&self, value: MagneticStripeReaderErrorReportingType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetErrorReportingType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_device_authentication_data_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RetrieveDeviceAuthenticationDataAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn authenticate_device_async(&self, responseToken: &[u8]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AuthenticateDeviceAsync)(self.0.as_abi() as *const _ as *mut _, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn de_authenticate_device_async(&self, responseToken: &[u8]) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeAuthenticateDeviceAsync)(self.0.as_abi() as *const _ as *mut _, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_key_async(&self, key: &HStringArg, keyName: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateKeyAsync)(self.0.as_abi() as *const _ as *mut _, key.get(), keyName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statistics) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_bank_card_data_received(&self, handler: &foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_BankCardDataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_bank_card_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_BankCardDataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_aamva_card_data_received(&self, handler: &foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AamvaCardDataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_aamva_card_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AamvaCardDataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_vendor_specific_data_received(&self, handler: &foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_VendorSpecificDataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_vendor_specific_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_VendorSpecificDataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &foundation::EventHandler<ClaimedMagneticStripeReader>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ErrorOccurred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedMagneticStripeReader: IClaimedMagneticStripeReader}
DEFINE_IID!(IID_IClaimedMagneticStripeReader2, 594522079, 58076, 19837, 156, 120, 6, 13, 242, 191, 41, 40);
RT_INTERFACE!{interface IClaimedMagneticStripeReader2(IClaimedMagneticStripeReader2Vtbl, IClaimedMagneticStripeReader2_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReader2] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedMagneticStripeReader2 {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedMagneticStripeReaderClosedEventArgs, 346925370, 44493, 19584, 172, 218, 195, 234, 237, 38, 71, 225);
RT_INTERFACE!{interface IClaimedMagneticStripeReaderClosedEventArgs(IClaimedMagneticStripeReaderClosedEventArgsVtbl, IClaimedMagneticStripeReaderClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReaderClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedMagneticStripeReaderClosedEventArgs: IClaimedMagneticStripeReaderClosedEventArgs}
DEFINE_IID!(IID_IClaimedPosPrinter, 1835322892, 57406, 19220, 163, 142, 194, 140, 52, 184, 99, 83);
RT_INTERFACE!{interface IClaimedPosPrinter(IClaimedPosPrinterVtbl, IClaimedPosPrinter_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_CharacterSet(&self, value: u32) -> HRESULT,
    fn get_CharacterSet(&self, out: *mut u32) -> HRESULT,
    fn get_IsCoverOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsCharacterSetMappingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCharacterSetMappingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_MapMode(&self, value: PosPrinterMapMode) -> HRESULT,
    fn get_MapMode(&self, out: *mut PosPrinterMapMode) -> HRESULT,
    fn get_Receipt(&self, out: *mut <ClaimedReceiptPrinter as RtType>::Abi) -> HRESULT,
    fn get_Slip(&self, out: *mut <ClaimedSlipPrinter as RtType>::Abi) -> HRESULT,
    fn get_Journal(&self, out: *mut <ClaimedJournalPrinter as RtType>::Abi) -> HRESULT,
    fn EnableAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn DisableAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RetainDeviceAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: <foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: <foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedPosPrinter {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_character_set(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CharacterSet)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_character_set(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacterSet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cover_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCoverOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_character_set_mapping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCharacterSetMappingEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_character_set_mapping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCharacterSetMappingEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_map_mode(&self, value: PosPrinterMapMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MapMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_map_mode(&self) -> Result<PosPrinterMapMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MapMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_receipt(&self) -> Result<Option<ClaimedReceiptPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Receipt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ClaimedReceiptPrinter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_slip(&self) -> Result<Option<ClaimedSlipPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Slip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ClaimedSlipPrinter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_journal(&self) -> Result<Option<ClaimedJournalPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Journal)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ClaimedJournalPrinter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).EnableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DisableAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RetainDeviceAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ResetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UpdateStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statistics) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReleaseDeviceRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedPosPrinter: IClaimedPosPrinter}
DEFINE_IID!(IID_IClaimedPosPrinter2, 1542955989, 20888, 17274, 130, 223, 88, 153, 147, 250, 119, 225);
RT_INTERFACE!{interface IClaimedPosPrinter2(IClaimedPosPrinter2Vtbl, IClaimedPosPrinter2_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinter2] {
    fn add_Closed(&self, handler: <foundation::TypedEventHandler<ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IClaimedPosPrinter2 {
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Closed)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Closed)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedPosPrinterClosedEventArgs, 3803685499, 19776, 18205, 146, 237, 99, 55, 91, 24, 199, 136);
RT_INTERFACE!{interface IClaimedPosPrinterClosedEventArgs(IClaimedPosPrinterClosedEventArgsVtbl, IClaimedPosPrinterClosedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinterClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedPosPrinterClosedEventArgs: IClaimedPosPrinterClosedEventArgs}
DEFINE_IID!(IID_IClaimedReceiptPrinter, 2597485172, 56673, 20194, 152, 55, 91, 93, 114, 213, 56, 185);
RT_INTERFACE!{interface IClaimedReceiptPrinter(IClaimedReceiptPrinterVtbl, IClaimedReceiptPrinter_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedReceiptPrinter] {
    fn get_SidewaysMaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_SidewaysMaxChars(&self, out: *mut u32) -> HRESULT,
    fn get_LinesToPaperCut(&self, out: *mut u32) -> HRESULT,
    fn get_PageSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_PrintArea(&self, out: *mut foundation::Rect) -> HRESULT,
    fn CreateJob(&self, out: *mut <ReceiptPrintJob as RtType>::Abi) -> HRESULT
}}
impl IClaimedReceiptPrinter {
    #[inline] pub fn get_sideways_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidewaysMaxLines)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sideways_max_chars(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidewaysMaxChars)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lines_to_paper_cut(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LinesToPaperCut)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PageSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_area(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrintArea)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_job(&self) -> Result<Option<ReceiptPrintJob>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateJob)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ReceiptPrintJob::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedReceiptPrinter: IClaimedReceiptPrinter}
DEFINE_IID!(IID_IClaimedSlipPrinter, 3177050098, 44944, 20106, 183, 123, 227, 174, 156, 166, 58, 127);
RT_INTERFACE!{interface IClaimedSlipPrinter(IClaimedSlipPrinterVtbl, IClaimedSlipPrinter_Abi): IInspectable(IInspectableVtbl) [IID_IClaimedSlipPrinter] {
    fn get_SidewaysMaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_SidewaysMaxChars(&self, out: *mut u32) -> HRESULT,
    fn get_MaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_LinesNearEndToEnd(&self, out: *mut u32) -> HRESULT,
    fn get_PrintSide(&self, out: *mut PosPrinterPrintSide) -> HRESULT,
    fn get_PageSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_PrintArea(&self, out: *mut foundation::Rect) -> HRESULT,
    fn OpenJaws(&self) -> HRESULT,
    fn CloseJaws(&self) -> HRESULT,
    fn InsertSlipAsync(&self, timeout: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RemoveSlipAsync(&self, timeout: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn ChangePrintSide(&self, printSide: PosPrinterPrintSide) -> HRESULT,
    fn CreateJob(&self, out: *mut <SlipPrintJob as RtType>::Abi) -> HRESULT
}}
impl IClaimedSlipPrinter {
    #[inline] pub fn get_sideways_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidewaysMaxLines)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sideways_max_chars(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SidewaysMaxChars)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxLines)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lines_near_end_to_end(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LinesNearEndToEnd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_side(&self) -> Result<PosPrinterPrintSide> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrintSide)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PageSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_area(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrintArea)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_jaws(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).OpenJaws)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close_jaws(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CloseJaws)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_slip_async(&self, timeout: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).InsertSlipAsync)(self.0.as_abi() as *const _ as *mut _, timeout, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_slip_async(&self, timeout: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RemoveSlipAsync)(self.0.as_abi() as *const _ as *mut _, timeout, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn change_print_side(&self, printSide: PosPrinterPrintSide) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ChangePrintSide)(self.0.as_abi() as *const _ as *mut _, printSide);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_job(&self) -> Result<Option<SlipPrintJob>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateJob)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SlipPrintJob::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedSlipPrinter: IClaimedSlipPrinter}
DEFINE_IID!(IID_ICommonClaimedPosPrinterStation, 3085657768, 65162, 19707, 139, 66, 227, 91, 40, 12, 178, 124);
RT_INTERFACE!{interface ICommonClaimedPosPrinterStation(ICommonClaimedPosPrinterStationVtbl, ICommonClaimedPosPrinterStation_Abi): IInspectable(IInspectableVtbl) [IID_ICommonClaimedPosPrinterStation] {
    fn put_CharactersPerLine(&self, value: u32) -> HRESULT,
    fn get_CharactersPerLine(&self, out: *mut u32) -> HRESULT,
    fn put_LineHeight(&self, value: u32) -> HRESULT,
    fn get_LineHeight(&self, out: *mut u32) -> HRESULT,
    fn put_LineSpacing(&self, value: u32) -> HRESULT,
    fn get_LineSpacing(&self, out: *mut u32) -> HRESULT,
    fn get_LineWidth(&self, out: *mut u32) -> HRESULT,
    fn put_IsLetterQuality(&self, value: bool) -> HRESULT,
    fn get_IsLetterQuality(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperNearEnd(&self, out: *mut bool) -> HRESULT,
    fn put_ColorCartridge(&self, value: PosPrinterColorCartridge) -> HRESULT,
    fn get_ColorCartridge(&self, out: *mut PosPrinterColorCartridge) -> HRESULT,
    fn get_IsCoverOpen(&self, out: *mut bool) -> HRESULT,
    fn get_IsCartridgeRemoved(&self, out: *mut bool) -> HRESULT,
    fn get_IsCartridgeEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsHeadCleaning(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsReadyToPrint(&self, out: *mut bool) -> HRESULT,
    fn ValidateData(&self, data: HSTRING, out: *mut bool) -> HRESULT
}}
impl ICommonClaimedPosPrinterStation {
    #[inline] pub fn set_characters_per_line(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CharactersPerLine)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_characters_per_line(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharactersPerLine)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LineHeight)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LineHeight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_spacing(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LineSpacing)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_spacing(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LineSpacing)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_line_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LineWidth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_letter_quality(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsLetterQuality)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_letter_quality(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLetterQuality)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_near_end(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaperNearEnd)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color_cartridge(&self, value: PosPrinterColorCartridge) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ColorCartridge)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_color_cartridge(&self) -> Result<PosPrinterColorCartridge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ColorCartridge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cover_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCoverOpen)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cartridge_removed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCartridgeRemoved)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cartridge_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCartridgeEmpty)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_head_cleaning(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHeadCleaning)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaperEmpty)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_ready_to_print(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReadyToPrint)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn validate_data(&self, data: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).ValidateData)(self.0.as_abi() as *const _ as *mut _, data.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICommonPosPrintStationCapabilities, 3730526922, 57390, 16617, 158, 94, 27, 72, 142, 106, 172, 252);
RT_INTERFACE!{interface ICommonPosPrintStationCapabilities(ICommonPosPrintStationCapabilitiesVtbl, ICommonPosPrintStationCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ICommonPosPrintStationCapabilities] {
    fn get_IsPrinterPresent(&self, out: *mut bool) -> HRESULT,
    fn get_IsDualColorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_ColorCartridgeCapabilities(&self, out: *mut PosPrinterColorCapabilities) -> HRESULT,
    fn get_CartridgeSensors(&self, out: *mut PosPrinterCartridgeSensors) -> HRESULT,
    fn get_IsBoldSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsItalicSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsUnderlineSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleHighPrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleWidePrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleHighDoubleWidePrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperEmptySensorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperNearEndSensorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedCharactersPerLine(&self, out: *mut <foundation::collections::IVectorView<u32> as RtType>::Abi) -> HRESULT
}}
impl ICommonPosPrintStationCapabilities {
    #[inline] pub fn get_is_printer_present(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPrinterPresent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_dual_color_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDualColorSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_cartridge_capabilities(&self) -> Result<PosPrinterColorCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ColorCartridgeCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cartridge_sensors(&self) -> Result<PosPrinterCartridgeSensors> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CartridgeSensors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_bold_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBoldSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_italic_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsItalicSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_underline_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsUnderlineSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_high_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDoubleHighPrintSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_wide_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDoubleWidePrintSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_high_double_wide_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDoubleHighDoubleWidePrintSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_empty_sensor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaperEmptySensorSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_near_end_sensor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPaperNearEndSensorSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_characters_per_line(&self) -> Result<Option<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCharactersPerLine)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICommonReceiptSlipCapabilities, 153643915, 39027, 19717, 191, 190, 71, 39, 166, 3, 143, 105);
RT_INTERFACE!{interface ICommonReceiptSlipCapabilities(ICommonReceiptSlipCapabilitiesVtbl, ICommonReceiptSlipCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ICommonReceiptSlipCapabilities] {
    fn get_IsBarcodeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBitmapSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsLeft90RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsRight90RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Is180RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPrintAreaSupported(&self, out: *mut bool) -> HRESULT,
    fn get_RuledLineCapabilities(&self, out: *mut PosPrinterRuledLineCapabilities) -> HRESULT,
    fn get_SupportedBarcodeRotations(&self, out: *mut <foundation::collections::IVectorView<PosPrinterRotation> as RtType>::Abi) -> HRESULT,
    fn get_SupportedBitmapRotations(&self, out: *mut <foundation::collections::IVectorView<PosPrinterRotation> as RtType>::Abi) -> HRESULT
}}
impl ICommonReceiptSlipCapabilities {
    #[inline] pub fn get_is_barcode_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBarcodeSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_bitmap_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBitmapSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_left_90_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsLeft90RotationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_right_90_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRight90RotationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_180_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Is180RotationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_print_area_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPrintAreaSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ruled_line_capabilities(&self) -> Result<PosPrinterRuledLineCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RuledLineCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_barcode_rotations(&self) -> Result<Option<foundation::collections::IVectorView<PosPrinterRotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedBarcodeRotations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_bitmap_rotations(&self) -> Result<Option<foundation::collections::IVectorView<PosPrinterRotation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedBitmapRotations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IJournalPrinterCapabilities, 995937347, 57415, 17507, 187, 88, 23, 181, 186, 29, 128, 86);
RT_INTERFACE!{interface IJournalPrinterCapabilities(IJournalPrinterCapabilitiesVtbl, IJournalPrinterCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IJournalPrinterCapabilities] {
    
}}
RT_CLASS!{class JournalPrinterCapabilities: IJournalPrinterCapabilities}
RT_CLASS!{class JournalPrintJob: IPosPrinterJob}
DEFINE_IID!(IID_ILineDisplay, 620093262, 15513, 17634, 183, 63, 229, 27, 227, 99, 122, 140);
RT_INTERFACE!{interface ILineDisplay(ILineDisplayVtbl, ILineDisplay_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplay] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <LineDisplayCapabilities as RtType>::Abi) -> HRESULT,
    fn get_PhysicalDeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceServiceVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn ClaimAsync(&self, out: *mut <foundation::IAsyncOperation<ClaimedLineDisplay> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplay {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<LineDisplayCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhysicalDeviceDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceControlDescription)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceControlVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_service_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceServiceVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_async(&self) -> Result<foundation::IAsyncOperation<ClaimedLineDisplay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClaimAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplay: ILineDisplay}
impl RtActivatable<ILineDisplayStatics> for LineDisplay {}
impl RtActivatable<ILineDisplayStatics2> for LineDisplay {}
impl LineDisplay {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LineDisplay>> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<LineDisplay>> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
    #[inline] pub fn get_statistics_category_selector() -> Result<Option<LineDisplayStatisticsCategorySelector>> {
        <Self as RtActivatable<ILineDisplayStatics2>>::get_activation_factory().get_statistics_category_selector()
    }
}
DEFINE_CLSID!(LineDisplay(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,76,105,110,101,68,105,115,112,108,97,121,0]) [CLSID_LineDisplay]);
DEFINE_IID!(IID_ILineDisplay2, 3264652840, 61252, 16627, 189, 28, 176, 76, 106, 92, 220, 125);
RT_INTERFACE!{interface ILineDisplay2(ILineDisplay2Vtbl, ILineDisplay2_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplay2] {
    fn CheckPowerStatusAsync(&self, out: *mut <foundation::IAsyncOperation<LineDisplayPowerStatus> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplay2 {
    #[inline] pub fn check_power_status_async(&self) -> Result<foundation::IAsyncOperation<LineDisplayPowerStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckPowerStatusAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayAttributes, 3246254492, 8858, 19476, 166, 241, 180, 228, 177, 254, 173, 146);
RT_INTERFACE!{interface ILineDisplayAttributes(ILineDisplayAttributesVtbl, ILineDisplayAttributes_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayAttributes] {
    fn get_IsPowerNotifyEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPowerNotifyEnabled(&self, value: bool) -> HRESULT,
    fn get_Brightness(&self, out: *mut i32) -> HRESULT,
    fn put_Brightness(&self, value: i32) -> HRESULT,
    fn get_BlinkRate(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BlinkRate(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ScreenSizeInCharacters(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_ScreenSizeInCharacters(&self, value: foundation::Size) -> HRESULT,
    fn get_CharacterSet(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSet(&self, value: i32) -> HRESULT,
    fn get_IsCharacterSetMappingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCharacterSetMappingEnabled(&self, value: bool) -> HRESULT,
    fn get_CurrentWindow(&self, out: *mut <LineDisplayWindow as RtType>::Abi) -> HRESULT,
    fn put_CurrentWindow(&self, value: <LineDisplayWindow as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayAttributes {
    #[inline] pub fn get_is_power_notify_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPowerNotifyEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_power_notify_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPowerNotifyEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Brightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Brightness)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_blink_rate(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BlinkRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_blink_rate(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BlinkRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_screen_size_in_characters(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScreenSizeInCharacters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_screen_size_in_characters(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScreenSizeInCharacters)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_character_set(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CharacterSet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_character_set(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CharacterSet)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_character_set_mapping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCharacterSetMappingEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_character_set_mapping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCharacterSetMappingEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_window(&self) -> Result<Option<LineDisplayWindow>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CurrentWindow)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayWindow::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_current_window(&self, value: &LineDisplayWindow) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CurrentWindow)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayAttributes: ILineDisplayAttributes}
DEFINE_IID!(IID_ILineDisplayCapabilities, 1511372241, 36293, 19356, 145, 114, 48, 62, 71, 183, 12, 85);
RT_INTERFACE!{interface ILineDisplayCapabilities(ILineDisplayCapabilitiesVtbl, ILineDisplayCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayCapabilities] {
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_CanChangeScreenSize(&self, out: *mut bool) -> HRESULT,
    fn get_CanDisplayBitmaps(&self, out: *mut bool) -> HRESULT,
    fn get_CanReadCharacterAtCursor(&self, out: *mut bool) -> HRESULT,
    fn get_CanMapCharacterSets(&self, out: *mut bool) -> HRESULT,
    fn get_CanDisplayCustomGlyphs(&self, out: *mut bool) -> HRESULT,
    fn get_CanReverse(&self, out: *mut LineDisplayTextAttributeGranularity) -> HRESULT,
    fn get_CanBlink(&self, out: *mut LineDisplayTextAttributeGranularity) -> HRESULT,
    fn get_CanChangeBlinkRate(&self, out: *mut bool) -> HRESULT,
    fn get_IsBrightnessSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCursorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsHorizontalMarqueeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsVerticalMarqueeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsInterCharacterWaitSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedDescriptors(&self, out: *mut u32) -> HRESULT,
    fn get_SupportedWindows(&self, out: *mut u32) -> HRESULT
}}
impl ILineDisplayCapabilities {
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsUpdatingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_change_screen_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanChangeScreenSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_display_bitmaps(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanDisplayBitmaps)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_read_character_at_cursor(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanReadCharacterAtCursor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_map_character_sets(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanMapCharacterSets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_display_custom_glyphs(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanDisplayCustomGlyphs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_reverse(&self) -> Result<LineDisplayTextAttributeGranularity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanReverse)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_blink(&self) -> Result<LineDisplayTextAttributeGranularity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanBlink)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_change_blink_rate(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanChangeBlinkRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_brightness_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBrightnessSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cursor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCursorSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_horizontal_marquee_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHorizontalMarqueeSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_vertical_marquee_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsVerticalMarqueeSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inter_character_wait_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsInterCharacterWaitSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_descriptors(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedDescriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_windows(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedWindows)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCapabilities: ILineDisplayCapabilities}
DEFINE_IID!(IID_ILineDisplayCursor, 3974102085, 30026, 20027, 171, 43, 21, 17, 129, 8, 86, 5);
RT_INTERFACE!{interface ILineDisplayCursor(ILineDisplayCursorVtbl, ILineDisplayCursor_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayCursor] {
    fn get_CanCustomize(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlinkSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlockSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsHalfBlockSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsUnderlineSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsReverseSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsOtherSupported(&self, out: *mut bool) -> HRESULT,
    fn GetAttributes(&self, out: *mut <LineDisplayCursorAttributes as RtType>::Abi) -> HRESULT,
    fn TryUpdateAttributesAsync(&self, attributes: <LineDisplayCursorAttributes as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayCursor {
    #[inline] pub fn get_can_customize(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanCustomize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_blink_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBlinkSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_block_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBlockSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_half_block_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsHalfBlockSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_underline_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsUnderlineSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_reverse_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsReverseSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_other_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsOtherSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<LineDisplayCursorAttributes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAttributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayCursorAttributes::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_attributes_async(&self, attributes: &LineDisplayCursorAttributes) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryUpdateAttributesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(attributes) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCursor: ILineDisplayCursor}
DEFINE_IID!(IID_ILineDisplayCursorAttributes, 1311593726, 20477, 16784, 170, 225, 206, 40, 95, 32, 200, 150);
RT_INTERFACE!{interface ILineDisplayCursorAttributes(ILineDisplayCursorAttributesVtbl, ILineDisplayCursorAttributes_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayCursorAttributes] {
    fn get_IsBlinkEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsBlinkEnabled(&self, value: bool) -> HRESULT,
    fn get_CursorType(&self, out: *mut LineDisplayCursorType) -> HRESULT,
    fn put_CursorType(&self, value: LineDisplayCursorType) -> HRESULT,
    fn get_IsAutoAdvanceEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutoAdvanceEnabled(&self, value: bool) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn put_Position(&self, value: foundation::Point) -> HRESULT
}}
impl ILineDisplayCursorAttributes {
    #[inline] pub fn get_is_blink_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBlinkEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_blink_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsBlinkEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cursor_type(&self) -> Result<LineDisplayCursorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CursorType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cursor_type(&self, value: LineDisplayCursorType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CursorType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_auto_advance_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAutoAdvanceEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_auto_advance_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsAutoAdvanceEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Position)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Position)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCursorAttributes: ILineDisplayCursorAttributes}
RT_ENUM! { enum LineDisplayCursorType: i32 {
    None = 0, Block = 1, HalfBlock = 2, Underline = 3, Reverse = 4, Other = 5,
}}
DEFINE_IID!(IID_ILineDisplayCustomGlyphs, 576190012, 62051, 17649, 161, 160, 231, 80, 166, 160, 236, 84);
RT_INTERFACE!{interface ILineDisplayCustomGlyphs(ILineDisplayCustomGlyphsVtbl, ILineDisplayCustomGlyphs_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayCustomGlyphs] {
    fn get_SizeInPixels(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SupportedGlyphCodes(&self, out: *mut <foundation::collections::IVectorView<u32> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRedefineAsync(&self, glyphCode: u32, glyphData: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayCustomGlyphs {
    #[inline] pub fn get_size_in_pixels(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SizeInPixels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_glyph_codes(&self) -> Result<Option<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedGlyphCodes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_redefine_async(&self, glyphCode: u32, glyphData: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRedefineAsync)(self.0.as_abi() as *const _ as *mut _, glyphCode, get_abi(glyphData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCustomGlyphs: ILineDisplayCustomGlyphs}
RT_ENUM! { enum LineDisplayDescriptorState: i32 {
    Off = 0, On = 1, Blink = 2,
}}
RT_ENUM! { enum LineDisplayHorizontalAlignment: i32 {
    Left = 0, Center = 1, Right = 2,
}}
DEFINE_IID!(IID_ILineDisplayMarquee, 2748530238, 62570, 19322, 188, 33, 83, 235, 59, 87, 248, 180);
RT_INTERFACE!{interface ILineDisplayMarquee(ILineDisplayMarqueeVtbl, ILineDisplayMarquee_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayMarquee] {
    fn get_Format(&self, out: *mut LineDisplayMarqueeFormat) -> HRESULT,
    fn put_Format(&self, value: LineDisplayMarqueeFormat) -> HRESULT,
    fn get_RepeatWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RepeatWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ScrollWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_ScrollWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn TryStartScrollingAsync(&self, direction: LineDisplayScrollDirection, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryStopScrollingAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayMarquee {
    #[inline] pub fn get_format(&self) -> Result<LineDisplayMarqueeFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: LineDisplayMarqueeFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Format)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repeat_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RepeatWaitInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repeat_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RepeatWaitInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScrollWaitInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scroll_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScrollWaitInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_start_scrolling_async(&self, direction: LineDisplayScrollDirection) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStartScrollingAsync)(self.0.as_abi() as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_stop_scrolling_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryStopScrollingAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayMarquee: ILineDisplayMarquee}
RT_ENUM! { enum LineDisplayMarqueeFormat: i32 {
    None = 0, Walk = 1, Place = 2,
}}
RT_ENUM! { enum LineDisplayPowerStatus: i32 {
    Unknown = 0, Online = 1, Off = 2, Offline = 3, OffOrOffline = 4,
}}
RT_ENUM! { enum LineDisplayScrollDirection: i32 {
    Up = 0, Down = 1, Left = 2, Right = 3,
}}
DEFINE_IID!(IID_ILineDisplayStatics, 36552886, 4528, 18064, 149, 71, 11, 57, 197, 175, 33, 20);
RT_INTERFACE!{static interface ILineDisplayStatics(ILineDisplayStaticsVtbl, ILineDisplayStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<LineDisplay> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<LineDisplay> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ILineDisplayStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LineDisplay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<LineDisplay>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayStatics2, 1611415324, 30635, 18792, 167, 222, 192, 47, 241, 105, 242, 204);
RT_INTERFACE!{static interface ILineDisplayStatics2(ILineDisplayStatics2Vtbl, ILineDisplayStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatics2] {
    fn get_StatisticsCategorySelector(&self, out: *mut <LineDisplayStatisticsCategorySelector as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayStatics2 {
    #[inline] pub fn get_statistics_category_selector(&self) -> Result<Option<LineDisplayStatisticsCategorySelector>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StatisticsCategorySelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayStatisticsCategorySelector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayStatisticsCategorySelector, 3038889067, 37492, 19748, 148, 243, 182, 1, 123, 131, 36, 68);
RT_INTERFACE!{interface ILineDisplayStatisticsCategorySelector(ILineDisplayStatisticsCategorySelectorVtbl, ILineDisplayStatisticsCategorySelector_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatisticsCategorySelector] {
    fn get_AllStatistics(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UnifiedPosStatistics(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ManufacturerStatistics(&self, out: *mut HSTRING) -> HRESULT
}}
impl ILineDisplayStatisticsCategorySelector {
    #[inline] pub fn get_all_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllStatistics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unified_pos_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UnifiedPosStatistics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ManufacturerStatistics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStatisticsCategorySelector: ILineDisplayStatisticsCategorySelector}
DEFINE_IID!(IID_ILineDisplayStatusUpdatedEventArgs, 3721755674, 34555, 20154, 147, 209, 111, 94, 218, 82, 183, 82);
RT_INTERFACE!{interface ILineDisplayStatusUpdatedEventArgs(ILineDisplayStatusUpdatedEventArgsVtbl, ILineDisplayStatusUpdatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut LineDisplayPowerStatus) -> HRESULT
}}
impl ILineDisplayStatusUpdatedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<LineDisplayPowerStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStatusUpdatedEventArgs: ILineDisplayStatusUpdatedEventArgs}
DEFINE_IID!(IID_ILineDisplayStoredBitmap, 4129378651, 55326, 17338, 191, 27, 188, 250, 60, 120, 91, 160);
RT_INTERFACE!{interface ILineDisplayStoredBitmap(ILineDisplayStoredBitmapVtbl, ILineDisplayStoredBitmap_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayStoredBitmap] {
    fn get_EscapeSequence(&self, out: *mut HSTRING) -> HRESULT,
    fn TryDeleteAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayStoredBitmap {
    #[inline] pub fn get_escape_sequence(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EscapeSequence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_delete_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDeleteAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStoredBitmap: ILineDisplayStoredBitmap}
RT_ENUM! { enum LineDisplayTextAttribute: i32 {
    Normal = 0, Blink = 1, Reverse = 2, ReverseBlink = 3,
}}
RT_ENUM! { enum LineDisplayTextAttributeGranularity: i32 {
    NotSupported = 0, EntireDisplay = 1, PerCharacter = 2,
}}
RT_ENUM! { enum LineDisplayVerticalAlignment: i32 {
    Top = 0, Center = 1, Bottom = 2,
}}
DEFINE_IID!(IID_ILineDisplayWindow, 3525308148, 9060, 19429, 190, 225, 133, 22, 128, 175, 73, 100);
RT_INTERFACE!{interface ILineDisplayWindow(ILineDisplayWindowVtbl, ILineDisplayWindow_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayWindow] {
    fn get_SizeInCharacters(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_InterCharacterWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_InterCharacterWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn TryRefreshAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryDisplayTextAsync(&self, text: HSTRING, displayAttribute: LineDisplayTextAttribute, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryDisplayTextAtPositionAsync(&self, text: HSTRING, displayAttribute: LineDisplayTextAttribute, startPosition: foundation::Point, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryDisplayTextNormalAsync(&self, text: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryScrollTextAsync(&self, direction: LineDisplayScrollDirection, numberOfColumnsOrRows: u32, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryClearTextAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayWindow {
    #[inline] pub fn get_size_in_characters(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SizeInCharacters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_inter_character_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterCharacterWaitInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inter_character_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InterCharacterWaitInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_refresh_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRefreshAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_async(&self, text: &HStringArg, displayAttribute: LineDisplayTextAttribute) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayTextAsync)(self.0.as_abi() as *const _ as *mut _, text.get(), displayAttribute, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_at_position_async(&self, text: &HStringArg, displayAttribute: LineDisplayTextAttribute, startPosition: foundation::Point) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayTextAtPositionAsync)(self.0.as_abi() as *const _ as *mut _, text.get(), displayAttribute, startPosition, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_normal_async(&self, text: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayTextNormalAsync)(self.0.as_abi() as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_scroll_text_async(&self, direction: LineDisplayScrollDirection, numberOfColumnsOrRows: u32) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryScrollTextAsync)(self.0.as_abi() as *const _ as *mut _, direction, numberOfColumnsOrRows, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_clear_text_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryClearTextAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayWindow: ILineDisplayWindow}
DEFINE_IID!(IID_ILineDisplayWindow2, 2841436902, 48600, 17253, 142, 17, 222, 148, 222, 141, 255, 2);
RT_INTERFACE!{interface ILineDisplayWindow2(ILineDisplayWindow2Vtbl, ILineDisplayWindow2_Abi): IInspectable(IInspectableVtbl) [IID_ILineDisplayWindow2] {
    fn get_Cursor(&self, out: *mut <LineDisplayCursor as RtType>::Abi) -> HRESULT,
    fn get_Marquee(&self, out: *mut <LineDisplayMarquee as RtType>::Abi) -> HRESULT,
    fn ReadCharacterAtCursorAsync(&self, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn TryDisplayStoredBitmapAtCursorAsync(&self, bitmap: <LineDisplayStoredBitmap as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorWithAlignmentAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorWithAlignmentAndWidthAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtPointAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, offsetInPixels: foundation::Point, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtPointWithWidthAsync(&self, bitmap: <super::super::storage::StorageFile as RtType>::Abi, offsetInPixels: foundation::Point, widthInPixels: i32, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ILineDisplayWindow2 {
    #[inline] pub fn get_cursor(&self) -> Result<Option<LineDisplayCursor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Cursor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayCursor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_marquee(&self) -> Result<Option<LineDisplayMarquee>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Marquee)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LineDisplayMarquee::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_character_at_cursor_async(&self) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadCharacterAtCursorAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_stored_bitmap_at_cursor_async(&self, bitmap: &LineDisplayStoredBitmap) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStoredBitmapAtCursorAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_async(&self, bitmap: &super::super::storage::StorageFile) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStorageFileBitmapAtCursorAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_with_alignment_async(&self, bitmap: &super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStorageFileBitmapAtCursorWithAlignmentAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, horizontalAlignment, verticalAlignment, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_with_alignment_and_width_async(&self, bitmap: &super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStorageFileBitmapAtCursorWithAlignmentAndWidthAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, horizontalAlignment, verticalAlignment, widthInPixels, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_point_async(&self, bitmap: &super::super::storage::StorageFile, offsetInPixels: foundation::Point) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStorageFileBitmapAtPointAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, offsetInPixels, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_point_with_width_async(&self, bitmap: &super::super::storage::StorageFile, offsetInPixels: foundation::Point, widthInPixels: i32) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryDisplayStorageFileBitmapAtPointWithWidthAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, offsetInPixels, widthInPixels, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReader, 445820949, 18371, 18058, 147, 51, 12, 101, 23, 87, 72, 131);
RT_INTERFACE!{interface IMagneticStripeReader(IMagneticStripeReaderVtbl, IMagneticStripeReader_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <MagneticStripeReaderCapabilities as RtType>::Abi) -> HRESULT,
    fn get_SupportedCardTypes(&self, outSize: *mut u32, out: *mut *mut u32) -> HRESULT,
    fn get_DeviceAuthenticationProtocol(&self, out: *mut MagneticStripeReaderAuthenticationProtocol) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn ClaimReaderAsync(&self, out: *mut <foundation::IAsyncOperation<ClaimedMagneticStripeReader> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn GetErrorReportingType(&self, out: *mut MagneticStripeReaderErrorReportingType) -> HRESULT,
    fn add_StatusUpdated(&self, handler: <foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMagneticStripeReader {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<MagneticStripeReaderCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_card_types(&self) -> Result<ComArray<u32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCardTypes)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_authentication_protocol(&self) -> Result<MagneticStripeReaderAuthenticationProtocol> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceAuthenticationProtocol)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckHealthAsync)(self.0.as_abi() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_reader_async(&self) -> Result<foundation::IAsyncOperation<ClaimedMagneticStripeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClaimReaderAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RetrieveStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error_reporting_type(&self) -> Result<MagneticStripeReaderErrorReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetErrorReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReader: IMagneticStripeReader}
impl RtActivatable<IMagneticStripeReaderStatics> for MagneticStripeReader {}
impl RtActivatable<IMagneticStripeReaderStatics2> for MagneticStripeReader {}
impl MagneticStripeReader {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<MagneticStripeReader>> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<MagneticStripeReader>> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IMagneticStripeReaderStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(MagneticStripeReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,0]) [CLSID_MagneticStripeReader]);
DEFINE_IID!(IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs, 172735825, 49942, 18704, 135, 243, 122, 98, 186, 134, 45, 49);
RT_INTERFACE!{interface IMagneticStripeReaderAamvaCardDataReceivedEventArgs(IMagneticStripeReaderAamvaCardDataReceivedEventArgsVtbl, IMagneticStripeReaderAamvaCardDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut <MagneticStripeReaderReport as RtType>::Abi) -> HRESULT,
    fn get_LicenseNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Restrictions(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Class(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Endorsements(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BirthDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Surname(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Suffix(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Gender(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HairColor(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EyeColor(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Height(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Weight(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMagneticStripeReaderAamvaCardDataReceivedEventArgs {
    #[inline] pub fn get_report(&self) -> Result<Option<MagneticStripeReaderReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_license_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LicenseNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpirationDate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_restrictions(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Restrictions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_class(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Class)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_endorsements(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Endorsements)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_birth_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BirthDate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_first_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FirstName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_surname(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Surname)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suffix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Suffix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gender(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Gender)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hair_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HairColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EyeColor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_weight(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Weight)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Address)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_City)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PostalCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderAamvaCardDataReceivedEventArgs: IMagneticStripeReaderAamvaCardDataReceivedEventArgs}
RT_ENUM! { enum MagneticStripeReaderAuthenticationLevel: i32 {
    NotSupported = 0, Optional = 1, Required = 2,
}}
RT_ENUM! { enum MagneticStripeReaderAuthenticationProtocol: i32 {
    None = 0, ChallengeResponse = 1,
}}
DEFINE_IID!(IID_IMagneticStripeReaderBankCardDataReceivedEventArgs, 781551651, 41754, 18275, 136, 44, 35, 114, 94, 57, 176, 142);
RT_INTERFACE!{interface IMagneticStripeReaderBankCardDataReceivedEventArgs(IMagneticStripeReaderBankCardDataReceivedEventArgsVtbl, IMagneticStripeReaderBankCardDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderBankCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut <MagneticStripeReaderReport as RtType>::Abi) -> HRESULT,
    fn get_AccountNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MiddleInitial(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Surname(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Suffix(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMagneticStripeReaderBankCardDataReceivedEventArgs {
    #[inline] pub fn get_report(&self) -> Result<Option<MagneticStripeReaderReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_account_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccountNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExpirationDate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Title)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_first_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FirstName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_middle_initial(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MiddleInitial)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_surname(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Surname)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suffix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Suffix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderBankCardDataReceivedEventArgs: IMagneticStripeReaderBankCardDataReceivedEventArgs}
DEFINE_IID!(IID_IMagneticStripeReaderCapabilities, 1898479772, 50240, 17570, 164, 103, 70, 145, 117, 208, 40, 150);
RT_INTERFACE!{interface IMagneticStripeReaderCapabilities(IMagneticStripeReaderCapabilitiesVtbl, IMagneticStripeReaderCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCapabilities] {
    fn get_CardAuthentication(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedEncryptionAlgorithms(&self, out: *mut u32) -> HRESULT,
    fn get_AuthenticationLevel(&self, out: *mut MagneticStripeReaderAuthenticationLevel) -> HRESULT,
    fn get_IsIsoSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsJisOneSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsJisTwoSupported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsTrackDataMaskingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsTransmitSentinelsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IMagneticStripeReaderCapabilities {
    #[inline] pub fn get_card_authentication(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CardAuthentication)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_encryption_algorithms(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedEncryptionAlgorithms)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_level(&self) -> Result<MagneticStripeReaderAuthenticationLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AuthenticationLevel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_iso_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsIsoSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_jis_one_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsJisOneSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_jis_two_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsJisTwoSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsUpdatingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_track_data_masking_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTrackDataMaskingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transmit_sentinels_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTransmitSentinelsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderCapabilities: IMagneticStripeReaderCapabilities}
RT_CLASS!{static class MagneticStripeReaderCardTypes}
impl RtActivatable<IMagneticStripeReaderCardTypesStatics> for MagneticStripeReaderCardTypes {}
impl MagneticStripeReaderCardTypes {
    #[inline] pub fn get_unknown() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_unknown()
    }
    #[inline] pub fn get_bank() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_bank()
    }
    #[inline] pub fn get_aamva() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_aamva()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_extended_base()
    }
}
DEFINE_CLSID!(MagneticStripeReaderCardTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,67,97,114,100,84,121,112,101,115,0]) [CLSID_MagneticStripeReaderCardTypes]);
DEFINE_IID!(IID_IMagneticStripeReaderCardTypesStatics, 1385114717, 10630, 18255, 132, 84, 124, 205, 5, 146, 141, 95);
RT_INTERFACE!{static interface IMagneticStripeReaderCardTypesStatics(IMagneticStripeReaderCardTypesStaticsVtbl, IMagneticStripeReaderCardTypesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCardTypesStatics] {
    fn get_Unknown(&self, out: *mut u32) -> HRESULT,
    fn get_Bank(&self, out: *mut u32) -> HRESULT,
    fn get_Aamva(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT
}}
impl IMagneticStripeReaderCardTypesStatics {
    #[inline] pub fn get_unknown(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Unknown)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bank(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bank)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aamva(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Aamva)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedBase)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class MagneticStripeReaderEncryptionAlgorithms}
impl RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics> for MagneticStripeReaderEncryptionAlgorithms {}
impl MagneticStripeReaderEncryptionAlgorithms {
    #[inline] pub fn get_none() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_none()
    }
    #[inline] pub fn get_triple_des_dukpt() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_triple_des_dukpt()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_extended_base()
    }
}
DEFINE_CLSID!(MagneticStripeReaderEncryptionAlgorithms(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,69,110,99,114,121,112,116,105,111,110,65,108,103,111,114,105,116,104,109,115,0]) [CLSID_MagneticStripeReaderEncryptionAlgorithms]);
DEFINE_IID!(IID_IMagneticStripeReaderEncryptionAlgorithmsStatics, 1404400464, 50139, 18260, 156, 0, 65, 57, 35, 116, 161, 9);
RT_INTERFACE!{static interface IMagneticStripeReaderEncryptionAlgorithmsStatics(IMagneticStripeReaderEncryptionAlgorithmsStaticsVtbl, IMagneticStripeReaderEncryptionAlgorithmsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderEncryptionAlgorithmsStatics] {
    fn get_None(&self, out: *mut u32) -> HRESULT,
    fn get_TripleDesDukpt(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT
}}
impl IMagneticStripeReaderEncryptionAlgorithmsStatics {
    #[inline] pub fn get_none(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_None)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_triple_des_dukpt(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TripleDesDukpt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedBase)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReaderErrorOccurredEventArgs, 535689565, 11396, 16813, 183, 120, 242, 53, 106, 120, 154, 177);
RT_INTERFACE!{interface IMagneticStripeReaderErrorOccurredEventArgs(IMagneticStripeReaderErrorOccurredEventArgsVtbl, IMagneticStripeReaderErrorOccurredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderErrorOccurredEventArgs] {
    fn get_Track1Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track2Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track3Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track4Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_ErrorData(&self, out: *mut <UnifiedPosErrorData as RtType>::Abi) -> HRESULT,
    fn get_PartialInputData(&self, out: *mut <MagneticStripeReaderReport as RtType>::Abi) -> HRESULT
}}
impl IMagneticStripeReaderErrorOccurredEventArgs {
    #[inline] pub fn get_track1_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track1Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track2_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track2Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track3_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track3Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track4_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track4Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_data(&self) -> Result<Option<UnifiedPosErrorData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UnifiedPosErrorData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_partial_input_data(&self) -> Result<Option<MagneticStripeReaderReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PartialInputData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderReport::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderErrorOccurredEventArgs: IMagneticStripeReaderErrorOccurredEventArgs}
RT_ENUM! { enum MagneticStripeReaderErrorReportingType: i32 {
    CardLevel = 0, TrackLevel = 1,
}}
DEFINE_IID!(IID_IMagneticStripeReaderReport, 1784373319, 39344, 16776, 190, 241, 237, 223, 121, 247, 143, 230);
RT_INTERFACE!{interface IMagneticStripeReaderReport(IMagneticStripeReaderReportVtbl, IMagneticStripeReaderReport_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderReport] {
    fn get_CardType(&self, out: *mut u32) -> HRESULT,
    fn get_Track1(&self, out: *mut <MagneticStripeReaderTrackData as RtType>::Abi) -> HRESULT,
    fn get_Track2(&self, out: *mut <MagneticStripeReaderTrackData as RtType>::Abi) -> HRESULT,
    fn get_Track3(&self, out: *mut <MagneticStripeReaderTrackData as RtType>::Abi) -> HRESULT,
    fn get_Track4(&self, out: *mut <MagneticStripeReaderTrackData as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, HString> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_CardAuthenticationData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_CardAuthenticationDataLength(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AdditionalSecurityInformation(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IMagneticStripeReaderReport {
    #[inline] pub fn get_card_type(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CardType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track1(&self) -> Result<Option<MagneticStripeReaderTrackData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track1)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderTrackData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track2(&self) -> Result<Option<MagneticStripeReaderTrackData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track2)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderTrackData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track3(&self) -> Result<Option<MagneticStripeReaderTrackData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track3)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderTrackData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track4(&self) -> Result<Option<MagneticStripeReaderTrackData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Track4)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderTrackData::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_card_authentication_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CardAuthenticationData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_card_authentication_data_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CardAuthenticationDataLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_additional_security_information(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdditionalSecurityInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderReport: IMagneticStripeReaderReport}
DEFINE_IID!(IID_IMagneticStripeReaderStatics, 3294604106, 61399, 18272, 165, 206, 21, 176, 228, 126, 148, 235);
RT_INTERFACE!{static interface IMagneticStripeReaderStatics(IMagneticStripeReaderStaticsVtbl, IMagneticStripeReaderStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<MagneticStripeReader> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<MagneticStripeReader> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMagneticStripeReaderStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<MagneticStripeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<MagneticStripeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReaderStatics2, 2360197986, 54887, 18682, 134, 188, 245, 174, 17, 137, 38, 43);
RT_INTERFACE!{static interface IMagneticStripeReaderStatics2(IMagneticStripeReaderStatics2Vtbl, IMagneticStripeReaderStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl IMagneticStripeReaderStatics2 {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MagneticStripeReaderStatus: i32 {
    Unauthenticated = 0, Authenticated = 1, Extended = 2,
}}
DEFINE_IID!(IID_IMagneticStripeReaderStatusUpdatedEventArgs, 164391856, 12898, 16413, 158, 138, 232, 13, 99, 88, 144, 107);
RT_INTERFACE!{interface IMagneticStripeReaderStatusUpdatedEventArgs(IMagneticStripeReaderStatusUpdatedEventArgsVtbl, IMagneticStripeReaderStatusUpdatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut MagneticStripeReaderStatus) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl IMagneticStripeReaderStatusUpdatedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<MagneticStripeReaderStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderStatusUpdatedEventArgs: IMagneticStripeReaderStatusUpdatedEventArgs}
DEFINE_IID!(IID_IMagneticStripeReaderTrackData, 273479281, 19101, 17518, 171, 197, 32, 64, 35, 7, 186, 54);
RT_INTERFACE!{interface IMagneticStripeReaderTrackData(IMagneticStripeReaderTrackDataVtbl, IMagneticStripeReaderTrackData_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderTrackData] {
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_DiscretionaryData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_EncryptedData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IMagneticStripeReaderTrackData {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Data)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_discretionary_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DiscretionaryData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_encrypted_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EncryptedData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderTrackData: IMagneticStripeReaderTrackData}
RT_ENUM! { enum MagneticStripeReaderTrackErrorType: i32 {
    None = 0, StartSentinelError = 1, EndSentinelError = 2, ParityError = 3, LrcError = 4, Unknown = -1,
}}
RT_ENUM! { enum MagneticStripeReaderTrackIds: i32 {
    None = 0, Track1 = 1, Track2 = 2, Track3 = 4, Track4 = 8,
}}
DEFINE_IID!(IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, 2936689940, 22988, 19040, 153, 232, 153, 165, 61, 172, 229, 170);
RT_INTERFACE!{interface IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgsVtbl, IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut <MagneticStripeReaderReport as RtType>::Abi) -> HRESULT
}}
impl IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs {
    #[inline] pub fn get_report(&self) -> Result<Option<MagneticStripeReaderReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Report)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagneticStripeReaderReport::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs}
RT_ENUM! { enum PosConnectionTypes: u32 {
    Local = 1, IP = 2, Bluetooth = 4, All = 4294967295,
}}
DEFINE_IID!(IID_IPosPrinter, 704889102, 39449, 18945, 153, 79, 18, 223, 173, 106, 220, 191);
RT_INTERFACE!{interface IPosPrinter(IPosPrinterVtbl, IPosPrinter_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut <PosPrinterCapabilities as RtType>::Abi) -> HRESULT,
    fn get_SupportedCharacterSets(&self, out: *mut <foundation::collections::IVectorView<u32> as RtType>::Abi) -> HRESULT,
    fn get_SupportedTypeFaces(&self, out: *mut <foundation::collections::IVectorView<HString> as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut <PosPrinterStatus as RtType>::Abi) -> HRESULT,
    fn ClaimPrinterAsync(&self, out: *mut <foundation::IAsyncOperation<ClaimedPosPrinter> as RtType>::Abi) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetStatisticsAsync(&self, statisticsCategories: <foundation::collections::IIterable<HString> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn add_StatusUpdated(&self, handler: <foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPosPrinter {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<PosPrinterCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PosPrinterCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_character_sets(&self) -> Result<Option<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCharacterSets)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_type_faces(&self) -> Result<Option<foundation::collections::IVectorView<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedTypeFaces)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<Option<PosPrinterStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PosPrinterStatus::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_printer_async(&self) -> Result<foundation::IAsyncOperation<ClaimedPosPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClaimPrinterAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CheckHealthAsync)(self.0.as_abi() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &foundation::collections::IIterable<HString>) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatisticsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(statisticsCategories) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinter: IPosPrinter}
impl RtActivatable<IPosPrinterStatics> for PosPrinter {}
impl RtActivatable<IPosPrinterStatics2> for PosPrinter {}
impl PosPrinter {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<PosPrinter>> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<PosPrinter>> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IPosPrinterStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(PosPrinter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,0]) [CLSID_PosPrinter]);
RT_ENUM! { enum PosPrinterAlignment: i32 {
    Left = 0, Center = 1, Right = 2,
}}
RT_ENUM! { enum PosPrinterBarcodeTextPosition: i32 {
    None = 0, Above = 1, Below = 2,
}}
DEFINE_IID!(IID_IPosPrinterCapabilities, 3454621473, 17280, 18821, 173, 197, 57, 219, 48, 205, 147, 188);
RT_INTERFACE!{interface IPosPrinterCapabilities(IPosPrinterCapabilitiesVtbl, IPosPrinterCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_DefaultCharacterSet(&self, out: *mut u32) -> HRESULT,
    fn get_HasCoverSensor(&self, out: *mut bool) -> HRESULT,
    fn get_CanMapCharacterSet(&self, out: *mut bool) -> HRESULT,
    fn get_IsTransactionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Receipt(&self, out: *mut <ReceiptPrinterCapabilities as RtType>::Abi) -> HRESULT,
    fn get_Slip(&self, out: *mut <SlipPrinterCapabilities as RtType>::Abi) -> HRESULT,
    fn get_Journal(&self, out: *mut <JournalPrinterCapabilities as RtType>::Abi) -> HRESULT
}}
impl IPosPrinterCapabilities {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerReportingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsReportingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStatisticsUpdatingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_character_set(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultCharacterSet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_cover_sensor(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HasCoverSensor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_map_character_set(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanMapCharacterSet)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transaction_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsTransactionSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_receipt(&self) -> Result<Option<ReceiptPrinterCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Receipt)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ReceiptPrinterCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_slip(&self) -> Result<Option<SlipPrinterCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Slip)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SlipPrinterCapabilities::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_journal(&self) -> Result<Option<JournalPrinterCapabilities>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Journal)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(JournalPrinterCapabilities::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterCapabilities: IPosPrinterCapabilities}
RT_ENUM! { enum PosPrinterCartridgeSensors: u32 {
    None = 0, Removed = 1, Empty = 2, HeadCleaning = 4, NearEnd = 8,
}}
RT_CLASS!{static class PosPrinterCharacterSetIds}
impl RtActivatable<IPosPrinterCharacterSetIdsStatics> for PosPrinterCharacterSetIds {}
impl PosPrinterCharacterSetIds {
    #[inline] pub fn get_utf16le() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_utf16le()
    }
    #[inline] pub fn get_ascii() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_ascii()
    }
    #[inline] pub fn get_ansi() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_ansi()
    }
}
DEFINE_CLSID!(PosPrinterCharacterSetIds(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,67,104,97,114,97,99,116,101,114,83,101,116,73,100,115,0]) [CLSID_PosPrinterCharacterSetIds]);
DEFINE_IID!(IID_IPosPrinterCharacterSetIdsStatics, 1550884607, 28826, 20455, 178, 21, 6, 167, 72, 163, 139, 57);
RT_INTERFACE!{static interface IPosPrinterCharacterSetIdsStatics(IPosPrinterCharacterSetIdsStaticsVtbl, IPosPrinterCharacterSetIdsStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterCharacterSetIdsStatics] {
    fn get_Utf16LE(&self, out: *mut u32) -> HRESULT,
    fn get_Ascii(&self, out: *mut u32) -> HRESULT,
    fn get_Ansi(&self, out: *mut u32) -> HRESULT
}}
impl IPosPrinterCharacterSetIdsStatics {
    #[inline] pub fn get_utf16le(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Utf16LE)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ascii(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ascii)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ansi(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ansi)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum PosPrinterColorCapabilities: u32 {
    None = 0, Primary = 1, Custom1 = 2, Custom2 = 4, Custom3 = 8, Custom4 = 16, Custom5 = 32, Custom6 = 64, Cyan = 128, Magenta = 256, Yellow = 512, Full = 1024,
}}
RT_ENUM! { enum PosPrinterColorCartridge: i32 {
    Unknown = 0, Primary = 1, Custom1 = 2, Custom2 = 3, Custom3 = 4, Custom4 = 5, Custom5 = 6, Custom6 = 7, Cyan = 8, Magenta = 9, Yellow = 10,
}}
DEFINE_IID!(IID_IPosPrinterJob, 2593390684, 1557, 17809, 165, 143, 48, 248, 126, 223, 226, 228);
RT_INTERFACE!{interface IPosPrinterJob(IPosPrinterJobVtbl, IPosPrinterJob_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterJob] {
    fn Print(&self, data: HSTRING) -> HRESULT,
    fn PrintLine(&self, data: HSTRING) -> HRESULT,
    fn PrintNewline(&self) -> HRESULT,
    fn ExecuteAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl IPosPrinterJob {
    #[inline] pub fn print(&self, data: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Print)(self.0.as_abi() as *const _ as *mut _, data.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_line(&self, data: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintLine)(self.0.as_abi() as *const _ as *mut _, data.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_newline(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintNewline)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn execute_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ExecuteAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PosPrinterLineDirection: i32 {
    Horizontal = 0, Vertical = 1,
}}
RT_ENUM! { enum PosPrinterLineStyle: i32 {
    SingleSolid = 0, DoubleSolid = 1, Broken = 2, Chain = 3,
}}
RT_ENUM! { enum PosPrinterMapMode: i32 {
    Dots = 0, Twips = 1, English = 2, Metric = 3,
}}
RT_ENUM! { enum PosPrinterMarkFeedCapabilities: u32 {
    None = 0, ToTakeUp = 1, ToCutter = 2, ToCurrentTopOfForm = 4, ToNextTopOfForm = 8,
}}
RT_ENUM! { enum PosPrinterMarkFeedKind: i32 {
    ToTakeUp = 0, ToCutter = 1, ToCurrentTopOfForm = 2, ToNextTopOfForm = 3,
}}
RT_ENUM! { enum PosPrinterPrintSide: i32 {
    Unknown = 0, Side1 = 1, Side2 = 2,
}}
DEFINE_IID!(IID_IPosPrinterReleaseDeviceRequestedEventArgs, 734765913, 7407, 16562, 158, 203, 249, 39, 248, 86, 174, 60);
RT_INTERFACE!{interface IPosPrinterReleaseDeviceRequestedEventArgs(IPosPrinterReleaseDeviceRequestedEventArgsVtbl, IPosPrinterReleaseDeviceRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterReleaseDeviceRequestedEventArgs] {
    
}}
RT_CLASS!{class PosPrinterReleaseDeviceRequestedEventArgs: IPosPrinterReleaseDeviceRequestedEventArgs}
RT_ENUM! { enum PosPrinterRotation: i32 {
    Normal = 0, Right90 = 1, Left90 = 2, Rotate180 = 3,
}}
RT_ENUM! { enum PosPrinterRuledLineCapabilities: u32 {
    None = 0, Horizontal = 1, Vertical = 2,
}}
DEFINE_IID!(IID_IPosPrinterStatics, 2363544810, 4911, 19679, 166, 74, 45, 13, 124, 150, 168, 91);
RT_INTERFACE!{static interface IPosPrinterStatics(IPosPrinterStaticsVtbl, IPosPrinterStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<PosPrinter> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<PosPrinter> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPosPrinterStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<PosPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<PosPrinter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPosPrinterStatics2, 4006423580, 45264, 17127, 177, 55, 184, 155, 22, 36, 77, 65);
RT_INTERFACE!{static interface IPosPrinterStatics2(IPosPrinterStatics2Vtbl, IPosPrinterStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl IPosPrinterStatics2 {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.0.as_abi() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPosPrinterStatus, 3522217776, 55872, 17192, 191, 118, 81, 86, 250, 51, 183, 71);
RT_INTERFACE!{interface IPosPrinterStatus(IPosPrinterStatusVtbl, IPosPrinterStatus_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatus] {
    fn get_StatusKind(&self, out: *mut PosPrinterStatusKind) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl IPosPrinterStatus {
    #[inline] pub fn get_status_kind(&self) -> Result<PosPrinterStatusKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StatusKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterStatus: IPosPrinterStatus}
RT_ENUM! { enum PosPrinterStatusKind: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_IPosPrinterStatusUpdatedEventArgs, 786139103, 5030, 17037, 186, 129, 176, 231, 195, 229, 163, 205);
RT_INTERFACE!{interface IPosPrinterStatusUpdatedEventArgs(IPosPrinterStatusUpdatedEventArgsVtbl, IPosPrinterStatusUpdatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut <PosPrinterStatus as RtType>::Abi) -> HRESULT
}}
impl IPosPrinterStatusUpdatedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<Option<PosPrinterStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PosPrinterStatus::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterStatusUpdatedEventArgs: IPosPrinterStatusUpdatedEventArgs}
DEFINE_IID!(IID_IReceiptOrSlipJob, 1394710974, 51395, 19906, 137, 233, 92, 74, 55, 179, 77, 220);
RT_INTERFACE!{interface IReceiptOrSlipJob(IReceiptOrSlipJobVtbl, IReceiptOrSlipJob_Abi): IInspectable(IInspectableVtbl) [IID_IReceiptOrSlipJob] {
    fn SetBarcodeRotation(&self, value: PosPrinterRotation) -> HRESULT,
    fn SetPrintRotation(&self, value: PosPrinterRotation, includeBitmaps: bool) -> HRESULT,
    fn SetPrintArea(&self, value: foundation::Rect) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmap(&self, bitmapNumber: u32, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignment: PosPrinterAlignment) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmapCustomWidthStandardAlign(&self, bitmapNumber: u32, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignment: PosPrinterAlignment, width: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetCustomAlignedBitmap(&self, bitmapNumber: u32, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmapCustomWidthCustomAlign(&self, bitmapNumber: u32, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignmentDistance: u32, width: u32) -> HRESULT,
    fn PrintSavedBitmap(&self, bitmapNumber: u32) -> HRESULT,
    fn DrawRuledLine(&self, positionList: HSTRING, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> HRESULT,
    fn PrintBarcode(&self, data: HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> HRESULT,
    fn PrintBarcodeCustomAlign(&self, data: HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmap(&self, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignment: PosPrinterAlignment) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmapCustomWidthStandardAlign(&self, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignment: PosPrinterAlignment, width: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintCustomAlignedBitmap(&self, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmapCustomWidthCustomAlign(&self, bitmap: <super::super::graphics::imaging::BitmapFrame as RtType>::Abi, alignmentDistance: u32, width: u32) -> HRESULT
}}
impl IReceiptOrSlipJob {
    #[inline] pub fn set_barcode_rotation(&self, value: PosPrinterRotation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBarcodeRotation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_print_rotation(&self, value: PosPrinterRotation, includeBitmaps: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPrintRotation)(self.0.as_abi() as *const _ as *mut _, value, includeBitmaps);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_print_area(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPrintArea)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap(&self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBitmap)(self.0.as_abi() as *const _ as *mut _, bitmapNumber, get_abi(bitmap) as *const _ as *mut _, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap_custom_width_standard_align(&self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBitmapCustomWidthStandardAlign)(self.0.as_abi() as *const _ as *mut _, bitmapNumber, get_abi(bitmap) as *const _ as *mut _, alignment, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_custom_aligned_bitmap(&self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetCustomAlignedBitmap)(self.0.as_abi() as *const _ as *mut _, bitmapNumber, get_abi(bitmap) as *const _ as *mut _, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap_custom_width_custom_align(&self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetBitmapCustomWidthCustomAlign)(self.0.as_abi() as *const _ as *mut _, bitmapNumber, get_abi(bitmap) as *const _ as *mut _, alignmentDistance, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_saved_bitmap(&self, bitmapNumber: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintSavedBitmap)(self.0.as_abi() as *const _ as *mut _, bitmapNumber);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn draw_ruled_line(&self, positionList: &HStringArg, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DrawRuledLine)(self.0.as_abi() as *const _ as *mut _, positionList.get(), lineDirection, lineWidth, lineStyle, lineColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_barcode(&self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintBarcode)(self.0.as_abi() as *const _ as *mut _, data.get(), symbology, height, width, textPosition, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_barcode_custom_align(&self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintBarcodeCustomAlign)(self.0.as_abi() as *const _ as *mut _, data.get(), symbology, height, width, textPosition, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap(&self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintBitmap)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap_custom_width_standard_align(&self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintBitmapCustomWidthStandardAlign)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, alignment, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_custom_aligned_bitmap(&self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintCustomAlignedBitmap)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap_custom_width_custom_align(&self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).PrintBitmapCustomWidthCustomAlign)(self.0.as_abi() as *const _ as *mut _, get_abi(bitmap) as *const _ as *mut _, alignmentDistance, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IReceiptPrinterCapabilities, 3102782863, 20904, 17404, 155, 213, 141, 226, 114, 166, 65, 91);
RT_INTERFACE!{interface IReceiptPrinterCapabilities(IReceiptPrinterCapabilitiesVtbl, IReceiptPrinterCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_IReceiptPrinterCapabilities] {
    fn get_CanCutPaper(&self, out: *mut bool) -> HRESULT,
    fn get_IsStampSupported(&self, out: *mut bool) -> HRESULT,
    fn get_MarkFeedCapabilities(&self, out: *mut PosPrinterMarkFeedCapabilities) -> HRESULT
}}
impl IReceiptPrinterCapabilities {
    #[inline] pub fn get_can_cut_paper(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanCutPaper)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stamp_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStampSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mark_feed_capabilities(&self) -> Result<PosPrinterMarkFeedCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MarkFeedCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ReceiptPrinterCapabilities: IReceiptPrinterCapabilities}
DEFINE_IID!(IID_IReceiptPrintJob, 2861958766, 44205, 19321, 157, 15, 192, 207, 192, 141, 199, 123);
RT_INTERFACE!{interface IReceiptPrintJob(IReceiptPrintJobVtbl, IReceiptPrintJob_Abi): IInspectable(IInspectableVtbl) [IID_IReceiptPrintJob] {
    fn MarkFeed(&self, kind: PosPrinterMarkFeedKind) -> HRESULT,
    fn CutPaper(&self, percentage: f64) -> HRESULT,
    fn CutPaperDefault(&self) -> HRESULT
}}
impl IReceiptPrintJob {
    #[inline] pub fn mark_feed(&self, kind: PosPrinterMarkFeedKind) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).MarkFeed)(self.0.as_abi() as *const _ as *mut _, kind);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cut_paper(&self, percentage: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CutPaper)(self.0.as_abi() as *const _ as *mut _, percentage);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cut_paper_default(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).CutPaperDefault)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ReceiptPrintJob: IReceiptPrintJob}
DEFINE_IID!(IID_ISlipPrinterCapabilities, 2578539417, 18572, 16727, 138, 194, 159, 87, 247, 8, 211, 219);
RT_INTERFACE!{interface ISlipPrinterCapabilities(ISlipPrinterCapabilitiesVtbl, ISlipPrinterCapabilities_Abi): IInspectable(IInspectableVtbl) [IID_ISlipPrinterCapabilities] {
    fn get_IsFullLengthSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBothSidesPrintingSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISlipPrinterCapabilities {
    #[inline] pub fn get_is_full_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsFullLengthSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_both_sides_printing_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsBothSidesPrintingSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SlipPrinterCapabilities: ISlipPrinterCapabilities}
RT_CLASS!{class SlipPrintJob: IReceiptOrSlipJob}
DEFINE_IID!(IID_IUnifiedPosErrorData, 731483194, 21852, 18569, 142, 216, 197, 153, 187, 58, 113, 42);
RT_INTERFACE!{interface IUnifiedPosErrorData(IUnifiedPosErrorDataVtbl, IUnifiedPosErrorData_Abi): IInspectable(IInspectableVtbl) [IID_IUnifiedPosErrorData] {
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Severity(&self, out: *mut UnifiedPosErrorSeverity) -> HRESULT,
    fn get_Reason(&self, out: *mut UnifiedPosErrorReason) -> HRESULT,
    fn get_ExtendedReason(&self, out: *mut u32) -> HRESULT
}}
impl IUnifiedPosErrorData {
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Message)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_severity(&self) -> Result<UnifiedPosErrorSeverity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Severity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<UnifiedPosErrorReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_reason(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ExtendedReason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UnifiedPosErrorData: IUnifiedPosErrorData}
impl RtActivatable<IUnifiedPosErrorDataFactory> for UnifiedPosErrorData {}
impl UnifiedPosErrorData {
    #[inline] pub fn create_instance(message: &HStringArg, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32) -> Result<UnifiedPosErrorData> {
        <Self as RtActivatable<IUnifiedPosErrorDataFactory>>::get_activation_factory().create_instance(message, severity, reason, extendedReason)
    }
}
DEFINE_CLSID!(UnifiedPosErrorData(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,85,110,105,102,105,101,100,80,111,115,69,114,114,111,114,68,97,116,97,0]) [CLSID_UnifiedPosErrorData]);
DEFINE_IID!(IID_IUnifiedPosErrorDataFactory, 1268262225, 8190, 17691, 163, 104, 99, 224, 206, 70, 95, 90);
RT_INTERFACE!{static interface IUnifiedPosErrorDataFactory(IUnifiedPosErrorDataFactoryVtbl, IUnifiedPosErrorDataFactory_Abi): IInspectable(IInspectableVtbl) [IID_IUnifiedPosErrorDataFactory] {
    fn CreateInstance(&self, message: HSTRING, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32, out: *mut <UnifiedPosErrorData as RtType>::Abi) -> HRESULT
}}
impl IUnifiedPosErrorDataFactory {
    #[inline] pub fn create_instance(&self, message: &HStringArg, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32) -> Result<UnifiedPosErrorData> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateInstance)(self.0.as_abi() as *const _ as *mut _, message.get(), severity, reason, extendedReason, &mut out);
        if hr == S_OK { Ok(UnifiedPosErrorData::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UnifiedPosErrorReason: i32 {
    UnknownErrorReason = 0, NoService = 1, Disabled = 2, Illegal = 3, NoHardware = 4, Closed = 5, Offline = 6, Failure = 7, Timeout = 8, Busy = 9, Extended = 10,
}}
RT_ENUM! { enum UnifiedPosErrorSeverity: i32 {
    UnknownErrorSeverity = 0, Warning = 1, Recoverable = 2, Unrecoverable = 3, AssistanceRequired = 4, Fatal = 5,
}}
RT_ENUM! { enum UnifiedPosHealthCheckLevel: i32 {
    UnknownHealthCheckLevel = 0, POSInternal = 1, External = 2, Interactive = 3,
}}
RT_ENUM! { enum UnifiedPosPowerReportingType: i32 {
    UnknownPowerReportingType = 0, Standard = 1, Advanced = 2,
}}
pub mod provider { // Windows.Devices.PointOfService.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequest, 2297231296, 14265, 17013, 142, 119, 200, 229, 42, 229, 169, 200);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequest(IBarcodeScannerDisableScannerRequestVtbl, IBarcodeScannerDisableScannerRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequest] {
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerDisableScannerRequest {
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDisableScannerRequest: IBarcodeScannerDisableScannerRequest}
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequest2, 3437225509, 26051, 19660, 180, 87, 243, 156, 122, 158, 166, 13);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequest2(IBarcodeScannerDisableScannerRequest2Vtbl, IBarcodeScannerDisableScannerRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerDisableScannerRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequestEventArgs, 1879499074, 59394, 18165, 182, 4, 53, 42, 21, 206, 146, 50);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequestEventArgs(IBarcodeScannerDisableScannerRequestEventArgsVtbl, IBarcodeScannerDisableScannerRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerDisableScannerRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerDisableScannerRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerDisableScannerRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerDisableScannerRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDisableScannerRequestEventArgs: IBarcodeScannerDisableScannerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequest, 3233016250, 33130, 17707, 189, 119, 183, 228, 83, 236, 68, 109);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequest(IBarcodeScannerEnableScannerRequestVtbl, IBarcodeScannerEnableScannerRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequest] {
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerEnableScannerRequest {
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerEnableScannerRequest: IBarcodeScannerEnableScannerRequest}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequest2, 1906635432, 39173, 16812, 145, 33, 182, 69, 145, 106, 132, 161);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequest2(IBarcodeScannerEnableScannerRequest2Vtbl, IBarcodeScannerEnableScannerRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerEnableScannerRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequestEventArgs, 2506920985, 31566, 17489, 140, 65, 142, 16, 207, 188, 91, 65);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequestEventArgs(IBarcodeScannerEnableScannerRequestEventArgsVtbl, IBarcodeScannerEnableScannerRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerEnableScannerRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerEnableScannerRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerEnableScannerRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerEnableScannerRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerEnableScannerRequestEventArgs: IBarcodeScannerEnableScannerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerFrameReader, 3687262983, 25795, 18475, 147, 200, 101, 251, 51, 194, 34, 8);
RT_INTERFACE!{interface IBarcodeScannerFrameReader(IBarcodeScannerFrameReaderVtbl, IBarcodeScannerFrameReader_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerFrameReader] {
    fn StartAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn StopAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn TryAcquireLatestFrameAsync(&self, out: *mut <foundation::IAsyncOperation<BarcodeScannerVideoFrame> as RtType>::Abi) -> HRESULT,
    fn get_Connection(&self, out: *mut <BarcodeScannerProviderConnection as RtType>::Abi) -> HRESULT,
    fn add_FrameArrived(&self, handler: <foundation::TypedEventHandler<BarcodeScannerFrameReader, BarcodeScannerFrameReaderFrameArrivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBarcodeScannerFrameReader {
    #[inline] pub fn start_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StartAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).StopAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_latest_frame_async(&self) -> Result<foundation::IAsyncOperation<BarcodeScannerVideoFrame>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryAcquireLatestFrameAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection(&self) -> Result<Option<BarcodeScannerProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Connection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerProviderConnection::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_frame_arrived(&self, handler: &foundation::TypedEventHandler<BarcodeScannerFrameReader, BarcodeScannerFrameReaderFrameArrivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_FrameArrived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_FrameArrived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerFrameReader: IBarcodeScannerFrameReader}
DEFINE_IID!(IID_IBarcodeScannerFrameReaderFrameArrivedEventArgs, 2965100036, 21757, 17261, 134, 41, 113, 46, 120, 114, 35, 221);
RT_INTERFACE!{interface IBarcodeScannerFrameReaderFrameArrivedEventArgs(IBarcodeScannerFrameReaderFrameArrivedEventArgsVtbl, IBarcodeScannerFrameReaderFrameArrivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerFrameReaderFrameArrivedEventArgs] {
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerFrameReaderFrameArrivedEventArgs {
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerFrameReaderFrameArrivedEventArgs: IBarcodeScannerFrameReaderFrameArrivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequest, 2541012074, 22756, 19551, 184, 233, 228, 20, 103, 99, 39, 0);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequest(IBarcodeScannerGetSymbologyAttributesRequestVtbl, IBarcodeScannerGetSymbologyAttributesRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequest] {
    fn get_Symbology(&self, out: *mut u32) -> HRESULT,
    fn ReportCompletedAsync(&self, attributes: <super::BarcodeSymbologyAttributes as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerGetSymbologyAttributesRequest {
    #[inline] pub fn get_symbology(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Symbology)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, attributes: &super::BarcodeSymbologyAttributes) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(attributes) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerGetSymbologyAttributesRequest: IBarcodeScannerGetSymbologyAttributesRequest}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequest2, 1785342739, 30120, 18939, 184, 82, 191, 185, 61, 118, 10, 247);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequest2(IBarcodeScannerGetSymbologyAttributesRequest2Vtbl, IBarcodeScannerGetSymbologyAttributesRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerGetSymbologyAttributesRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequestEventArgs, 2139741758, 64349, 18748, 180, 2, 53, 107, 36, 213, 116, 166);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequestEventArgs(IBarcodeScannerGetSymbologyAttributesRequestEventArgsVtbl, IBarcodeScannerGetSymbologyAttributesRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerGetSymbologyAttributesRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerGetSymbologyAttributesRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerGetSymbologyAttributesRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerGetSymbologyAttributesRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerGetSymbologyAttributesRequestEventArgs: IBarcodeScannerGetSymbologyAttributesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequest, 4199464575, 26224, 16609, 185, 11, 187, 16, 216, 212, 37, 250);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequest(IBarcodeScannerHideVideoPreviewRequestVtbl, IBarcodeScannerHideVideoPreviewRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequest] {
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerHideVideoPreviewRequest {
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerHideVideoPreviewRequest: IBarcodeScannerHideVideoPreviewRequest}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequest2, 2116567901, 38932, 17181, 162, 242, 214, 36, 140, 90, 212, 181);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequest2(IBarcodeScannerHideVideoPreviewRequest2Vtbl, IBarcodeScannerHideVideoPreviewRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerHideVideoPreviewRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequestEventArgs, 379748860, 54974, 19399, 157, 241, 51, 116, 31, 62, 173, 234);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequestEventArgs(IBarcodeScannerHideVideoPreviewRequestEventArgsVtbl, IBarcodeScannerHideVideoPreviewRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerHideVideoPreviewRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerHideVideoPreviewRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerHideVideoPreviewRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerHideVideoPreviewRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerHideVideoPreviewRequestEventArgs: IBarcodeScannerHideVideoPreviewRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerProviderConnection, 3024800749, 2874, 20387, 134, 197, 73, 30, 163, 7, 128, 235);
RT_INTERFACE!{interface IBarcodeScannerProviderConnection(IBarcodeScannerProviderConnectionVtbl, IBarcodeScannerProviderConnection_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderConnection] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedSymbologies(&self, out: *mut <foundation::collections::IVector<u32> as RtType>::Abi) -> HRESULT,
    fn get_CompanyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyName(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Version(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Version(&self, value: HSTRING) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn ReportScannedDataAsync(&self, report: <super::BarcodeScannerReport as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportTriggerStateAsync(&self, state: BarcodeScannerTriggerState, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportErrorAsync(&self, errorData: <super::UnifiedPosErrorData as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportErrorAsyncWithScanReport(&self, errorData: <super::UnifiedPosErrorData as RtType>::Abi, isRetriable: bool, scanReport: <super::BarcodeScannerReport as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_EnableScannerRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerEnableScannerRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnableScannerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DisableScannerRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerDisableScannerRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DisableScannerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetActiveSymbologiesRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetActiveSymbologiesRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetActiveSymbologiesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StartSoftwareTriggerRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStartSoftwareTriggerRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StartSoftwareTriggerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StopSoftwareTriggerRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStopSoftwareTriggerRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StopSoftwareTriggerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GetBarcodeSymbologyAttributesRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerGetSymbologyAttributesRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GetBarcodeSymbologyAttributesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetBarcodeSymbologyAttributesRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetSymbologyAttributesRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetBarcodeSymbologyAttributesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HideVideoPreviewRequested(&self, handler: <foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerHideVideoPreviewRequestEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HideVideoPreviewRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBarcodeScannerProviderConnection {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VideoDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_symbologies(&self) -> Result<Option<foundation::collections::IVector<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedSymbologies)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_company_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CompanyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_company_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CompanyName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Name)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Version)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_version(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Version)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_scanned_data_async(&self, report: &super::BarcodeScannerReport) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportScannedDataAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(report) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_trigger_state_async(&self, state: BarcodeScannerTriggerState) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportTriggerStateAsync)(self.0.as_abi() as *const _ as *mut _, state, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_error_async(&self, errorData: &super::UnifiedPosErrorData) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportErrorAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(errorData) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_error_async_with_scan_report(&self, errorData: &super::UnifiedPosErrorData, isRetriable: bool, scanReport: &super::BarcodeScannerReport) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportErrorAsyncWithScanReport)(self.0.as_abi() as *const _ as *mut _, get_abi(errorData) as *const _ as *mut _, isRetriable, get_abi(scanReport) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_enable_scanner_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerEnableScannerRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_EnableScannerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enable_scanner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_EnableScannerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disable_scanner_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerDisableScannerRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DisableScannerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disable_scanner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DisableScannerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_set_active_symbologies_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetActiveSymbologiesRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SetActiveSymbologiesRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_set_active_symbologies_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SetActiveSymbologiesRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_start_software_trigger_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStartSoftwareTriggerRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StartSoftwareTriggerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_start_software_trigger_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StartSoftwareTriggerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stop_software_trigger_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStopSoftwareTriggerRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StopSoftwareTriggerRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stop_software_trigger_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StopSoftwareTriggerRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_get_barcode_symbology_attributes_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerGetSymbologyAttributesRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_GetBarcodeSymbologyAttributesRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_get_barcode_symbology_attributes_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_GetBarcodeSymbologyAttributesRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_set_barcode_symbology_attributes_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetSymbologyAttributesRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SetBarcodeSymbologyAttributesRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_set_barcode_symbology_attributes_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SetBarcodeSymbologyAttributesRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hide_video_preview_requested(&self, handler: &foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerHideVideoPreviewRequestEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_HideVideoPreviewRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hide_video_preview_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_HideVideoPreviewRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerProviderConnection: IBarcodeScannerProviderConnection}
DEFINE_IID!(IID_IBarcodeScannerProviderConnection2, 3197850573, 4404, 16780, 160, 107, 4, 66, 58, 115, 243, 215);
RT_INTERFACE!{interface IBarcodeScannerProviderConnection2(IBarcodeScannerProviderConnection2Vtbl, IBarcodeScannerProviderConnection2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderConnection2] {
    fn CreateFrameReaderAsync(&self, out: *mut <foundation::IAsyncOperation<BarcodeScannerFrameReader> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateFrameReaderWithFormatAsync(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, out: *mut <foundation::IAsyncOperation<BarcodeScannerFrameReader> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateFrameReaderWithFormatAndSizeAsync(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, preferredSize: crate::windows::graphics::imaging::BitmapSize, out: *mut <foundation::IAsyncOperation<BarcodeScannerFrameReader> as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerProviderConnection2 {
    #[inline] pub fn create_frame_reader_async(&self) -> Result<foundation::IAsyncOperation<BarcodeScannerFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_frame_reader_with_format_async(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat) -> Result<foundation::IAsyncOperation<BarcodeScannerFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderWithFormatAsync)(self.0.as_abi() as *const _ as *mut _, preferredFormat, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_frame_reader_with_format_and_size_async(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, preferredSize: crate::windows::graphics::imaging::BitmapSize) -> Result<foundation::IAsyncOperation<BarcodeScannerFrameReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFrameReaderWithFormatAndSizeAsync)(self.0.as_abi() as *const _ as *mut _, preferredFormat, preferredSize, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerProviderTriggerDetails, 1350921602, 9443, 18638, 153, 199, 112, 170, 193, 203, 201, 247);
RT_INTERFACE!{interface IBarcodeScannerProviderTriggerDetails(IBarcodeScannerProviderTriggerDetailsVtbl, IBarcodeScannerProviderTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut <BarcodeScannerProviderConnection as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerProviderTriggerDetails {
    #[inline] pub fn get_connection(&self) -> Result<Option<BarcodeScannerProviderConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Connection)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerProviderConnection::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerProviderTriggerDetails: IBarcodeScannerProviderTriggerDetails}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequest, 3678352057, 63450, 16801, 159, 121, 7, 188, 217, 95, 11, 223);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequest(IBarcodeScannerSetActiveSymbologiesRequestVtbl, IBarcodeScannerSetActiveSymbologiesRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequest] {
    fn get_Symbologies(&self, out: *mut <foundation::collections::IVectorView<u32> as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetActiveSymbologiesRequest {
    #[inline] pub fn get_symbologies(&self) -> Result<Option<foundation::collections::IVectorView<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Symbologies)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetActiveSymbologiesRequest: IBarcodeScannerSetActiveSymbologiesRequest}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequest2, 4127157983, 64154, 18249, 177, 27, 232, 252, 203, 117, 188, 107);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequest2(IBarcodeScannerSetActiveSymbologiesRequest2Vtbl, IBarcodeScannerSetActiveSymbologiesRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetActiveSymbologiesRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequestEventArgs, 103832314, 31734, 19794, 128, 26, 51, 2, 114, 246, 10, 225);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequestEventArgs(IBarcodeScannerSetActiveSymbologiesRequestEventArgsVtbl, IBarcodeScannerSetActiveSymbologiesRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerSetActiveSymbologiesRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetActiveSymbologiesRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerSetActiveSymbologiesRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerSetActiveSymbologiesRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetActiveSymbologiesRequestEventArgs: IBarcodeScannerSetActiveSymbologiesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequest, 855343439, 41855, 18608, 172, 234, 220, 225, 72, 15, 18, 174);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequest(IBarcodeScannerSetSymbologyAttributesRequestVtbl, IBarcodeScannerSetSymbologyAttributesRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequest] {
    fn get_Symbology(&self, out: *mut u32) -> HRESULT,
    fn get_Attributes(&self, out: *mut <super::BarcodeSymbologyAttributes as RtType>::Abi) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetSymbologyAttributesRequest {
    #[inline] pub fn get_symbology(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Symbology)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<super::BarcodeSymbologyAttributes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Attributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BarcodeSymbologyAttributes::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetSymbologyAttributesRequest: IBarcodeScannerSetSymbologyAttributesRequest}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequest2, 3757817793, 56232, 19319, 190, 30, 181, 108, 215, 47, 101, 179);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequest2(IBarcodeScannerSetSymbologyAttributesRequest2Vtbl, IBarcodeScannerSetSymbologyAttributesRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetSymbologyAttributesRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequestEventArgs, 2998441993, 38948, 18388, 133, 189, 208, 7, 123, 170, 123, 210);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequestEventArgs(IBarcodeScannerSetSymbologyAttributesRequestEventArgsVtbl, IBarcodeScannerSetSymbologyAttributesRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerSetSymbologyAttributesRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerSetSymbologyAttributesRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerSetSymbologyAttributesRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerSetSymbologyAttributesRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetSymbologyAttributesRequestEventArgs: IBarcodeScannerSetSymbologyAttributesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequest, 3824843559, 65378, 17492, 175, 74, 203, 97, 68, 163, 227, 247);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequest(IBarcodeScannerStartSoftwareTriggerRequestVtbl, IBarcodeScannerStartSoftwareTriggerRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequest] {
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStartSoftwareTriggerRequest {
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStartSoftwareTriggerRequest: IBarcodeScannerStartSoftwareTriggerRequest}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequest2, 3950158428, 26200, 18277, 166, 142, 50, 116, 130, 101, 61, 235);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequest2(IBarcodeScannerStartSoftwareTriggerRequest2Vtbl, IBarcodeScannerStartSoftwareTriggerRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStartSoftwareTriggerRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequestEventArgs, 587585603, 51343, 20283, 140, 59, 211, 223, 7, 16, 81, 236);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequestEventArgs(IBarcodeScannerStartSoftwareTriggerRequestEventArgsVtbl, IBarcodeScannerStartSoftwareTriggerRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerStartSoftwareTriggerRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStartSoftwareTriggerRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerStartSoftwareTriggerRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerStartSoftwareTriggerRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStartSoftwareTriggerRequestEventArgs: IBarcodeScannerStartSoftwareTriggerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequest, 1872736053, 57991, 19624, 183, 13, 90, 145, 214, 148, 246, 104);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequest(IBarcodeScannerStopSoftwareTriggerRequestVtbl, IBarcodeScannerStopSoftwareTriggerRequest_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequest] {
    fn ReportCompletedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStopSoftwareTriggerRequest {
    #[inline] pub fn report_completed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportCompletedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStopSoftwareTriggerRequest: IBarcodeScannerStopSoftwareTriggerRequest}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequest2, 3411527133, 65104, 18936, 160, 180, 189, 194, 48, 129, 77, 162);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequest2(IBarcodeScannerStopSoftwareTriggerRequest2Vtbl, IBarcodeScannerStopSoftwareTriggerRequest2_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStopSoftwareTriggerRequest2 {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAsync)(self.0.as_abi() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.0.as_abi() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequestEventArgs, 3938665552, 20151, 18458, 146, 115, 20, 122, 39, 59, 153, 184);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequestEventArgs(IBarcodeScannerStopSoftwareTriggerRequestEventArgsVtbl, IBarcodeScannerStopSoftwareTriggerRequestEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequestEventArgs] {
    fn get_Request(&self, out: *mut <BarcodeScannerStopSoftwareTriggerRequest as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <foundation::Deferral as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerStopSoftwareTriggerRequestEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<BarcodeScannerStopSoftwareTriggerRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarcodeScannerStopSoftwareTriggerRequest::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<foundation::Deferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::Deferral::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStopSoftwareTriggerRequestEventArgs: IBarcodeScannerStopSoftwareTriggerRequestEventArgs}
RT_ENUM! { enum BarcodeScannerTriggerState: i32 {
    Released = 0, Pressed = 1,
}}
DEFINE_IID!(IID_IBarcodeScannerVideoFrame, 2119717448, 40439, 16673, 161, 117, 128, 29, 128, 0, 17, 46);
RT_INTERFACE!{interface IBarcodeScannerVideoFrame(IBarcodeScannerVideoFrameVtbl, IBarcodeScannerVideoFrame_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerVideoFrame] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Format(&self, out: *mut crate::windows::graphics::imaging::BitmapPixelFormat) -> HRESULT,
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_PixelData(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IBarcodeScannerVideoFrame {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_format(&self) -> Result<crate::windows::graphics::imaging::BitmapPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Width)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Height)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_pixel_data(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PixelData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerVideoFrame: IBarcodeScannerVideoFrame}
DEFINE_IID!(IID_IBarcodeSymbologyAttributesBuilder, 3313175743, 58613, 16569, 132, 207, 230, 63, 186, 234, 66, 180);
RT_INTERFACE!{interface IBarcodeSymbologyAttributesBuilder(IBarcodeSymbologyAttributesBuilderVtbl, IBarcodeSymbologyAttributesBuilder_Abi): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologyAttributesBuilder] {
    fn get_IsCheckDigitValidationSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitValidationSupported(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitTransmissionSupported(&self, value: bool) -> HRESULT,
    fn get_IsDecodeLengthSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeLengthSupported(&self, value: bool) -> HRESULT,
    fn CreateAttributes(&self, out: *mut <super::BarcodeSymbologyAttributes as RtType>::Abi) -> HRESULT
}}
impl IBarcodeSymbologyAttributesBuilder {
    #[inline] pub fn get_is_check_digit_validation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitValidationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_validation_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCheckDigitValidationSupported)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsCheckDigitTransmissionSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_transmission_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsCheckDigitTransmissionSupported)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDecodeLengthSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_length_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDecodeLengthSupported)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_attributes(&self) -> Result<Option<super::BarcodeSymbologyAttributes>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateAttributes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::BarcodeSymbologyAttributes::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeSymbologyAttributesBuilder: IBarcodeSymbologyAttributesBuilder}
impl RtActivatable<IActivationFactory> for BarcodeSymbologyAttributesBuilder {}
DEFINE_CLSID!(BarcodeSymbologyAttributesBuilder(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,114,111,118,105,100,101,114,46,66,97,114,99,111,100,101,83,121,109,98,111,108,111,103,121,65,116,116,114,105,98,117,116,101,115,66,117,105,108,100,101,114,0]) [CLSID_BarcodeSymbologyAttributesBuilder]);
} // Windows.Devices.PointOfService.Provider
} // Windows.Devices.PointOfService
pub mod portable { // Windows.Devices.Portable
use crate::prelude::*;
RT_CLASS!{static class ServiceDevice}
impl RtActivatable<IServiceDeviceStatics> for ServiceDevice {}
impl ServiceDevice {
    #[inline] pub fn get_device_selector(serviceType: ServiceDeviceType) -> Result<HString> {
        <Self as RtActivatable<IServiceDeviceStatics>>::get_activation_factory().get_device_selector(serviceType)
    }
    #[inline] pub fn get_device_selector_from_service_id(serviceId: Guid) -> Result<HString> {
        <Self as RtActivatable<IServiceDeviceStatics>>::get_activation_factory().get_device_selector_from_service_id(serviceId)
    }
}
DEFINE_CLSID!(ServiceDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,101,114,118,105,99,101,68,101,118,105,99,101,0]) [CLSID_ServiceDevice]);
DEFINE_IID!(IID_IServiceDeviceStatics, 2827097313, 22983, 18976, 171, 166, 159, 103, 7, 147, 114, 48);
RT_INTERFACE!{static interface IServiceDeviceStatics(IServiceDeviceStaticsVtbl, IServiceDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IServiceDeviceStatics] {
    fn GetDeviceSelector(&self, serviceType: ServiceDeviceType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromServiceId(&self, serviceId: Guid, out: *mut HSTRING) -> HRESULT
}}
impl IServiceDeviceStatics {
    #[inline] pub fn get_device_selector(&self, serviceType: ServiceDeviceType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, serviceType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_service_id(&self, serviceId: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromServiceId)(self.0.as_abi() as *const _ as *mut _, serviceId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ServiceDeviceType: i32 {
    CalendarService = 0, ContactsService = 1, DeviceStatusService = 2, NotesService = 3, RingtonesService = 4, SmsService = 5, TasksService = 6,
}}
RT_CLASS!{static class StorageDevice}
impl RtActivatable<IStorageDeviceStatics> for StorageDevice {}
impl StorageDevice {
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<super::super::storage::StorageFolder>> {
        <Self as RtActivatable<IStorageDeviceStatics>>::get_activation_factory().from_id(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IStorageDeviceStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(StorageDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,116,111,114,97,103,101,68,101,118,105,99,101,0]) [CLSID_StorageDevice]);
DEFINE_IID!(IID_IStorageDeviceStatics, 1590576366, 6947, 19922, 134, 82, 188, 22, 79, 0, 49, 40);
RT_INTERFACE!{static interface IStorageDeviceStatics(IStorageDeviceStaticsVtbl, IStorageDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IStorageDeviceStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn FromId(&self, deviceId: HSTRING, out: *mut <super::super::storage::StorageFolder as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStorageDeviceStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<super::super::storage::StorageFolder>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(super::super::storage::StorageFolder::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Portable
pub mod power { // Windows.Devices.Power
use crate::prelude::*;
DEFINE_IID!(IID_IBattery, 3163115462, 114, 18376, 139, 93, 97, 74, 170, 122, 67, 126);
RT_INTERFACE!{interface IBattery(IBatteryVtbl, IBattery_Abi): IInspectable(IInspectableVtbl) [IID_IBattery] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn GetReport(&self, out: *mut <BatteryReport as RtType>::Abi) -> HRESULT,
    fn add_ReportUpdated(&self, handler: <foundation::TypedEventHandler<Battery, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReportUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBattery {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_report(&self) -> Result<Option<BatteryReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BatteryReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_report_updated(&self, handler: &foundation::TypedEventHandler<Battery, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReportUpdated)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_report_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReportUpdated)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Battery: IBattery}
impl RtActivatable<IBatteryStatics> for Battery {}
impl Battery {
    #[inline] pub fn get_aggregate_battery() -> Result<Option<Battery>> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().get_aggregate_battery()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Battery>> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Battery(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,119,101,114,46,66,97,116,116,101,114,121,0]) [CLSID_Battery]);
DEFINE_IID!(IID_IBatteryReport, 3380972602, 19987, 16906, 168, 208, 36, 241, 143, 57, 84, 1);
RT_INTERFACE!{interface IBatteryReport(IBatteryReportVtbl, IBatteryReport_Abi): IInspectable(IInspectableVtbl) [IID_IBatteryReport] {
    fn get_ChargeRateInMilliwatts(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_DesignCapacityInMilliwattHours(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_FullChargeCapacityInMilliwattHours(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    fn get_RemainingCapacityInMilliwattHours(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_Status(&self, out: *mut super::super::system::power::BatteryStatus) -> HRESULT
}}
impl IBatteryReport {
    #[inline] pub fn get_charge_rate_in_milliwatts(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChargeRateInMilliwatts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_design_capacity_in_milliwatt_hours(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesignCapacityInMilliwattHours)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_full_charge_capacity_in_milliwatt_hours(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FullChargeCapacityInMilliwattHours)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remaining_capacity_in_milliwatt_hours(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemainingCapacityInMilliwattHours)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_status(&self) -> Result<super::super::system::power::BatteryStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BatteryReport: IBatteryReport}
DEFINE_IID!(IID_IBatteryStatics, 2043507382, 40542, 17490, 190, 166, 223, 205, 84, 30, 89, 127);
RT_INTERFACE!{static interface IBatteryStatics(IBatteryStaticsVtbl, IBatteryStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBatteryStatics] {
    fn get_AggregateBattery(&self, out: *mut <Battery as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Battery> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBatteryStatics {
    #[inline] pub fn get_aggregate_battery(&self) -> Result<Option<Battery>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AggregateBattery)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Battery::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Battery>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Power
pub mod printers { // Windows.Devices.Printers
use crate::prelude::*;
DEFINE_IID!(IID_IPrint3DDevice, 68959513, 38675, 17058, 152, 19, 125, 195, 51, 116, 40, 211);
RT_INTERFACE!{interface IPrint3DDevice(IPrint3DDeviceVtbl, IPrint3DDevice_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DDevice] {
    fn get_PrintSchema(&self, out: *mut <PrintSchema as RtType>::Abi) -> HRESULT
}}
impl IPrint3DDevice {
    #[inline] pub fn get_print_schema(&self) -> Result<Option<PrintSchema>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrintSchema)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PrintSchema::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DDevice: IPrint3DDevice}
impl RtActivatable<IPrint3DDeviceStatics> for Print3DDevice {}
impl Print3DDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Print3DDevice>> {
        <Self as RtActivatable<IPrint3DDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPrint3DDeviceStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Print3DDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,80,114,105,110,116,51,68,68,101,118,105,99,101,0]) [CLSID_Print3DDevice]);
DEFINE_IID!(IID_IPrint3DDeviceStatics, 4259537418, 26573, 16823, 163, 68, 81, 80, 161, 253, 117, 181);
RT_INTERFACE!{static interface IPrint3DDeviceStatics(IPrint3DDeviceStaticsVtbl, IPrint3DDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Print3DDevice> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPrint3DDeviceStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Print3DDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPrintSchema, 3266937622, 9912, 19451, 129, 56, 159, 150, 44, 34, 163, 91);
RT_INTERFACE!{interface IPrintSchema(IPrintSchemaVtbl, IPrintSchema_Abi): IInspectable(IInspectableVtbl) [IID_IPrintSchema] {
    #[cfg(feature="windows-storage")] fn GetDefaultPrintTicketAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetCapabilitiesAsync(&self, constrainTicket: <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn MergeAndValidateWithDefaultPrintTicketAsync(&self, deltaTicket: <super::super::storage::streams::IRandomAccessStreamWithContentType as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType> as RtType>::Abi) -> HRESULT
}}
impl IPrintSchema {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_default_print_ticket_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultPrintTicketAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_capabilities_async(&self, constrainTicket: &super::super::storage::streams::IRandomAccessStreamWithContentType) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCapabilitiesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(constrainTicket) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn merge_and_validate_with_default_print_ticket_async(&self, deltaTicket: &super::super::storage::streams::IRandomAccessStreamWithContentType) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).MergeAndValidateWithDefaultPrintTicketAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(deltaTicket) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintSchema: IPrintSchema}
pub mod extensions { // Windows.Devices.Printers.Extensions
use crate::prelude::*;
DEFINE_IID!(IID_IPrint3DWorkflow, 3312415933, 13929, 19046, 171, 66, 200, 21, 25, 48, 205, 52);
RT_INTERFACE!{interface IPrint3DWorkflow(IPrint3DWorkflowVtbl, IPrint3DWorkflow_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow] {
    fn get_DeviceID(&self, out: *mut HSTRING) -> HRESULT,
    fn GetPrintModelPackage(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn get_IsPrintReady(&self, out: *mut bool) -> HRESULT,
    fn put_IsPrintReady(&self, value: bool) -> HRESULT,
    fn add_PrintRequested(&self, eventHandler: <foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrintRequested(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPrint3DWorkflow {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceID)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_print_model_package(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetPrintModelPackage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_print_ready(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsPrintReady)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_print_ready(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsPrintReady)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_print_requested(&self, eventHandler: &foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PrintRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_print_requested(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PrintRequested)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflow: IPrint3DWorkflow}
DEFINE_IID!(IID_IPrint3DWorkflow2, 2728838479, 35521, 18712, 151, 65, 227, 79, 48, 4, 35, 158);
RT_INTERFACE!{interface IPrint3DWorkflow2(IPrint3DWorkflow2Vtbl, IPrint3DWorkflow2_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow2] {
    fn add_PrinterChanged(&self, eventHandler: <foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrinterChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPrint3DWorkflow2 {
    #[inline] pub fn add_printer_changed(&self, eventHandler: &foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PrinterChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_printer_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PrinterChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum Print3DWorkflowDetail: i32 {
    Unknown = 0, ModelExceedsPrintBed = 1, UploadFailed = 2, InvalidMaterialSelection = 3, InvalidModel = 4, ModelNotManifold = 5, InvalidPrintTicket = 6,
}}
DEFINE_IID!(IID_IPrint3DWorkflowPrinterChangedEventArgs, 1159881730, 38396, 18503, 147, 179, 19, 77, 191, 92, 96, 247);
RT_INTERFACE!{interface IPrint3DWorkflowPrinterChangedEventArgs(IPrint3DWorkflowPrinterChangedEventArgsVtbl, IPrint3DWorkflowPrinterChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrinterChangedEventArgs] {
    fn get_NewDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPrint3DWorkflowPrinterChangedEventArgs {
    #[inline] pub fn get_new_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NewDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflowPrinterChangedEventArgs: IPrint3DWorkflowPrinterChangedEventArgs}
DEFINE_IID!(IID_IPrint3DWorkflowPrintRequestedEventArgs, 435734616, 23240, 19285, 138, 95, 230, 21, 103, 218, 251, 77);
RT_INTERFACE!{interface IPrint3DWorkflowPrintRequestedEventArgs(IPrint3DWorkflowPrintRequestedEventArgsVtbl, IPrint3DWorkflowPrintRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrintRequestedEventArgs] {
    fn get_Status(&self, out: *mut Print3DWorkflowStatus) -> HRESULT,
    fn SetExtendedStatus(&self, value: Print3DWorkflowDetail) -> HRESULT,
    fn SetSource(&self, source: <IInspectable as RtType>::Abi) -> HRESULT,
    fn SetSourceChanged(&self, value: bool) -> HRESULT
}}
impl IPrint3DWorkflowPrintRequestedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<Print3DWorkflowStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extended_status(&self, value: Print3DWorkflowDetail) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetExtendedStatus)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, source: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSource)(self.0.as_abi() as *const _ as *mut _, get_abi(source) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_source_changed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetSourceChanged)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflowPrintRequestedEventArgs: IPrint3DWorkflowPrintRequestedEventArgs}
RT_ENUM! { enum Print3DWorkflowStatus: i32 {
    Abandoned = 0, Canceled = 1, Failed = 2, Slicing = 3, Submitted = 4,
}}
RT_CLASS!{static class PrintExtensionContext}
impl RtActivatable<IPrintExtensionContextStatic> for PrintExtensionContext {}
impl PrintExtensionContext {
    #[inline] pub fn from_device_id(deviceId: &HStringArg) -> Result<Option<IInspectable>> {
        <Self as RtActivatable<IPrintExtensionContextStatic>>::get_activation_factory().from_device_id(deviceId)
    }
}
DEFINE_CLSID!(PrintExtensionContext(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,69,120,116,101,110,115,105,111,110,115,46,80,114,105,110,116,69,120,116,101,110,115,105,111,110,67,111,110,116,101,120,116,0]) [CLSID_PrintExtensionContext]);
DEFINE_IID!(IID_IPrintExtensionContextStatic, 3876429761, 65401, 19108, 140, 155, 12, 147, 174, 223, 222, 138);
RT_INTERFACE!{static interface IPrintExtensionContextStatic(IPrintExtensionContextStaticVtbl, IPrintExtensionContextStatic_Abi): IInspectable(IInspectableVtbl) [IID_IPrintExtensionContextStatic] {
    fn FromDeviceId(&self, deviceId: HSTRING, out: *mut <IInspectable as RtType>::Abi) -> HRESULT
}}
impl IPrintExtensionContextStatic {
    #[inline] pub fn from_device_id(&self, deviceId: &HStringArg) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromDeviceId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPrintNotificationEventDetails, 3759033482, 18472, 19873, 139, 184, 134, 114, 223, 133, 21, 231);
RT_INTERFACE!{interface IPrintNotificationEventDetails(IPrintNotificationEventDetailsVtbl, IPrintNotificationEventDetails_Abi): IInspectable(IInspectableVtbl) [IID_IPrintNotificationEventDetails] {
    fn get_PrinterName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EventData(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EventData(&self, value: HSTRING) -> HRESULT
}}
impl IPrintNotificationEventDetails {
    #[inline] pub fn get_printer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrinterName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_event_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EventData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_event_data(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_EventData)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintNotificationEventDetails: IPrintNotificationEventDetails}
DEFINE_IID!(IID_IPrintTaskConfiguration, 3821151313, 15012, 18565, 146, 64, 49, 31, 95, 143, 190, 157);
RT_INTERFACE!{interface IPrintTaskConfiguration(IPrintTaskConfigurationVtbl, IPrintTaskConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfiguration] {
    fn get_PrinterExtensionContext(&self, out: *mut <IInspectable as RtType>::Abi) -> HRESULT,
    fn add_SaveRequested(&self, eventHandler: <foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SaveRequested(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPrintTaskConfiguration {
    #[inline] pub fn get_printer_extension_context(&self) -> Result<Option<IInspectable>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PrinterExtensionContext)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(IInspectable::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_save_requested(&self, eventHandler: &foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SaveRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_save_requested(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SaveRequested)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfiguration: IPrintTaskConfiguration}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequest, 4004458443, 25118, 19298, 172, 119, 178, 129, 204, 224, 141, 96);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequest(IPrintTaskConfigurationSaveRequestVtbl, IPrintTaskConfigurationSaveRequest_Abi): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequest] {
    fn Cancel(&self) -> HRESULT,
    fn Save(&self, printerExtensionContext: <IInspectable as RtType>::Abi) -> HRESULT,
    fn GetDeferral(&self, out: *mut <PrintTaskConfigurationSaveRequestedDeferral as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IPrintTaskConfigurationSaveRequest {
    #[inline] pub fn cancel(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Cancel)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn save(&self, printerExtensionContext: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Save)(self.0.as_abi() as *const _ as *mut _, get_abi(printerExtensionContext) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<PrintTaskConfigurationSaveRequestedDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PrintTaskConfigurationSaveRequestedDeferral::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Deadline)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequest: IPrintTaskConfigurationSaveRequest}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedDeferral, 3914978664, 63273, 17572, 135, 29, 189, 6, 40, 105, 106, 51);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedDeferral(IPrintTaskConfigurationSaveRequestedDeferralVtbl, IPrintTaskConfigurationSaveRequestedDeferral_Abi): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IPrintTaskConfigurationSaveRequestedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequestedDeferral: IPrintTaskConfigurationSaveRequestedDeferral}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedEventArgs, 3765184633, 3425, 18744, 145, 208, 150, 164, 91, 238, 132, 121);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedEventArgs(IPrintTaskConfigurationSaveRequestedEventArgsVtbl, IPrintTaskConfigurationSaveRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedEventArgs] {
    fn get_Request(&self, out: *mut <PrintTaskConfigurationSaveRequest as RtType>::Abi) -> HRESULT
}}
impl IPrintTaskConfigurationSaveRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<PrintTaskConfigurationSaveRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PrintTaskConfigurationSaveRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequestedEventArgs: IPrintTaskConfigurationSaveRequestedEventArgs}
} // Windows.Devices.Printers.Extensions
} // Windows.Devices.Printers
pub mod pwm { // Windows.Devices.Pwm
use crate::prelude::*;
DEFINE_IID!(IID_IPwmController, 3294583941, 53992, 17103, 155, 214, 207, 94, 208, 41, 230, 167);
RT_INTERFACE!{interface IPwmController(IPwmControllerVtbl, IPwmController_Abi): IInspectable(IInspectableVtbl) [IID_IPwmController] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn get_ActualFrequency(&self, out: *mut f64) -> HRESULT,
    fn SetDesiredFrequency(&self, desiredFrequency: f64, out: *mut f64) -> HRESULT,
    fn get_MinFrequency(&self, out: *mut f64) -> HRESULT,
    fn get_MaxFrequency(&self, out: *mut f64) -> HRESULT,
    fn OpenPin(&self, pinNumber: i32, out: *mut <PwmPin as RtType>::Abi) -> HRESULT
}}
impl IPwmController {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActualFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_frequency(&self, desiredFrequency: f64) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).SetDesiredFrequency)(self.0.as_abi() as *const _ as *mut _, desiredFrequency, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin(&self, pinNumber: i32) -> Result<Option<PwmPin>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).OpenPin)(self.0.as_abi() as *const _ as *mut _, pinNumber, &mut out);
        if hr == S_OK { Ok(PwmPin::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PwmController: IPwmController}
impl RtActivatable<IPwmControllerStatics> for PwmController {}
impl RtActivatable<IPwmControllerStatics2> for PwmController {}
impl RtActivatable<IPwmControllerStatics3> for PwmController {}
impl PwmController {
    #[inline] pub fn get_controllers_async(provider: &provider::IPwmProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>>> {
        <Self as RtActivatable<IPwmControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<PwmController>> {
        <Self as RtActivatable<IPwmControllerStatics2>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<PwmController>> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(PwmController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,119,109,46,80,119,109,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_PwmController]);
DEFINE_IID!(IID_IPwmControllerStatics, 1113832865, 35142, 17412, 189, 72, 129, 221, 18, 74, 244, 217);
RT_INTERFACE!{static interface IPwmControllerStatics(IPwmControllerStaticsVtbl, IPwmControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics] {
    fn GetControllersAsync(&self, provider: <provider::IPwmProvider as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>> as RtType>::Abi) -> HRESULT
}}
impl IPwmControllerStatics {
    #[inline] pub fn get_controllers_async(&self, provider: &provider::IPwmProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmControllerStatics2, 1157389087, 61721, 19421, 151, 173, 247, 110, 249, 134, 115, 109);
RT_INTERFACE!{static interface IPwmControllerStatics2(IPwmControllerStatics2Vtbl, IPwmControllerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics2] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<PwmController> as RtType>::Abi) -> HRESULT
}}
impl IPwmControllerStatics2 {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<PwmController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmControllerStatics3, 2992117873, 553, 17220, 174, 63, 155, 124, 208, 230, 107, 148);
RT_INTERFACE!{static interface IPwmControllerStatics3(IPwmControllerStatics3Vtbl, IPwmControllerStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics3] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<PwmController> as RtType>::Abi) -> HRESULT
}}
impl IPwmControllerStatics3 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<PwmController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmPin, 580333000, 50895, 18465, 183, 249, 198, 69, 79, 182, 175, 121);
RT_INTERFACE!{interface IPwmPin(IPwmPinVtbl, IPwmPin_Abi): IInspectable(IInspectableVtbl) [IID_IPwmPin] {
    fn get_Controller(&self, out: *mut <PwmController as RtType>::Abi) -> HRESULT,
    fn GetActiveDutyCyclePercentage(&self, out: *mut f64) -> HRESULT,
    fn SetActiveDutyCyclePercentage(&self, dutyCyclePercentage: f64) -> HRESULT,
    fn get_Polarity(&self, out: *mut PwmPulsePolarity) -> HRESULT,
    fn put_Polarity(&self, value: PwmPulsePolarity) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT
}}
impl IPwmPin {
    #[inline] pub fn get_controller(&self) -> Result<Option<PwmController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Controller)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PwmController::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_duty_cycle_percentage(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetActiveDutyCyclePercentage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_active_duty_cycle_percentage(&self, dutyCyclePercentage: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetActiveDutyCyclePercentage)(self.0.as_abi() as *const _ as *mut _, dutyCyclePercentage);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<PwmPulsePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Polarity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_polarity(&self, value: PwmPulsePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Polarity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsStarted)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PwmPin: IPwmPin}
RT_ENUM! { enum PwmPulsePolarity: i32 {
    ActiveHigh = 0, ActiveLow = 1,
}}
pub mod provider { // Windows.Devices.Pwm.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IPwmControllerProvider, 318789947, 58083, 16548, 183, 217, 72, 223, 240, 55, 122, 82);
RT_INTERFACE!{interface IPwmControllerProvider(IPwmControllerProviderVtbl, IPwmControllerProvider_Abi): IInspectable(IInspectableVtbl) [IID_IPwmControllerProvider] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn get_ActualFrequency(&self, out: *mut f64) -> HRESULT,
    fn SetDesiredFrequency(&self, frequency: f64, out: *mut f64) -> HRESULT,
    fn get_MaxFrequency(&self, out: *mut f64) -> HRESULT,
    fn get_MinFrequency(&self, out: *mut f64) -> HRESULT,
    fn AcquirePin(&self, pin: i32) -> HRESULT,
    fn ReleasePin(&self, pin: i32) -> HRESULT,
    fn EnablePin(&self, pin: i32) -> HRESULT,
    fn DisablePin(&self, pin: i32) -> HRESULT,
    fn SetPulseParameters(&self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> HRESULT
}}
impl IPwmControllerProvider {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActualFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_frequency(&self, frequency: f64) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).SetDesiredFrequency)(self.0.as_abi() as *const _ as *mut _, frequency, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn acquire_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).AcquirePin)(self.0.as_abi() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn release_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReleasePin)(self.0.as_abi() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).EnablePin)(self.0.as_abi() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disable_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).DisablePin)(self.0.as_abi() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_pulse_parameters(&self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetPulseParameters)(self.0.as_abi() as *const _ as *mut _, pin, dutyCycle, invertPolarity);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmProvider, 2737836584, 21233, 18352, 147, 73, 102, 186, 67, 210, 89, 2);
RT_INTERFACE!{interface IPwmProvider(IPwmProviderVtbl, IPwmProvider_Abi): IInspectable(IInspectableVtbl) [IID_IPwmProvider] {
    fn GetControllers(&self, out: *mut <foundation::collections::IVectorView<IPwmControllerProvider> as RtType>::Abi) -> HRESULT
}}
impl IPwmProvider {
    #[inline] pub fn get_controllers(&self) -> Result<Option<foundation::collections::IVectorView<IPwmControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Pwm.Provider
} // Windows.Devices.Pwm
pub mod radios { // Windows.Devices.Radios
use crate::prelude::*;
DEFINE_IID!(IID_IRadio, 622926047, 45886, 16746, 135, 95, 28, 243, 138, 226, 216, 62);
RT_INTERFACE!{interface IRadio(IRadioVtbl, IRadio_Abi): IInspectable(IInspectableVtbl) [IID_IRadio] {
    fn SetStateAsync(&self, value: RadioState, out: *mut <foundation::IAsyncOperation<RadioAccessStatus> as RtType>::Abi) -> HRESULT,
    fn add_StateChanged(&self, handler: <foundation::TypedEventHandler<Radio, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_State(&self, out: *mut RadioState) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut RadioKind) -> HRESULT
}}
impl IRadio {
    #[inline] pub fn set_state_async(&self, value: RadioState) -> Result<foundation::IAsyncOperation<RadioAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetStateAsync)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &foundation::TypedEventHandler<Radio, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StateChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StateChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<RadioState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<RadioKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Radio: IRadio}
impl RtActivatable<IRadioStatics> for Radio {}
impl Radio {
    #[inline] pub fn get_radios_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().get_radios_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Radio>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<RadioAccessStatus>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(Radio(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,82,97,100,105,111,115,46,82,97,100,105,111,0]) [CLSID_Radio]);
RT_ENUM! { enum RadioAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
RT_ENUM! { enum RadioKind: i32 {
    Other = 0, WiFi = 1, MobileBroadband = 2, Bluetooth = 3, FM = 4,
}}
RT_ENUM! { enum RadioState: i32 {
    Unknown = 0, On = 1, Off = 2, Disabled = 3,
}}
DEFINE_IID!(IID_IRadioStatics, 1605804334, 26571, 18094, 170, 233, 101, 145, 159, 134, 239, 244);
RT_INTERFACE!{static interface IRadioStatics(IRadioStaticsVtbl, IRadioStatics_Abi): IInspectable(IInspectableVtbl) [IID_IRadioStatics] {
    fn GetRadiosAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Radio> as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<RadioAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IRadioStatics {
    #[inline] pub fn get_radios_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRadiosAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Radio>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<RadioAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Radios
pub mod scanners { // Windows.Devices.Scanners
use crate::prelude::*;
DEFINE_IID!(IID_IImageScanner, 1403555704, 21144, 18592, 141, 163, 128, 135, 81, 150, 101, 224);
RT_INTERFACE!{interface IImageScanner(IImageScannerVtbl, IImageScanner_Abi): IInspectable(IInspectableVtbl) [IID_IImageScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultScanSource(&self, out: *mut ImageScannerScanSource) -> HRESULT,
    fn IsScanSourceSupported(&self, value: ImageScannerScanSource, out: *mut bool) -> HRESULT,
    fn get_FlatbedConfiguration(&self, out: *mut <ImageScannerFlatbedConfiguration as RtType>::Abi) -> HRESULT,
    fn get_FeederConfiguration(&self, out: *mut <ImageScannerFeederConfiguration as RtType>::Abi) -> HRESULT,
    fn get_AutoConfiguration(&self, out: *mut <ImageScannerAutoConfiguration as RtType>::Abi) -> HRESULT,
    fn IsPreviewSupported(&self, scanSource: ImageScannerScanSource, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ScanPreviewToStreamAsync(&self, scanSource: ImageScannerScanSource, targetStream: <super::super::storage::streams::IRandomAccessStream as RtType>::Abi, out: *mut <foundation::IAsyncOperation<ImageScannerPreviewResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ScanFilesToFolderAsync(&self, scanSource: ImageScannerScanSource, storageFolder: <super::super::storage::StorageFolder as RtType>::Abi, out: *mut <foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32> as RtType>::Abi) -> HRESULT
}}
impl IImageScanner {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_scan_source(&self) -> Result<ImageScannerScanSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultScanSource)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_scan_source_supported(&self, value: ImageScannerScanSource) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsScanSourceSupported)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_flatbed_configuration(&self) -> Result<Option<ImageScannerFlatbedConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FlatbedConfiguration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageScannerFlatbedConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feeder_configuration(&self) -> Result<Option<ImageScannerFeederConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_FeederConfiguration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageScannerFeederConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_configuration(&self) -> Result<Option<ImageScannerAutoConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoConfiguration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ImageScannerAutoConfiguration::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_preview_supported(&self, scanSource: ImageScannerScanSource) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsPreviewSupported)(self.0.as_abi() as *const _ as *mut _, scanSource, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn scan_preview_to_stream_async(&self, scanSource: ImageScannerScanSource, targetStream: &super::super::storage::streams::IRandomAccessStream) -> Result<foundation::IAsyncOperation<ImageScannerPreviewResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ScanPreviewToStreamAsync)(self.0.as_abi() as *const _ as *mut _, scanSource, get_abi(targetStream) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn scan_files_to_folder_async(&self, scanSource: ImageScannerScanSource, storageFolder: &super::super::storage::StorageFolder) -> Result<foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ScanFilesToFolderAsync)(self.0.as_abi() as *const _ as *mut _, scanSource, get_abi(storageFolder) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScanner: IImageScanner}
impl RtActivatable<IImageScannerStatics> for ImageScanner {}
impl ImageScanner {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ImageScanner>> {
        <Self as RtActivatable<IImageScannerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IImageScannerStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(ImageScanner(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,99,97,110,110,101,114,115,46,73,109,97,103,101,83,99,97,110,110,101,114,0]) [CLSID_ImageScanner]);
RT_CLASS!{class ImageScannerAutoConfiguration: IImageScannerFormatConfiguration}
RT_ENUM! { enum ImageScannerAutoCroppingMode: i32 {
    Disabled = 0, SingleRegion = 1, MultipleRegion = 2,
}}
RT_ENUM! { enum ImageScannerColorMode: i32 {
    Color = 0, Grayscale = 1, Monochrome = 2, AutoColor = 3,
}}
DEFINE_IID!(IID_IImageScannerFeederConfiguration, 1958587630, 64151, 19479, 130, 128, 64, 227, 156, 109, 204, 103);
RT_INTERFACE!{interface IImageScannerFeederConfiguration(IImageScannerFeederConfigurationVtbl, IImageScannerFeederConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerFeederConfiguration] {
    fn get_CanAutoDetectPageSize(&self, out: *mut bool) -> HRESULT,
    fn get_AutoDetectPageSize(&self, out: *mut bool) -> HRESULT,
    fn put_AutoDetectPageSize(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PageSize(&self, out: *mut super::super::graphics::printing::PrintMediaSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_PageSize(&self, value: super::super::graphics::printing::PrintMediaSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PageOrientation(&self, out: *mut super::super::graphics::printing::PrintOrientation) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_PageOrientation(&self, value: super::super::graphics::printing::PrintOrientation) -> HRESULT,
    fn get_PageSizeDimensions(&self, out: *mut foundation::Size) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-graphics")] fn IsPageSizeSupported(&self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation, out: *mut bool) -> HRESULT,
    fn get_MaxNumberOfPages(&self, out: *mut u32) -> HRESULT,
    fn put_MaxNumberOfPages(&self, value: u32) -> HRESULT,
    fn get_CanScanDuplex(&self, out: *mut bool) -> HRESULT,
    fn get_Duplex(&self, out: *mut bool) -> HRESULT,
    fn put_Duplex(&self, value: bool) -> HRESULT,
    fn get_CanScanAhead(&self, out: *mut bool) -> HRESULT,
    fn get_ScanAhead(&self, out: *mut bool) -> HRESULT,
    fn put_ScanAhead(&self, value: bool) -> HRESULT
}}
impl IImageScannerFeederConfiguration {
    #[inline] pub fn get_can_auto_detect_page_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanAutoDetectPageSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_detect_page_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoDetectPageSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_detect_page_size(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoDetectPageSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_page_size(&self) -> Result<super::super::graphics::printing::PrintMediaSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PageSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_page_size(&self, value: super::super::graphics::printing::PrintMediaSize) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PageSize)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_page_orientation(&self) -> Result<super::super::graphics::printing::PrintOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PageOrientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_page_orientation(&self, value: super::super::graphics::printing::PrintOrientation) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PageOrientation)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size_dimensions(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PageSizeDimensions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_page_size_supported(&self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsPageSizeSupported)(self.0.as_abi() as *const _ as *mut _, pageSize, pageOrientation, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_number_of_pages(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxNumberOfPages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_number_of_pages(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxNumberOfPages)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_scan_duplex(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanScanDuplex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duplex(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Duplex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duplex(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Duplex)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_scan_ahead(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CanScanAhead)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_ahead(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScanAhead)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scan_ahead(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ScanAhead)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerFeederConfiguration: IImageScannerFormatConfiguration}
RT_CLASS!{class ImageScannerFlatbedConfiguration: IImageScannerFormatConfiguration}
RT_ENUM! { enum ImageScannerFormat: i32 {
    Jpeg = 0, Png = 1, DeviceIndependentBitmap = 2, Tiff = 3, Xps = 4, OpenXps = 5, Pdf = 6,
}}
DEFINE_IID!(IID_IImageScannerFormatConfiguration, 2921815313, 56031, 16400, 191, 16, 204, 165, 200, 61, 203, 176);
RT_INTERFACE!{interface IImageScannerFormatConfiguration(IImageScannerFormatConfigurationVtbl, IImageScannerFormatConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerFormatConfiguration] {
    fn get_DefaultFormat(&self, out: *mut ImageScannerFormat) -> HRESULT,
    fn get_Format(&self, out: *mut ImageScannerFormat) -> HRESULT,
    fn put_Format(&self, value: ImageScannerFormat) -> HRESULT,
    fn IsFormatSupported(&self, value: ImageScannerFormat, out: *mut bool) -> HRESULT
}}
impl IImageScannerFormatConfiguration {
    #[inline] pub fn get_default_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: ImageScannerFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Format)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_format_supported(&self, value: ImageScannerFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsFormatSupported)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageScannerPreviewResult, 146275982, 34961, 17437, 190, 156, 23, 111, 161, 9, 200, 187);
RT_INTERFACE!{interface IImageScannerPreviewResult(IImageScannerPreviewResultVtbl, IImageScannerPreviewResult_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerPreviewResult] {
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT,
    fn get_Format(&self, out: *mut ImageScannerFormat) -> HRESULT
}}
impl IImageScannerPreviewResult {
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Succeeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerPreviewResult: IImageScannerPreviewResult}
RT_STRUCT! { struct ImageScannerResolution {
    DpiX: f32, DpiY: f32,
}}
DEFINE_IID!(IID_IImageScannerScanResult, 3373671629, 36919, 20040, 132, 193, 172, 9, 117, 7, 107, 197);
RT_INTERFACE!{interface IImageScannerScanResult(IImageScannerScanResultVtbl, IImageScannerScanResult_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerScanResult] {
    #[cfg(feature="windows-storage")] fn get_ScannedFiles(&self, out: *mut <foundation::collections::IVectorView<super::super::storage::StorageFile> as RtType>::Abi) -> HRESULT
}}
impl IImageScannerScanResult {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scanned_files(&self) -> Result<Option<foundation::collections::IVectorView<super::super::storage::StorageFile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ScannedFiles)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerScanResult: IImageScannerScanResult}
RT_ENUM! { enum ImageScannerScanSource: i32 {
    Default = 0, Flatbed = 1, Feeder = 2, AutoConfigured = 3,
}}
DEFINE_IID!(IID_IImageScannerSourceConfiguration, 3216310357, 2884, 19586, 158, 137, 32, 95, 156, 35, 78, 89);
RT_INTERFACE!{interface IImageScannerSourceConfiguration(IImageScannerSourceConfigurationVtbl, IImageScannerSourceConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerSourceConfiguration] {
    fn get_MinScanArea(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MaxScanArea(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SelectedScanRegion(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_SelectedScanRegion(&self, value: foundation::Rect) -> HRESULT,
    fn get_AutoCroppingMode(&self, out: *mut ImageScannerAutoCroppingMode) -> HRESULT,
    fn put_AutoCroppingMode(&self, value: ImageScannerAutoCroppingMode) -> HRESULT,
    fn IsAutoCroppingModeSupported(&self, value: ImageScannerAutoCroppingMode, out: *mut bool) -> HRESULT,
    fn get_MinResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_MaxResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_OpticalResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_DesiredResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn put_DesiredResolution(&self, value: ImageScannerResolution) -> HRESULT,
    fn get_ActualResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_DefaultColorMode(&self, out: *mut ImageScannerColorMode) -> HRESULT,
    fn get_ColorMode(&self, out: *mut ImageScannerColorMode) -> HRESULT,
    fn put_ColorMode(&self, value: ImageScannerColorMode) -> HRESULT,
    fn IsColorModeSupported(&self, value: ImageScannerColorMode, out: *mut bool) -> HRESULT,
    fn get_MinBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_MaxBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_BrightnessStep(&self, out: *mut u32) -> HRESULT,
    fn get_DefaultBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_Brightness(&self, out: *mut i32) -> HRESULT,
    fn put_Brightness(&self, value: i32) -> HRESULT,
    fn get_MinContrast(&self, out: *mut i32) -> HRESULT,
    fn get_MaxContrast(&self, out: *mut i32) -> HRESULT,
    fn get_ContrastStep(&self, out: *mut u32) -> HRESULT,
    fn get_DefaultContrast(&self, out: *mut i32) -> HRESULT,
    fn get_Contrast(&self, out: *mut i32) -> HRESULT,
    fn put_Contrast(&self, value: i32) -> HRESULT
}}
impl IImageScannerSourceConfiguration {
    #[inline] pub fn get_min_scan_area(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinScanArea)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_scan_area(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxScanArea)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_scan_region(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedScanRegion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selected_scan_region(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SelectedScanRegion)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_cropping_mode(&self) -> Result<ImageScannerAutoCroppingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoCroppingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_cropping_mode(&self, value: ImageScannerAutoCroppingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoCroppingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_auto_cropping_mode_supported(&self, value: ImageScannerAutoCroppingMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsAutoCroppingModeSupported)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_optical_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OpticalResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DesiredResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_resolution(&self, value: ImageScannerResolution) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DesiredResolution)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActualResolution)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_color_mode(&self) -> Result<ImageScannerColorMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultColorMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_mode(&self) -> Result<ImageScannerColorMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ColorMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color_mode(&self, value: ImageScannerColorMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ColorMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_color_mode_supported(&self, value: ImageScannerColorMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsColorModeSupported)(self.0.as_abi() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinBrightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBrightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BrightnessStep)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultBrightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Brightness)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Brightness)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_min_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinContrast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxContrast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contrast_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContrastStep)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultContrast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Contrast)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_contrast(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Contrast)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageScannerStatics, 3159877390, 55300, 17527, 159, 181, 185, 17, 181, 71, 56, 151);
RT_INTERFACE!{static interface IImageScannerStatics(IImageScannerStaticsVtbl, IImageScannerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IImageScannerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<ImageScanner> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IImageScannerStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ImageScanner>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Scanners
pub mod sensors { // Windows.Devices.Sensors
use crate::prelude::*;
DEFINE_IID!(IID_IAccelerometer, 3742909768, 10001, 19879, 128, 152, 75, 130, 32, 93, 60, 125);
RT_INTERFACE!{interface IAccelerometer(IAccelerometerVtbl, IAccelerometer_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometer] {
    fn GetCurrentReading(&self, out: *mut <AccelerometerReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Shaken(&self, handler: <foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Shaken(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAccelerometer {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<AccelerometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AccelerometerReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_shaken(&self, handler: &foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_Shaken)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_shaken(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_Shaken)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Accelerometer: IAccelerometer}
impl RtActivatable<IAccelerometerStatics> for Accelerometer {}
impl RtActivatable<IAccelerometerStatics2> for Accelerometer {}
impl RtActivatable<IAccelerometerStatics3> for Accelerometer {}
impl Accelerometer {
    #[inline] pub fn get_default() -> Result<Option<Accelerometer>> {
        <Self as RtActivatable<IAccelerometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_with_accelerometer_reading_type(readingType: AccelerometerReadingType) -> Result<Option<Accelerometer>> {
        <Self as RtActivatable<IAccelerometerStatics2>>::get_activation_factory().get_default_with_accelerometer_reading_type(readingType)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Accelerometer>> {
        <Self as RtActivatable<IAccelerometerStatics3>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector(readingType: AccelerometerReadingType) -> Result<HString> {
        <Self as RtActivatable<IAccelerometerStatics3>>::get_activation_factory().get_device_selector(readingType)
    }
}
DEFINE_CLSID!(Accelerometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,99,101,108,101,114,111,109,101,116,101,114,0]) [CLSID_Accelerometer]);
DEFINE_IID!(IID_IAccelerometer2, 3908080366, 18788, 16410, 182, 2, 34, 13, 113, 83, 198, 10);
RT_INTERFACE!{interface IAccelerometer2(IAccelerometer2Vtbl, IAccelerometer2_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl IAccelerometer2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometer3, 2279604778, 60800, 18923, 191, 138, 164, 234, 49, 229, 205, 132);
RT_INTERFACE!{interface IAccelerometer3(IAccelerometer3Vtbl, IAccelerometer3_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IAccelerometer3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometer4, 490159183, 17107, 17842, 129, 68, 171, 127, 182, 101, 235, 89);
RT_INTERFACE!{interface IAccelerometer4(IAccelerometer4Vtbl, IAccelerometer4_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometer4] {
    fn get_ReadingType(&self, out: *mut AccelerometerReadingType) -> HRESULT
}}
impl IAccelerometer4 {
    #[inline] pub fn get_reading_type(&self) -> Result<AccelerometerReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerDeviceId, 2125227177, 38869, 17517, 171, 90, 145, 125, 249, 185, 106, 44);
RT_INTERFACE!{interface IAccelerometerDeviceId(IAccelerometerDeviceIdVtbl, IAccelerometerDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAccelerometerDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerReading, 3120462539, 54097, 16559, 139, 182, 122, 169, 174, 100, 31, 183);
RT_INTERFACE!{interface IAccelerometerReading(IAccelerometerReadingVtbl, IAccelerometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AccelerationX(&self, out: *mut f64) -> HRESULT,
    fn get_AccelerationY(&self, out: *mut f64) -> HRESULT,
    fn get_AccelerationZ(&self, out: *mut f64) -> HRESULT
}}
impl IAccelerometerReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccelerationX)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccelerationY)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_z(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccelerationZ)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerReading: IAccelerometerReading}
DEFINE_IID!(IID_IAccelerometerReading2, 176573090, 5550, 19008, 190, 85, 219, 88, 215, 222, 115, 137);
RT_INTERFACE!{interface IAccelerometerReading2(IAccelerometerReading2Vtbl, IAccelerometerReading2_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IAccelerometerReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerReadingChangedEventArgs, 9815643, 46764, 18266, 159, 68, 139, 50, 211, 90, 63, 37);
RT_INTERFACE!{interface IAccelerometerReadingChangedEventArgs(IAccelerometerReadingChangedEventArgsVtbl, IAccelerometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <AccelerometerReading as RtType>::Abi) -> HRESULT
}}
impl IAccelerometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<AccelerometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AccelerometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerReadingChangedEventArgs: IAccelerometerReadingChangedEventArgs}
RT_ENUM! { enum AccelerometerReadingType: i32 {
    Standard = 0, Linear = 1, Gravity = 2,
}}
DEFINE_IID!(IID_IAccelerometerShakenEventArgs, 2516517329, 18984, 20277, 152, 232, 129, 120, 170, 228, 8, 74);
RT_INTERFACE!{interface IAccelerometerShakenEventArgs(IAccelerometerShakenEventArgsVtbl, IAccelerometerShakenEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerShakenEventArgs] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IAccelerometerShakenEventArgs {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerShakenEventArgs: IAccelerometerShakenEventArgs}
DEFINE_IID!(IID_IAccelerometerStatics, 2783087476, 23175, 18989, 190, 204, 15, 144, 110, 160, 97, 221);
RT_INTERFACE!{static interface IAccelerometerStatics(IAccelerometerStaticsVtbl, IAccelerometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics] {
    fn GetDefault(&self, out: *mut <Accelerometer as RtType>::Abi) -> HRESULT
}}
impl IAccelerometerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Accelerometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Accelerometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerStatics2, 3301213231, 55403, 18053, 178, 215, 51, 150, 247, 152, 213, 123);
RT_INTERFACE!{static interface IAccelerometerStatics2(IAccelerometerStatics2Vtbl, IAccelerometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics2] {
    fn GetDefaultWithAccelerometerReadingType(&self, readingType: AccelerometerReadingType, out: *mut <Accelerometer as RtType>::Abi) -> HRESULT
}}
impl IAccelerometerStatics2 {
    #[inline] pub fn get_default_with_accelerometer_reading_type(&self, readingType: AccelerometerReadingType) -> Result<Option<Accelerometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultWithAccelerometerReadingType)(self.0.as_abi() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(Accelerometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerStatics3, 2648840399, 17757, 19699, 130, 0, 112, 225, 65, 3, 64, 248);
RT_INTERFACE!{static interface IAccelerometerStatics3(IAccelerometerStatics3Vtbl, IAccelerometerStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics3] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Accelerometer> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, readingType: AccelerometerReadingType, out: *mut HSTRING) -> HRESULT
}}
impl IAccelerometerStatics3 {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Accelerometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self, readingType: AccelerometerReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivitySensor, 3447350028, 64351, 18667, 176, 155, 162, 112, 141, 28, 97, 239);
RT_INTERFACE!{interface IActivitySensor(IActivitySensorVtbl, IActivitySensor_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensor] {
    fn GetCurrentReadingAsync(&self, out: *mut <foundation::IAsyncOperation<ActivitySensorReading> as RtType>::Abi) -> HRESULT,
    fn get_SubscribedActivities(&self, out: *mut <foundation::collections::IVector<ActivityType> as RtType>::Abi) -> HRESULT,
    fn get_PowerInMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedActivities(&self, out: *mut <foundation::collections::IVectorView<ActivityType> as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IActivitySensor {
    #[inline] pub fn get_current_reading_async(&self) -> Result<foundation::IAsyncOperation<ActivitySensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReadingAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subscribed_activities(&self) -> Result<Option<foundation::collections::IVector<ActivityType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubscribedActivities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_power_in_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerInMilliwatts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_activities(&self) -> Result<Option<foundation::collections::IVectorView<ActivityType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedActivities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensor: IActivitySensor}
impl RtActivatable<IActivitySensorStatics> for ActivitySensor {}
impl ActivitySensor {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<ActivitySensor>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ActivitySensor>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_system_history_async(fromTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_system_history_async(fromTime)
    }
    #[inline] pub fn get_system_history_with_duration_async(fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_system_history_with_duration_async(fromTime, duration)
    }
}
DEFINE_CLSID!(ActivitySensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,116,105,118,105,116,121,83,101,110,115,111,114,0]) [CLSID_ActivitySensor]);
DEFINE_IID!(IID_IActivitySensorReading, 2232572566, 5234, 16546, 178, 174, 225, 239, 41, 34, 108, 120);
RT_INTERFACE!{interface IActivitySensorReading(IActivitySensorReadingVtbl, IActivitySensorReading_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Activity(&self, out: *mut ActivityType) -> HRESULT,
    fn get_Confidence(&self, out: *mut ActivitySensorReadingConfidence) -> HRESULT
}}
impl IActivitySensorReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_activity(&self) -> Result<ActivityType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Activity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_confidence(&self) -> Result<ActivitySensorReadingConfidence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Confidence)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReading: IActivitySensorReading}
DEFINE_IID!(IID_IActivitySensorReadingChangedEventArgs, 3728238359, 44726, 20167, 148, 106, 217, 204, 25, 185, 81, 236);
RT_INTERFACE!{interface IActivitySensorReadingChangedEventArgs(IActivitySensorReadingChangedEventArgsVtbl, IActivitySensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <ActivitySensorReading as RtType>::Abi) -> HRESULT
}}
impl IActivitySensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<ActivitySensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ActivitySensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReadingChangedEventArgs: IActivitySensorReadingChangedEventArgs}
DEFINE_IID!(IID_IActivitySensorReadingChangeReport, 1329342741, 55611, 18365, 150, 10, 242, 15, 178, 243, 34, 185);
RT_INTERFACE!{interface IActivitySensorReadingChangeReport(IActivitySensorReadingChangeReportVtbl, IActivitySensorReadingChangeReport_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangeReport] {
    fn get_Reading(&self, out: *mut <ActivitySensorReading as RtType>::Abi) -> HRESULT
}}
impl IActivitySensorReadingChangeReport {
    #[inline] pub fn get_reading(&self) -> Result<Option<ActivitySensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ActivitySensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReadingChangeReport: IActivitySensorReadingChangeReport}
RT_ENUM! { enum ActivitySensorReadingConfidence: i32 {
    High = 0, Low = 1,
}}
DEFINE_IID!(IID_IActivitySensorStatics, 2803764893, 61067, 17873, 178, 91, 8, 204, 13, 249, 42, 182);
RT_INTERFACE!{static interface IActivitySensorStatics(IActivitySensorStaticsVtbl, IActivitySensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensorStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<ActivitySensor> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<ActivitySensor> as RtType>::Abi) -> HRESULT,
    fn GetSystemHistoryAsync(&self, fromTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>> as RtType>::Abi) -> HRESULT,
    fn GetSystemHistoryWithDurationAsync(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>> as RtType>::Abi) -> HRESULT
}}
impl IActivitySensorStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<ActivitySensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<ActivitySensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_async(&self, fromTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSystemHistoryAsync)(self.0.as_abi() as *const _ as *mut _, fromTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_with_duration_async(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSystemHistoryWithDurationAsync)(self.0.as_abi() as *const _ as *mut _, fromTime, duration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivitySensorTriggerDetails, 748578322, 47562, 18039, 178, 99, 36, 50, 151, 247, 157, 58);
RT_INTERFACE!{interface IActivitySensorTriggerDetails(IActivitySensorTriggerDetailsVtbl, IActivitySensorTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_IActivitySensorTriggerDetails] {
    fn ReadReports(&self, out: *mut <foundation::collections::IVectorView<ActivitySensorReadingChangeReport> as RtType>::Abi) -> HRESULT
}}
impl IActivitySensorTriggerDetails {
    #[inline] pub fn read_reports(&self) -> Result<Option<foundation::collections::IVectorView<ActivitySensorReadingChangeReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ReadReports)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorTriggerDetails: IActivitySensorTriggerDetails}
RT_ENUM! { enum ActivityType: i32 {
    Unknown = 0, Idle = 1, Stationary = 2, Fidgeting = 3, Walking = 4, Running = 5, InVehicle = 6, Biking = 7,
}}
DEFINE_IID!(IID_IAltimeter, 1928353789, 36612, 18929, 180, 167, 244, 227, 99, 183, 1, 162);
RT_INTERFACE!{interface IAltimeter(IAltimeterVtbl, IAltimeter_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeter] {
    fn GetCurrentReading(&self, out: *mut <AltimeterReading as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAltimeter {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<AltimeterReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AltimeterReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Altimeter: IAltimeter}
impl RtActivatable<IAltimeterStatics> for Altimeter {}
impl Altimeter {
    #[inline] pub fn get_default() -> Result<Option<Altimeter>> {
        <Self as RtActivatable<IAltimeterStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(Altimeter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,108,116,105,109,101,116,101,114,0]) [CLSID_Altimeter]);
DEFINE_IID!(IID_IAltimeter2, 3376880633, 10973, 18677, 159, 8, 61, 12, 118, 96, 217, 56);
RT_INTERFACE!{interface IAltimeter2(IAltimeter2Vtbl, IAltimeter2_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeter2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IAltimeter2 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAltimeterReading, 4226346867, 32606, 18632, 170, 26, 241, 243, 190, 252, 17, 68);
RT_INTERFACE!{interface IAltimeterReading(IAltimeterReadingVtbl, IAltimeterReading_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeterReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AltitudeChangeInMeters(&self, out: *mut f64) -> HRESULT
}}
impl IAltimeterReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_change_in_meters(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AltitudeChangeInMeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AltimeterReading: IAltimeterReading}
DEFINE_IID!(IID_IAltimeterReading2, 1413094361, 27915, 17074, 189, 105, 188, 143, 174, 15, 120, 44);
RT_INTERFACE!{interface IAltimeterReading2(IAltimeterReading2Vtbl, IAltimeterReading2_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeterReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IAltimeterReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAltimeterReadingChangedEventArgs, 1885982839, 17517, 18423, 153, 140, 235, 194, 59, 69, 228, 162);
RT_INTERFACE!{interface IAltimeterReadingChangedEventArgs(IAltimeterReadingChangedEventArgsVtbl, IAltimeterReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeterReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <AltimeterReading as RtType>::Abi) -> HRESULT
}}
impl IAltimeterReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<AltimeterReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(AltimeterReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AltimeterReadingChangedEventArgs: IAltimeterReadingChangedEventArgs}
DEFINE_IID!(IID_IAltimeterStatics, 2662651843, 58796, 18382, 142, 239, 211, 113, 129, 104, 192, 31);
RT_INTERFACE!{static interface IAltimeterStatics(IAltimeterStaticsVtbl, IAltimeterStatics_Abi): IInspectable(IInspectableVtbl) [IID_IAltimeterStatics] {
    fn GetDefault(&self, out: *mut <Altimeter as RtType>::Abi) -> HRESULT
}}
impl IAltimeterStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Altimeter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Altimeter::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometer, 2470737320, 30911, 17711, 176, 23, 240, 32, 156, 230, 218, 180);
RT_INTERFACE!{interface IBarometer(IBarometerVtbl, IBarometer_Abi): IInspectable(IInspectableVtbl) [IID_IBarometer] {
    fn GetCurrentReading(&self, out: *mut <BarometerReading as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IBarometer {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<BarometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarometerReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Barometer: IBarometer}
impl RtActivatable<IBarometerStatics> for Barometer {}
impl RtActivatable<IBarometerStatics2> for Barometer {}
impl Barometer {
    #[inline] pub fn get_default() -> Result<Option<Barometer>> {
        <Self as RtActivatable<IBarometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Barometer>> {
        <Self as RtActivatable<IBarometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBarometerStatics2>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Barometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,66,97,114,111,109,101,116,101,114,0]) [CLSID_Barometer]);
DEFINE_IID!(IID_IBarometer2, 851231768, 16107, 19716, 149, 116, 118, 51, 168, 120, 31, 159);
RT_INTERFACE!{interface IBarometer2(IBarometer2Vtbl, IBarometer2_Abi): IInspectable(IInspectableVtbl) [IID_IBarometer2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IBarometer2 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerReading, 4122596070, 7670, 18970, 167, 173, 50, 29, 79, 93, 178, 71);
RT_INTERFACE!{interface IBarometerReading(IBarometerReadingVtbl, IBarometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IBarometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_StationPressureInHectopascals(&self, out: *mut f64) -> HRESULT
}}
impl IBarometerReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_station_pressure_in_hectopascals(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StationPressureInHectopascals)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarometerReading: IBarometerReading}
DEFINE_IID!(IID_IBarometerReading2, 2242004203, 37061, 18549, 137, 28, 56, 101, 180, 195, 87, 231);
RT_INTERFACE!{interface IBarometerReading2(IBarometerReading2Vtbl, IBarometerReading2_Abi): IInspectable(IInspectableVtbl) [IID_IBarometerReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IBarometerReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerReadingChangedEventArgs, 1032098911, 891, 16463, 155, 187, 98, 50, 214, 149, 67, 195);
RT_INTERFACE!{interface IBarometerReadingChangedEventArgs(IBarometerReadingChangedEventArgsVtbl, IBarometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IBarometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <BarometerReading as RtType>::Abi) -> HRESULT
}}
impl IBarometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<BarometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(BarometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarometerReadingChangedEventArgs: IBarometerReadingChangedEventArgs}
DEFINE_IID!(IID_IBarometerStatics, 678110986, 739, 20358, 132, 252, 253, 216, 146, 181, 148, 15);
RT_INTERFACE!{static interface IBarometerStatics(IBarometerStaticsVtbl, IBarometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IBarometerStatics] {
    fn GetDefault(&self, out: *mut <Barometer as RtType>::Abi) -> HRESULT
}}
impl IBarometerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Barometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Barometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerStatics2, 2412163559, 38399, 17580, 135, 142, 214, 92, 131, 8, 195, 76);
RT_INTERFACE!{static interface IBarometerStatics2(IBarometerStatics2Vtbl, IBarometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IBarometerStatics2] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Barometer> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IBarometerStatics2 {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Barometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompass, 691010196, 6981, 16444, 186, 6, 177, 6, 219, 166, 154, 100);
RT_INTERFACE!{interface ICompass(ICompassVtbl, ICompass_Abi): IInspectable(IInspectableVtbl) [IID_ICompass] {
    fn GetCurrentReading(&self, out: *mut <CompassReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompass {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<CompassReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CompassReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Compass: ICompass}
impl RtActivatable<ICompassStatics> for Compass {}
impl RtActivatable<ICompassStatics2> for Compass {}
impl Compass {
    #[inline] pub fn get_default() -> Result<Option<Compass>> {
        <Self as RtActivatable<ICompassStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ICompassStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Compass>> {
        <Self as RtActivatable<ICompassStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Compass(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,111,109,112,97,115,115,0]) [CLSID_Compass]);
DEFINE_IID!(IID_ICompass2, 921857289, 51159, 17231, 180, 97, 151, 157, 223, 194, 50, 47);
RT_INTERFACE!{interface ICompass2(ICompass2Vtbl, ICompass2_Abi): IInspectable(IInspectableVtbl) [IID_ICompass2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ICompass2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompass3, 2753855515, 50666, 19781, 160, 236, 75, 121, 31, 4, 26, 137);
RT_INTERFACE!{interface ICompass3(ICompass3Vtbl, ICompass3_Abi): IInspectable(IInspectableVtbl) [IID_ICompass3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ICompass3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassDeviceId, 3514944041, 45189, 19229, 135, 10, 79, 245, 123, 167, 79, 212);
RT_INTERFACE!{interface ICompassDeviceId(ICompassDeviceIdVtbl, ICompassDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_ICompassDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICompassDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassReading, 2190545192, 20797, 19913, 183, 129, 94, 237, 251, 240, 45, 12);
RT_INTERFACE!{interface ICompassReading(ICompassReadingVtbl, ICompassReading_Abi): IInspectable(IInspectableVtbl) [IID_ICompassReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_HeadingMagneticNorth(&self, out: *mut f64) -> HRESULT,
    fn get_HeadingTrueNorth(&self, out: *mut <foundation::IReference<f64> as RtType>::Abi) -> HRESULT
}}
impl ICompassReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heading_magnetic_north(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeadingMagneticNorth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heading_true_north(&self) -> Result<Option<foundation::IReference<f64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeadingTrueNorth)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompassReading: ICompassReading}
DEFINE_IID!(IID_ICompassReading2, 2973394462, 20923, 18962, 190, 221, 173, 71, 255, 135, 210, 232);
RT_INTERFACE!{interface ICompassReading2(ICompassReading2Vtbl, ICompassReading2_Abi): IInspectable(IInspectableVtbl) [IID_ICompassReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl ICompassReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassReadingChangedEventArgs, 2400537008, 59580, 19582, 176, 9, 78, 65, 223, 19, 112, 114);
RT_INTERFACE!{interface ICompassReadingChangedEventArgs(ICompassReadingChangedEventArgsVtbl, ICompassReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICompassReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <CompassReading as RtType>::Abi) -> HRESULT
}}
impl ICompassReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<CompassReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CompassReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompassReadingChangedEventArgs: ICompassReadingChangedEventArgs}
DEFINE_IID!(IID_ICompassReadingHeadingAccuracy, 3881907534, 35089, 16631, 158, 22, 110, 204, 125, 174, 197, 222);
RT_INTERFACE!{interface ICompassReadingHeadingAccuracy(ICompassReadingHeadingAccuracyVtbl, ICompassReadingHeadingAccuracy_Abi): IInspectable(IInspectableVtbl) [IID_ICompassReadingHeadingAccuracy] {
    fn get_HeadingAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl ICompassReadingHeadingAccuracy {
    #[inline] pub fn get_heading_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_HeadingAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassStatics, 2596050911, 22252, 19493, 181, 77, 64, 166, 139, 181, 178, 105);
RT_INTERFACE!{static interface ICompassStatics(ICompassStaticsVtbl, ICompassStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICompassStatics] {
    fn GetDefault(&self, out: *mut <Compass as RtType>::Abi) -> HRESULT
}}
impl ICompassStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Compass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Compass::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassStatics2, 181276333, 15274, 18832, 156, 228, 190, 9, 19, 117, 78, 210);
RT_INTERFACE!{static interface ICompassStatics2(ICompassStatics2Vtbl, ICompassStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ICompassStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Compass> as RtType>::Abi) -> HRESULT
}}
impl ICompassStatics2 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Compass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometer, 4256803268, 33969, 19618, 151, 99, 155, 88, 149, 6, 199, 12);
RT_INTERFACE!{interface IGyrometer(IGyrometerVtbl, IGyrometer_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometer] {
    fn GetCurrentReading(&self, out: *mut <GyrometerReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGyrometer {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<GyrometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GyrometerReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Gyrometer: IGyrometer}
impl RtActivatable<IGyrometerStatics> for Gyrometer {}
impl RtActivatable<IGyrometerStatics2> for Gyrometer {}
impl Gyrometer {
    #[inline] pub fn get_default() -> Result<Option<Gyrometer>> {
        <Self as RtActivatable<IGyrometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IGyrometerStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Gyrometer>> {
        <Self as RtActivatable<IGyrometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Gyrometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,71,121,114,111,109,101,116,101,114,0]) [CLSID_Gyrometer]);
DEFINE_IID!(IID_IGyrometer2, 1675568195, 36072, 16835, 172, 68, 134, 152, 129, 11, 85, 127);
RT_INTERFACE!{interface IGyrometer2(IGyrometer2Vtbl, IGyrometer2_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl IGyrometer2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometer3, 1567590613, 36796, 17540, 145, 75, 82, 138, 223, 217, 71, 177);
RT_INTERFACE!{interface IGyrometer3(IGyrometer3Vtbl, IGyrometer3_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IGyrometer3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerDeviceId, 518383992, 35234, 17013, 158, 149, 113, 38, 244, 112, 135, 96);
RT_INTERFACE!{interface IGyrometerDeviceId(IGyrometerDeviceIdVtbl, IGyrometerDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IGyrometerDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerReading, 3017203292, 7908, 17775, 157, 231, 226, 73, 59, 92, 142, 3);
RT_INTERFACE!{interface IGyrometerReading(IGyrometerReadingVtbl, IGyrometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AngularVelocityX(&self, out: *mut f64) -> HRESULT,
    fn get_AngularVelocityY(&self, out: *mut f64) -> HRESULT,
    fn get_AngularVelocityZ(&self, out: *mut f64) -> HRESULT
}}
impl IGyrometerReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AngularVelocityX)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AngularVelocityY)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_z(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AngularVelocityZ)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GyrometerReading: IGyrometerReading}
DEFINE_IID!(IID_IGyrometerReading2, 380625212, 11145, 17595, 130, 43, 209, 225, 85, 111, 240, 155);
RT_INTERFACE!{interface IGyrometerReading2(IGyrometerReading2Vtbl, IGyrometerReading2_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IGyrometerReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerReadingChangedEventArgs, 266279061, 28574, 17102, 141, 88, 56, 140, 10, 184, 53, 109);
RT_INTERFACE!{interface IGyrometerReadingChangedEventArgs(IGyrometerReadingChangedEventArgsVtbl, IGyrometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <GyrometerReading as RtType>::Abi) -> HRESULT
}}
impl IGyrometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<GyrometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(GyrometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GyrometerReadingChangedEventArgs: IGyrometerReadingChangedEventArgs}
DEFINE_IID!(IID_IGyrometerStatics, 2209802185, 58525, 19257, 134, 230, 205, 85, 75, 228, 197, 193);
RT_INTERFACE!{static interface IGyrometerStatics(IGyrometerStaticsVtbl, IGyrometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerStatics] {
    fn GetDefault(&self, out: *mut <Gyrometer as RtType>::Abi) -> HRESULT
}}
impl IGyrometerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Gyrometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Gyrometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerStatics2, 4018403233, 55040, 16900, 150, 19, 121, 198, 177, 97, 223, 78);
RT_INTERFACE!{static interface IGyrometerStatics2(IGyrometerStatics2Vtbl, IGyrometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IGyrometerStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Gyrometer> as RtType>::Abi) -> HRESULT
}}
impl IGyrometerStatics2 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Gyrometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHingeAngleReading, 2748138937, 7153, 20325, 167, 4, 226, 218, 4, 241, 130, 192);
RT_INTERFACE!{interface IHingeAngleReading(IHingeAngleReadingVtbl, IHingeAngleReading_Abi): IInspectable(IInspectableVtbl) [IID_IHingeAngleReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AngleInDegrees(&self, out: *mut f64) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IHingeAngleReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angle_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AngleInDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleReading: IHingeAngleReading}
DEFINE_IID!(IID_IHingeAngleSensor, 3922968066, 49119, 17279, 140, 41, 136, 199, 115, 147, 211, 9);
RT_INTERFACE!{interface IHingeAngleSensor(IHingeAngleSensorVtbl, IHingeAngleSensor_Abi): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensor] {
    fn GetCurrentReadingAsync(&self, out: *mut <foundation::IAsyncOperation<HingeAngleReading> as RtType>::Abi) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinReportThresholdInDegrees(&self, out: *mut f64) -> HRESULT,
    fn get_ReportThresholdInDegrees(&self, out: *mut f64) -> HRESULT,
    fn put_ReportThresholdInDegrees(&self, value: f64) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IHingeAngleSensor {
    #[inline] pub fn get_current_reading_async(&self) -> Result<foundation::IAsyncOperation<HingeAngleReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReadingAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min_report_threshold_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinReportThresholdInDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_threshold_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportThresholdInDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_threshold_in_degrees(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportThresholdInDegrees)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleSensor: IHingeAngleSensor}
impl RtActivatable<IHingeAngleSensorStatics> for HingeAngleSensor {}
impl HingeAngleSensor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<HingeAngleSensor>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_related_to_adjacent_panels_async(firstPanelId: &HStringArg, secondPanelId: &HStringArg) -> Result<foundation::IAsyncOperation<HingeAngleSensor>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_related_to_adjacent_panels_async(firstPanelId, secondPanelId)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<HingeAngleSensor>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(HingeAngleSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,72,105,110,103,101,65,110,103,108,101,83,101,110,115,111,114,0]) [CLSID_HingeAngleSensor]);
DEFINE_IID!(IID_IHingeAngleSensorReadingChangedEventArgs, 618222987, 64208, 17080, 168, 84, 120, 146, 48, 73, 161, 186);
RT_INTERFACE!{interface IHingeAngleSensorReadingChangedEventArgs(IHingeAngleSensorReadingChangedEventArgsVtbl, IHingeAngleSensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <HingeAngleReading as RtType>::Abi) -> HRESULT
}}
impl IHingeAngleSensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<HingeAngleReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HingeAngleReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleSensorReadingChangedEventArgs: IHingeAngleSensorReadingChangedEventArgs}
DEFINE_IID!(IID_IHingeAngleSensorStatics, 3082172688, 64433, 16675, 137, 206, 78, 163, 78, 176, 223, 202);
RT_INTERFACE!{static interface IHingeAngleSensorStatics(IHingeAngleSensorStaticsVtbl, IHingeAngleSensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<HingeAngleSensor> as RtType>::Abi) -> HRESULT,
    fn GetRelatedToAdjacentPanelsAsync(&self, firstPanelId: HSTRING, secondPanelId: HSTRING, out: *mut <foundation::IAsyncOperation<HingeAngleSensor> as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<HingeAngleSensor> as RtType>::Abi) -> HRESULT
}}
impl IHingeAngleSensorStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<HingeAngleSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_related_to_adjacent_panels_async(&self, firstPanelId: &HStringArg, secondPanelId: &HStringArg) -> Result<foundation::IAsyncOperation<HingeAngleSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetRelatedToAdjacentPanelsAsync)(self.0.as_abi() as *const _ as *mut _, firstPanelId.get(), secondPanelId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<HingeAngleSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometer, 642304623, 8838, 16495, 145, 97, 240, 196, 189, 128, 110, 191);
RT_INTERFACE!{interface IInclinometer(IInclinometerVtbl, IInclinometer_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometer] {
    fn GetCurrentReading(&self, out: *mut <InclinometerReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IInclinometer {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<InclinometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(InclinometerReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Inclinometer: IInclinometer}
impl RtActivatable<IInclinometerStatics> for Inclinometer {}
impl RtActivatable<IInclinometerStatics2> for Inclinometer {}
impl RtActivatable<IInclinometerStatics3> for Inclinometer {}
impl RtActivatable<IInclinometerStatics4> for Inclinometer {}
impl Inclinometer {
    #[inline] pub fn get_default() -> Result<Option<Inclinometer>> {
        <Self as RtActivatable<IInclinometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_for_relative_readings() -> Result<Option<Inclinometer>> {
        <Self as RtActivatable<IInclinometerStatics2>>::get_activation_factory().get_default_for_relative_readings()
    }
    #[inline] pub fn get_default_with_sensor_reading_type(sensorReadingtype: SensorReadingType) -> Result<Option<Inclinometer>> {
        <Self as RtActivatable<IInclinometerStatics3>>::get_activation_factory().get_default_with_sensor_reading_type(sensorReadingtype)
    }
    #[inline] pub fn get_device_selector(readingType: SensorReadingType) -> Result<HString> {
        <Self as RtActivatable<IInclinometerStatics4>>::get_activation_factory().get_device_selector(readingType)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Inclinometer>> {
        <Self as RtActivatable<IInclinometerStatics4>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Inclinometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,73,110,99,108,105,110,111,109,101,116,101,114,0]) [CLSID_Inclinometer]);
DEFINE_IID!(IID_IInclinometer2, 43987859, 10418, 17912, 187, 22, 97, 232, 106, 127, 174, 110);
RT_INTERFACE!{interface IInclinometer2(IInclinometer2Vtbl, IInclinometer2_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometer2] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT,
    fn get_ReadingType(&self, out: *mut SensorReadingType) -> HRESULT
}}
impl IInclinometer2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reading_type(&self) -> Result<SensorReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometer3, 973688836, 55141, 17284, 163, 215, 2, 131, 243, 171, 230, 174);
RT_INTERFACE!{interface IInclinometer3(IInclinometer3Vtbl, IInclinometer3_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IInclinometer3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerDeviceId, 32053634, 16895, 17414, 174, 131, 98, 33, 15, 241, 111, 227);
RT_INTERFACE!{interface IInclinometerDeviceId(IInclinometerDeviceIdVtbl, IInclinometerDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInclinometerDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerReading, 2672095317, 46838, 18815, 177, 39, 26, 119, 94, 80, 20, 88);
RT_INTERFACE!{interface IInclinometerReading(IInclinometerReadingVtbl, IInclinometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PitchDegrees(&self, out: *mut f32) -> HRESULT,
    fn get_RollDegrees(&self, out: *mut f32) -> HRESULT,
    fn get_YawDegrees(&self, out: *mut f32) -> HRESULT
}}
impl IInclinometerReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pitch_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PitchDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_roll_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RollDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_yaw_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_YawDegrees)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InclinometerReading: IInclinometerReading}
DEFINE_IID!(IID_IInclinometerReading2, 1326860161, 59659, 18008, 137, 21, 1, 3, 224, 138, 128, 90);
RT_INTERFACE!{interface IInclinometerReading2(IInclinometerReading2Vtbl, IInclinometerReading2_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IInclinometerReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerReadingChangedEventArgs, 1256791489, 59371, 18744, 133, 17, 174, 13, 107, 68, 4, 56);
RT_INTERFACE!{interface IInclinometerReadingChangedEventArgs(IInclinometerReadingChangedEventArgsVtbl, IInclinometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <InclinometerReading as RtType>::Abi) -> HRESULT
}}
impl IInclinometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<InclinometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(InclinometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InclinometerReadingChangedEventArgs: IInclinometerReadingChangedEventArgs}
DEFINE_IID!(IID_IInclinometerReadingYawAccuracy, 3025397888, 8163, 18822, 162, 87, 230, 236, 226, 114, 57, 73);
RT_INTERFACE!{interface IInclinometerReadingYawAccuracy(IInclinometerReadingYawAccuracyVtbl, IInclinometerReadingYawAccuracy_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingYawAccuracy] {
    fn get_YawAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl IInclinometerReadingYawAccuracy {
    #[inline] pub fn get_yaw_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_YawAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics, 4063151441, 39984, 17722, 139, 73, 60, 62, 235, 51, 203, 97);
RT_INTERFACE!{static interface IInclinometerStatics(IInclinometerStaticsVtbl, IInclinometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics] {
    fn GetDefault(&self, out: *mut <Inclinometer as RtType>::Abi) -> HRESULT
}}
impl IInclinometerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Inclinometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Inclinometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics2, 71276405, 27166, 18844, 134, 224, 99, 140, 26, 134, 75, 0);
RT_INTERFACE!{static interface IInclinometerStatics2(IInclinometerStatics2Vtbl, IInclinometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics2] {
    fn GetDefaultForRelativeReadings(&self, out: *mut <Inclinometer as RtType>::Abi) -> HRESULT
}}
impl IInclinometerStatics2 {
    #[inline] pub fn get_default_for_relative_readings(&self) -> Result<Option<Inclinometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultForRelativeReadings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Inclinometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics3, 3181003392, 47386, 18473, 147, 146, 171, 192, 182, 189, 242, 180);
RT_INTERFACE!{static interface IInclinometerStatics3(IInclinometerStatics3Vtbl, IInclinometerStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics3] {
    fn GetDefaultWithSensorReadingType(&self, sensorReadingtype: SensorReadingType, out: *mut <Inclinometer as RtType>::Abi) -> HRESULT
}}
impl IInclinometerStatics3 {
    #[inline] pub fn get_default_with_sensor_reading_type(&self, sensorReadingtype: SensorReadingType) -> Result<Option<Inclinometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultWithSensorReadingType)(self.0.as_abi() as *const _ as *mut _, sensorReadingtype, &mut out);
        if hr == S_OK { Ok(Inclinometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics4, 3904542457, 28293, 19075, 174, 208, 215, 205, 204, 152, 86, 200);
RT_INTERFACE!{static interface IInclinometerStatics4(IInclinometerStatics4Vtbl, IInclinometerStatics4_Abi): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics4] {
    fn GetDeviceSelector(&self, readingType: SensorReadingType, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Inclinometer> as RtType>::Abi) -> HRESULT
}}
impl IInclinometerStatics4 {
    #[inline] pub fn get_device_selector(&self, readingType: SensorReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Inclinometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensor, 4165732120, 3156, 18350, 146, 46, 120, 159, 87, 251, 3, 160);
RT_INTERFACE!{interface ILightSensor(ILightSensorVtbl, ILightSensor_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensor] {
    fn GetCurrentReading(&self, out: *mut <LightSensorReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ILightSensor {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<LightSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LightSensorReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensor: ILightSensor}
impl RtActivatable<ILightSensorStatics> for LightSensor {}
impl RtActivatable<ILightSensorStatics2> for LightSensor {}
impl LightSensor {
    #[inline] pub fn get_default() -> Result<Option<LightSensor>> {
        <Self as RtActivatable<ILightSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILightSensorStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LightSensor>> {
        <Self as RtActivatable<ILightSensorStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(LightSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,76,105,103,104,116,83,101,110,115,111,114,0]) [CLSID_LightSensor]);
DEFINE_IID!(IID_ILightSensor2, 1214981352, 43340, 16528, 143, 72, 9, 247, 130, 169, 247, 213);
RT_INTERFACE!{interface ILightSensor2(ILightSensor2Vtbl, ILightSensor2_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensor2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ILightSensor2 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorDeviceId, 2146322936, 2811, 20305, 135, 240, 108, 38, 55, 92, 233, 79);
RT_INTERFACE!{interface ILightSensorDeviceId(ILightSensorDeviceIdVtbl, ILightSensorDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ILightSensorDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorReading, 4292829952, 8828, 19755, 179, 2, 252, 1, 66, 72, 92, 104);
RT_INTERFACE!{interface ILightSensorReading(ILightSensorReadingVtbl, ILightSensorReading_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IlluminanceInLux(&self, out: *mut f32) -> HRESULT
}}
impl ILightSensorReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_illuminance_in_lux(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IlluminanceInLux)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensorReading: ILightSensorReading}
DEFINE_IID!(IID_ILightSensorReading2, 3075547525, 17571, 17609, 129, 144, 158, 246, 222, 10, 138, 116);
RT_INTERFACE!{interface ILightSensorReading2(ILightSensorReading2Vtbl, ILightSensorReading2_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl ILightSensorReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorReadingChangedEventArgs, 2745365711, 9611, 16908, 184, 171, 142, 221, 96, 30, 207, 80);
RT_INTERFACE!{interface ILightSensorReadingChangedEventArgs(ILightSensorReadingChangedEventArgsVtbl, ILightSensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <LightSensorReading as RtType>::Abi) -> HRESULT
}}
impl ILightSensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<LightSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LightSensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensorReadingChangedEventArgs: ILightSensorReadingChangedEventArgs}
DEFINE_IID!(IID_ILightSensorStatics, 1172016260, 50088, 18206, 154, 83, 100, 87, 250, 216, 124, 14);
RT_INTERFACE!{static interface ILightSensorStatics(ILightSensorStaticsVtbl, ILightSensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorStatics] {
    fn GetDefault(&self, out: *mut <LightSensor as RtType>::Abi) -> HRESULT
}}
impl ILightSensorStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<LightSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(LightSensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorStatics2, 247506512, 56774, 16555, 172, 227, 236, 51, 89, 212, 44, 81);
RT_INTERFACE!{static interface ILightSensorStatics2(ILightSensorStatics2Vtbl, ILightSensorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ILightSensorStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<LightSensor> as RtType>::Abi) -> HRESULT
}}
impl ILightSensorStatics2 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<LightSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometer, 1213162094, 54217, 16657, 179, 246, 44, 241, 250, 164, 24, 213);
RT_INTERFACE!{interface IMagnetometer(IMagnetometerVtbl, IMagnetometer_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometer] {
    fn GetCurrentReading(&self, out: *mut <MagnetometerReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IMagnetometer {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<MagnetometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagnetometerReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Magnetometer: IMagnetometer}
impl RtActivatable<IMagnetometerStatics> for Magnetometer {}
impl RtActivatable<IMagnetometerStatics2> for Magnetometer {}
impl Magnetometer {
    #[inline] pub fn get_default() -> Result<Option<Magnetometer>> {
        <Self as RtActivatable<IMagnetometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMagnetometerStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Magnetometer>> {
        <Self as RtActivatable<IMagnetometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Magnetometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,77,97,103,110,101,116,111,109,101,116,101,114,0]) [CLSID_Magnetometer]);
DEFINE_IID!(IID_IMagnetometer2, 3026545797, 9974, 17483, 169, 226, 162, 63, 150, 108, 211, 104);
RT_INTERFACE!{interface IMagnetometer2(IMagnetometer2Vtbl, IMagnetometer2_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl IMagnetometer2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometer3, 3197361020, 42533, 18671, 172, 247, 250, 193, 4, 131, 38, 113);
RT_INTERFACE!{interface IMagnetometer3(IMagnetometer3Vtbl, IMagnetometer3_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IMagnetometer3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum MagnetometerAccuracy: i32 {
    Unknown = 0, Unreliable = 1, Approximate = 2, High = 3,
}}
DEFINE_IID!(IID_IMagnetometerDeviceId, 1488230594, 32331, 16460, 159, 197, 93, 232, 180, 14, 186, 227);
RT_INTERFACE!{interface IMagnetometerDeviceId(IMagnetometerDeviceIdVtbl, IMagnetometerDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IMagnetometerDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerReading, 204260365, 60413, 20060, 187, 17, 175, 194, 155, 60, 174, 97);
RT_INTERFACE!{interface IMagnetometerReading(IMagnetometerReadingVtbl, IMagnetometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_MagneticFieldX(&self, out: *mut f32) -> HRESULT,
    fn get_MagneticFieldY(&self, out: *mut f32) -> HRESULT,
    fn get_MagneticFieldZ(&self, out: *mut f32) -> HRESULT,
    fn get_DirectionalAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl IMagnetometerReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MagneticFieldX)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MagneticFieldY)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_z(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MagneticFieldZ)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_directional_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DirectionalAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagnetometerReading: IMagnetometerReading}
DEFINE_IID!(IID_IMagnetometerReading2, 3569966177, 25049, 16459, 163, 40, 6, 111, 23, 122, 20, 9);
RT_INTERFACE!{interface IMagnetometerReading2(IMagnetometerReading2Vtbl, IMagnetometerReading2_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IMagnetometerReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerReadingChangedEventArgs, 401270898, 11961, 20199, 138, 208, 49, 39, 83, 125, 148, 155);
RT_INTERFACE!{interface IMagnetometerReadingChangedEventArgs(IMagnetometerReadingChangedEventArgsVtbl, IMagnetometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <MagnetometerReading as RtType>::Abi) -> HRESULT
}}
impl IMagnetometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<MagnetometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(MagnetometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagnetometerReadingChangedEventArgs: IMagnetometerReadingChangedEventArgs}
DEFINE_IID!(IID_IMagnetometerStatics, 2235327692, 1688, 19930, 166, 223, 156, 185, 204, 74, 180, 10);
RT_INTERFACE!{static interface IMagnetometerStatics(IMagnetometerStaticsVtbl, IMagnetometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerStatics] {
    fn GetDefault(&self, out: *mut <Magnetometer as RtType>::Abi) -> HRESULT
}}
impl IMagnetometerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<Magnetometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(Magnetometer::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerStatics2, 738728432, 65478, 20361, 160, 111, 24, 250, 16, 121, 41, 51);
RT_INTERFACE!{static interface IMagnetometerStatics2(IMagnetometerStatics2Vtbl, IMagnetometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IMagnetometerStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Magnetometer> as RtType>::Abi) -> HRESULT
}}
impl IMagnetometerStatics2 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Magnetometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensor, 1580549685, 53099, 19555, 171, 216, 16, 37, 43, 11, 246, 236);
RT_INTERFACE!{interface IOrientationSensor(IOrientationSensorVtbl, IOrientationSensor_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensor] {
    fn GetCurrentReading(&self, out: *mut <OrientationSensorReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IOrientationSensor {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<OrientationSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OrientationSensorReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensor: IOrientationSensor}
impl RtActivatable<IOrientationSensorStatics> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics2> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics3> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics4> for OrientationSensor {}
impl OrientationSensor {
    #[inline] pub fn get_default() -> Result<Option<OrientationSensor>> {
        <Self as RtActivatable<IOrientationSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_for_relative_readings() -> Result<Option<OrientationSensor>> {
        <Self as RtActivatable<IOrientationSensorStatics2>>::get_activation_factory().get_default_for_relative_readings()
    }
    #[inline] pub fn get_default_with_sensor_reading_type(sensorReadingtype: SensorReadingType) -> Result<Option<OrientationSensor>> {
        <Self as RtActivatable<IOrientationSensorStatics3>>::get_activation_factory().get_default_with_sensor_reading_type(sensorReadingtype)
    }
    #[inline] pub fn get_default_with_sensor_reading_type_and_sensor_optimization_goal(sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<Option<OrientationSensor>> {
        <Self as RtActivatable<IOrientationSensorStatics3>>::get_activation_factory().get_default_with_sensor_reading_type_and_sensor_optimization_goal(sensorReadingType, optimizationGoal)
    }
    #[inline] pub fn get_device_selector(readingType: SensorReadingType) -> Result<HString> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().get_device_selector(readingType)
    }
    #[inline] pub fn get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<HString> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(readingType, optimizationGoal)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<OrientationSensor>> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(OrientationSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]) [CLSID_OrientationSensor]);
DEFINE_IID!(IID_IOrientationSensor2, 227691769, 12063, 18889, 128, 66, 74, 24, 19, 214, 119, 96);
RT_INTERFACE!{interface IOrientationSensor2(IOrientationSensor2Vtbl, IOrientationSensor2_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensor2] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT,
    fn get_ReadingType(&self, out: *mut SensorReadingType) -> HRESULT
}}
impl IOrientationSensor2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reading_type(&self) -> Result<SensorReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensor3, 751720333, 25707, 18629, 183, 238, 68, 253, 196, 198, 170, 253);
RT_INTERFACE!{interface IOrientationSensor3(IOrientationSensor3Vtbl, IOrientationSensor3_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensor3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl IOrientationSensor3 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorDeviceId, 1516877384, 19497, 18924, 178, 143, 234, 29, 17, 123, 102, 240);
RT_INTERFACE!{interface IOrientationSensorDeviceId(IOrientationSensorDeviceIdVtbl, IOrientationSensorDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOrientationSensorDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorReading, 1196870035, 26005, 18583, 188, 198, 213, 55, 238, 117, 117, 100);
RT_INTERFACE!{interface IOrientationSensorReading(IOrientationSensorReadingVtbl, IOrientationSensorReading_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_RotationMatrix(&self, out: *mut <SensorRotationMatrix as RtType>::Abi) -> HRESULT,
    fn get_Quaternion(&self, out: *mut <SensorQuaternion as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_matrix(&self) -> Result<Option<SensorRotationMatrix>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RotationMatrix)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SensorRotationMatrix::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_quaternion(&self) -> Result<Option<SensorQuaternion>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Quaternion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SensorQuaternion::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensorReading: IOrientationSensorReading}
DEFINE_IID!(IID_IOrientationSensorReading2, 5729887, 18936, 19461, 158, 7, 36, 250, 199, 148, 8, 195);
RT_INTERFACE!{interface IOrientationSensorReading2(IOrientationSensorReading2Vtbl, IOrientationSensorReading2_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorReadingChangedEventArgs, 19665286, 50106, 18108, 174, 101, 122, 152, 153, 108, 191, 184);
RT_INTERFACE!{interface IOrientationSensorReadingChangedEventArgs(IOrientationSensorReadingChangedEventArgsVtbl, IOrientationSensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <OrientationSensorReading as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<OrientationSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OrientationSensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensorReadingChangedEventArgs: IOrientationSensorReadingChangedEventArgs}
DEFINE_IID!(IID_IOrientationSensorReadingYawAccuracy, 3517749284, 16218, 18850, 188, 123, 17, 128, 188, 56, 205, 43);
RT_INTERFACE!{interface IOrientationSensorReadingYawAccuracy(IOrientationSensorReadingYawAccuracyVtbl, IOrientationSensorReadingYawAccuracy_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingYawAccuracy] {
    fn get_YawAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl IOrientationSensorReadingYawAccuracy {
    #[inline] pub fn get_yaw_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_YawAccuracy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics, 284133138, 64332, 17034, 137, 139, 39, 101, 228, 9, 230, 105);
RT_INTERFACE!{static interface IOrientationSensorStatics(IOrientationSensorStaticsVtbl, IOrientationSensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics] {
    fn GetDefault(&self, out: *mut <OrientationSensor as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<OrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OrientationSensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics2, 1507462411, 54282, 19569, 146, 118, 138, 39, 42, 10, 102, 25);
RT_INTERFACE!{static interface IOrientationSensorStatics2(IOrientationSensorStatics2Vtbl, IOrientationSensorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics2] {
    fn GetDefaultForRelativeReadings(&self, out: *mut <OrientationSensor as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorStatics2 {
    #[inline] pub fn get_default_for_relative_readings(&self) -> Result<Option<OrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultForRelativeReadings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(OrientationSensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics3, 3626821920, 10103, 16639, 159, 89, 214, 84, 176, 133, 241, 47);
RT_INTERFACE!{static interface IOrientationSensorStatics3(IOrientationSensorStatics3Vtbl, IOrientationSensorStatics3_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics3] {
    fn GetDefaultWithSensorReadingType(&self, sensorReadingtype: SensorReadingType, out: *mut <OrientationSensor as RtType>::Abi) -> HRESULT,
    fn GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(&self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal, out: *mut <OrientationSensor as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorStatics3 {
    #[inline] pub fn get_default_with_sensor_reading_type(&self, sensorReadingtype: SensorReadingType) -> Result<Option<OrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultWithSensorReadingType)(self.0.as_abi() as *const _ as *mut _, sensorReadingtype, &mut out);
        if hr == S_OK { Ok(OrientationSensor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_with_sensor_reading_type_and_sensor_optimization_goal(&self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<Option<OrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal)(self.0.as_abi() as *const _ as *mut _, sensorReadingType, optimizationGoal, &mut out);
        if hr == S_OK { Ok(OrientationSensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics4, 2793401173, 11397, 19240, 160, 254, 88, 196, 178, 4, 149, 245);
RT_INTERFACE!{static interface IOrientationSensorStatics4(IOrientationSensorStatics4Vtbl, IOrientationSensorStatics4_Abi): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics4] {
    fn GetDeviceSelector(&self, readingType: SensorReadingType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal(&self, readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<OrientationSensor> as RtType>::Abi) -> HRESULT
}}
impl IOrientationSensorStatics4 {
    #[inline] pub fn get_device_selector(&self, readingType: SensorReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(&self, readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal)(self.0.as_abi() as *const _ as *mut _, readingType, optimizationGoal, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<OrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometer, 2585657661, 15768, 17912, 137, 32, 142, 78, 202, 202, 95, 151);
RT_INTERFACE!{interface IPedometer(IPedometerVtbl, IPedometer_Abi): IInspectable(IInspectableVtbl) [IID_IPedometer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PowerInMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IPedometer {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_power_in_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PowerInMilliwatts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Pedometer: IPedometer}
impl RtActivatable<IPedometerStatics> for Pedometer {}
impl RtActivatable<IPedometerStatics2> for Pedometer {}
impl Pedometer {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Pedometer>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<Pedometer>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_system_history_async(fromTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_system_history_async(fromTime)
    }
    #[inline] pub fn get_system_history_with_duration_async(fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_system_history_with_duration_async(fromTime, duration)
    }
    #[inline] pub fn get_readings_from_trigger_details(triggerDetails: &SensorDataThresholdTriggerDetails) -> Result<Option<foundation::collections::IVectorView<PedometerReading>>> {
        <Self as RtActivatable<IPedometerStatics2>>::get_activation_factory().get_readings_from_trigger_details(triggerDetails)
    }
}
DEFINE_CLSID!(Pedometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,0]) [CLSID_Pedometer]);
DEFINE_IID!(IID_IPedometer2, 3852732127, 11137, 19165, 178, 255, 119, 171, 108, 152, 186, 25);
RT_INTERFACE!{interface IPedometer2(IPedometer2Vtbl, IPedometer2_Abi): IInspectable(IInspectableVtbl) [IID_IPedometer2] {
    fn GetCurrentReadings(&self, out: *mut <foundation::collections::IMapView<PedometerStepKind, PedometerReading> as RtType>::Abi) -> HRESULT
}}
impl IPedometer2 {
    #[inline] pub fn get_current_readings(&self) -> Result<Option<foundation::collections::IMapView<PedometerStepKind, PedometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReadings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerDataThreshold: ISensorDataThreshold}
impl RtActivatable<IPedometerDataThresholdFactory> for PedometerDataThreshold {}
impl PedometerDataThreshold {
    #[inline] pub fn create(sensor: &Pedometer, stepGoal: i32) -> Result<PedometerDataThreshold> {
        <Self as RtActivatable<IPedometerDataThresholdFactory>>::get_activation_factory().create(sensor, stepGoal)
    }
}
DEFINE_CLSID!(PedometerDataThreshold(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]) [CLSID_PedometerDataThreshold]);
DEFINE_IID!(IID_IPedometerDataThresholdFactory, 3417149264, 31316, 18027, 144, 16, 119, 161, 98, 252, 165, 215);
RT_INTERFACE!{static interface IPedometerDataThresholdFactory(IPedometerDataThresholdFactoryVtbl, IPedometerDataThresholdFactory_Abi): IInspectable(IInspectableVtbl) [IID_IPedometerDataThresholdFactory] {
    fn Create(&self, sensor: <Pedometer as RtType>::Abi, stepGoal: i32, out: *mut <PedometerDataThreshold as RtType>::Abi) -> HRESULT
}}
impl IPedometerDataThresholdFactory {
    #[inline] pub fn create(&self, sensor: &Pedometer, stepGoal: i32) -> Result<PedometerDataThreshold> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(sensor) as *const _ as *mut _, stepGoal, &mut out);
        if hr == S_OK { Ok(PedometerDataThreshold::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometerReading, 575003892, 43233, 17199, 137, 106, 190, 13, 217, 176, 45, 36);
RT_INTERFACE!{interface IPedometerReading(IPedometerReadingVtbl, IPedometerReading_Abi): IInspectable(IInspectableVtbl) [IID_IPedometerReading] {
    fn get_StepKind(&self, out: *mut PedometerStepKind) -> HRESULT,
    fn get_CumulativeSteps(&self, out: *mut i32) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_CumulativeStepsDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl IPedometerReading {
    #[inline] pub fn get_step_kind(&self) -> Result<PedometerStepKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StepKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative_steps(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CumulativeSteps)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative_steps_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CumulativeStepsDuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerReading: IPedometerReading}
DEFINE_IID!(IID_IPedometerReadingChangedEventArgs, 4166378622, 43964, 17494, 134, 168, 37, 207, 43, 51, 55, 66);
RT_INTERFACE!{interface IPedometerReadingChangedEventArgs(IPedometerReadingChangedEventArgsVtbl, IPedometerReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPedometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <PedometerReading as RtType>::Abi) -> HRESULT
}}
impl IPedometerReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<PedometerReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(PedometerReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerReadingChangedEventArgs: IPedometerReadingChangedEventArgs}
DEFINE_IID!(IID_IPedometerStatics, 2191002159, 16515, 19963, 180, 17, 147, 142, 160, 244, 185, 70);
RT_INTERFACE!{static interface IPedometerStatics(IPedometerStaticsVtbl, IPedometerStatics_Abi): IInspectable(IInspectableVtbl) [IID_IPedometerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<Pedometer> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<Pedometer> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetSystemHistoryAsync(&self, fromTime: foundation::DateTime, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>> as RtType>::Abi) -> HRESULT,
    fn GetSystemHistoryWithDurationAsync(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>> as RtType>::Abi) -> HRESULT
}}
impl IPedometerStatics {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<Pedometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<Pedometer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_async(&self, fromTime: foundation::DateTime) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSystemHistoryAsync)(self.0.as_abi() as *const _ as *mut _, fromTime, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_with_duration_async(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSystemHistoryWithDurationAsync)(self.0.as_abi() as *const _ as *mut _, fromTime, duration, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometerStatics2, 2046150331, 52750, 16691, 180, 126, 134, 39, 234, 114, 246, 119);
RT_INTERFACE!{static interface IPedometerStatics2(IPedometerStatics2Vtbl, IPedometerStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IPedometerStatics2] {
    fn GetReadingsFromTriggerDetails(&self, triggerDetails: <SensorDataThresholdTriggerDetails as RtType>::Abi, out: *mut <foundation::collections::IVectorView<PedometerReading> as RtType>::Abi) -> HRESULT
}}
impl IPedometerStatics2 {
    #[inline] pub fn get_readings_from_trigger_details(&self, triggerDetails: &SensorDataThresholdTriggerDetails) -> Result<Option<foundation::collections::IVectorView<PedometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetReadingsFromTriggerDetails)(self.0.as_abi() as *const _ as *mut _, get_abi(triggerDetails) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PedometerStepKind: i32 {
    Unknown = 0, Walking = 1, Running = 2,
}}
DEFINE_IID!(IID_IProximitySensor, 1421899448, 60667, 18756, 185, 40, 116, 252, 80, 77, 71, 238);
RT_INTERFACE!{interface IProximitySensor(IProximitySensorVtbl, IProximitySensor_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensor] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxDistanceInMillimeters(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_MinDistanceInMillimeters(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn GetCurrentReading(&self, out: *mut <ProximitySensorReading as RtType>::Abi) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn CreateDisplayOnOffController(&self, out: *mut <ProximitySensorDisplayOnOffController as RtType>::Abi) -> HRESULT
}}
impl IProximitySensor {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_distance_in_millimeters(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxDistanceInMillimeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min_distance_in_millimeters(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinDistanceInMillimeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ProximitySensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ProximitySensorReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_display_on_off_controller(&self) -> Result<Option<ProximitySensorDisplayOnOffController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateDisplayOnOffController)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ProximitySensorDisplayOnOffController::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensor: IProximitySensor}
impl RtActivatable<IProximitySensorStatics> for ProximitySensor {}
impl RtActivatable<IProximitySensorStatics2> for ProximitySensor {}
impl ProximitySensor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IProximitySensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id(sensorId: &HStringArg) -> Result<Option<ProximitySensor>> {
        <Self as RtActivatable<IProximitySensorStatics>>::get_activation_factory().from_id(sensorId)
    }
    #[inline] pub fn get_readings_from_trigger_details(triggerDetails: &SensorDataThresholdTriggerDetails) -> Result<Option<foundation::collections::IVectorView<ProximitySensorReading>>> {
        <Self as RtActivatable<IProximitySensorStatics2>>::get_activation_factory().get_readings_from_trigger_details(triggerDetails)
    }
}
DEFINE_CLSID!(ProximitySensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,0]) [CLSID_ProximitySensor]);
RT_CLASS!{class ProximitySensorDataThreshold: ISensorDataThreshold}
impl RtActivatable<IProximitySensorDataThresholdFactory> for ProximitySensorDataThreshold {}
impl ProximitySensorDataThreshold {
    #[inline] pub fn create(sensor: &ProximitySensor) -> Result<ProximitySensorDataThreshold> {
        <Self as RtActivatable<IProximitySensorDataThresholdFactory>>::get_activation_factory().create(sensor)
    }
}
DEFINE_CLSID!(ProximitySensorDataThreshold(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]) [CLSID_ProximitySensorDataThreshold]);
DEFINE_IID!(IID_IProximitySensorDataThresholdFactory, 2421866785, 27943, 19155, 157, 181, 100, 103, 242, 165, 173, 157);
RT_INTERFACE!{static interface IProximitySensorDataThresholdFactory(IProximitySensorDataThresholdFactoryVtbl, IProximitySensorDataThresholdFactory_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensorDataThresholdFactory] {
    fn Create(&self, sensor: <ProximitySensor as RtType>::Abi, out: *mut <ProximitySensorDataThreshold as RtType>::Abi) -> HRESULT
}}
impl IProximitySensorDataThresholdFactory {
    #[inline] pub fn create(&self, sensor: &ProximitySensor) -> Result<ProximitySensorDataThreshold> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(sensor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ProximitySensorDataThreshold::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorDisplayOnOffController: foundation::IClosable}
DEFINE_IID!(IID_IProximitySensorReading, 1898089817, 4909, 19807, 143, 249, 47, 13, 184, 117, 28, 237);
RT_INTERFACE!{interface IProximitySensorReading(IProximitySensorReadingVtbl, IProximitySensorReading_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IsDetected(&self, out: *mut bool) -> HRESULT,
    fn get_DistanceInMillimeters(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl IProximitySensorReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_detected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDetected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_distance_in_millimeters(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DistanceInMillimeters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorReading: IProximitySensorReading}
DEFINE_IID!(IID_IProximitySensorReadingChangedEventArgs, 3485660006, 50152, 16637, 140, 195, 103, 226, 137, 0, 73, 56);
RT_INTERFACE!{interface IProximitySensorReadingChangedEventArgs(IProximitySensorReadingChangedEventArgsVtbl, IProximitySensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <ProximitySensorReading as RtType>::Abi) -> HRESULT
}}
impl IProximitySensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<ProximitySensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ProximitySensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorReadingChangedEventArgs: IProximitySensorReadingChangedEventArgs}
DEFINE_IID!(IID_IProximitySensorStatics, 689464905, 25193, 20055, 165, 173, 130, 190, 128, 129, 51, 146);
RT_INTERFACE!{static interface IProximitySensorStatics(IProximitySensorStaticsVtbl, IProximitySensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromId(&self, sensorId: HSTRING, out: *mut <ProximitySensor as RtType>::Abi) -> HRESULT
}}
impl IProximitySensorStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id(&self, sensorId: &HStringArg) -> Result<Option<ProximitySensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, sensorId.get(), &mut out);
        if hr == S_OK { Ok(ProximitySensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProximitySensorStatics2, 3421795246, 59850, 16943, 173, 103, 76, 61, 37, 223, 53, 12);
RT_INTERFACE!{static interface IProximitySensorStatics2(IProximitySensorStatics2Vtbl, IProximitySensorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics2] {
    fn GetReadingsFromTriggerDetails(&self, triggerDetails: <SensorDataThresholdTriggerDetails as RtType>::Abi, out: *mut <foundation::collections::IVectorView<ProximitySensorReading> as RtType>::Abi) -> HRESULT
}}
impl IProximitySensorStatics2 {
    #[inline] pub fn get_readings_from_trigger_details(&self, triggerDetails: &SensorDataThresholdTriggerDetails) -> Result<Option<foundation::collections::IVectorView<ProximitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetReadingsFromTriggerDetails)(self.0.as_abi() as *const _ as *mut _, get_abi(triggerDetails) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISensorDataThreshold, 1423633505, 65099, 19975, 178, 96, 58, 76, 223, 190, 57, 110);
RT_INTERFACE!{interface ISensorDataThreshold(ISensorDataThresholdVtbl, ISensorDataThreshold_Abi): IInspectable(IInspectableVtbl) [IID_ISensorDataThreshold] {
    
}}
DEFINE_IID!(IID_ISensorDataThresholdTriggerDetails, 2433151415, 59533, 18609, 188, 144, 97, 156, 123, 52, 147, 145);
RT_INTERFACE!{interface ISensorDataThresholdTriggerDetails(ISensorDataThresholdTriggerDetailsVtbl, ISensorDataThresholdTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_ISensorDataThresholdTriggerDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SensorType(&self, out: *mut SensorType) -> HRESULT
}}
impl ISensorDataThresholdTriggerDetails {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sensor_type(&self) -> Result<SensorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SensorType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorDataThresholdTriggerDetails: ISensorDataThresholdTriggerDetails}
RT_ENUM! { enum SensorOptimizationGoal: i32 {
    Precision = 0, PowerEfficiency = 1,
}}
DEFINE_IID!(IID_ISensorQuaternion, 3385182247, 50972, 18151, 157, 163, 54, 161, 147, 178, 50, 188);
RT_INTERFACE!{interface ISensorQuaternion(ISensorQuaternionVtbl, ISensorQuaternion_Abi): IInspectable(IInspectableVtbl) [IID_ISensorQuaternion] {
    fn get_W(&self, out: *mut f32) -> HRESULT,
    fn get_X(&self, out: *mut f32) -> HRESULT,
    fn get_Y(&self, out: *mut f32) -> HRESULT,
    fn get_Z(&self, out: *mut f32) -> HRESULT
}}
impl ISensorQuaternion {
    #[inline] pub fn get_w(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_W)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_X)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Y)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_z(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Z)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorQuaternion: ISensorQuaternion}
RT_ENUM! { enum SensorReadingType: i32 {
    Absolute = 0, Relative = 1,
}}
DEFINE_IID!(IID_ISensorRotationMatrix, 171792999, 8948, 17298, 149, 56, 101, 208, 189, 6, 74, 166);
RT_INTERFACE!{interface ISensorRotationMatrix(ISensorRotationMatrixVtbl, ISensorRotationMatrix_Abi): IInspectable(IInspectableVtbl) [IID_ISensorRotationMatrix] {
    fn get_M11(&self, out: *mut f32) -> HRESULT,
    fn get_M12(&self, out: *mut f32) -> HRESULT,
    fn get_M13(&self, out: *mut f32) -> HRESULT,
    fn get_M21(&self, out: *mut f32) -> HRESULT,
    fn get_M22(&self, out: *mut f32) -> HRESULT,
    fn get_M23(&self, out: *mut f32) -> HRESULT,
    fn get_M31(&self, out: *mut f32) -> HRESULT,
    fn get_M32(&self, out: *mut f32) -> HRESULT,
    fn get_M33(&self, out: *mut f32) -> HRESULT
}}
impl ISensorRotationMatrix {
    #[inline] pub fn get_m11(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M11)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m12(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M12)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m13(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M13)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m21(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M21)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m22(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M22)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m23(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M23)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m31(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M31)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m32(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M32)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m33(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_M33)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorRotationMatrix: ISensorRotationMatrix}
RT_ENUM! { enum SensorType: i32 {
    Accelerometer = 0, ActivitySensor = 1, Barometer = 2, Compass = 3, CustomSensor = 4, Gyroscope = 5, ProximitySensor = 6, Inclinometer = 7, LightSensor = 8, OrientationSensor = 9, Pedometer = 10, RelativeInclinometer = 11, RelativeOrientationSensor = 12, SimpleOrientationSensor = 13,
}}
RT_ENUM! { enum SimpleOrientation: i32 {
    NotRotated = 0, Rotated90DegreesCounterclockwise = 1, Rotated180DegreesCounterclockwise = 2, Rotated270DegreesCounterclockwise = 3, Faceup = 4, Facedown = 5,
}}
DEFINE_IID!(IID_ISimpleOrientationSensor, 1609906262, 8522, 19950, 163, 249, 97, 111, 26, 176, 111, 253);
RT_INTERFACE!{interface ISimpleOrientationSensor(ISimpleOrientationSensorVtbl, ISimpleOrientationSensor_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor] {
    fn GetCurrentOrientation(&self, out: *mut SimpleOrientation) -> HRESULT,
    fn add_OrientationChanged(&self, handler: <foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OrientationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISimpleOrientationSensor {
    #[inline] pub fn get_current_orientation(&self) -> Result<SimpleOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentOrientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_orientation_changed(&self, handler: &foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_OrientationChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_orientation_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_OrientationChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleOrientationSensor: ISimpleOrientationSensor}
impl RtActivatable<ISimpleOrientationSensorStatics> for SimpleOrientationSensor {}
impl RtActivatable<ISimpleOrientationSensorStatics2> for SimpleOrientationSensor {}
impl SimpleOrientationSensor {
    #[inline] pub fn get_default() -> Result<Option<SimpleOrientationSensor>> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SimpleOrientationSensor>> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SimpleOrientationSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,83,105,109,112,108,101,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]) [CLSID_SimpleOrientationSensor]);
DEFINE_IID!(IID_ISimpleOrientationSensor2, 2725750680, 34928, 17726, 139, 214, 184, 245, 216, 215, 148, 27);
RT_INTERFACE!{interface ISimpleOrientationSensor2(ISimpleOrientationSensor2Vtbl, ISimpleOrientationSensor2_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ISimpleOrientationSensor2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadingTransform)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorDeviceId, 4223666891, 15222, 16886, 128, 145, 48, 239, 230, 70, 211, 207);
RT_INTERFACE!{interface ISimpleOrientationSensorDeviceId(ISimpleOrientationSensorDeviceIdVtbl, ISimpleOrientationSensorDeviceId_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISimpleOrientationSensorDeviceId {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorOrientationChangedEventArgs, 3168126560, 9172, 19276, 162, 46, 186, 129, 173, 224, 198, 1);
RT_INTERFACE!{interface ISimpleOrientationSensorOrientationChangedEventArgs(ISimpleOrientationSensorOrientationChangedEventArgsVtbl, ISimpleOrientationSensorOrientationChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorOrientationChangedEventArgs] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Orientation(&self, out: *mut SimpleOrientation) -> HRESULT
}}
impl ISimpleOrientationSensorOrientationChangedEventArgs {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<SimpleOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Orientation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleOrientationSensorOrientationChangedEventArgs: ISimpleOrientationSensorOrientationChangedEventArgs}
DEFINE_IID!(IID_ISimpleOrientationSensorStatics, 1928136303, 28842, 16582, 155, 27, 52, 51, 247, 69, 155, 78);
RT_INTERFACE!{static interface ISimpleOrientationSensorStatics(ISimpleOrientationSensorStaticsVtbl, ISimpleOrientationSensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorStatics] {
    fn GetDefault(&self, out: *mut <SimpleOrientationSensor as RtType>::Abi) -> HRESULT
}}
impl ISimpleOrientationSensorStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<SimpleOrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SimpleOrientationSensor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorStatics2, 2224004223, 45368, 19985, 137, 16, 162, 162, 163, 181, 109, 131);
RT_INTERFACE!{static interface ISimpleOrientationSensorStatics2(ISimpleOrientationSensorStatics2Vtbl, ISimpleOrientationSensorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<SimpleOrientationSensor> as RtType>::Abi) -> HRESULT
}}
impl ISimpleOrientationSensorStatics2 {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SimpleOrientationSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
pub mod custom { // Windows.Devices.Sensors.Custom
use crate::prelude::*;
DEFINE_IID!(IID_ICustomSensor, 2704734637, 16436, 19277, 153, 221, 83, 26, 172, 100, 156, 9);
RT_INTERFACE!{interface ICustomSensor(ICustomSensorVtbl, ICustomSensor_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensor] {
    fn GetCurrentReading(&self, out: *mut <CustomSensorReading as RtType>::Abi) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ReadingChanged(&self, handler: <foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICustomSensor {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<CustomSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetCurrentReading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CustomSensorReading::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinimumReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportInterval)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ReadingChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensor: ICustomSensor}
impl RtActivatable<ICustomSensorStatics> for CustomSensor {}
impl CustomSensor {
    #[inline] pub fn get_device_selector(interfaceId: Guid) -> Result<HString> {
        <Self as RtActivatable<ICustomSensorStatics>>::get_activation_factory().get_device_selector(interfaceId)
    }
    #[inline] pub fn from_id_async(sensorId: &HStringArg) -> Result<foundation::IAsyncOperation<CustomSensor>> {
        <Self as RtActivatable<ICustomSensorStatics>>::get_activation_factory().from_id_async(sensorId)
    }
}
DEFINE_CLSID!(CustomSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,83,101,110,115,111,114,0]) [CLSID_CustomSensor]);
DEFINE_IID!(IID_ICustomSensor2, 551235857, 60504, 19871, 191, 189, 231, 120, 37, 8, 133, 16);
RT_INTERFACE!{interface ICustomSensor2(ICustomSensor2Vtbl, ICustomSensor2_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensor2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ICustomSensor2 {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReportLatency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReportLatency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxBatchSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICustomSensorReading, 1677741901, 17514, 17254, 168, 122, 95, 150, 50, 104, 236, 83);
RT_INTERFACE!{interface ICustomSensorReading(ICustomSensorReadingVtbl, ICustomSensorReading_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::IMapView<HString, IInspectable> as RtType>::Abi) -> HRESULT
}}
impl ICustomSensorReading {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::IMapView<HString, IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMapView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensorReading: ICustomSensorReading}
DEFINE_IID!(IID_ICustomSensorReading2, 574396650, 49011, 18834, 154, 72, 211, 200, 151, 89, 76, 203);
RT_INTERFACE!{interface ICustomSensorReading2(ICustomSensorReading2Vtbl, ICustomSensorReading2_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut <foundation::IReference<foundation::TimeSpan> as RtType>::Abi) -> HRESULT
}}
impl ICustomSensorReading2 {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<foundation::IReference<foundation::TimeSpan>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PerformanceCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICustomSensorReadingChangedEventArgs, 1797267491, 53245, 19649, 143, 240, 226, 24, 35, 215, 111, 204);
RT_INTERFACE!{interface ICustomSensorReadingChangedEventArgs(ICustomSensorReadingChangedEventArgsVtbl, ICustomSensorReadingChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut <CustomSensorReading as RtType>::Abi) -> HRESULT
}}
impl ICustomSensorReadingChangedEventArgs {
    #[inline] pub fn get_reading(&self) -> Result<Option<CustomSensorReading>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reading)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(CustomSensorReading::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensorReadingChangedEventArgs: ICustomSensorReadingChangedEventArgs}
DEFINE_IID!(IID_ICustomSensorStatics, 2569032399, 62498, 19581, 131, 107, 231, 220, 116, 167, 18, 75);
RT_INTERFACE!{static interface ICustomSensorStatics(ICustomSensorStaticsVtbl, ICustomSensorStatics_Abi): IInspectable(IInspectableVtbl) [IID_ICustomSensorStatics] {
    fn GetDeviceSelector(&self, interfaceId: Guid, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, sensorId: HSTRING, out: *mut <foundation::IAsyncOperation<CustomSensor> as RtType>::Abi) -> HRESULT
}}
impl ICustomSensorStatics {
    #[inline] pub fn get_device_selector(&self, interfaceId: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, interfaceId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, sensorId: &HStringArg) -> Result<foundation::IAsyncOperation<CustomSensor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, sensorId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Sensors.Custom
} // Windows.Devices.Sensors
pub mod serialcommunication { // Windows.Devices.SerialCommunication
use crate::prelude::*;
DEFINE_IID!(IID_IErrorReceivedEventArgs, 4240883545, 4739, 19850, 191, 223, 86, 107, 51, 221, 178, 143);
RT_INTERFACE!{interface IErrorReceivedEventArgs(IErrorReceivedEventArgsVtbl, IErrorReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IErrorReceivedEventArgs] {
    fn get_Error(&self, out: *mut SerialError) -> HRESULT
}}
impl IErrorReceivedEventArgs {
    #[inline] pub fn get_error(&self) -> Result<SerialError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ErrorReceivedEventArgs: IErrorReceivedEventArgs}
DEFINE_IID!(IID_IPinChangedEventArgs, 2730433968, 64668, 17927, 147, 208, 250, 94, 131, 67, 238, 34);
RT_INTERFACE!{interface IPinChangedEventArgs(IPinChangedEventArgsVtbl, IPinChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IPinChangedEventArgs] {
    fn get_PinChange(&self, out: *mut SerialPinChange) -> HRESULT
}}
impl IPinChangedEventArgs {
    #[inline] pub fn get_pin_change(&self) -> Result<SerialPinChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PinChange)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PinChangedEventArgs: IPinChangedEventArgs}
DEFINE_IID!(IID_ISerialDevice, 3783773382, 8720, 16719, 182, 90, 245, 85, 58, 3, 55, 42);
RT_INTERFACE!{interface ISerialDevice(ISerialDeviceVtbl, ISerialDevice_Abi): IInspectable(IInspectableVtbl) [IID_ISerialDevice] {
    fn get_BaudRate(&self, out: *mut u32) -> HRESULT,
    fn put_BaudRate(&self, value: u32) -> HRESULT,
    fn get_BreakSignalState(&self, out: *mut bool) -> HRESULT,
    fn put_BreakSignalState(&self, value: bool) -> HRESULT,
    fn get_BytesReceived(&self, out: *mut u32) -> HRESULT,
    fn get_CarrierDetectState(&self, out: *mut bool) -> HRESULT,
    fn get_ClearToSendState(&self, out: *mut bool) -> HRESULT,
    fn get_DataBits(&self, out: *mut u16) -> HRESULT,
    fn put_DataBits(&self, value: u16) -> HRESULT,
    fn get_DataSetReadyState(&self, out: *mut bool) -> HRESULT,
    fn get_Handshake(&self, out: *mut SerialHandshake) -> HRESULT,
    fn put_Handshake(&self, value: SerialHandshake) -> HRESULT,
    fn get_IsDataTerminalReadyEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDataTerminalReadyEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRequestToSendEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRequestToSendEnabled(&self, value: bool) -> HRESULT,
    fn get_Parity(&self, out: *mut SerialParity) -> HRESULT,
    fn put_Parity(&self, value: SerialParity) -> HRESULT,
    fn get_PortName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReadTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_ReadTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StopBits(&self, out: *mut SerialStopBitCount) -> HRESULT,
    fn put_StopBits(&self, value: SerialStopBitCount) -> HRESULT,
    fn get_UsbVendorId(&self, out: *mut u16) -> HRESULT,
    fn get_UsbProductId(&self, out: *mut u16) -> HRESULT,
    fn get_WriteTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_WriteTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy27(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut <super::super::storage::streams::IInputStream as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy28(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut <super::super::storage::streams::IOutputStream as RtType>::Abi) -> HRESULT,
    fn add_ErrorReceived(&self, reportHandler: <foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PinChanged(&self, reportHandler: <foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PinChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISerialDevice {
    #[inline] pub fn get_baud_rate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BaudRate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_baud_rate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BaudRate)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_break_signal_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BreakSignalState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_break_signal_state(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BreakSignalState)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bytes_received(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BytesReceived)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_carrier_detect_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CarrierDetectState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_clear_to_send_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClearToSendState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bits(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataBits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bits(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataBits)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_set_ready_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataSetReadyState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_handshake(&self) -> Result<SerialHandshake> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Handshake)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handshake(&self, value: SerialHandshake) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Handshake)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_data_terminal_ready_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDataTerminalReadyEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_data_terminal_ready_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDataTerminalReadyEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_request_to_send_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsRequestToSendEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_request_to_send_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsRequestToSendEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_parity(&self) -> Result<SerialParity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Parity)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_parity(&self, value: SerialParity) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Parity)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_port_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PortName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_read_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_read_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stop_bits(&self) -> Result<SerialStopBitCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_StopBits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stop_bits(&self, value: SerialStopBitCount) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_StopBits)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_usb_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsbVendorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usb_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsbProductId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteTimeout)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WriteTimeout)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<super::super::storage::streams::IInputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IInputStream::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<super::super::storage::streams::IOutputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IOutputStream::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_error_received(&self, reportHandler: &foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ErrorReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(reportHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ErrorReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pin_changed(&self, reportHandler: &foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_PinChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(reportHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pin_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_PinChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SerialDevice: ISerialDevice}
impl RtActivatable<ISerialDeviceStatics> for SerialDevice {}
impl SerialDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_port_name(portName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector_from_port_name(portName)
    }
    #[inline] pub fn get_device_selector_from_usb_vid_pid(vendorId: u16, productId: u16) -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector_from_usb_vid_pid(vendorId, productId)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SerialDevice>> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SerialDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,114,105,97,108,67,111,109,109,117,110,105,99,97,116,105,111,110,46,83,101,114,105,97,108,68,101,118,105,99,101,0]) [CLSID_SerialDevice]);
DEFINE_IID!(IID_ISerialDeviceStatics, 93080176, 2102, 18835, 174, 26, 182, 26, 227, 190, 5, 107);
RT_INTERFACE!{static interface ISerialDeviceStatics(ISerialDeviceStaticsVtbl, ISerialDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISerialDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromPortName(&self, portName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromUsbVidPid(&self, vendorId: u16, productId: u16, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<SerialDevice> as RtType>::Abi) -> HRESULT
}}
impl ISerialDeviceStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_port_name(&self, portName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromPortName)(self.0.as_abi() as *const _ as *mut _, portName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_usb_vid_pid(&self, vendorId: u16, productId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromUsbVidPid)(self.0.as_abi() as *const _ as *mut _, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SerialDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SerialError: i32 {
    Frame = 0, BufferOverrun = 1, ReceiveFull = 2, ReceiveParity = 3, TransmitFull = 4,
}}
RT_ENUM! { enum SerialHandshake: i32 {
    None = 0, RequestToSend = 1, XOnXOff = 2, RequestToSendXOnXOff = 3,
}}
RT_ENUM! { enum SerialParity: i32 {
    None = 0, Odd = 1, Even = 2, Mark = 3, Space = 4,
}}
RT_ENUM! { enum SerialPinChange: i32 {
    BreakSignal = 0, CarrierDetect = 1, ClearToSend = 2, DataSetReady = 3, RingIndicator = 4,
}}
RT_ENUM! { enum SerialStopBitCount: i32 {
    One = 0, OnePointFive = 1, Two = 2,
}}
} // Windows.Devices.SerialCommunication
pub mod smartcards { // Windows.Devices.SmartCards
use crate::prelude::*;
DEFINE_IID!(IID_ICardAddedEventArgs, 414969752, 61835, 19923, 177, 24, 223, 178, 200, 226, 60, 198);
RT_INTERFACE!{interface ICardAddedEventArgs(ICardAddedEventArgsVtbl, ICardAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICardAddedEventArgs] {
    fn get_SmartCard(&self, out: *mut <SmartCard as RtType>::Abi) -> HRESULT
}}
impl ICardAddedEventArgs {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<SmartCard>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCard)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCard::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CardAddedEventArgs: ICardAddedEventArgs}
DEFINE_IID!(IID_ICardRemovedEventArgs, 355670703, 8919, 18757, 175, 201, 3, 180, 111, 66, 166, 205);
RT_INTERFACE!{interface ICardRemovedEventArgs(ICardRemovedEventArgsVtbl, ICardRemovedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ICardRemovedEventArgs] {
    fn get_SmartCard(&self, out: *mut <SmartCard as RtType>::Abi) -> HRESULT
}}
impl ICardRemovedEventArgs {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<SmartCard>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCard)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCard::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CardRemovedEventArgs: ICardRemovedEventArgs}
DEFINE_IID!(IID_IKnownSmartCardAppletIds, 2063915224, 38324, 19592, 140, 234, 65, 30, 85, 81, 30, 252);
RT_INTERFACE!{static interface IKnownSmartCardAppletIds(IKnownSmartCardAppletIdsVtbl, IKnownSmartCardAppletIds_Abi): IInspectable(IInspectableVtbl) [IID_IKnownSmartCardAppletIds] {
    #[cfg(feature="windows-storage")] fn get_PaymentSystemEnvironment(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ProximityPaymentSystemEnvironment(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IKnownSmartCardAppletIds {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_payment_system_environment(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PaymentSystemEnvironment)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proximity_payment_system_environment(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProximityPaymentSystemEnvironment)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownSmartCardAppletIds}
impl RtActivatable<IKnownSmartCardAppletIds> for KnownSmartCardAppletIds {}
impl KnownSmartCardAppletIds {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_payment_system_environment() -> Result<Option<super::super::storage::streams::IBuffer>> {
        <Self as RtActivatable<IKnownSmartCardAppletIds>>::get_activation_factory().get_payment_system_environment()
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proximity_payment_system_environment() -> Result<Option<super::super::storage::streams::IBuffer>> {
        <Self as RtActivatable<IKnownSmartCardAppletIds>>::get_activation_factory().get_proximity_payment_system_environment()
    }
}
DEFINE_CLSID!(KnownSmartCardAppletIds(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,75,110,111,119,110,83,109,97,114,116,67,97,114,100,65,112,112,108,101,116,73,100,115,0]) [CLSID_KnownSmartCardAppletIds]);
DEFINE_IID!(IID_ISmartCard, 460425329, 25652, 17396, 181, 90, 106, 41, 98, 56, 112, 170);
RT_INTERFACE!{interface ISmartCard(ISmartCardVtbl, ISmartCard_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCard] {
    fn get_Reader(&self, out: *mut <SmartCardReader as RtType>::Abi) -> HRESULT,
    fn GetStatusAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetAnswerToResetAsync(&self, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT
}}
impl ISmartCard {
    #[inline] pub fn get_reader(&self) -> Result<Option<SmartCardReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reader)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardReader::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status_async(&self) -> Result<foundation::IAsyncOperation<SmartCardStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatusAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_answer_to_reset_async(&self) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAnswerToResetAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCard: ISmartCard}
RT_ENUM! { enum SmartCardActivationPolicyChangeResult: i32 {
    Denied = 0, Allowed = 1,
}}
DEFINE_IID!(IID_ISmartCardAppletIdGroup, 2108777958, 25188, 22260, 94, 3, 200, 99, 133, 57, 94, 177);
RT_INTERFACE!{interface ISmartCardAppletIdGroup(ISmartCardAppletIdGroupVtbl, ISmartCardAppletIdGroup_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroup] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AppletIds(&self, out: *mut <foundation::collections::IVector<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn get_SmartCardEmulationCategory(&self, out: *mut SmartCardEmulationCategory) -> HRESULT,
    fn put_SmartCardEmulationCategory(&self, value: SmartCardEmulationCategory) -> HRESULT,
    fn get_SmartCardEmulationType(&self, out: *mut SmartCardEmulationType) -> HRESULT,
    fn put_SmartCardEmulationType(&self, value: SmartCardEmulationType) -> HRESULT,
    fn get_AutomaticEnablement(&self, out: *mut bool) -> HRESULT,
    fn put_AutomaticEnablement(&self, value: bool) -> HRESULT
}}
impl ISmartCardAppletIdGroup {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DisplayName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DisplayName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_applet_ids(&self) -> Result<Option<foundation::collections::IVector<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppletIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_smart_card_emulation_category(&self) -> Result<SmartCardEmulationCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCardEmulationCategory)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_smart_card_emulation_category(&self, value: SmartCardEmulationCategory) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SmartCardEmulationCategory)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_smart_card_emulation_type(&self) -> Result<SmartCardEmulationType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCardEmulationType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_smart_card_emulation_type(&self, value: SmartCardEmulationType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SmartCardEmulationType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_automatic_enablement(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutomaticEnablement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_automatic_enablement(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutomaticEnablement)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAppletIdGroup: ISmartCardAppletIdGroup}
impl RtActivatable<ISmartCardAppletIdGroupFactory> for SmartCardAppletIdGroup {}
impl RtActivatable<ISmartCardAppletIdGroupStatics> for SmartCardAppletIdGroup {}
impl RtActivatable<IActivationFactory> for SmartCardAppletIdGroup {}
impl SmartCardAppletIdGroup {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(displayName: &HStringArg, appletIds: &foundation::collections::IVector<super::super::storage::streams::IBuffer>, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType) -> Result<SmartCardAppletIdGroup> {
        <Self as RtActivatable<ISmartCardAppletIdGroupFactory>>::get_activation_factory().create(displayName, appletIds, emulationCategory, emulationType)
    }
    #[inline] pub fn get_max_applet_ids() -> Result<u16> {
        <Self as RtActivatable<ISmartCardAppletIdGroupStatics>>::get_activation_factory().get_max_applet_ids()
    }
}
DEFINE_CLSID!(SmartCardAppletIdGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,65,112,112,108,101,116,73,100,71,114,111,117,112,0]) [CLSID_SmartCardAppletIdGroup]);
DEFINE_IID!(IID_ISmartCardAppletIdGroup2, 1796143580, 39254, 19042, 141, 78, 211, 122, 104, 235, 195, 166);
RT_INTERFACE!{interface ISmartCardAppletIdGroup2(ISmartCardAppletIdGroup2Vtbl, ISmartCardAppletIdGroup2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroup2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo(&self, out: *mut <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo(&self, value: <super::super::storage::streams::IRandomAccessStreamReference as RtType>::Abi) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut <foundation::collections::ValueSet as RtType>::Abi) -> HRESULT,
    fn get_SecureUserAuthenticationRequired(&self, out: *mut bool) -> HRESULT,
    fn put_SecureUserAuthenticationRequired(&self, value: bool) -> HRESULT
}}
impl ISmartCardAppletIdGroup2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo(&self) -> Result<Option<super::super::storage::streams::IRandomAccessStreamReference>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Logo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IRandomAccessStreamReference::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Logo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Description)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Description)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<foundation::collections::ValueSet>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Properties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::ValueSet::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_secure_user_authentication_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecureUserAuthenticationRequired)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_secure_user_authentication_required(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SecureUserAuthenticationRequired)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardAppletIdGroupActivationPolicy: i32 {
    Disabled = 0, ForegroundOverride = 1, Enabled = 2,
}}
DEFINE_IID!(IID_ISmartCardAppletIdGroupFactory, 2433084237, 19045, 20033, 128, 97, 203, 232, 63, 54, 149, 229);
RT_INTERFACE!{static interface ISmartCardAppletIdGroupFactory(ISmartCardAppletIdGroupFactoryVtbl, ISmartCardAppletIdGroupFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, displayName: HSTRING, appletIds: <foundation::collections::IVector<super::super::storage::streams::IBuffer> as RtType>::Abi, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType, out: *mut <SmartCardAppletIdGroup as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAppletIdGroupFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, displayName: &HStringArg, appletIds: &foundation::collections::IVector<super::super::storage::streams::IBuffer>, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType) -> Result<SmartCardAppletIdGroup> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, displayName.get(), get_abi(appletIds) as *const _ as *mut _, emulationCategory, emulationType, &mut out);
        if hr == S_OK { Ok(SmartCardAppletIdGroup::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAppletIdGroupRegistration, 3742501073, 12731, 21910, 67, 177, 109, 105, 160, 37, 123, 58);
RT_INTERFACE!{interface ISmartCardAppletIdGroupRegistration(ISmartCardAppletIdGroupRegistrationVtbl, ISmartCardAppletIdGroupRegistration_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupRegistration] {
    fn get_ActivationPolicy(&self, out: *mut SmartCardAppletIdGroupActivationPolicy) -> HRESULT,
    fn get_AppletIdGroup(&self, out: *mut <SmartCardAppletIdGroup as RtType>::Abi) -> HRESULT,
    fn RequestActivationPolicyChangeAsync(&self, policy: SmartCardAppletIdGroupActivationPolicy, out: *mut <foundation::IAsyncOperation<SmartCardActivationPolicyChangeResult> as RtType>::Abi) -> HRESULT,
    fn get_Id(&self, out: *mut Guid) -> HRESULT,
    fn SetAutomaticResponseApdusAsync(&self, apdus: <foundation::collections::IIterable<SmartCardAutomaticResponseApdu> as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAppletIdGroupRegistration {
    #[inline] pub fn get_activation_policy(&self) -> Result<SmartCardAppletIdGroupActivationPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActivationPolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_applet_id_group(&self) -> Result<Option<SmartCardAppletIdGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppletIdGroup)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardAppletIdGroup::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_activation_policy_change_async(&self, policy: SmartCardAppletIdGroupActivationPolicy) -> Result<foundation::IAsyncOperation<SmartCardActivationPolicyChangeResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestActivationPolicyChangeAsync)(self.0.as_abi() as *const _ as *mut _, policy, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_automatic_response_apdus_async(&self, apdus: &foundation::collections::IIterable<SmartCardAutomaticResponseApdu>) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetAutomaticResponseApdusAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(apdus) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAppletIdGroupRegistration: ISmartCardAppletIdGroupRegistration}
DEFINE_IID!(IID_ISmartCardAppletIdGroupRegistration2, 1599408344, 39079, 20270, 145, 217, 108, 252, 206, 218, 64, 127);
RT_INTERFACE!{interface ISmartCardAppletIdGroupRegistration2(ISmartCardAppletIdGroupRegistration2Vtbl, ISmartCardAppletIdGroupRegistration2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupRegistration2] {
    fn get_SmartCardReaderId(&self, out: *mut HSTRING) -> HRESULT,
    fn SetPropertiesAsync(&self, props: <foundation::collections::ValueSet as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAppletIdGroupRegistration2 {
    #[inline] pub fn get_smart_card_reader_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCardReaderId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_properties_async(&self, props: &foundation::collections::ValueSet) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SetPropertiesAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(props) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAppletIdGroupStatics, 2871564713, 59244, 17871, 191, 29, 144, 234, 166, 32, 89, 39);
RT_INTERFACE!{static interface ISmartCardAppletIdGroupStatics(ISmartCardAppletIdGroupStaticsVtbl, ISmartCardAppletIdGroupStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupStatics] {
    fn get_MaxAppletIds(&self, out: *mut u16) -> HRESULT
}}
impl ISmartCardAppletIdGroupStatics {
    #[inline] pub fn get_max_applet_ids(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxAppletIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu, 1377119147, 50750, 17713, 168, 87, 215, 86, 217, 155, 152, 106);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu(ISmartCardAutomaticResponseApduVtbl, ISmartCardAutomaticResponseApdu_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu] {
    #[cfg(feature="windows-storage")] fn get_CommandApdu(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_CommandApdu(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_CommandApduBitMask(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_CommandApduBitMask(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ShouldMatchLength(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldMatchLength(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AppletId(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_AppletId(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ResponseApdu(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_ResponseApdu(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAutomaticResponseApdu {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CommandApdu)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_command_apdu(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CommandApdu)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu_bit_mask(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CommandApduBitMask)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_command_apdu_bit_mask(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CommandApduBitMask)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_should_match_length(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ShouldMatchLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_match_length(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ShouldMatchLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_applet_id(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppletId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_applet_id(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AppletId)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_response_apdu(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ResponseApdu)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_response_apdu(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ResponseApdu)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAutomaticResponseApdu: ISmartCardAutomaticResponseApdu}
impl RtActivatable<ISmartCardAutomaticResponseApduFactory> for SmartCardAutomaticResponseApdu {}
impl SmartCardAutomaticResponseApdu {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(commandApdu: &super::super::storage::streams::IBuffer, responseApdu: &super::super::storage::streams::IBuffer) -> Result<SmartCardAutomaticResponseApdu> {
        <Self as RtActivatable<ISmartCardAutomaticResponseApduFactory>>::get_activation_factory().create(commandApdu, responseApdu)
    }
}
DEFINE_CLSID!(SmartCardAutomaticResponseApdu(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,65,117,116,111,109,97,116,105,99,82,101,115,112,111,110,115,101,65,112,100,117,0]) [CLSID_SmartCardAutomaticResponseApdu]);
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu2, 1152301844, 21917, 17713, 78, 81, 137, 219, 111, 168, 165, 122);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu2(ISmartCardAutomaticResponseApdu2Vtbl, ISmartCardAutomaticResponseApdu2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu2] {
    fn get_InputState(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_InputState(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn get_OutputState(&self, out: *mut <foundation::IReference<u32> as RtType>::Abi) -> HRESULT,
    fn put_OutputState(&self, value: <foundation::IReference<u32> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAutomaticResponseApdu2 {
    #[inline] pub fn get_input_state(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_input_state(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InputState)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_output_state(&self) -> Result<Option<foundation::IReference<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputState)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_output_state(&self, value: &foundation::IReference<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OutputState)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu3, 3208895092, 25974, 17298, 147, 103, 254, 59, 201, 226, 212, 150);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu3(ISmartCardAutomaticResponseApdu3Vtbl, ISmartCardAutomaticResponseApdu3_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu3] {
    fn get_AllowWhenCryptogramGeneratorNotPrepared(&self, out: *mut bool) -> HRESULT,
    fn put_AllowWhenCryptogramGeneratorNotPrepared(&self, value: bool) -> HRESULT
}}
impl ISmartCardAutomaticResponseApdu3 {
    #[inline] pub fn get_allow_when_cryptogram_generator_not_prepared(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowWhenCryptogramGeneratorNotPrepared)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_when_cryptogram_generator_not_prepared(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AllowWhenCryptogramGeneratorNotPrepared)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApduFactory, 3917390586, 53292, 19541, 176, 42, 140, 255, 127, 169, 240, 91);
RT_INTERFACE!{static interface ISmartCardAutomaticResponseApduFactory(ISmartCardAutomaticResponseApduFactoryVtbl, ISmartCardAutomaticResponseApduFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApduFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, commandApdu: <super::super::storage::streams::IBuffer as RtType>::Abi, responseApdu: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <SmartCardAutomaticResponseApdu as RtType>::Abi) -> HRESULT
}}
impl ISmartCardAutomaticResponseApduFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, commandApdu: &super::super::storage::streams::IBuffer, responseApdu: &super::super::storage::streams::IBuffer) -> Result<SmartCardAutomaticResponseApdu> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, get_abi(commandApdu) as *const _ as *mut _, get_abi(responseApdu) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardAutomaticResponseApdu::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardAutomaticResponseStatus: i32 {
    None = 0, Success = 1, UnknownError = 2,
}}
DEFINE_IID!(IID_ISmartCardChallengeContext, 422204185, 51652, 18759, 129, 204, 68, 121, 74, 97, 239, 145);
RT_INTERFACE!{interface ISmartCardChallengeContext(ISmartCardChallengeContextVtbl, ISmartCardChallengeContext_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardChallengeContext] {
    #[cfg(feature="windows-storage")] fn get_Challenge(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn VerifyResponseAsync(&self, response: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ProvisionAsync(&self, response: <super::super::storage::streams::IBuffer as RtType>::Abi, formatCard: bool, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ProvisionAsyncWithNewCardId(&self, response: <super::super::storage::streams::IBuffer as RtType>::Abi, formatCard: bool, newCardId: Guid, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ChangeAdministrativeKeyAsync(&self, response: <super::super::storage::streams::IBuffer as RtType>::Abi, newAdministrativeKey: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT
}}
impl ISmartCardChallengeContext {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_challenge(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Challenge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn verify_response_async(&self, response: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).VerifyResponseAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(response) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn provision_async(&self, response: &super::super::storage::streams::IBuffer, formatCard: bool) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ProvisionAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(response) as *const _ as *mut _, formatCard, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn provision_async_with_new_card_id(&self, response: &super::super::storage::streams::IBuffer, formatCard: bool, newCardId: Guid) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ProvisionAsyncWithNewCardId)(self.0.as_abi() as *const _ as *mut _, get_abi(response) as *const _ as *mut _, formatCard, newCardId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn change_administrative_key_async(&self, response: &super::super::storage::streams::IBuffer, newAdministrativeKey: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ChangeAdministrativeKeyAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(response) as *const _ as *mut _, get_abi(newAdministrativeKey) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardChallengeContext: ISmartCardChallengeContext}
DEFINE_IID!(IID_ISmartCardConnect, 803178469, 653, 18718, 160, 88, 51, 130, 195, 152, 111, 64);
RT_INTERFACE!{interface ISmartCardConnect(ISmartCardConnectVtbl, ISmartCardConnect_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardConnect] {
    fn ConnectAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardConnection> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardConnect {
    #[inline] pub fn connect_async(&self) -> Result<foundation::IAsyncOperation<SmartCardConnection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardConnection, 2128320794, 43034, 18364, 166, 73, 21, 107, 230, 183, 242, 49);
RT_INTERFACE!{interface ISmartCardConnection(ISmartCardConnectionVtbl, ISmartCardConnection_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardConnection] {
    #[cfg(feature="windows-storage")] fn TransmitAsync(&self, command: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardConnection {
    #[cfg(feature="windows-storage")] #[inline] pub fn transmit_async(&self, command: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TransmitAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(command) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardConnection: ISmartCardConnection}
RT_ENUM! { enum SmartCardCryptogramAlgorithm: i32 {
    None = 0, CbcMac = 1, Cvc3Umd = 2, DecimalizedMsd = 3, Cvc3MD = 4, Sha1 = 5, SignedDynamicApplicationData = 6, RsaPkcs1 = 7, Sha256Hmac = 8,
}}
DEFINE_IID!(IID_ISmartCardCryptogramGenerator, 3818870907, 60883, 20041, 181, 148, 15, 245, 228, 208, 199, 111);
RT_INTERFACE!{interface ISmartCardCryptogramGenerator(ISmartCardCryptogramGeneratorVtbl, ISmartCardCryptogramGenerator_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGenerator] {
    fn get_SupportedCryptogramMaterialTypes(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialType> as RtType>::Abi) -> HRESULT,
    fn get_SupportedCryptogramAlgorithms(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramAlgorithm> as RtType>::Abi) -> HRESULT,
    fn get_SupportedCryptogramMaterialPackageFormats(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageFormat> as RtType>::Abi) -> HRESULT,
    fn get_SupportedCryptogramMaterialPackageConfirmationResponseFormats(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat> as RtType>::Abi) -> HRESULT,
    fn get_SupportedSmartCardCryptogramStorageKeyCapabilities(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCapabilities> as RtType>::Abi) -> HRESULT,
    fn DeleteCryptogramMaterialStorageKeyAsync(&self, storageKeyName: HSTRING, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    fn CreateCryptogramMaterialStorageKeyAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: HSTRING, algorithm: SmartCardCryptogramStorageKeyAlgorithm, capabilities: SmartCardCryptogramStorageKeyCapabilities, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-security")] fn RequestCryptogramMaterialStorageKeyInfoAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: HSTRING, format: super::super::security::cryptography::core::CryptographicPublicKeyBlobType, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramStorageKeyInfo> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportCryptogramMaterialPackageAsync(&self, format: SmartCardCryptogramMaterialPackageFormat, storageKeyName: HSTRING, materialPackageName: HSTRING, cryptogramMaterialPackage: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn TryProvePossessionOfCryptogramMaterialPackageAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, responseFormat: SmartCardCryptogramMaterialPackageConfirmationResponseFormat, materialPackageName: HSTRING, materialName: HSTRING, challenge: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramMaterialPossessionProof> as RtType>::Abi) -> HRESULT,
    fn RequestUnlockCryptogramMaterialForUseAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    fn DeleteCryptogramMaterialPackageAsync(&self, materialPackageName: HSTRING, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGenerator {
    #[inline] pub fn get_supported_cryptogram_material_types(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCryptogramMaterialTypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_algorithms(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCryptogramAlgorithms)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_material_package_formats(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCryptogramMaterialPackageFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_material_package_confirmation_response_formats(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedCryptogramMaterialPackageConfirmationResponseFormats)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_smart_card_cryptogram_storage_key_capabilities(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedSmartCardCryptogramStorageKeyCapabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_cryptogram_material_storage_key_async(&self, storageKeyName: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteCryptogramMaterialStorageKeyAsync)(self.0.as_abi() as *const _ as *mut _, storageKeyName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_cryptogram_material_storage_key_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: &HStringArg, algorithm: SmartCardCryptogramStorageKeyAlgorithm, capabilities: SmartCardCryptogramStorageKeyCapabilities) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateCryptogramMaterialStorageKeyAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, storageKeyName.get(), algorithm, capabilities, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn request_cryptogram_material_storage_key_info_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: &HStringArg, format: super::super::security::cryptography::core::CryptographicPublicKeyBlobType) -> Result<foundation::IAsyncOperation<SmartCardCryptogramStorageKeyInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestCryptogramMaterialStorageKeyInfoAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, storageKeyName.get(), format, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn import_cryptogram_material_package_async(&self, format: SmartCardCryptogramMaterialPackageFormat, storageKeyName: &HStringArg, materialPackageName: &HStringArg, cryptogramMaterialPackage: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ImportCryptogramMaterialPackageAsync)(self.0.as_abi() as *const _ as *mut _, format, storageKeyName.get(), materialPackageName.get(), get_abi(cryptogramMaterialPackage) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_prove_possession_of_cryptogram_material_package_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, responseFormat: SmartCardCryptogramMaterialPackageConfirmationResponseFormat, materialPackageName: &HStringArg, materialName: &HStringArg, challenge: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<SmartCardCryptogramMaterialPossessionProof>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryProvePossessionOfCryptogramMaterialPackageAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, responseFormat, materialPackageName.get(), materialName.get(), get_abi(challenge) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_unlock_cryptogram_material_for_use_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestUnlockCryptogramMaterialForUseAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_cryptogram_material_package_async(&self, materialPackageName: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteCryptogramMaterialPackageAsync)(self.0.as_abi() as *const _ as *mut _, materialPackageName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGenerator: ISmartCardCryptogramGenerator}
impl RtActivatable<ISmartCardCryptogramGeneratorStatics> for SmartCardCryptogramGenerator {}
impl RtActivatable<ISmartCardCryptogramGeneratorStatics2> for SmartCardCryptogramGenerator {}
impl SmartCardCryptogramGenerator {
    #[inline] pub fn get_smart_card_cryptogram_generator_async() -> Result<foundation::IAsyncOperation<SmartCardCryptogramGenerator>> {
        <Self as RtActivatable<ISmartCardCryptogramGeneratorStatics>>::get_activation_factory().get_smart_card_cryptogram_generator_async()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<ISmartCardCryptogramGeneratorStatics2>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(SmartCardCryptogramGenerator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,110,101,114,97,116,111,114,0]) [CLSID_SmartCardCryptogramGenerator]);
DEFINE_IID!(IID_ISmartCardCryptogramGenerator2, 1897310772, 23917, 19274, 150, 163, 239, 164, 125, 42, 126, 37);
RT_INTERFACE!{interface ISmartCardCryptogramGenerator2(ISmartCardCryptogramGenerator2Vtbl, ISmartCardCryptogramGenerator2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGenerator2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ValidateRequestApduAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, apduToValidate: <super::super::storage::streams::IBuffer as RtType>::Abi, cryptogramPlacementSteps: <foundation::collections::IIterable<SmartCardCryptogramPlacementStep> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    fn GetAllCryptogramStorageKeyCharacteristicsAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetAllCryptogramMaterialPackageCharacteristicsAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetAllCryptogramMaterialPackageCharacteristicsWithStorageKeyAsync(&self, storageKeyName: HSTRING, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult> as RtType>::Abi) -> HRESULT,
    fn GetAllCryptogramMaterialCharacteristicsAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, materialPackageName: HSTRING, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGenerator2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn validate_request_apdu_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, apduToValidate: &super::super::storage::streams::IBuffer, cryptogramPlacementSteps: &foundation::collections::IIterable<SmartCardCryptogramPlacementStep>) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ValidateRequestApduAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, get_abi(apduToValidate) as *const _ as *mut _, get_abi(cryptogramPlacementSteps) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_storage_key_characteristics_async(&self) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllCryptogramStorageKeyCharacteristicsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_package_characteristics_async(&self) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllCryptogramMaterialPackageCharacteristicsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_package_characteristics_with_storage_key_async(&self, storageKeyName: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllCryptogramMaterialPackageCharacteristicsWithStorageKeyAsync)(self.0.as_abi() as *const _ as *mut _, storageKeyName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_characteristics_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, materialPackageName: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAllCryptogramMaterialCharacteristicsAsync)(self.0.as_abi() as *const _ as *mut _, promptingBehavior, materialPackageName.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardCryptogramGeneratorOperationStatus: i32 {
    Success = 0, AuthorizationFailed = 1, AuthorizationCanceled = 2, AuthorizationRequired = 3, CryptogramMaterialPackageStorageKeyExists = 4, NoCryptogramMaterialPackageStorageKey = 5, NoCryptogramMaterialPackage = 6, UnsupportedCryptogramMaterialPackage = 7, UnknownCryptogramMaterialName = 8, InvalidCryptogramMaterialUsage = 9, ApduResponseNotSent = 10, OtherError = 11, ValidationFailed = 12, NotSupported = 13,
}}
DEFINE_IID!(IID_ISmartCardCryptogramGeneratorStatics, 160643344, 52124, 16405, 150, 125, 82, 52, 243, 176, 41, 0);
RT_INTERFACE!{static interface ISmartCardCryptogramGeneratorStatics(ISmartCardCryptogramGeneratorStaticsVtbl, ISmartCardCryptogramGeneratorStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGeneratorStatics] {
    fn GetSmartCardCryptogramGeneratorAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGenerator> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGeneratorStatics {
    #[inline] pub fn get_smart_card_cryptogram_generator_async(&self) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGenerator>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSmartCardCryptogramGeneratorAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardCryptogramGeneratorStatics2, 163444197, 46269, 20003, 165, 136, 116, 70, 146, 4, 193, 40);
RT_INTERFACE!{static interface ISmartCardCryptogramGeneratorStatics2(ISmartCardCryptogramGeneratorStatics2Vtbl, ISmartCardCryptogramGeneratorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGeneratorStatics2] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISmartCardCryptogramGeneratorStatics2 {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, 664330281, 54919, 19602, 134, 198, 57, 158, 154, 14, 203, 9);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResultVtbl, ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialCharacteristics> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialCharacteristics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, 1315605084, 38771, 18116, 163, 47, 177, 229, 67, 21, 158, 4);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResultVtbl, ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageCharacteristics> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageCharacteristics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,80,97,99,107,97,103,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, 2356996183, 42983, 18589, 185, 214, 54, 128, 97, 81, 80, 18);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResultVtbl, ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCharacteristics> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCharacteristics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Characteristics)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,83,116,111,114,97,103,101,75,101,121,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramMaterialCharacteristics, 4238001612, 49623, 16723, 146, 59, 162, 212, 60, 108, 141, 73);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialCharacteristics(ISmartCardCryptogramMaterialCharacteristicsVtbl, ISmartCardCryptogramMaterialCharacteristics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialCharacteristics] {
    fn get_MaterialName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowedAlgorithms(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramAlgorithm> as RtType>::Abi) -> HRESULT,
    fn get_AllowedProofOfPossessionAlgorithms(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat> as RtType>::Abi) -> HRESULT,
    fn get_AllowedValidations(&self, out: *mut <foundation::collections::IVectorView<SmartCardCryptogramAlgorithm> as RtType>::Abi) -> HRESULT,
    fn get_MaterialType(&self, out: *mut SmartCardCryptogramMaterialType) -> HRESULT,
    fn get_ProtectionMethod(&self, out: *mut SmartCardCryptogramMaterialProtectionMethod) -> HRESULT,
    fn get_ProtectionVersion(&self, out: *mut i32) -> HRESULT,
    fn get_MaterialLength(&self, out: *mut i32) -> HRESULT
}}
impl ISmartCardCryptogramMaterialCharacteristics {
    #[inline] pub fn get_material_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaterialName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_algorithms(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowedAlgorithms)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_proof_of_possession_algorithms(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowedProofOfPossessionAlgorithms)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_validations(&self) -> Result<Option<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllowedValidations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_material_type(&self) -> Result<SmartCardCryptogramMaterialType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaterialType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_method(&self) -> Result<SmartCardCryptogramMaterialProtectionMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionMethod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_version(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtectionVersion)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_material_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaterialLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialCharacteristics: ISmartCardCryptogramMaterialCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramMaterialCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramMaterialCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramMaterialCharacteristics]);
DEFINE_IID!(IID_ISmartCardCryptogramMaterialPackageCharacteristics, 4290088479, 1682, 19527, 147, 207, 52, 217, 31, 157, 205, 0);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialPackageCharacteristics(ISmartCardCryptogramMaterialPackageCharacteristicsVtbl, ISmartCardCryptogramMaterialPackageCharacteristics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialPackageCharacteristics] {
    fn get_PackageName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StorageKeyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DateImported(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PackageFormat(&self, out: *mut SmartCardCryptogramMaterialPackageFormat) -> HRESULT
}}
impl ISmartCardCryptogramMaterialPackageCharacteristics {
    #[inline] pub fn get_package_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PackageName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_storage_key_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StorageKeyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_imported(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateImported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package_format(&self) -> Result<SmartCardCryptogramMaterialPackageFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PackageFormat)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialPackageCharacteristics: ISmartCardCryptogramMaterialPackageCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramMaterialPackageCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramMaterialPackageCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,80,97,99,107,97,103,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramMaterialPackageCharacteristics]);
RT_ENUM! { enum SmartCardCryptogramMaterialPackageConfirmationResponseFormat: i32 {
    None = 0, VisaHmac = 1,
}}
RT_ENUM! { enum SmartCardCryptogramMaterialPackageFormat: i32 {
    None = 0, JweRsaPki = 1,
}}
DEFINE_IID!(IID_ISmartCardCryptogramMaterialPossessionProof, 3854150540, 41281, 16693, 154, 221, 176, 210, 227, 170, 31, 201);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialPossessionProof(ISmartCardCryptogramMaterialPossessionProofVtbl, ISmartCardCryptogramMaterialPossessionProof_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialPossessionProof] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Proof(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramMaterialPossessionProof {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proof(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Proof)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialPossessionProof: ISmartCardCryptogramMaterialPossessionProof}
RT_ENUM! { enum SmartCardCryptogramMaterialProtectionMethod: i32 {
    None = 0, WhiteBoxing = 1,
}}
RT_ENUM! { enum SmartCardCryptogramMaterialType: i32 {
    None = 0, StaticDataAuthentication = 1, TripleDes112 = 2, Aes = 3, RsaPkcs1 = 4,
}}
RT_ENUM! { enum SmartCardCryptogramPlacementOptions: u32 {
    None = 0, UnitsAreInNibbles = 1, ChainOutput = 2,
}}
DEFINE_IID!(IID_ISmartCardCryptogramPlacementStep, 2491089899, 33602, 18322, 162, 229, 146, 86, 54, 55, 138, 83);
RT_INTERFACE!{interface ISmartCardCryptogramPlacementStep(ISmartCardCryptogramPlacementStepVtbl, ISmartCardCryptogramPlacementStep_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramPlacementStep] {
    fn get_Algorithm(&self, out: *mut SmartCardCryptogramAlgorithm) -> HRESULT,
    fn put_Algorithm(&self, value: SmartCardCryptogramAlgorithm) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SourceData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SourceData(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_CryptogramMaterialPackageName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CryptogramMaterialPackageName(&self, value: HSTRING) -> HRESULT,
    fn get_CryptogramMaterialName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CryptogramMaterialName(&self, value: HSTRING) -> HRESULT,
    fn get_TemplateOffset(&self, out: *mut i32) -> HRESULT,
    fn put_TemplateOffset(&self, value: i32) -> HRESULT,
    fn get_CryptogramOffset(&self, out: *mut i32) -> HRESULT,
    fn put_CryptogramOffset(&self, value: i32) -> HRESULT,
    fn get_CryptogramLength(&self, out: *mut i32) -> HRESULT,
    fn put_CryptogramLength(&self, value: i32) -> HRESULT,
    fn get_CryptogramPlacementOptions(&self, out: *mut SmartCardCryptogramPlacementOptions) -> HRESULT,
    fn put_CryptogramPlacementOptions(&self, value: SmartCardCryptogramPlacementOptions) -> HRESULT,
    fn get_ChainedOutputStep(&self, out: *mut <SmartCardCryptogramPlacementStep as RtType>::Abi) -> HRESULT,
    fn put_ChainedOutputStep(&self, value: <SmartCardCryptogramPlacementStep as RtType>::Abi) -> HRESULT
}}
impl ISmartCardCryptogramPlacementStep {
    #[inline] pub fn get_algorithm(&self) -> Result<SmartCardCryptogramAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Algorithm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_algorithm(&self, value: SmartCardCryptogramAlgorithm) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Algorithm)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_source_data(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SourceData)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_material_package_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CryptogramMaterialPackageName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_material_package_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CryptogramMaterialPackageName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_material_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CryptogramMaterialName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_material_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CryptogramMaterialName)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_template_offset(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TemplateOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_template_offset(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TemplateOffset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_offset(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CryptogramOffset)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_offset(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CryptogramOffset)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CryptogramLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CryptogramLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_placement_options(&self) -> Result<SmartCardCryptogramPlacementOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CryptogramPlacementOptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_placement_options(&self, value: SmartCardCryptogramPlacementOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CryptogramPlacementOptions)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_chained_output_step(&self) -> Result<Option<SmartCardCryptogramPlacementStep>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChainedOutputStep)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardCryptogramPlacementStep::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_chained_output_step(&self, value: &SmartCardCryptogramPlacementStep) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChainedOutputStep)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramPlacementStep: ISmartCardCryptogramPlacementStep}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramPlacementStep {}
DEFINE_CLSID!(SmartCardCryptogramPlacementStep(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,80,108,97,99,101,109,101,110,116,83,116,101,112,0]) [CLSID_SmartCardCryptogramPlacementStep]);
RT_ENUM! { enum SmartCardCryptogramStorageKeyAlgorithm: i32 {
    None = 0, Rsa2048 = 1,
}}
RT_ENUM! { enum SmartCardCryptogramStorageKeyCapabilities: u32 {
    None = 0, HardwareProtection = 1, UnlockPrompt = 2,
}}
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyCharacteristics, 2236765294, 17495, 18469, 180, 100, 99, 84, 113, 163, 159, 92);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyCharacteristics(ISmartCardCryptogramStorageKeyCharacteristicsVtbl, ISmartCardCryptogramStorageKeyCharacteristics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyCharacteristics] {
    fn get_StorageKeyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DateCreated(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Algorithm(&self, out: *mut SmartCardCryptogramStorageKeyAlgorithm) -> HRESULT,
    fn get_Capabilities(&self, out: *mut SmartCardCryptogramStorageKeyCapabilities) -> HRESULT
}}
impl ISmartCardCryptogramStorageKeyCharacteristics {
    #[inline] pub fn get_storage_key_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StorageKeyName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_created(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DateCreated)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_algorithm(&self) -> Result<SmartCardCryptogramStorageKeyAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Algorithm)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<SmartCardCryptogramStorageKeyCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramStorageKeyCharacteristics: ISmartCardCryptogramStorageKeyCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramStorageKeyCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramStorageKeyCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,83,116,111,114,97,103,101,75,101,121,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramStorageKeyCharacteristics]);
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyInfo, 2008084493, 45207, 20321, 162, 106, 149, 97, 99, 156, 156, 58);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyInfo(ISmartCardCryptogramStorageKeyInfoVtbl, ISmartCardCryptogramStorageKeyInfo_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyInfo] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PublicKeyBlobType(&self, out: *mut super::super::security::cryptography::core::CryptographicPublicKeyBlobType) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PublicKey(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_AttestationStatus(&self, out: *mut SmartCardCryptographicKeyAttestationStatus) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Attestation(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AttestationCertificateChain(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Capabilities(&self, out: *mut SmartCardCryptogramStorageKeyCapabilities) -> HRESULT
}}
impl ISmartCardCryptogramStorageKeyInfo {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_public_key_blob_type(&self) -> Result<super::super::security::cryptography::core::CryptographicPublicKeyBlobType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PublicKeyBlobType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_public_key(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PublicKey)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_attestation_status(&self) -> Result<SmartCardCryptographicKeyAttestationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttestationStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_attestation(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Attestation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_attestation_certificate_chain(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AttestationCertificateChain)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<SmartCardCryptogramStorageKeyCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Capabilities)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramStorageKeyInfo: ISmartCardCryptogramStorageKeyInfo}
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyInfo2, 278777, 63485, 16765, 137, 225, 251, 176, 56, 42, 220, 77);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyInfo2(ISmartCardCryptogramStorageKeyInfo2Vtbl, ISmartCardCryptogramStorageKeyInfo2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyInfo2] {
    fn get_OperationalRequirements(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISmartCardCryptogramStorageKeyInfo2 {
    #[inline] pub fn get_operational_requirements(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OperationalRequirements)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardCryptographicKeyAttestationStatus: i32 {
    NoAttestation = 0, SoftwareKeyWithoutTpm = 1, SoftwareKeyWithTpm = 2, TpmKeyUnknownAttestationStatus = 3, TpmKeyWithoutAttestationCapability = 4, TpmKeyWithTemporaryAttestationFailure = 5, TpmKeyWithLongTermAttestationFailure = 6, TpmKeyWithAttestation = 7,
}}
RT_ENUM! { enum SmartCardEmulationCategory: i32 {
    Other = 0, Payment = 1,
}}
RT_ENUM! { enum SmartCardEmulationType: i32 {
    Host = 0, Uicc = 1, EmbeddedSE = 2,
}}
DEFINE_IID!(IID_ISmartCardEmulator, 3753445042, 34654, 18405, 128, 119, 232, 191, 241, 177, 198, 251);
RT_INTERFACE!{interface ISmartCardEmulator(ISmartCardEmulatorVtbl, ISmartCardEmulator_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulator] {
    fn get_EnablementPolicy(&self, out: *mut SmartCardEmulatorEnablementPolicy) -> HRESULT
}}
impl ISmartCardEmulator {
    #[inline] pub fn get_enablement_policy(&self) -> Result<SmartCardEmulatorEnablementPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EnablementPolicy)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulator: ISmartCardEmulator}
impl RtActivatable<ISmartCardEmulatorStatics> for SmartCardEmulator {}
impl RtActivatable<ISmartCardEmulatorStatics2> for SmartCardEmulator {}
impl RtActivatable<ISmartCardEmulatorStatics3> for SmartCardEmulator {}
impl SmartCardEmulator {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<SmartCardEmulator>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_applet_id_group_registrations_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().get_applet_id_group_registrations_async()
    }
    #[inline] pub fn register_applet_id_group_async(appletIdGroup: &SmartCardAppletIdGroup) -> Result<foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().register_applet_id_group_async(appletIdGroup)
    }
    #[inline] pub fn unregister_applet_id_group_async(registration: &SmartCardAppletIdGroupRegistration) -> Result<foundation::IAsyncAction> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().unregister_applet_id_group_async(registration)
    }
    #[inline] pub fn get_max_applet_id_group_registrations() -> Result<u16> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().get_max_applet_id_group_registrations()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<ISmartCardEmulatorStatics3>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(SmartCardEmulator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,69,109,117,108,97,116,111,114,0]) [CLSID_SmartCardEmulator]);
DEFINE_IID!(IID_ISmartCardEmulator2, 4265590968, 34089, 16666, 128, 123, 72, 237, 194, 160, 171, 68);
RT_INTERFACE!{interface ISmartCardEmulator2(ISmartCardEmulator2Vtbl, ISmartCardEmulator2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulator2] {
    fn add_ApduReceived(&self, value: <foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorApduReceivedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ApduReceived(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionDeactivated(&self, value: <foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorConnectionDeactivatedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionDeactivated(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn IsHostCardEmulationSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISmartCardEmulator2 {
    #[inline] pub fn add_apdu_received(&self, value: &foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorApduReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ApduReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_apdu_received(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ApduReceived)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_deactivated(&self, value: &foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorConnectionDeactivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConnectionDeactivated)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_deactivated(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConnectionDeactivated)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_host_card_emulation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsHostCardEmulationSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgs, 3579647350, 27090, 21299, 91, 95, 248, 192, 214, 233, 240, 159);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgs(ISmartCardEmulatorApduReceivedEventArgsVtbl, ISmartCardEmulatorApduReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_CommandApdu(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ConnectionProperties(&self, out: *mut <SmartCardEmulatorConnectionProperties as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn TryRespondAsync(&self, responseApdu: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn get_AutomaticResponseStatus(&self, out: *mut SmartCardAutomaticResponseStatus) -> HRESULT
}}
impl ISmartCardEmulatorApduReceivedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CommandApdu)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_properties(&self) -> Result<Option<SmartCardEmulatorConnectionProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardEmulatorConnectionProperties::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_async(&self, responseApdu: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRespondAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(responseApdu) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_automatic_response_status(&self) -> Result<SmartCardAutomaticResponseStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutomaticResponseStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorApduReceivedEventArgs: ISmartCardEmulatorApduReceivedEventArgs}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgs2, 2348367344, 8929, 16952, 134, 16, 148, 206, 74, 150, 84, 37);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgs2(ISmartCardEmulatorApduReceivedEventArgs2Vtbl, ISmartCardEmulatorApduReceivedEventArgs2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgs2] {
    fn get_State(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRespondWithStateAsync(&self, responseApdu: <super::super::storage::streams::IBuffer as RtType>::Abi, nextState: <foundation::IReference<u32> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardEmulatorApduReceivedEventArgs2 {
    #[inline] pub fn get_state(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_State)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_state_async(&self, responseApdu: &super::super::storage::streams::IBuffer, nextState: &foundation::IReference<u32>) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRespondWithStateAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(responseApdu) as *const _ as *mut _, get_abi(nextState) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgsWithCryptograms, 3578837703, 47039, 20009, 146, 148, 12, 74, 195, 201, 65, 189);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgsWithCryptograms(ISmartCardEmulatorApduReceivedEventArgsWithCryptogramsVtbl, ISmartCardEmulatorApduReceivedEventArgsWithCryptograms_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgsWithCryptograms] {
    #[cfg(feature="windows-storage")] fn TryRespondWithCryptogramsAsync(&self, responseTemplate: <super::super::storage::streams::IBuffer as RtType>::Abi, cryptogramPlacementSteps: <foundation::collections::IIterable<SmartCardCryptogramPlacementStep> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRespondWithCryptogramsAndStateAsync(&self, responseTemplate: <super::super::storage::streams::IBuffer as RtType>::Abi, cryptogramPlacementSteps: <foundation::collections::IIterable<SmartCardCryptogramPlacementStep> as RtType>::Abi, nextState: <foundation::IReference<u32> as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardEmulatorApduReceivedEventArgsWithCryptograms {
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_cryptograms_async(&self, responseTemplate: &super::super::storage::streams::IBuffer, cryptogramPlacementSteps: &foundation::collections::IIterable<SmartCardCryptogramPlacementStep>) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRespondWithCryptogramsAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(responseTemplate) as *const _ as *mut _, get_abi(cryptogramPlacementSteps) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_cryptograms_and_state_async(&self, responseTemplate: &super::super::storage::streams::IBuffer, cryptogramPlacementSteps: &foundation::collections::IIterable<SmartCardCryptogramPlacementStep>, nextState: &foundation::IReference<u32>) -> Result<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryRespondWithCryptogramsAndStateAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(responseTemplate) as *const _ as *mut _, get_abi(cryptogramPlacementSteps) as *const _ as *mut _, get_abi(nextState) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorConnectionDeactivatedEventArgs, 562485459, 50667, 21090, 67, 223, 98, 160, 161, 181, 85, 87);
RT_INTERFACE!{interface ISmartCardEmulatorConnectionDeactivatedEventArgs(ISmartCardEmulatorConnectionDeactivatedEventArgsVtbl, ISmartCardEmulatorConnectionDeactivatedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorConnectionDeactivatedEventArgs] {
    fn get_ConnectionProperties(&self, out: *mut <SmartCardEmulatorConnectionProperties as RtType>::Abi) -> HRESULT,
    fn get_Reason(&self, out: *mut SmartCardEmulatorConnectionDeactivatedReason) -> HRESULT
}}
impl ISmartCardEmulatorConnectionDeactivatedEventArgs {
    #[inline] pub fn get_connection_properties(&self) -> Result<Option<SmartCardEmulatorConnectionProperties>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionProperties)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardEmulatorConnectionProperties::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<SmartCardEmulatorConnectionDeactivatedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Reason)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorConnectionDeactivatedEventArgs: ISmartCardEmulatorConnectionDeactivatedEventArgs}
RT_ENUM! { enum SmartCardEmulatorConnectionDeactivatedReason: i32 {
    ConnectionLost = 0, ConnectionRedirected = 1,
}}
DEFINE_IID!(IID_ISmartCardEmulatorConnectionProperties, 1311548910, 63849, 20605, 108, 249, 52, 226, 209, 141, 243, 17);
RT_INTERFACE!{interface ISmartCardEmulatorConnectionProperties(ISmartCardEmulatorConnectionPropertiesVtbl, ISmartCardEmulatorConnectionProperties_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorConnectionProperties] {
    fn get_Id(&self, out: *mut Guid) -> HRESULT,
    fn get_Source(&self, out: *mut SmartCardEmulatorConnectionSource) -> HRESULT
}}
impl ISmartCardEmulatorConnectionProperties {
    #[inline] pub fn get_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<SmartCardEmulatorConnectionSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Source)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorConnectionProperties: ISmartCardEmulatorConnectionProperties}
RT_ENUM! { enum SmartCardEmulatorConnectionSource: i32 {
    Unknown = 0, NfcReader = 1,
}}
RT_ENUM! { enum SmartCardEmulatorEnablementPolicy: i32 {
    Never = 0, Always = 1, ScreenOn = 2, ScreenUnlocked = 3,
}}
DEFINE_IID!(IID_ISmartCardEmulatorStatics, 2057043019, 50387, 18767, 184, 162, 98, 21, 216, 30, 133, 178);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics(ISmartCardEmulatorStaticsVtbl, ISmartCardEmulatorStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardEmulator> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardEmulatorStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<SmartCardEmulator>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorStatics2, 1773051786, 46965, 18571, 132, 54, 108, 30, 40, 237, 115, 31);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics2(ISmartCardEmulatorStatics2Vtbl, ISmartCardEmulatorStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics2] {
    fn GetAppletIdGroupRegistrationsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>> as RtType>::Abi) -> HRESULT,
    fn RegisterAppletIdGroupAsync(&self, appletIdGroup: <SmartCardAppletIdGroup as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration> as RtType>::Abi) -> HRESULT,
    fn UnregisterAppletIdGroupAsync(&self, registration: <SmartCardAppletIdGroupRegistration as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_MaxAppletIdGroupRegistrations(&self, out: *mut u16) -> HRESULT
}}
impl ISmartCardEmulatorStatics2 {
    #[inline] pub fn get_applet_id_group_registrations_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAppletIdGroupRegistrationsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn register_applet_id_group_async(&self, appletIdGroup: &SmartCardAppletIdGroup) -> Result<foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RegisterAppletIdGroupAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(appletIdGroup) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister_applet_id_group_async(&self, registration: &SmartCardAppletIdGroupRegistration) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).UnregisterAppletIdGroupAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(registration) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_applet_id_group_registrations(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxAppletIdGroupRegistrations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorStatics3, 1508512810, 40713, 17397, 133, 101, 207, 168, 20, 142, 76, 178);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics3(ISmartCardEmulatorStatics3Vtbl, ISmartCardEmulatorStatics3_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics3] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISmartCardEmulatorStatics3 {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).IsSupported)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardLaunchBehavior: i32 {
    Default = 0, AboveLock = 1,
}}
RT_ENUM! { enum SmartCardPinCharacterPolicyOption: i32 {
    Allow = 0, RequireAtLeastOne = 1, Disallow = 2,
}}
DEFINE_IID!(IID_ISmartCardPinPolicy, 406643076, 19894, 18497, 172, 158, 42, 193, 243, 155, 115, 4);
RT_INTERFACE!{interface ISmartCardPinPolicy(ISmartCardPinPolicyVtbl, ISmartCardPinPolicy_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardPinPolicy] {
    fn get_MinLength(&self, out: *mut u32) -> HRESULT,
    fn put_MinLength(&self, value: u32) -> HRESULT,
    fn get_MaxLength(&self, out: *mut u32) -> HRESULT,
    fn put_MaxLength(&self, value: u32) -> HRESULT,
    fn get_UppercaseLetters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_UppercaseLetters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_LowercaseLetters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_LowercaseLetters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_Digits(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_Digits(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_SpecialCharacters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_SpecialCharacters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT
}}
impl ISmartCardPinPolicy {
    #[inline] pub fn get_min_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MinLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_MaxLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uppercase_letters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UppercaseLetters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_uppercase_letters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_UppercaseLetters)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_lowercase_letters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_LowercaseLetters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_lowercase_letters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_LowercaseLetters)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_digits(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Digits)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_digits(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Digits)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_special_characters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SpecialCharacters)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_special_characters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SpecialCharacters)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinPolicy: ISmartCardPinPolicy}
impl RtActivatable<IActivationFactory> for SmartCardPinPolicy {}
DEFINE_CLSID!(SmartCardPinPolicy(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,80,105,110,80,111,108,105,99,121,0]) [CLSID_SmartCardPinPolicy]);
DEFINE_IID!(IID_ISmartCardPinResetDeferral, 415845036, 30725, 16388, 133, 228, 187, 239, 172, 143, 104, 132);
RT_INTERFACE!{interface ISmartCardPinResetDeferral(ISmartCardPinResetDeferralVtbl, ISmartCardPinResetDeferral_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISmartCardPinResetDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Complete)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinResetDeferral: ISmartCardPinResetDeferral}
DEFINE_IID!(IID_SmartCardPinResetHandler, 328031808, 62396, 19036, 180, 29, 75, 78, 246, 132, 226, 55);
RT_DELEGATE!{delegate SmartCardPinResetHandler(SmartCardPinResetHandlerVtbl, SmartCardPinResetHandler_Abi, SmartCardPinResetHandlerImpl) [IID_SmartCardPinResetHandler] {
    fn Invoke(&self, sender: <SmartCardProvisioning as RtType>::Abi, request: <SmartCardPinResetRequest as RtType>::Abi) -> HRESULT
}}
impl SmartCardPinResetHandler {
    #[inline] pub fn invoke(&self, sender: &SmartCardProvisioning, request: &SmartCardPinResetRequest) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(request) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardPinResetRequest, 318651469, 24505, 20110, 159, 246, 97, 244, 117, 18, 79, 239);
RT_INTERFACE!{interface ISmartCardPinResetRequest(ISmartCardPinResetRequestVtbl, ISmartCardPinResetRequest_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetRequest] {
    #[cfg(feature="windows-storage")] fn get_Challenge(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetDeferral(&self, out: *mut <SmartCardPinResetDeferral as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetResponse(&self, response: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl ISmartCardPinResetRequest {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_challenge(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Challenge)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Deadline)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<SmartCardPinResetDeferral>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeferral)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardPinResetDeferral::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_response(&self, response: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetResponse)(self.0.as_abi() as *const _ as *mut _, get_abi(response) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinResetRequest: ISmartCardPinResetRequest}
DEFINE_IID!(IID_ISmartCardProvisioning, 435088829, 8107, 18300, 183, 18, 26, 44, 90, 241, 253, 110);
RT_INTERFACE!{interface ISmartCardProvisioning(ISmartCardProvisioningVtbl, ISmartCardProvisioning_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning] {
    fn get_SmartCard(&self, out: *mut <SmartCard as RtType>::Abi) -> HRESULT,
    fn GetIdAsync(&self, out: *mut <foundation::IAsyncOperation<Guid> as RtType>::Abi) -> HRESULT,
    fn GetNameAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT,
    fn GetChallengeContextAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardChallengeContext> as RtType>::Abi) -> HRESULT,
    fn RequestPinChangeAsync(&self, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn RequestPinResetAsync(&self, handler: <SmartCardPinResetHandler as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardProvisioning {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<SmartCard>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCard)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCard::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id_async(&self) -> Result<foundation::IAsyncOperation<Guid>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetIdAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetNameAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_challenge_context_async(&self) -> Result<foundation::IAsyncOperation<SmartCardChallengeContext>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetChallengeContextAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_change_async(&self) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestPinChangeAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_reset_async(&self, handler: &SmartCardPinResetHandler) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestPinResetAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardProvisioning: ISmartCardProvisioning}
impl RtActivatable<ISmartCardProvisioningStatics> for SmartCardProvisioning {}
impl RtActivatable<ISmartCardProvisioningStatics2> for SmartCardProvisioning {}
impl SmartCardProvisioning {
    #[inline] pub fn from_smart_card_async(card: &SmartCard) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().from_smart_card_async(card)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async(friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_creation_async(friendlyName, administrativeKey, pinPolicy)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async_with_card_id(friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: Guid) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_creation_async_with_card_id(friendlyName, administrativeKey, pinPolicy, cardId)
    }
    #[inline] pub fn request_virtual_smart_card_deletion_async(card: &SmartCard) -> Result<foundation::IAsyncOperation<bool>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_deletion_async(card)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async(friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics2>>::get_activation_factory().request_attested_virtual_smart_card_creation_async(friendlyName, administrativeKey, pinPolicy)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async_with_card_id(friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: Guid) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics2>>::get_activation_factory().request_attested_virtual_smart_card_creation_async_with_card_id(friendlyName, administrativeKey, pinPolicy, cardId)
    }
}
DEFINE_CLSID!(SmartCardProvisioning(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,80,114,111,118,105,115,105,111,110,105,110,103,0]) [CLSID_SmartCardProvisioning]);
DEFINE_IID!(IID_ISmartCardProvisioning2, 285026539, 16249, 19302, 155, 124, 17, 193, 73, 183, 208, 188);
RT_INTERFACE!{interface ISmartCardProvisioning2(ISmartCardProvisioning2Vtbl, ISmartCardProvisioning2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning2] {
    fn GetAuthorityKeyContainerNameAsync(&self, out: *mut <foundation::IAsyncOperation<HString> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardProvisioning2 {
    #[inline] pub fn get_authority_key_container_name_async(&self) -> Result<foundation::IAsyncOperation<HString>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetAuthorityKeyContainerNameAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardProvisioningStatics, 327690312, 3347, 20080, 151, 53, 81, 218, 236, 165, 37, 79);
RT_INTERFACE!{static interface ISmartCardProvisioningStatics(ISmartCardProvisioningStaticsVtbl, ISmartCardProvisioningStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics] {
    fn FromSmartCardAsync(&self, card: <SmartCard as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardProvisioning> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn RequestVirtualSmartCardCreationAsync(&self, friendlyName: HSTRING, administrativeKey: <super::super::storage::streams::IBuffer as RtType>::Abi, pinPolicy: <SmartCardPinPolicy as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardProvisioning> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn RequestVirtualSmartCardCreationAsyncWithCardId(&self, friendlyName: HSTRING, administrativeKey: <super::super::storage::streams::IBuffer as RtType>::Abi, pinPolicy: <SmartCardPinPolicy as RtType>::Abi, cardId: Guid, out: *mut <foundation::IAsyncOperation<SmartCardProvisioning> as RtType>::Abi) -> HRESULT,
    fn RequestVirtualSmartCardDeletionAsync(&self, card: <SmartCard as RtType>::Abi, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardProvisioningStatics {
    #[inline] pub fn from_smart_card_async(&self, card: &SmartCard) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromSmartCardAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(card) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async(&self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestVirtualSmartCardCreationAsync)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), get_abi(administrativeKey) as *const _ as *mut _, get_abi(pinPolicy) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async_with_card_id(&self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: Guid) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestVirtualSmartCardCreationAsyncWithCardId)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), get_abi(administrativeKey) as *const _ as *mut _, get_abi(pinPolicy) as *const _ as *mut _, cardId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_virtual_smart_card_deletion_async(&self, card: &SmartCard) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestVirtualSmartCardDeletionAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(card) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardProvisioningStatics2, 877119144, 51616, 19414, 181, 13, 37, 31, 78, 141, 58, 98);
RT_INTERFACE!{static interface ISmartCardProvisioningStatics2(ISmartCardProvisioningStatics2Vtbl, ISmartCardProvisioningStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics2] {
    #[cfg(feature="windows-storage")] fn RequestAttestedVirtualSmartCardCreationAsync(&self, friendlyName: HSTRING, administrativeKey: <super::super::storage::streams::IBuffer as RtType>::Abi, pinPolicy: <SmartCardPinPolicy as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmartCardProvisioning> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn RequestAttestedVirtualSmartCardCreationAsyncWithCardId(&self, friendlyName: HSTRING, administrativeKey: <super::super::storage::streams::IBuffer as RtType>::Abi, pinPolicy: <SmartCardPinPolicy as RtType>::Abi, cardId: Guid, out: *mut <foundation::IAsyncOperation<SmartCardProvisioning> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardProvisioningStatics2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async(&self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAttestedVirtualSmartCardCreationAsync)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), get_abi(administrativeKey) as *const _ as *mut _, get_abi(pinPolicy) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async_with_card_id(&self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: Guid) -> Result<foundation::IAsyncOperation<SmartCardProvisioning>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAttestedVirtualSmartCardCreationAsyncWithCardId)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), get_abi(administrativeKey) as *const _ as *mut _, get_abi(pinPolicy) as *const _ as *mut _, cardId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardReader, 276083936, 21698, 19952, 129, 122, 20, 193, 67, 120, 240, 108);
RT_INTERFACE!{interface ISmartCardReader(ISmartCardReaderVtbl, ISmartCardReader_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut SmartCardReaderKind) -> HRESULT,
    fn GetStatusAsync(&self, out: *mut <foundation::IAsyncOperation<SmartCardReaderStatus> as RtType>::Abi) -> HRESULT,
    fn FindAllCardsAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCard>> as RtType>::Abi) -> HRESULT,
    fn add_CardAdded(&self, handler: <foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CardAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CardRemoved(&self, handler: <foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CardRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISmartCardReader {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Name)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<SmartCardReaderKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Kind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status_async(&self) -> Result<foundation::IAsyncOperation<SmartCardReaderStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetStatusAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_cards_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllCardsAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_card_added(&self, handler: &foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CardAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_card_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CardAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_card_removed(&self, handler: &foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_CardRemoved)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_card_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_CardRemoved)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardReader: ISmartCardReader}
impl RtActivatable<ISmartCardReaderStatics> for SmartCardReader {}
impl SmartCardReader {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_kind(kind: SmartCardReaderKind) -> Result<HString> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().get_device_selector_with_kind(kind)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardReader>> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SmartCardReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,82,101,97,100,101,114,0]) [CLSID_SmartCardReader]);
RT_ENUM! { enum SmartCardReaderKind: i32 {
    Any = 0, Generic = 1, Tpm = 2, Nfc = 3, Uicc = 4, EmbeddedSE = 5,
}}
DEFINE_IID!(IID_ISmartCardReaderStatics, 272368865, 41418, 18674, 162, 129, 91, 111, 102, 154, 241, 7);
RT_INTERFACE!{static interface ISmartCardReaderStatics(ISmartCardReaderStaticsVtbl, ISmartCardReaderStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardReaderStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithKind(&self, kind: SmartCardReaderKind, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<SmartCardReader> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardReaderStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_kind(&self, kind: SmartCardReaderKind) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorWithKind)(self.0.as_abi() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SmartCardReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardReaderStatus: i32 {
    Disconnected = 0, Ready = 1, Exclusive = 2,
}}
RT_ENUM! { enum SmartCardStatus: i32 {
    Disconnected = 0, Ready = 1, Shared = 2, Exclusive = 3, Unresponsive = 4,
}}
DEFINE_IID!(IID_ISmartCardTriggerDetails, 1604055326, 14831, 20267, 180, 79, 10, 145, 85, 177, 119, 188);
RT_INTERFACE!{interface ISmartCardTriggerDetails(ISmartCardTriggerDetailsVtbl, ISmartCardTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails] {
    fn get_TriggerType(&self, out: *mut SmartCardTriggerType) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SourceAppletId(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_TriggerData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl ISmartCardTriggerDetails {
    #[inline] pub fn get_trigger_type(&self) -> Result<SmartCardTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TriggerType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_applet_id(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SourceAppletId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_trigger_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TriggerData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardTriggerDetails: ISmartCardTriggerDetails}
DEFINE_IID!(IID_ISmartCardTriggerDetails2, 692438377, 35189, 19025, 158, 26, 95, 138, 118, 238, 81, 175);
RT_INTERFACE!{interface ISmartCardTriggerDetails2(ISmartCardTriggerDetails2Vtbl, ISmartCardTriggerDetails2_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails2] {
    fn get_Emulator(&self, out: *mut <SmartCardEmulator as RtType>::Abi) -> HRESULT,
    fn TryLaunchCurrentAppAsync(&self, arguments: HSTRING, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT,
    fn TryLaunchCurrentAppWithBehaviorAsync(&self, arguments: HSTRING, behavior: SmartCardLaunchBehavior, out: *mut <foundation::IAsyncOperation<bool> as RtType>::Abi) -> HRESULT
}}
impl ISmartCardTriggerDetails2 {
    #[inline] pub fn get_emulator(&self) -> Result<Option<SmartCardEmulator>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Emulator)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCardEmulator::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_launch_current_app_async(&self, arguments: &HStringArg) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryLaunchCurrentAppAsync)(self.0.as_abi() as *const _ as *mut _, arguments.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_launch_current_app_with_behavior_async(&self, arguments: &HStringArg, behavior: SmartCardLaunchBehavior) -> Result<foundation::IAsyncOperation<bool>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).TryLaunchCurrentAppWithBehaviorAsync)(self.0.as_abi() as *const _ as *mut _, arguments.get(), behavior, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardTriggerDetails3, 3017982589, 6342, 19368, 131, 118, 239, 3, 212, 145, 38, 102);
RT_INTERFACE!{interface ISmartCardTriggerDetails3(ISmartCardTriggerDetails3Vtbl, ISmartCardTriggerDetails3_Abi): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails3] {
    fn get_SmartCard(&self, out: *mut <SmartCard as RtType>::Abi) -> HRESULT
}}
impl ISmartCardTriggerDetails3 {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<SmartCard>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmartCard)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmartCard::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardTriggerType: i32 {
    EmulatorTransaction = 0, EmulatorNearFieldEntry = 1, EmulatorNearFieldExit = 2, EmulatorHostApplicationActivated = 3, EmulatorAppletIdGroupRegistrationChanged = 4, ReaderCardAdded = 5,
}}
RT_ENUM! { enum SmartCardUnlockPromptingBehavior: i32 {
    AllowUnlockPrompt = 0, RequireUnlockPrompt = 1, PreventUnlockPrompt = 2,
}}
} // Windows.Devices.SmartCards
pub mod sms { // Windows.Devices.Sms
use crate::prelude::*;
RT_ENUM! { enum CellularClass: i32 {
    None = 0, Gsm = 1, Cdma = 2,
}}
RT_CLASS!{class DeleteSmsMessageOperation: foundation::IAsyncAction}
RT_CLASS!{class DeleteSmsMessagesOperation: foundation::IAsyncAction}
RT_CLASS!{class GetSmsDeviceOperation: foundation::IAsyncOperation<SmsDevice>}
RT_CLASS!{class GetSmsMessageOperation: foundation::IAsyncOperation<ISmsMessage>}
RT_CLASS!{class GetSmsMessagesOperation: foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32>}
RT_CLASS!{class SendSmsMessageOperation: foundation::IAsyncAction}
DEFINE_IID!(IID_ISmsAppMessage, 3904603284, 54176, 18954, 134, 215, 41, 16, 51, 168, 207, 84);
RT_INTERFACE!{interface ISmsAppMessage(ISmsAppMessageVtbl, ISmsAppMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsAppMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_CallbackNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallbackNumber(&self, value: HSTRING) -> HRESULT,
    fn get_IsDeliveryNotificationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDeliveryNotificationEnabled(&self, value: bool) -> HRESULT,
    fn get_RetryAttemptCount(&self, out: *mut i32) -> HRESULT,
    fn put_RetryAttemptCount(&self, value: i32) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn get_PortNumber(&self, out: *mut i32) -> HRESULT,
    fn put_PortNumber(&self, value: i32) -> HRESULT,
    fn get_TeleserviceId(&self, out: *mut i32) -> HRESULT,
    fn put_TeleserviceId(&self, value: i32) -> HRESULT,
    fn get_ProtocolId(&self, out: *mut i32) -> HRESULT,
    fn put_ProtocolId(&self, value: i32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_BinaryBody(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_BinaryBody(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl ISmsAppMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_To)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_From)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Body)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_callback_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CallbackNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_callback_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CallbackNumber)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_delivery_notification_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDeliveryNotificationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_delivery_notification_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDeliveryNotificationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_retry_attempt_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RetryAttemptCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_retry_attempt_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RetryAttemptCount)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Encoding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Encoding)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_port_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PortNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_port_number(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PortNumber)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TeleserviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_teleservice_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_TeleserviceId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protocol_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProtocolId)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_binary_body(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BinaryBody)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_binary_body(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_BinaryBody)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsAppMessage: ISmsAppMessage}
impl RtActivatable<IActivationFactory> for SmsAppMessage {}
DEFINE_CLSID!(SmsAppMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,65,112,112,77,101,115,115,97,103,101,0]) [CLSID_SmsAppMessage]);
DEFINE_IID!(IID_ISmsBinaryMessage, 1542776851, 15187, 19566, 182, 26, 216, 106, 99, 117, 86, 80);
RT_INTERFACE!{interface ISmsBinaryMessage(ISmsBinaryMessageVtbl, ISmsBinaryMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsBinaryMessage] {
    fn get_Format(&self, out: *mut SmsDataFormat) -> HRESULT,
    fn put_Format(&self, value: SmsDataFormat) -> HRESULT,
    fn GetData(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn SetData(&self, valueSize: u32, value: *mut u8) -> HRESULT
}}
impl ISmsBinaryMessage {
    #[inline] pub fn get_format(&self) -> Result<SmsDataFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Format)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: SmsDataFormat) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Format)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetData)(self.0.as_abi() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).SetData)(self.0.as_abi() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsBinaryMessage: ISmsBinaryMessage}
impl RtActivatable<IActivationFactory> for SmsBinaryMessage {}
DEFINE_CLSID!(SmsBinaryMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,66,105,110,97,114,121,77,101,115,115,97,103,101,0]) [CLSID_SmsBinaryMessage]);
DEFINE_IID!(IID_ISmsBroadcastMessage, 1974385649, 58551, 18548, 160, 156, 41, 86, 229, 146, 249, 87);
RT_INTERFACE!{interface ISmsBroadcastMessage(ISmsBroadcastMessageVtbl, ISmsBroadcastMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsBroadcastMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Channel(&self, out: *mut i32) -> HRESULT,
    fn get_GeographicalScope(&self, out: *mut SmsGeographicalScope) -> HRESULT,
    fn get_MessageCode(&self, out: *mut i32) -> HRESULT,
    fn get_UpdateNumber(&self, out: *mut i32) -> HRESULT,
    fn get_BroadcastType(&self, out: *mut SmsBroadcastType) -> HRESULT,
    fn get_IsEmergencyAlert(&self, out: *mut bool) -> HRESULT,
    fn get_IsUserPopupRequested(&self, out: *mut bool) -> HRESULT
}}
impl ISmsBroadcastMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_channel(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Channel)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geographical_scope(&self) -> Result<SmsGeographicalScope> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GeographicalScope)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_update_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_UpdateNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_type(&self) -> Result<SmsBroadcastType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_emergency_alert(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEmergencyAlert)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_user_popup_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsUserPopupRequested)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsBroadcastMessage: ISmsBroadcastMessage}
RT_ENUM! { enum SmsBroadcastType: i32 {
    Other = 0, CmasPresidential = 1, CmasExtreme = 2, CmasSevere = 3, CmasAmber = 4, CmasTest = 5, EUAlert1 = 6, EUAlert2 = 7, EUAlert3 = 8, EUAlertAmber = 9, EUAlertInfo = 10, EtwsEarthquake = 11, EtwsTsunami = 12, EtwsTsunamiAndEarthquake = 13, LatAlertLocal = 14,
}}
RT_ENUM! { enum SmsDataFormat: i32 {
    Unknown = 0, CdmaSubmit = 1, GsmSubmit = 2, CdmaDeliver = 3, GsmDeliver = 4,
}}
DEFINE_IID!(IID_ISmsDevice, 152539629, 34603, 20204, 156, 114, 171, 17, 98, 123, 52, 236);
RT_INTERFACE!{interface ISmsDevice(ISmsDeviceVtbl, ISmsDevice_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDevice] {
    fn SendMessageAsync(&self, message: <ISmsMessage as RtType>::Abi, out: *mut <SendSmsMessageOperation as RtType>::Abi) -> HRESULT,
    fn CalculateLength(&self, message: <SmsTextMessage as RtType>::Abi, out: *mut SmsEncodedLength) -> HRESULT,
    fn get_AccountPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_MessageStore(&self, out: *mut <SmsDeviceMessageStore as RtType>::Abi) -> HRESULT,
    fn get_DeviceStatus(&self, out: *mut SmsDeviceStatus) -> HRESULT,
    fn add_SmsMessageReceived(&self, eventHandler: <SmsMessageReceivedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SmsMessageReceived(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SmsDeviceStatusChanged(&self, eventHandler: <SmsDeviceStatusChangedEventHandler as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SmsDeviceStatusChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISmsDevice {
    #[inline] pub fn send_message_async(&self, message: &ISmsMessage) -> Result<SendSmsMessageOperation> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendMessageAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(message) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SendSmsMessageOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn calculate_length(&self, message: &SmsTextMessage) -> Result<SmsEncodedLength> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CalculateLength)(self.0.as_abi() as *const _ as *mut _, get_abi(message) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_account_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccountPhoneNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CellularClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_store(&self) -> Result<Option<SmsDeviceMessageStore>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageStore)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsDeviceMessageStore::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_status(&self) -> Result<SmsDeviceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_sms_message_received(&self, eventHandler: &SmsMessageReceivedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SmsMessageReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sms_message_received(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SmsMessageReceived)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sms_device_status_changed(&self, eventHandler: &SmsDeviceStatusChangedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SmsDeviceStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sms_device_status_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SmsDeviceStatusChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDevice: ISmsDevice}
impl RtActivatable<ISmsDeviceStatics> for SmsDevice {}
impl RtActivatable<ISmsDeviceStatics2> for SmsDevice {}
impl SmsDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SmsDevice>> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<SmsDevice>> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_network_account_id_async(networkAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<SmsDevice>> {
        <Self as RtActivatable<ISmsDeviceStatics2>>::get_activation_factory().from_network_account_id_async(networkAccountId)
    }
}
DEFINE_CLSID!(SmsDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,0]) [CLSID_SmsDevice]);
DEFINE_IID!(IID_ISmsDevice2, 3179961363, 58658, 18123, 184, 213, 158, 173, 48, 251, 108, 71);
RT_INTERFACE!{interface ISmsDevice2(ISmsDevice2Vtbl, ISmsDevice2_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDevice2] {
    fn get_SmscAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SmscAddress(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AccountPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_DeviceStatus(&self, out: *mut SmsDeviceStatus) -> HRESULT,
    fn CalculateLength(&self, message: <ISmsMessageBase as RtType>::Abi, out: *mut SmsEncodedLength) -> HRESULT,
    fn SendMessageAndGetResultAsync(&self, message: <ISmsMessageBase as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SmsSendMessageResult> as RtType>::Abi) -> HRESULT,
    fn add_DeviceStatusChanged(&self, eventHandler: <foundation::TypedEventHandler<SmsDevice2, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeviceStatusChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISmsDevice2 {
    #[inline] pub fn get_smsc_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SmscAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_smsc_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SmscAddress)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ParentDeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_account_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AccountPhoneNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CellularClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_status(&self) -> Result<SmsDeviceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn calculate_length(&self, message: &ISmsMessageBase) -> Result<SmsEncodedLength> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).CalculateLength)(self.0.as_abi() as *const _ as *mut _, get_abi(message) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn send_message_and_get_result_async(&self, message: &ISmsMessageBase) -> Result<foundation::IAsyncOperation<SmsSendMessageResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendMessageAndGetResultAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(message) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_device_status_changed(&self, eventHandler: &foundation::TypedEventHandler<SmsDevice2, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DeviceStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_status_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DeviceStatusChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDevice2: ISmsDevice2}
impl RtActivatable<ISmsDevice2Statics> for SmsDevice2 {}
impl SmsDevice2 {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<SmsDevice2>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().from_id(deviceId)
    }
    #[inline] pub fn get_default() -> Result<Option<SmsDevice2>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn from_parent_id(parentDeviceId: &HStringArg) -> Result<Option<SmsDevice2>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().from_parent_id(parentDeviceId)
    }
}
DEFINE_CLSID!(SmsDevice2(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,50,0]) [CLSID_SmsDevice2]);
DEFINE_IID!(IID_ISmsDevice2Statics, 1707574053, 4145, 18718, 143, 182, 239, 153, 145, 175, 227, 99);
RT_INTERFACE!{static interface ISmsDevice2Statics(ISmsDevice2StaticsVtbl, ISmsDevice2Statics_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDevice2Statics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromId(&self, deviceId: HSTRING, out: *mut <SmsDevice2 as RtType>::Abi) -> HRESULT,
    fn GetDefault(&self, out: *mut <SmsDevice2 as RtType>::Abi) -> HRESULT,
    fn FromParentId(&self, parentDeviceId: HSTRING, out: *mut <SmsDevice2 as RtType>::Abi) -> HRESULT
}}
impl ISmsDevice2Statics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<SmsDevice2>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromId)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(SmsDevice2::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default(&self) -> Result<Option<SmsDevice2>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefault)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsDevice2::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parent_id(&self, parentDeviceId: &HStringArg) -> Result<Option<SmsDevice2>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromParentId)(self.0.as_abi() as *const _ as *mut _, parentDeviceId.get(), &mut out);
        if hr == S_OK { Ok(SmsDevice2::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsDeviceMessageStore, 2559177299, 61832, 17447, 141, 84, 206, 12, 36, 35, 197, 193);
RT_INTERFACE!{interface ISmsDeviceMessageStore(ISmsDeviceMessageStoreVtbl, ISmsDeviceMessageStore_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDeviceMessageStore] {
    fn DeleteMessageAsync(&self, messageId: u32, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn DeleteMessagesAsync(&self, messageFilter: SmsMessageFilter, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn GetMessageAsync(&self, messageId: u32, out: *mut <foundation::IAsyncOperation<ISmsMessage> as RtType>::Abi) -> HRESULT,
    fn GetMessagesAsync(&self, messageFilter: SmsMessageFilter, out: *mut <foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32> as RtType>::Abi) -> HRESULT,
    fn get_MaxMessages(&self, out: *mut u32) -> HRESULT
}}
impl ISmsDeviceMessageStore {
    #[inline] pub fn delete_message_async(&self, messageId: u32) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteMessageAsync)(self.0.as_abi() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_messages_async(&self, messageFilter: SmsMessageFilter) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).DeleteMessagesAsync)(self.0.as_abi() as *const _ as *mut _, messageFilter, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, messageId: u32) -> Result<foundation::IAsyncOperation<ISmsMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetMessageAsync)(self.0.as_abi() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_messages_async(&self, messageFilter: SmsMessageFilter) -> Result<foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetMessagesAsync)(self.0.as_abi() as *const _ as *mut _, messageFilter, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperationWithProgress::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_messages(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxMessages)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDeviceMessageStore: ISmsDeviceMessageStore}
DEFINE_IID!(IID_ISmsDeviceStatics, 4169992170, 55317, 19921, 162, 52, 69, 32, 206, 70, 4, 164);
RT_INTERFACE!{static interface ISmsDeviceStatics(ISmsDeviceStaticsVtbl, ISmsDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<SmsDevice> as RtType>::Abi) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<SmsDevice> as RtType>::Abi) -> HRESULT
}}
impl ISmsDeviceStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<SmsDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<SmsDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsDeviceStatics2, 748756103, 2163, 19631, 138, 125, 189, 71, 30, 133, 134, 209);
RT_INTERFACE!{static interface ISmsDeviceStatics2(ISmsDeviceStatics2Vtbl, ISmsDeviceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics2] {
    fn FromNetworkAccountIdAsync(&self, networkAccountId: HSTRING, out: *mut <foundation::IAsyncOperation<SmsDevice> as RtType>::Abi) -> HRESULT
}}
impl ISmsDeviceStatics2 {
    #[inline] pub fn from_network_account_id_async(&self, networkAccountId: &HStringArg) -> Result<foundation::IAsyncOperation<SmsDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromNetworkAccountIdAsync)(self.0.as_abi() as *const _ as *mut _, networkAccountId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsDeviceStatus: i32 {
    Off = 0, Ready = 1, SimNotInserted = 2, BadSim = 3, DeviceFailure = 4, SubscriptionNotActivated = 5, DeviceLocked = 6, DeviceBlocked = 7,
}}
DEFINE_IID!(IID_SmsDeviceStatusChangedEventHandler, 2552959330, 15831, 17944, 175, 137, 12, 39, 45, 93, 6, 216);
RT_DELEGATE!{delegate SmsDeviceStatusChangedEventHandler(SmsDeviceStatusChangedEventHandlerVtbl, SmsDeviceStatusChangedEventHandler_Abi, SmsDeviceStatusChangedEventHandlerImpl) [IID_SmsDeviceStatusChangedEventHandler] {
    fn Invoke(&self, sender: <SmsDevice as RtType>::Abi) -> HRESULT
}}
impl SmsDeviceStatusChangedEventHandler {
    #[inline] pub fn invoke(&self, sender: &SmsDevice) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_STRUCT! { struct SmsEncodedLength {
    SegmentCount: u32, CharacterCountLastSegment: u32, CharactersPerSegment: u32, ByteCountLastSegment: u32, BytesPerSegment: u32,
}}
RT_ENUM! { enum SmsEncoding: i32 {
    Unknown = 0, Optimal = 1, SevenBitAscii = 2, Unicode = 3, GsmSevenBit = 4, EightBit = 5, Latin = 6, Korean = 7, IA5 = 8, ShiftJis = 9, LatinHebrew = 10,
}}
RT_ENUM! { enum SmsFilterActionType: i32 {
    AcceptImmediately = 0, Drop = 1, Peek = 2, Accept = 3,
}}
DEFINE_IID!(IID_ISmsFilterRule, 1088630702, 45129, 20412, 175, 233, 226, 166, 16, 239, 245, 92);
RT_INTERFACE!{interface ISmsFilterRule(ISmsFilterRuleVtbl, ISmsFilterRule_Abi): IInspectable(IInspectableVtbl) [IID_ISmsFilterRule] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_ImsiPrefixes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_DeviceIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_SenderNumbers(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_TextMessagePrefixes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_PortNumbers(&self, out: *mut <foundation::collections::IVector<i32> as RtType>::Abi) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn put_CellularClass(&self, value: CellularClass) -> HRESULT,
    fn get_ProtocolIds(&self, out: *mut <foundation::collections::IVector<i32> as RtType>::Abi) -> HRESULT,
    fn get_TeleserviceIds(&self, out: *mut <foundation::collections::IVector<i32> as RtType>::Abi) -> HRESULT,
    fn get_WapApplicationIds(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_WapContentTypes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    fn get_BroadcastTypes(&self, out: *mut <foundation::collections::IVector<SmsBroadcastType> as RtType>::Abi) -> HRESULT,
    fn get_BroadcastChannels(&self, out: *mut <foundation::collections::IVector<i32> as RtType>::Abi) -> HRESULT
}}
impl ISmsFilterRule {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_imsi_prefixes(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ImsiPrefixes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sender_numbers(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SenderNumbers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_message_prefixes(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TextMessagePrefixes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_port_numbers(&self) -> Result<Option<foundation::collections::IVector<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PortNumbers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CellularClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cellular_class(&self, value: CellularClass) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CellularClass)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_ids(&self) -> Result<Option<foundation::collections::IVector<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_ids(&self) -> Result<Option<foundation::collections::IVector<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TeleserviceIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_application_ids(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WapApplicationIds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_content_types(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WapContentTypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_types(&self) -> Result<Option<foundation::collections::IVector<SmsBroadcastType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastTypes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_channels(&self) -> Result<Option<foundation::collections::IVector<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastChannels)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsFilterRule: ISmsFilterRule}
impl RtActivatable<ISmsFilterRuleFactory> for SmsFilterRule {}
impl SmsFilterRule {
    #[inline] pub fn create_filter_rule(messageType: SmsMessageType) -> Result<SmsFilterRule> {
        <Self as RtActivatable<ISmsFilterRuleFactory>>::get_activation_factory().create_filter_rule(messageType)
    }
}
DEFINE_CLSID!(SmsFilterRule(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,0]) [CLSID_SmsFilterRule]);
DEFINE_IID!(IID_ISmsFilterRuleFactory, 12805384, 25238, 20265, 154, 173, 137, 32, 206, 186, 60, 232);
RT_INTERFACE!{static interface ISmsFilterRuleFactory(ISmsFilterRuleFactoryVtbl, ISmsFilterRuleFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISmsFilterRuleFactory] {
    fn CreateFilterRule(&self, messageType: SmsMessageType, out: *mut <SmsFilterRule as RtType>::Abi) -> HRESULT
}}
impl ISmsFilterRuleFactory {
    #[inline] pub fn create_filter_rule(&self, messageType: SmsMessageType) -> Result<SmsFilterRule> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFilterRule)(self.0.as_abi() as *const _ as *mut _, messageType, &mut out);
        if hr == S_OK { Ok(SmsFilterRule::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsFilterRules, 1313336059, 31181, 18561, 152, 148, 85, 164, 19, 91, 35, 250);
RT_INTERFACE!{interface ISmsFilterRules(ISmsFilterRulesVtbl, ISmsFilterRules_Abi): IInspectable(IInspectableVtbl) [IID_ISmsFilterRules] {
    fn get_ActionType(&self, out: *mut SmsFilterActionType) -> HRESULT,
    fn get_Rules(&self, out: *mut <foundation::collections::IVector<SmsFilterRule> as RtType>::Abi) -> HRESULT
}}
impl ISmsFilterRules {
    #[inline] pub fn get_action_type(&self) -> Result<SmsFilterActionType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActionType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rules(&self) -> Result<Option<foundation::collections::IVector<SmsFilterRule>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Rules)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsFilterRules: ISmsFilterRules}
impl RtActivatable<ISmsFilterRulesFactory> for SmsFilterRules {}
impl SmsFilterRules {
    #[inline] pub fn create_filter_rules(actionType: SmsFilterActionType) -> Result<SmsFilterRules> {
        <Self as RtActivatable<ISmsFilterRulesFactory>>::get_activation_factory().create_filter_rules(actionType)
    }
}
DEFINE_CLSID!(SmsFilterRules(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,115,0]) [CLSID_SmsFilterRules]);
DEFINE_IID!(IID_ISmsFilterRulesFactory, 2694391021, 28206, 17712, 159, 222, 70, 93, 2, 238, 208, 14);
RT_INTERFACE!{static interface ISmsFilterRulesFactory(ISmsFilterRulesFactoryVtbl, ISmsFilterRulesFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISmsFilterRulesFactory] {
    fn CreateFilterRules(&self, actionType: SmsFilterActionType, out: *mut <SmsFilterRules as RtType>::Abi) -> HRESULT
}}
impl ISmsFilterRulesFactory {
    #[inline] pub fn create_filter_rules(&self, actionType: SmsFilterActionType) -> Result<SmsFilterRules> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFilterRules)(self.0.as_abi() as *const _ as *mut _, actionType, &mut out);
        if hr == S_OK { Ok(SmsFilterRules::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsGeographicalScope: i32 {
    None = 0, CellWithImmediateDisplay = 1, LocationArea = 2, Plmn = 3, Cell = 4,
}}
DEFINE_IID!(IID_ISmsMessage, 3980156456, 27012, 19207, 129, 29, 141, 89, 6, 237, 60, 234);
RT_INTERFACE!{interface ISmsMessage(ISmsMessageVtbl, ISmsMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessage] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT
}}
impl ISmsMessage {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsMessageBase, 753991216, 65104, 20422, 170, 136, 76, 207, 226, 122, 41, 234);
RT_INTERFACE!{interface ISmsMessageBase(ISmsMessageBaseVtbl, ISmsMessageBase_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessageBase] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT,
    fn get_SimIccId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISmsMessageBase {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CellularClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sim_icc_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SimIccId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsMessageClass: i32 {
    None = 0, Class0 = 1, Class1 = 2, Class2 = 3, Class3 = 4,
}}
RT_ENUM! { enum SmsMessageFilter: i32 {
    All = 0, Unread = 1, Read = 2, Sent = 3, Draft = 4,
}}
DEFINE_IID!(IID_ISmsMessageReceivedEventArgs, 149424792, 47333, 16833, 163, 216, 211, 171, 250, 226, 38, 117);
RT_INTERFACE!{interface ISmsMessageReceivedEventArgs(ISmsMessageReceivedEventArgsVtbl, ISmsMessageReceivedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedEventArgs] {
    fn get_TextMessage(&self, out: *mut <SmsTextMessage as RtType>::Abi) -> HRESULT,
    fn get_BinaryMessage(&self, out: *mut <SmsBinaryMessage as RtType>::Abi) -> HRESULT
}}
impl ISmsMessageReceivedEventArgs {
    #[inline] pub fn get_text_message(&self) -> Result<Option<SmsTextMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TextMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsTextMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_binary_message(&self) -> Result<Option<SmsBinaryMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BinaryMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsBinaryMessage::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageReceivedEventArgs: ISmsMessageReceivedEventArgs}
DEFINE_IID!(IID_SmsMessageReceivedEventHandler, 192599049, 60461, 18382, 162, 83, 115, 43, 238, 235, 202, 205);
RT_DELEGATE!{delegate SmsMessageReceivedEventHandler(SmsMessageReceivedEventHandlerVtbl, SmsMessageReceivedEventHandler_Abi, SmsMessageReceivedEventHandlerImpl) [IID_SmsMessageReceivedEventHandler] {
    fn Invoke(&self, sender: <SmsDevice as RtType>::Abi, e: <SmsMessageReceivedEventArgs as RtType>::Abi) -> HRESULT
}}
impl SmsMessageReceivedEventHandler {
    #[inline] pub fn invoke(&self, sender: &SmsDevice, e: &SmsMessageReceivedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Invoke)(self.0.as_abi() as *const _ as *mut _, get_abi(sender) as *const _ as *mut _, get_abi(e) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsMessageReceivedTriggerDetails, 735038420, 9815, 16680, 173, 95, 227, 135, 113, 50, 189, 177);
RT_INTERFACE!{interface ISmsMessageReceivedTriggerDetails(ISmsMessageReceivedTriggerDetailsVtbl, ISmsMessageReceivedTriggerDetails_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedTriggerDetails] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_TextMessage(&self, out: *mut <SmsTextMessage2 as RtType>::Abi) -> HRESULT,
    fn get_WapMessage(&self, out: *mut <SmsWapMessage as RtType>::Abi) -> HRESULT,
    fn get_AppMessage(&self, out: *mut <SmsAppMessage as RtType>::Abi) -> HRESULT,
    fn get_BroadcastMessage(&self, out: *mut <SmsBroadcastMessage as RtType>::Abi) -> HRESULT,
    fn get_VoicemailMessage(&self, out: *mut <SmsVoicemailMessage as RtType>::Abi) -> HRESULT,
    fn get_StatusMessage(&self, out: *mut <SmsStatusMessage as RtType>::Abi) -> HRESULT,
    fn Drop(&self) -> HRESULT,
    fn Accept(&self) -> HRESULT
}}
impl ISmsMessageReceivedTriggerDetails {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text_message(&self) -> Result<Option<SmsTextMessage2>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_TextMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsTextMessage2::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_message(&self) -> Result<Option<SmsWapMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_WapMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsWapMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_message(&self) -> Result<Option<SmsAppMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AppMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsAppMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_message(&self) -> Result<Option<SmsBroadcastMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BroadcastMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsBroadcastMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_voicemail_message(&self) -> Result<Option<SmsVoicemailMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VoicemailMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsVoicemailMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status_message(&self) -> Result<Option<SmsStatusMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_StatusMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsStatusMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn drop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Drop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Accept)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageReceivedTriggerDetails: ISmsMessageReceivedTriggerDetails}
DEFINE_IID!(IID_ISmsMessageRegistration, 387993662, 62287, 17515, 131, 179, 15, 241, 153, 35, 180, 9);
RT_INTERFACE!{interface ISmsMessageRegistration(ISmsMessageRegistrationVtbl, ISmsMessageRegistration_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistration] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn Unregister(&self) -> HRESULT,
    fn add_MessageReceived(&self, eventHandler: <foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceived(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISmsMessageRegistration {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Id)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Unregister)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_message_received(&self, eventHandler: &foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_MessageReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(eventHandler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_MessageReceived)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageRegistration: ISmsMessageRegistration}
impl RtActivatable<ISmsMessageRegistrationStatics> for SmsMessageRegistration {}
impl SmsMessageRegistration {
    #[inline] pub fn get_all_registrations() -> Result<Option<foundation::collections::IVectorView<SmsMessageRegistration>>> {
        <Self as RtActivatable<ISmsMessageRegistrationStatics>>::get_activation_factory().get_all_registrations()
    }
    #[inline] pub fn register(id: &HStringArg, filterRules: &SmsFilterRules) -> Result<Option<SmsMessageRegistration>> {
        <Self as RtActivatable<ISmsMessageRegistrationStatics>>::get_activation_factory().register(id, filterRules)
    }
}
DEFINE_CLSID!(SmsMessageRegistration(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,77,101,115,115,97,103,101,82,101,103,105,115,116,114,97,116,105,111,110,0]) [CLSID_SmsMessageRegistration]);
DEFINE_IID!(IID_ISmsMessageRegistrationStatics, 1671451748, 10392, 18296, 160, 60, 111, 153, 73, 7, 214, 58);
RT_INTERFACE!{static interface ISmsMessageRegistrationStatics(ISmsMessageRegistrationStaticsVtbl, ISmsMessageRegistrationStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistrationStatics] {
    fn get_AllRegistrations(&self, out: *mut <foundation::collections::IVectorView<SmsMessageRegistration> as RtType>::Abi) -> HRESULT,
    fn Register(&self, id: HSTRING, filterRules: <SmsFilterRules as RtType>::Abi, out: *mut <SmsMessageRegistration as RtType>::Abi) -> HRESULT
}}
impl ISmsMessageRegistrationStatics {
    #[inline] pub fn get_all_registrations(&self) -> Result<Option<foundation::collections::IVectorView<SmsMessageRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AllRegistrations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn register(&self, id: &HStringArg, filterRules: &SmsFilterRules) -> Result<Option<SmsMessageRegistration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Register)(self.0.as_abi() as *const _ as *mut _, id.get(), get_abi(filterRules) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsMessageRegistration::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsMessageType: i32 {
    Binary = 0, Text = 1, Wap = 2, App = 3, Broadcast = 4, Voicemail = 5, Status = 6,
}}
RT_ENUM! { enum SmsModemErrorCode: i32 {
    Other = 0, MessagingNetworkError = 1, SmsOperationNotSupportedByDevice = 2, SmsServiceNotSupportedByNetwork = 3, DeviceFailure = 4, MessageNotEncodedProperly = 5, MessageTooLarge = 6, DeviceNotReady = 7, NetworkNotReady = 8, InvalidSmscAddress = 9, NetworkFailure = 10, FixedDialingNumberRestricted = 11,
}}
DEFINE_IID!(IID_ISmsReceivedEventDetails, 1538592533, 58477, 19586, 132, 125, 90, 3, 4, 193, 213, 61);
RT_INTERFACE!{interface ISmsReceivedEventDetails(ISmsReceivedEventDetailsVtbl, ISmsReceivedEventDetails_Abi): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MessageIndex(&self, out: *mut u32) -> HRESULT
}}
impl ISmsReceivedEventDetails {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageIndex)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsReceivedEventDetails: ISmsReceivedEventDetails}
DEFINE_IID!(IID_ISmsReceivedEventDetails2, 1088445574, 42932, 18289, 154, 231, 11, 95, 251, 18, 192, 58);
RT_INTERFACE!{interface ISmsReceivedEventDetails2(ISmsReceivedEventDetails2Vtbl, ISmsReceivedEventDetails2_Abi): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails2] {
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT,
    fn get_BinaryMessage(&self, out: *mut <SmsBinaryMessage as RtType>::Abi) -> HRESULT
}}
impl ISmsReceivedEventDetails2 {
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_binary_message(&self) -> Result<Option<SmsBinaryMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BinaryMessage)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsBinaryMessage::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsSendMessageResult, 3675495154, 30921, 20459, 150, 34, 69, 35, 40, 8, 141, 98);
RT_INTERFACE!{interface ISmsSendMessageResult(ISmsSendMessageResultVtbl, ISmsSendMessageResult_Abi): IInspectable(IInspectableVtbl) [IID_ISmsSendMessageResult] {
    fn get_IsSuccessful(&self, out: *mut bool) -> HRESULT,
    fn get_MessageReferenceNumbers(&self, out: *mut <foundation::collections::IVectorView<i32> as RtType>::Abi) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_ModemErrorCode(&self, out: *mut SmsModemErrorCode) -> HRESULT,
    fn get_IsErrorTransient(&self, out: *mut bool) -> HRESULT,
    fn get_NetworkCauseCode(&self, out: *mut i32) -> HRESULT,
    fn get_TransportFailureCause(&self, out: *mut i32) -> HRESULT
}}
impl ISmsSendMessageResult {
    #[inline] pub fn get_is_successful(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsSuccessful)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reference_numbers(&self) -> Result<Option<foundation::collections::IVectorView<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageReferenceNumbers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CellularClass)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_modem_error_code(&self) -> Result<SmsModemErrorCode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ModemErrorCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_error_transient(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsErrorTransient)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_cause_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NetworkCauseCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_failure_cause(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TransportFailureCause)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsSendMessageResult: ISmsSendMessageResult}
DEFINE_IID!(IID_ISmsStatusMessage, 3872555842, 46859, 18039, 147, 121, 201, 120, 63, 223, 248, 244);
RT_INTERFACE!{interface ISmsStatusMessage(ISmsStatusMessageVtbl, ISmsStatusMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsStatusMessage] {
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn get_MessageReferenceNumber(&self, out: *mut i32) -> HRESULT,
    fn get_ServiceCenterTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_DischargeTime(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ISmsStatusMessage {
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_From)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reference_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageReferenceNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_center_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceCenterTimestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_discharge_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DischargeTime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsStatusMessage: ISmsStatusMessage}
DEFINE_IID!(IID_ISmsTextMessage, 3592196172, 42133, 18559, 154, 111, 151, 21, 72, 197, 188, 159);
RT_INTERFACE!{interface ISmsTextMessage(ISmsTextMessageVtbl, ISmsTextMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PartReferenceId(&self, out: *mut u32) -> HRESULT,
    fn get_PartNumber(&self, out: *mut u32) -> HRESULT,
    fn get_PartCount(&self, out: *mut u32) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn put_From(&self, value: HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn ToBinaryMessages(&self, format: SmsDataFormat, out: *mut <foundation::collections::IVectorView<ISmsBinaryMessage> as RtType>::Abi) -> HRESULT
}}
impl ISmsTextMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_reference_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PartReferenceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_number(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PartNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PartCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_To)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_From)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_from(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_From)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Body)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Encoding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Encoding)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn to_binary_messages(&self, format: SmsDataFormat) -> Result<Option<foundation::collections::IVectorView<ISmsBinaryMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ToBinaryMessages)(self.0.as_abi() as *const _ as *mut _, format, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsTextMessage: ISmsTextMessage}
impl RtActivatable<ISmsTextMessageStatics> for SmsTextMessage {}
impl RtActivatable<IActivationFactory> for SmsTextMessage {}
impl SmsTextMessage {
    #[inline] pub fn from_binary_message(binaryMessage: &SmsBinaryMessage) -> Result<Option<SmsTextMessage>> {
        <Self as RtActivatable<ISmsTextMessageStatics>>::get_activation_factory().from_binary_message(binaryMessage)
    }
    #[inline] pub fn from_binary_data(format: SmsDataFormat, value: &[u8]) -> Result<Option<SmsTextMessage>> {
        <Self as RtActivatable<ISmsTextMessageStatics>>::get_activation_factory().from_binary_data(format, value)
    }
}
DEFINE_CLSID!(SmsTextMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,84,101,120,116,77,101,115,115,97,103,101,0]) [CLSID_SmsTextMessage]);
DEFINE_IID!(IID_ISmsTextMessage2, 580966547, 17749, 18261, 181, 161, 231, 253, 132, 149, 95, 141);
RT_INTERFACE!{interface ISmsTextMessage2(ISmsTextMessage2Vtbl, ISmsTextMessage2_Abi): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage2] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn get_CallbackNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallbackNumber(&self, value: HSTRING) -> HRESULT,
    fn get_IsDeliveryNotificationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDeliveryNotificationEnabled(&self, value: bool) -> HRESULT,
    fn get_RetryAttemptCount(&self, out: *mut i32) -> HRESULT,
    fn put_RetryAttemptCount(&self, value: i32) -> HRESULT,
    fn get_TeleserviceId(&self, out: *mut i32) -> HRESULT,
    fn get_ProtocolId(&self, out: *mut i32) -> HRESULT
}}
impl ISmsTextMessage2 {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_To)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_From)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Body)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Encoding)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Encoding)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_callback_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CallbackNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_callback_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CallbackNumber)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_delivery_notification_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsDeliveryNotificationEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_delivery_notification_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsDeliveryNotificationEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_retry_attempt_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RetryAttemptCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_retry_attempt_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RetryAttemptCount)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_TeleserviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsTextMessage2: ISmsTextMessage2}
impl RtActivatable<IActivationFactory> for SmsTextMessage2 {}
DEFINE_CLSID!(SmsTextMessage2(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,84,101,120,116,77,101,115,115,97,103,101,50,0]) [CLSID_SmsTextMessage2]);
DEFINE_IID!(IID_ISmsTextMessageStatics, 2137572845, 15564, 18339, 140, 85, 56, 13, 59, 1, 8, 146);
RT_INTERFACE!{static interface ISmsTextMessageStatics(ISmsTextMessageStaticsVtbl, ISmsTextMessageStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISmsTextMessageStatics] {
    fn FromBinaryMessage(&self, binaryMessage: <SmsBinaryMessage as RtType>::Abi, out: *mut <SmsTextMessage as RtType>::Abi) -> HRESULT,
    fn FromBinaryData(&self, format: SmsDataFormat, valueSize: u32, value: *mut u8, out: *mut <SmsTextMessage as RtType>::Abi) -> HRESULT
}}
impl ISmsTextMessageStatics {
    #[inline] pub fn from_binary_message(&self, binaryMessage: &SmsBinaryMessage) -> Result<Option<SmsTextMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromBinaryMessage)(self.0.as_abi() as *const _ as *mut _, get_abi(binaryMessage) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SmsTextMessage::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_binary_data(&self, format: SmsDataFormat, value: &[u8]) -> Result<Option<SmsTextMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromBinaryData)(self.0.as_abi() as *const _ as *mut _, format, value.len() as u32, value.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(SmsTextMessage::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsVoicemailMessage, 656056486, 38321, 17663, 188, 184, 184, 253, 215, 224, 139, 195);
RT_INTERFACE!{interface ISmsVoicemailMessage(ISmsVoicemailMessageVtbl, ISmsVoicemailMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsVoicemailMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MessageCount(&self, out: *mut <foundation::IReference<i32> as RtType>::Abi) -> HRESULT
}}
impl ISmsVoicemailMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Body)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_count(&self) -> Result<Option<foundation::IReference<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_MessageCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsVoicemailMessage: ISmsVoicemailMessage}
DEFINE_IID!(IID_ISmsWapMessage, 3448993603, 31317, 19771, 144, 33, 242, 46, 2, 45, 9, 197);
RT_INTERFACE!{interface ISmsWapMessage(ISmsWapMessageVtbl, ISmsWapMessage_Abi): IInspectable(IInspectableVtbl) [IID_ISmsWapMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentType(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_BinaryBody(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_Headers(&self, out: *mut <foundation::collections::IMap<HString, HString> as RtType>::Abi) -> HRESULT
}}
impl ISmsWapMessage {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_To)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_From)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ApplicationId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ContentType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_binary_body(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BinaryBody)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_headers(&self) -> Result<Option<foundation::collections::IMap<HString, HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Headers)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IMap::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsWapMessage: ISmsWapMessage}
} // Windows.Devices.Sms
pub mod spi { // Windows.Devices.Spi
use crate::prelude::*;
DEFINE_IID!(IID_ISpiBusInfo, 2569618506, 21746, 18630, 185, 82, 156, 50, 252, 2, 198, 105);
RT_INTERFACE!{interface ISpiBusInfo(ISpiBusInfoVtbl, ISpiBusInfo_Abi): IInspectable(IInspectableVtbl) [IID_ISpiBusInfo] {
    fn get_ChipSelectLineCount(&self, out: *mut i32) -> HRESULT,
    fn get_MinClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn get_MaxClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn get_SupportedDataBitLengths(&self, out: *mut <foundation::collections::IVectorView<i32> as RtType>::Abi) -> HRESULT
}}
impl ISpiBusInfo {
    #[inline] pub fn get_chip_select_line_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChipSelectLineCount)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MinClockFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxClockFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_data_bit_lengths(&self) -> Result<Option<foundation::collections::IVectorView<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedDataBitLengths)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiBusInfo: ISpiBusInfo}
DEFINE_IID!(IID_ISpiConnectionSettings, 1384358783, 63797, 19359, 167, 167, 58, 120, 144, 175, 165, 206);
RT_INTERFACE!{interface ISpiConnectionSettings(ISpiConnectionSettingsVtbl, ISpiConnectionSettings_Abi): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettings] {
    fn get_ChipSelectLine(&self, out: *mut i32) -> HRESULT,
    fn put_ChipSelectLine(&self, value: i32) -> HRESULT,
    fn get_Mode(&self, out: *mut SpiMode) -> HRESULT,
    fn put_Mode(&self, value: SpiMode) -> HRESULT,
    fn get_DataBitLength(&self, out: *mut i32) -> HRESULT,
    fn put_DataBitLength(&self, value: i32) -> HRESULT,
    fn get_ClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn put_ClockFrequency(&self, value: i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut SpiSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: SpiSharingMode) -> HRESULT
}}
impl ISpiConnectionSettings {
    #[inline] pub fn get_chip_select_line(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChipSelectLine)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_chip_select_line(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChipSelectLine)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<SpiMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: SpiMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bit_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataBitLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bit_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataBitLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClockFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clock_frequency(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ClockFrequency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<SpiSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: SpiSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SharingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiConnectionSettings: ISpiConnectionSettings}
impl RtActivatable<ISpiConnectionSettingsFactory> for SpiConnectionSettings {}
impl SpiConnectionSettings {
    #[inline] pub fn create(chipSelectLine: i32) -> Result<SpiConnectionSettings> {
        <Self as RtActivatable<ISpiConnectionSettingsFactory>>::get_activation_factory().create(chipSelectLine)
    }
}
DEFINE_CLSID!(SpiConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_SpiConnectionSettings]);
DEFINE_IID!(IID_ISpiConnectionSettingsFactory, 4288219166, 4292, 17591, 159, 234, 167, 72, 181, 164, 111, 49);
RT_INTERFACE!{static interface ISpiConnectionSettingsFactory(ISpiConnectionSettingsFactoryVtbl, ISpiConnectionSettingsFactory_Abi): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettingsFactory] {
    fn Create(&self, chipSelectLine: i32, out: *mut <SpiConnectionSettings as RtType>::Abi) -> HRESULT
}}
impl ISpiConnectionSettingsFactory {
    #[inline] pub fn create(&self, chipSelectLine: i32) -> Result<SpiConnectionSettings> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, chipSelectLine, &mut out);
        if hr == S_OK { Ok(SpiConnectionSettings::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiController, 2832451625, 39061, 16729, 169, 52, 135, 65, 241, 238, 109, 39);
RT_INTERFACE!{interface ISpiController(ISpiControllerVtbl, ISpiController_Abi): IInspectable(IInspectableVtbl) [IID_ISpiController] {
    fn GetDevice(&self, settings: <SpiConnectionSettings as RtType>::Abi, out: *mut <SpiDevice as RtType>::Abi) -> HRESULT
}}
impl ISpiController {
    #[inline] pub fn get_device(&self, settings: &SpiConnectionSettings) -> Result<Option<SpiDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDevice)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpiDevice::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiController: ISpiController}
impl RtActivatable<ISpiControllerStatics> for SpiController {}
impl SpiController {
    #[inline] pub fn get_default_async() -> Result<foundation::IAsyncOperation<SpiController>> {
        <Self as RtActivatable<ISpiControllerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_controllers_async(provider: &provider::ISpiProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>>> {
        <Self as RtActivatable<ISpiControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
}
DEFINE_CLSID!(SpiController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_SpiController]);
DEFINE_IID!(IID_ISpiControllerStatics, 223488482, 5003, 20040, 185, 100, 79, 47, 121, 185, 197, 162);
RT_INTERFACE!{static interface ISpiControllerStatics(ISpiControllerStaticsVtbl, ISpiControllerStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpiControllerStatics] {
    fn GetDefaultAsync(&self, out: *mut <foundation::IAsyncOperation<SpiController> as RtType>::Abi) -> HRESULT,
    fn GetControllersAsync(&self, provider: <provider::ISpiProvider as RtType>::Abi, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>> as RtType>::Abi) -> HRESULT
}}
impl ISpiControllerStatics {
    #[inline] pub fn get_default_async(&self) -> Result<foundation::IAsyncOperation<SpiController>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDefaultAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_controllers_async(&self, provider: &provider::ISpiProvider) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(provider) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiDevice, 97858925, 4534, 19769, 132, 213, 149, 223, 180, 201, 242, 206);
RT_INTERFACE!{interface ISpiDevice(ISpiDeviceVtbl, ISpiDevice_Abi): IInspectable(IInspectableVtbl) [IID_ISpiDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut <SpiConnectionSettings as RtType>::Abi) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn TransferSequential(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn TransferFullDuplex(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT
}}
impl ISpiDevice {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<SpiConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(SpiConnectionSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_sequential(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).TransferSequential)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_full_duplex(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).TransferFullDuplex)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiDevice: ISpiDevice}
impl RtActivatable<ISpiDeviceStatics> for SpiDevice {}
impl SpiDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn get_bus_info(busId: &HStringArg) -> Result<Option<SpiBusInfo>> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_bus_info(busId)
    }
    #[inline] pub fn from_id_async(busId: &HStringArg, settings: &SpiConnectionSettings) -> Result<foundation::IAsyncOperation<SpiDevice>> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().from_id_async(busId, settings)
    }
}
DEFINE_CLSID!(SpiDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,68,101,118,105,99,101,0]) [CLSID_SpiDevice]);
DEFINE_IID!(IID_ISpiDeviceStatics, 2725832025, 22304, 19775, 189, 147, 86, 245, 255, 90, 88, 121);
RT_INTERFACE!{static interface ISpiDeviceStatics(ISpiDeviceStaticsVtbl, ISpiDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_ISpiDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetBusInfo(&self, busId: HSTRING, out: *mut <SpiBusInfo as RtType>::Abi) -> HRESULT,
    fn FromIdAsync(&self, busId: HSTRING, settings: <SpiConnectionSettings as RtType>::Abi, out: *mut <foundation::IAsyncOperation<SpiDevice> as RtType>::Abi) -> HRESULT
}}
impl ISpiDeviceStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.0.as_abi() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_info(&self, busId: &HStringArg) -> Result<Option<SpiBusInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetBusInfo)(self.0.as_abi() as *const _ as *mut _, busId.get(), &mut out);
        if hr == S_OK { Ok(SpiBusInfo::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, busId: &HStringArg, settings: &SpiConnectionSettings) -> Result<foundation::IAsyncOperation<SpiDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, busId.get(), get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpiMode: i32 {
    Mode0 = 0, Mode1 = 1, Mode2 = 2, Mode3 = 3,
}}
RT_ENUM! { enum SpiSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
pub mod provider { // Windows.Devices.Spi.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IProviderSpiConnectionSettings, 4127409488, 42306, 20160, 150, 1, 164, 221, 104, 248, 105, 123);
RT_INTERFACE!{interface IProviderSpiConnectionSettings(IProviderSpiConnectionSettingsVtbl, IProviderSpiConnectionSettings_Abi): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettings] {
    fn get_ChipSelectLine(&self, out: *mut i32) -> HRESULT,
    fn put_ChipSelectLine(&self, value: i32) -> HRESULT,
    fn get_Mode(&self, out: *mut ProviderSpiMode) -> HRESULT,
    fn put_Mode(&self, value: ProviderSpiMode) -> HRESULT,
    fn get_DataBitLength(&self, out: *mut i32) -> HRESULT,
    fn put_DataBitLength(&self, value: i32) -> HRESULT,
    fn get_ClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn put_ClockFrequency(&self, value: i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderSpiSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: ProviderSpiSharingMode) -> HRESULT
}}
impl IProviderSpiConnectionSettings {
    #[inline] pub fn get_chip_select_line(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChipSelectLine)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_chip_select_line(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ChipSelectLine)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<ProviderSpiMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Mode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: ProviderSpiMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Mode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bit_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DataBitLength)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bit_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DataBitLength)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClockFrequency)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clock_frequency(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ClockFrequency)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderSpiSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SharingMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: ProviderSpiSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SharingMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ProviderSpiConnectionSettings: IProviderSpiConnectionSettings}
impl RtActivatable<IProviderSpiConnectionSettingsFactory> for ProviderSpiConnectionSettings {}
impl ProviderSpiConnectionSettings {
    #[inline] pub fn create(chipSelectLine: i32) -> Result<ProviderSpiConnectionSettings> {
        <Self as RtActivatable<IProviderSpiConnectionSettingsFactory>>::get_activation_factory().create(chipSelectLine)
    }
}
DEFINE_CLSID!(ProviderSpiConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,80,114,111,118,105,100,101,114,46,80,114,111,118,105,100,101,114,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_ProviderSpiConnectionSettings]);
DEFINE_IID!(IID_IProviderSpiConnectionSettingsFactory, 1715825498, 3193, 17379, 159, 60, 229, 151, 128, 172, 24, 250);
RT_INTERFACE!{static interface IProviderSpiConnectionSettingsFactory(IProviderSpiConnectionSettingsFactoryVtbl, IProviderSpiConnectionSettingsFactory_Abi): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettingsFactory] {
    fn Create(&self, chipSelectLine: i32, out: *mut <ProviderSpiConnectionSettings as RtType>::Abi) -> HRESULT
}}
impl IProviderSpiConnectionSettingsFactory {
    #[inline] pub fn create(&self, chipSelectLine: i32) -> Result<ProviderSpiConnectionSettings> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Create)(self.0.as_abi() as *const _ as *mut _, chipSelectLine, &mut out);
        if hr == S_OK { Ok(ProviderSpiConnectionSettings::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderSpiMode: i32 {
    Mode0 = 0, Mode1 = 1, Mode2 = 2, Mode3 = 3,
}}
RT_ENUM! { enum ProviderSpiSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
DEFINE_IID!(IID_ISpiControllerProvider, 3244844292, 718, 16934, 163, 133, 79, 17, 251, 4, 180, 27);
RT_INTERFACE!{interface ISpiControllerProvider(ISpiControllerProviderVtbl, ISpiControllerProvider_Abi): IInspectable(IInspectableVtbl) [IID_ISpiControllerProvider] {
    fn GetDeviceProvider(&self, settings: <ProviderSpiConnectionSettings as RtType>::Abi, out: *mut <ISpiDeviceProvider as RtType>::Abi) -> HRESULT
}}
impl ISpiControllerProvider {
    #[inline] pub fn get_device_provider(&self, settings: &ProviderSpiConnectionSettings) -> Result<Option<ISpiDeviceProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceProvider)(self.0.as_abi() as *const _ as *mut _, get_abi(settings) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ISpiDeviceProvider::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiDeviceProvider, 219952195, 12363, 16476, 180, 247, 245, 171, 16, 116, 70, 30);
RT_INTERFACE!{interface ISpiDeviceProvider(ISpiDeviceProviderVtbl, ISpiDeviceProvider_Abi): IInspectable(IInspectableVtbl) [IID_ISpiDeviceProvider] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut <ProviderSpiConnectionSettings as RtType>::Abi) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn TransferSequential(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn TransferFullDuplex(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT
}}
impl ISpiDeviceProvider {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<ProviderSpiConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ProviderSpiConnectionSettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Write)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Read)(self.0.as_abi() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_sequential(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).TransferSequential)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_full_duplex(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).TransferFullDuplex)(self.0.as_abi() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiProvider, 2528403938, 30676, 18638, 170, 160, 117, 113, 90, 131, 98, 207);
RT_INTERFACE!{interface ISpiProvider(ISpiProviderVtbl, ISpiProvider_Abi): IInspectable(IInspectableVtbl) [IID_ISpiProvider] {
    fn GetControllersAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<ISpiControllerProvider>> as RtType>::Abi) -> HRESULT
}}
impl ISpiProvider {
    #[inline] pub fn get_controllers_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<ISpiControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetControllersAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Spi.Provider
} // Windows.Devices.Spi
pub mod usb { // Windows.Devices.Usb
use crate::prelude::*;
DEFINE_IID!(IID_IUsbBulkInEndpointDescriptor, 1013860422, 1743, 17065, 157, 194, 151, 28, 27, 20, 182, 227);
RT_INTERFACE!{interface IUsbBulkInEndpointDescriptor(IUsbBulkInEndpointDescriptorVtbl, IUsbBulkInEndpointDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbBulkInEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Pipe(&self, out: *mut <UsbBulkInPipe as RtType>::Abi) -> HRESULT
}}
impl IUsbBulkInEndpointDescriptor {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPacketSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<UsbBulkInPipe>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pipe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkInPipe::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkInEndpointDescriptor: IUsbBulkInEndpointDescriptor}
DEFINE_IID!(IID_IUsbBulkInPipe, 4028443963, 17736, 19792, 179, 38, 216, 44, 218, 190, 18, 32);
RT_INTERFACE!{interface IUsbBulkInPipe(IUsbBulkInPipeVtbl, IUsbBulkInPipe_Abi): IInspectable(IInspectableVtbl) [IID_IUsbBulkInPipe] {
    fn get_MaxTransferSizeBytes(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointDescriptor(&self, out: *mut <UsbBulkInEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn put_ReadOptions(&self, value: UsbReadOptions) -> HRESULT,
    fn get_ReadOptions(&self, out: *mut UsbReadOptions) -> HRESULT,
    fn FlushBuffer(&self) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut <super::super::storage::streams::IInputStream as RtType>::Abi) -> HRESULT
}}
impl IUsbBulkInPipe {
    #[inline] pub fn get_max_transfer_size_bytes(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxTransferSizeBytes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<UsbBulkInEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkInEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearStallAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_read_options(&self, value: UsbReadOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ReadOptions)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_options(&self) -> Result<UsbReadOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ReadOptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn flush_buffer(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).FlushBuffer)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<super::super::storage::streams::IInputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IInputStream::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkInPipe: IUsbBulkInPipe}
DEFINE_IID!(IID_IUsbBulkOutEndpointDescriptor, 673219706, 65518, 20320, 155, 225, 149, 108, 172, 62, 203, 101);
RT_INTERFACE!{interface IUsbBulkOutEndpointDescriptor(IUsbBulkOutEndpointDescriptorVtbl, IUsbBulkOutEndpointDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Pipe(&self, out: *mut <UsbBulkOutPipe as RtType>::Abi) -> HRESULT
}}
impl IUsbBulkOutEndpointDescriptor {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPacketSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<UsbBulkOutPipe>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pipe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkOutPipe::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkOutEndpointDescriptor: IUsbBulkOutEndpointDescriptor}
DEFINE_IID!(IID_IUsbBulkOutPipe, 2833903214, 277, 17834, 139, 33, 55, 178, 37, 188, 206, 231);
RT_INTERFACE!{interface IUsbBulkOutPipe(IUsbBulkOutPipeVtbl, IUsbBulkOutPipe_Abi): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutPipe] {
    fn get_EndpointDescriptor(&self, out: *mut <UsbBulkOutEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn put_WriteOptions(&self, value: UsbWriteOptions) -> HRESULT,
    fn get_WriteOptions(&self, out: *mut UsbWriteOptions) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut <super::super::storage::streams::IOutputStream as RtType>::Abi) -> HRESULT
}}
impl IUsbBulkOutPipe {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<UsbBulkOutEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkOutEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearStallAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_write_options(&self, value: UsbWriteOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WriteOptions)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_options(&self) -> Result<UsbWriteOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteOptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<super::super::storage::streams::IOutputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IOutputStream::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkOutPipe: IUsbBulkOutPipe}
DEFINE_IID!(IID_IUsbConfiguration, 1746367529, 13993, 18135, 184, 115, 252, 104, 146, 81, 236, 48);
RT_INTERFACE!{interface IUsbConfiguration(IUsbConfigurationVtbl, IUsbConfiguration_Abi): IInspectable(IInspectableVtbl) [IID_IUsbConfiguration] {
    fn get_UsbInterfaces(&self, out: *mut <foundation::collections::IVectorView<UsbInterface> as RtType>::Abi) -> HRESULT,
    fn get_ConfigurationDescriptor(&self, out: *mut <UsbConfigurationDescriptor as RtType>::Abi) -> HRESULT,
    fn get_Descriptors(&self, out: *mut <foundation::collections::IVectorView<UsbDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IUsbConfiguration {
    #[inline] pub fn get_usb_interfaces(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_UsbInterfaces)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration_descriptor(&self) -> Result<Option<UsbConfigurationDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConfigurationDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbConfigurationDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<UsbDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbConfiguration: IUsbConfiguration}
DEFINE_IID!(IID_IUsbConfigurationDescriptor, 4061621650, 46146, 16506, 130, 7, 125, 100, 108, 3, 133, 243);
RT_INTERFACE!{interface IUsbConfigurationDescriptor(IUsbConfigurationDescriptorVtbl, IUsbConfigurationDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptor] {
    fn get_ConfigurationValue(&self, out: *mut u8) -> HRESULT,
    fn get_MaxPowerMilliamps(&self, out: *mut u32) -> HRESULT,
    fn get_SelfPowered(&self, out: *mut bool) -> HRESULT,
    fn get_RemoteWakeup(&self, out: *mut bool) -> HRESULT
}}
impl IUsbConfigurationDescriptor {
    #[inline] pub fn get_configuration_value(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConfigurationValue)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_power_milliamps(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPowerMilliamps)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_self_powered(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelfPowered)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_wakeup(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemoteWakeup)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbConfigurationDescriptor: IUsbConfigurationDescriptor}
impl RtActivatable<IUsbConfigurationDescriptorStatics> for UsbConfigurationDescriptor {}
impl UsbConfigurationDescriptor {
    #[inline] pub fn try_parse(descriptor: &UsbDescriptor) -> Result<(Option<UsbConfigurationDescriptor>, bool)> {
        <Self as RtActivatable<IUsbConfigurationDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &UsbDescriptor) -> Result<Option<UsbConfigurationDescriptor>> {
        <Self as RtActivatable<IUsbConfigurationDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbConfigurationDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,67,111,110,102,105,103,117,114,97,116,105,111,110,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbConfigurationDescriptor]);
DEFINE_IID!(IID_IUsbConfigurationDescriptorStatics, 1112337811, 59200, 16545, 146, 189, 218, 18, 14, 160, 73, 20);
RT_INTERFACE!{static interface IUsbConfigurationDescriptorStatics(IUsbConfigurationDescriptorStaticsVtbl, IUsbConfigurationDescriptorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptorStatics] {
    fn TryParse(&self, descriptor: <UsbDescriptor as RtType>::Abi, parsed: *mut <UsbConfigurationDescriptor as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: <UsbDescriptor as RtType>::Abi, out: *mut <UsbConfigurationDescriptor as RtType>::Abi) -> HRESULT
}}
impl IUsbConfigurationDescriptorStatics {
    #[inline] pub fn try_parse(&self, descriptor: &UsbDescriptor) -> Result<(Option<UsbConfigurationDescriptor>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryParse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((UsbConfigurationDescriptor::wrap(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &UsbDescriptor) -> Result<Option<UsbConfigurationDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Parse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbConfigurationDescriptor::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbControlRecipient: i32 {
    Device = 0, SpecifiedInterface = 1, Endpoint = 2, Other = 3, DefaultInterface = 4,
}}
DEFINE_IID!(IID_IUsbControlRequestType, 2392090022, 55101, 18142, 148, 190, 170, 231, 240, 124, 15, 92);
RT_INTERFACE!{interface IUsbControlRequestType(IUsbControlRequestTypeVtbl, IUsbControlRequestType_Abi): IInspectable(IInspectableVtbl) [IID_IUsbControlRequestType] {
    fn get_Direction(&self, out: *mut UsbTransferDirection) -> HRESULT,
    fn put_Direction(&self, value: UsbTransferDirection) -> HRESULT,
    fn get_ControlTransferType(&self, out: *mut UsbControlTransferType) -> HRESULT,
    fn put_ControlTransferType(&self, value: UsbControlTransferType) -> HRESULT,
    fn get_Recipient(&self, out: *mut UsbControlRecipient) -> HRESULT,
    fn put_Recipient(&self, value: UsbControlRecipient) -> HRESULT,
    fn get_AsByte(&self, out: *mut u8) -> HRESULT,
    fn put_AsByte(&self, value: u8) -> HRESULT
}}
impl IUsbControlRequestType {
    #[inline] pub fn get_direction(&self) -> Result<UsbTransferDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direction)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: UsbTransferDirection) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Direction)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_transfer_type(&self) -> Result<UsbControlTransferType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ControlTransferType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_control_transfer_type(&self, value: UsbControlTransferType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ControlTransferType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recipient(&self) -> Result<UsbControlRecipient> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Recipient)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_recipient(&self, value: UsbControlRecipient) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Recipient)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_as_byte(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AsByte)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_as_byte(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AsByte)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbControlRequestType: IUsbControlRequestType}
impl RtActivatable<IActivationFactory> for UsbControlRequestType {}
DEFINE_CLSID!(UsbControlRequestType(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,67,111,110,116,114,111,108,82,101,113,117,101,115,116,84,121,112,101,0]) [CLSID_UsbControlRequestType]);
RT_ENUM! { enum UsbControlTransferType: i32 {
    Standard = 0, Class = 1, Vendor = 2,
}}
DEFINE_IID!(IID_IUsbDescriptor, 176812566, 24477, 18548, 137, 4, 218, 154, 211, 245, 82, 143);
RT_INTERFACE!{interface IUsbDescriptor(IUsbDescriptorVtbl, IUsbDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDescriptor] {
    fn get_Length(&self, out: *mut u8) -> HRESULT,
    fn get_DescriptorType(&self, out: *mut u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ReadDescriptorBuffer(&self, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IUsbDescriptor {
    #[inline] pub fn get_length(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptor_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_DescriptorType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn read_descriptor_buffer(&self, buffer: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).ReadDescriptorBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDescriptor: IUsbDescriptor}
DEFINE_IID!(IID_IUsbDevice, 1380563346, 50262, 17621, 173, 94, 36, 245, 160, 137, 246, 59);
RT_INTERFACE!{interface IUsbDevice(IUsbDeviceVtbl, IUsbDevice_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDevice] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlOutTransferAsync(&self, setupPacket: <UsbSetupPacket as RtType>::Abi, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    fn SendControlOutTransferAsyncNoBuffer(&self, setupPacket: <UsbSetupPacket as RtType>::Abi, out: *mut <foundation::IAsyncOperation<u32> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlInTransferAsync(&self, setupPacket: <UsbSetupPacket as RtType>::Abi, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlInTransferAsyncNoBuffer(&self, setupPacket: <UsbSetupPacket as RtType>::Abi, out: *mut <foundation::IAsyncOperation<super::super::storage::streams::IBuffer> as RtType>::Abi) -> HRESULT,
    fn get_DefaultInterface(&self, out: *mut <UsbInterface as RtType>::Abi) -> HRESULT,
    fn get_DeviceDescriptor(&self, out: *mut <UsbDeviceDescriptor as RtType>::Abi) -> HRESULT,
    fn get_Configuration(&self, out: *mut <UsbConfiguration as RtType>::Abi) -> HRESULT
}}
impl IUsbDevice {
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_out_transfer_async(&self, setupPacket: &UsbSetupPacket, buffer: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendControlOutTransferAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(setupPacket) as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_control_out_transfer_async_no_buffer(&self, setupPacket: &UsbSetupPacket) -> Result<foundation::IAsyncOperation<u32>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendControlOutTransferAsyncNoBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(setupPacket) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_in_transfer_async(&self, setupPacket: &UsbSetupPacket, buffer: &super::super::storage::streams::IBuffer) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendControlInTransferAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(setupPacket) as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_in_transfer_async_no_buffer(&self, setupPacket: &UsbSetupPacket) -> Result<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SendControlInTransferAsyncNoBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(setupPacket) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_interface(&self) -> Result<Option<UsbInterface>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DefaultInterface)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterface::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_descriptor(&self) -> Result<Option<UsbDeviceDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration(&self) -> Result<Option<UsbConfiguration>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Configuration)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbConfiguration::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDevice: IUsbDevice}
impl RtActivatable<IUsbDeviceStatics> for UsbDevice {}
impl UsbDevice {
    #[inline] pub fn get_device_selector(vendorId: u32, productId: u32, winUsbInterfaceClass: Guid) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector(vendorId, productId, winUsbInterfaceClass)
    }
    #[inline] pub fn get_device_selector_guid_only(winUsbInterfaceClass: Guid) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector_guid_only(winUsbInterfaceClass)
    }
    #[inline] pub fn get_device_selector_vid_pid_only(vendorId: u32, productId: u32) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector_vid_pid_only(vendorId, productId)
    }
    #[inline] pub fn get_device_class_selector(usbClass: &UsbDeviceClass) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_class_selector(usbClass)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<UsbDevice>> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(UsbDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,0]) [CLSID_UsbDevice]);
DEFINE_IID!(IID_IUsbDeviceClass, 85541625, 33886, 18411, 177, 42, 56, 242, 246, 23, 175, 231);
RT_INTERFACE!{interface IUsbDeviceClass(IUsbDeviceClassVtbl, IUsbDeviceClass_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClass] {
    fn get_ClassCode(&self, out: *mut u8) -> HRESULT,
    fn put_ClassCode(&self, value: u8) -> HRESULT,
    fn get_SubclassCode(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn put_SubclassCode(&self, value: <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn get_ProtocolCode(&self, out: *mut <foundation::IReference<u8> as RtType>::Abi) -> HRESULT,
    fn put_ProtocolCode(&self, value: <foundation::IReference<u8> as RtType>::Abi) -> HRESULT
}}
impl IUsbDeviceClass {
    #[inline] pub fn get_class_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClassCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_class_code(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ClassCode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subclass_code(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubclassCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subclass_code(&self, value: &foundation::IReference<u8>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SubclassCode)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_code(&self) -> Result<Option<foundation::IReference<u8>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IReference::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_protocol_code(&self, value: &foundation::IReference<u8>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ProtocolCode)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDeviceClass: IUsbDeviceClass}
impl RtActivatable<IActivationFactory> for UsbDeviceClass {}
DEFINE_CLSID!(UsbDeviceClass(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,67,108,97,115,115,0]) [CLSID_UsbDeviceClass]);
DEFINE_IID!(IID_IUsbDeviceClasses, 1752143197, 39826, 19248, 151, 129, 194, 44, 85, 172, 53, 203);
RT_INTERFACE!{interface IUsbDeviceClasses(IUsbDeviceClassesVtbl, IUsbDeviceClasses_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClasses] {
    
}}
RT_CLASS!{class UsbDeviceClasses: IUsbDeviceClasses}
impl RtActivatable<IUsbDeviceClassesStatics> for UsbDeviceClasses {}
impl UsbDeviceClasses {
    #[inline] pub fn get_cdc_control() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_cdc_control()
    }
    #[inline] pub fn get_physical() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_physical()
    }
    #[inline] pub fn get_personal_healthcare() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_personal_healthcare()
    }
    #[inline] pub fn get_active_sync() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_active_sync()
    }
    #[inline] pub fn get_palm_sync() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_palm_sync()
    }
    #[inline] pub fn get_device_firmware_update() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_device_firmware_update()
    }
    #[inline] pub fn get_irda() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_irda()
    }
    #[inline] pub fn get_measurement() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_measurement()
    }
    #[inline] pub fn get_vendor_specific() -> Result<Option<UsbDeviceClass>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_vendor_specific()
    }
}
DEFINE_CLSID!(UsbDeviceClasses(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,67,108,97,115,115,101,115,0]) [CLSID_UsbDeviceClasses]);
DEFINE_IID!(IID_IUsbDeviceClassesStatics, 2987066663, 50560, 17817, 161, 101, 152, 27, 79, 208, 50, 48);
RT_INTERFACE!{static interface IUsbDeviceClassesStatics(IUsbDeviceClassesStaticsVtbl, IUsbDeviceClassesStatics_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClassesStatics] {
    fn get_CdcControl(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_Physical(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_PersonalHealthcare(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_ActiveSync(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_PalmSync(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_DeviceFirmwareUpdate(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_Irda(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_Measurement(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT,
    fn get_VendorSpecific(&self, out: *mut <UsbDeviceClass as RtType>::Abi) -> HRESULT
}}
impl IUsbDeviceClassesStatics {
    #[inline] pub fn get_cdc_control(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_CdcControl)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Physical)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_personal_healthcare(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PersonalHealthcare)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_sync(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ActiveSync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_palm_sync(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PalmSync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_firmware_update(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceFirmwareUpdate)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_irda(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Irda)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_measurement(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Measurement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vendor_specific(&self) -> Result<Option<UsbDeviceClass>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_VendorSpecific)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbDeviceClass::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbDeviceDescriptor, 524866038, 47767, 17186, 185, 44, 181, 177, 137, 33, 101, 136);
RT_INTERFACE!{interface IUsbDeviceDescriptor(IUsbDeviceDescriptorVtbl, IUsbDeviceDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDeviceDescriptor] {
    fn get_BcdUsb(&self, out: *mut u32) -> HRESULT,
    fn get_MaxPacketSize0(&self, out: *mut u8) -> HRESULT,
    fn get_VendorId(&self, out: *mut u32) -> HRESULT,
    fn get_ProductId(&self, out: *mut u32) -> HRESULT,
    fn get_BcdDeviceRevision(&self, out: *mut u32) -> HRESULT,
    fn get_NumberOfConfigurations(&self, out: *mut u8) -> HRESULT
}}
impl IUsbDeviceDescriptor {
    #[inline] pub fn get_bcd_usb(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BcdUsb)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_packet_size0(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPacketSize0)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_vendor_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_VendorId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_product_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProductId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bcd_device_revision(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BcdDeviceRevision)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_number_of_configurations(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NumberOfConfigurations)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDeviceDescriptor: IUsbDeviceDescriptor}
DEFINE_IID!(IID_IUsbDeviceStatics, 107709858, 2487, 17478, 133, 2, 111, 230, 220, 170, 115, 9);
RT_INTERFACE!{static interface IUsbDeviceStatics(IUsbDeviceStaticsVtbl, IUsbDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IUsbDeviceStatics] {
    fn GetDeviceSelector(&self, vendorId: u32, productId: u32, winUsbInterfaceClass: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorGuidOnly(&self, winUsbInterfaceClass: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorVidPidOnly(&self, vendorId: u32, productId: u32, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceClassSelector(&self, usbClass: <UsbDeviceClass as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<UsbDevice> as RtType>::Abi) -> HRESULT
}}
impl IUsbDeviceStatics {
    #[inline] pub fn get_device_selector(&self, vendorId: u32, productId: u32, winUsbInterfaceClass: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, vendorId, productId, winUsbInterfaceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_guid_only(&self, winUsbInterfaceClass: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorGuidOnly)(self.0.as_abi() as *const _ as *mut _, winUsbInterfaceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_vid_pid_only(&self, vendorId: u32, productId: u32) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelectorVidPidOnly)(self.0.as_abi() as *const _ as *mut _, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_class_selector(&self, usbClass: &UsbDeviceClass) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceClassSelector)(self.0.as_abi() as *const _ as *mut _, get_abi(usbClass) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<UsbDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbEndpointDescriptor, 1799906009, 36343, 19264, 172, 131, 87, 143, 19, 159, 5, 117);
RT_INTERFACE!{interface IUsbEndpointDescriptor(IUsbEndpointDescriptorVtbl, IUsbEndpointDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptor] {
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Direction(&self, out: *mut UsbTransferDirection) -> HRESULT,
    fn get_EndpointType(&self, out: *mut UsbEndpointType) -> HRESULT,
    fn get_AsBulkInEndpointDescriptor(&self, out: *mut <UsbBulkInEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn get_AsInterruptInEndpointDescriptor(&self, out: *mut <UsbInterruptInEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn get_AsBulkOutEndpointDescriptor(&self, out: *mut <UsbBulkOutEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn get_AsInterruptOutEndpointDescriptor(&self, out: *mut <UsbInterruptOutEndpointDescriptor as RtType>::Abi) -> HRESULT
}}
impl IUsbEndpointDescriptor {
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<UsbTransferDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Direction)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_type(&self) -> Result<UsbEndpointType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_as_bulk_in_endpoint_descriptor(&self) -> Result<Option<UsbBulkInEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AsBulkInEndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkInEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_interrupt_in_endpoint_descriptor(&self) -> Result<Option<UsbInterruptInEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AsInterruptInEndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptInEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_bulk_out_endpoint_descriptor(&self) -> Result<Option<UsbBulkOutEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AsBulkOutEndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbBulkOutEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_interrupt_out_endpoint_descriptor(&self) -> Result<Option<UsbInterruptOutEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AsInterruptOutEndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptOutEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbEndpointDescriptor: IUsbEndpointDescriptor}
impl RtActivatable<IUsbEndpointDescriptorStatics> for UsbEndpointDescriptor {}
impl UsbEndpointDescriptor {
    #[inline] pub fn try_parse(descriptor: &UsbDescriptor) -> Result<(Option<UsbEndpointDescriptor>, bool)> {
        <Self as RtActivatable<IUsbEndpointDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &UsbDescriptor) -> Result<Option<UsbEndpointDescriptor>> {
        <Self as RtActivatable<IUsbEndpointDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbEndpointDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,69,110,100,112,111,105,110,116,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbEndpointDescriptor]);
DEFINE_IID!(IID_IUsbEndpointDescriptorStatics, 3364925953, 39530, 18782, 168, 44, 41, 91, 158, 112, 129, 6);
RT_INTERFACE!{static interface IUsbEndpointDescriptorStatics(IUsbEndpointDescriptorStaticsVtbl, IUsbEndpointDescriptorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptorStatics] {
    fn TryParse(&self, descriptor: <UsbDescriptor as RtType>::Abi, parsed: *mut <UsbEndpointDescriptor as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: <UsbDescriptor as RtType>::Abi, out: *mut <UsbEndpointDescriptor as RtType>::Abi) -> HRESULT
}}
impl IUsbEndpointDescriptorStatics {
    #[inline] pub fn try_parse(&self, descriptor: &UsbDescriptor) -> Result<(Option<UsbEndpointDescriptor>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryParse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((UsbEndpointDescriptor::wrap(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &UsbDescriptor) -> Result<Option<UsbEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Parse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbEndpointType: i32 {
    Control = 0, Isochronous = 1, Bulk = 2, Interrupt = 3,
}}
DEFINE_IID!(IID_IUsbInterface, 2687642517, 32583, 18603, 167, 39, 103, 140, 37, 190, 33, 18);
RT_INTERFACE!{interface IUsbInterface(IUsbInterfaceVtbl, IUsbInterface_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterface] {
    fn get_BulkInPipes(&self, out: *mut <foundation::collections::IVectorView<UsbBulkInPipe> as RtType>::Abi) -> HRESULT,
    fn get_InterruptInPipes(&self, out: *mut <foundation::collections::IVectorView<UsbInterruptInPipe> as RtType>::Abi) -> HRESULT,
    fn get_BulkOutPipes(&self, out: *mut <foundation::collections::IVectorView<UsbBulkOutPipe> as RtType>::Abi) -> HRESULT,
    fn get_InterruptOutPipes(&self, out: *mut <foundation::collections::IVectorView<UsbInterruptOutPipe> as RtType>::Abi) -> HRESULT,
    fn get_InterfaceSettings(&self, out: *mut <foundation::collections::IVectorView<UsbInterfaceSetting> as RtType>::Abi) -> HRESULT,
    fn get_InterfaceNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Descriptors(&self, out: *mut <foundation::collections::IVectorView<UsbDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IUsbInterface {
    #[inline] pub fn get_bulk_in_pipes(&self) -> Result<Option<foundation::collections::IVectorView<UsbBulkInPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BulkInPipes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_in_pipes(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterruptInPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterruptInPipes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bulk_out_pipes(&self) -> Result<Option<foundation::collections::IVectorView<UsbBulkOutPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BulkOutPipes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_out_pipes(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterruptOutPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterruptOutPipes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_settings(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterfaceSetting>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterfaceSettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterfaceNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<UsbDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterface: IUsbInterface}
DEFINE_IID!(IID_IUsbInterfaceDescriptor, 429289671, 47086, 20368, 140, 213, 148, 162, 226, 87, 89, 138);
RT_INTERFACE!{interface IUsbInterfaceDescriptor(IUsbInterfaceDescriptorVtbl, IUsbInterfaceDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptor] {
    fn get_ClassCode(&self, out: *mut u8) -> HRESULT,
    fn get_SubclassCode(&self, out: *mut u8) -> HRESULT,
    fn get_ProtocolCode(&self, out: *mut u8) -> HRESULT,
    fn get_AlternateSettingNumber(&self, out: *mut u8) -> HRESULT,
    fn get_InterfaceNumber(&self, out: *mut u8) -> HRESULT
}}
impl IUsbInterfaceDescriptor {
    #[inline] pub fn get_class_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ClassCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subclass_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SubclassCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProtocolCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alternate_setting_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AlternateSettingNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterfaceNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterfaceDescriptor: IUsbInterfaceDescriptor}
impl RtActivatable<IUsbInterfaceDescriptorStatics> for UsbInterfaceDescriptor {}
impl UsbInterfaceDescriptor {
    #[inline] pub fn try_parse(descriptor: &UsbDescriptor) -> Result<(Option<UsbInterfaceDescriptor>, bool)> {
        <Self as RtActivatable<IUsbInterfaceDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &UsbDescriptor) -> Result<Option<UsbInterfaceDescriptor>> {
        <Self as RtActivatable<IUsbInterfaceDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbInterfaceDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,73,110,116,101,114,102,97,99,101,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbInterfaceDescriptor]);
DEFINE_IID!(IID_IUsbInterfaceDescriptorStatics, 3813318645, 30678, 18614, 176, 190, 22, 198, 66, 35, 22, 254);
RT_INTERFACE!{static interface IUsbInterfaceDescriptorStatics(IUsbInterfaceDescriptorStaticsVtbl, IUsbInterfaceDescriptorStatics_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptorStatics] {
    fn TryParse(&self, descriptor: <UsbDescriptor as RtType>::Abi, parsed: *mut <UsbInterfaceDescriptor as RtType>::Abi, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: <UsbDescriptor as RtType>::Abi, out: *mut <UsbInterfaceDescriptor as RtType>::Abi) -> HRESULT
}}
impl IUsbInterfaceDescriptorStatics {
    #[inline] pub fn try_parse(&self, descriptor: &UsbDescriptor) -> Result<(Option<UsbInterfaceDescriptor>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).TryParse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((UsbInterfaceDescriptor::wrap(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &UsbDescriptor) -> Result<Option<UsbInterfaceDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).Parse)(self.0.as_abi() as *const _ as *mut _, get_abi(descriptor) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterfaceDescriptor::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbInterfaceSetting, 405257127, 36263, 19191, 143, 76, 127, 48, 50, 231, 129, 245);
RT_INTERFACE!{interface IUsbInterfaceSetting(IUsbInterfaceSettingVtbl, IUsbInterfaceSetting_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceSetting] {
    fn get_BulkInEndpoints(&self, out: *mut <foundation::collections::IVectorView<UsbBulkInEndpointDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_InterruptInEndpoints(&self, out: *mut <foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_BulkOutEndpoints(&self, out: *mut <foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_InterruptOutEndpoints(&self, out: *mut <foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor> as RtType>::Abi) -> HRESULT,
    fn get_Selected(&self, out: *mut bool) -> HRESULT,
    fn SelectSettingAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_InterfaceDescriptor(&self, out: *mut <UsbInterfaceDescriptor as RtType>::Abi) -> HRESULT,
    fn get_Descriptors(&self, out: *mut <foundation::collections::IVectorView<UsbDescriptor> as RtType>::Abi) -> HRESULT
}}
impl IUsbInterfaceSetting {
    #[inline] pub fn get_bulk_in_endpoints(&self) -> Result<Option<foundation::collections::IVectorView<UsbBulkInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BulkInEndpoints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_in_endpoints(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterruptInEndpoints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bulk_out_endpoints(&self) -> Result<Option<foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_BulkOutEndpoints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_out_endpoints(&self) -> Result<Option<foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterruptOutEndpoints)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Selected)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn select_setting_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).SelectSettingAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_descriptor(&self) -> Result<Option<UsbInterfaceDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterfaceDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterfaceDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<foundation::collections::IVectorView<UsbDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Descriptors)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterfaceSetting: IUsbInterfaceSetting}
DEFINE_IID!(IID_IUsbInterruptInEndpointDescriptor, 3226634599, 51473, 19514, 134, 178, 65, 156, 45, 168, 144, 57);
RT_INTERFACE!{interface IUsbInterruptInEndpointDescriptor(IUsbInterruptInEndpointDescriptorVtbl, IUsbInterruptInEndpointDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Interval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Pipe(&self, out: *mut <UsbInterruptInPipe as RtType>::Abi) -> HRESULT
}}
impl IUsbInterruptInEndpointDescriptor {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPacketSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Interval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<UsbInterruptInPipe>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pipe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptInPipe::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInEndpointDescriptor: IUsbInterruptInEndpointDescriptor}
DEFINE_IID!(IID_IUsbInterruptInEventArgs, 3081781394, 5144, 18742, 130, 9, 41, 156, 245, 96, 85, 131);
RT_INTERFACE!{interface IUsbInterruptInEventArgs(IUsbInterruptInEventArgsVtbl, IUsbInterruptInEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEventArgs] {
    #[cfg(feature="windows-storage")] fn get_InterruptData(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IUsbInterruptInEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_interrupt_data(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InterruptData)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInEventArgs: IUsbInterruptInEventArgs}
DEFINE_IID!(IID_IUsbInterruptInPipe, 4194332950, 34007, 18631, 138, 63, 76, 11, 35, 95, 46, 166);
RT_INTERFACE!{interface IUsbInterruptInPipe(IUsbInterruptInPipeVtbl, IUsbInterruptInPipe_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInPipe] {
    fn get_EndpointDescriptor(&self, out: *mut <UsbInterruptInEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_DataReceived(&self, handler: <foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUsbInterruptInPipe {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<UsbInterruptInEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptInEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearStallAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_data_received(&self, handler: &foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_DataReceived)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_DataReceived)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInPipe: IUsbInterruptInPipe}
DEFINE_IID!(IID_IUsbInterruptOutEndpointDescriptor, 3433033089, 4298, 17715, 149, 45, 158, 39, 131, 65, 232, 15);
RT_INTERFACE!{interface IUsbInterruptOutEndpointDescriptor(IUsbInterruptOutEndpointDescriptorVtbl, IUsbInterruptOutEndpointDescriptor_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Interval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Pipe(&self, out: *mut <UsbInterruptOutPipe as RtType>::Abi) -> HRESULT
}}
impl IUsbInterruptOutEndpointDescriptor {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_MaxPacketSize)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointNumber)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Interval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<UsbInterruptOutPipe>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Pipe)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptOutPipe::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptOutEndpointDescriptor: IUsbInterruptOutEndpointDescriptor}
DEFINE_IID!(IID_IUsbInterruptOutPipe, 3917793449, 43769, 18896, 185, 108, 246, 97, 171, 74, 127, 149);
RT_INTERFACE!{interface IUsbInterruptOutPipe(IUsbInterruptOutPipeVtbl, IUsbInterruptOutPipe_Abi): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutPipe] {
    fn get_EndpointDescriptor(&self, out: *mut <UsbInterruptOutEndpointDescriptor as RtType>::Abi) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn put_WriteOptions(&self, value: UsbWriteOptions) -> HRESULT,
    fn get_WriteOptions(&self, out: *mut UsbWriteOptions) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut <super::super::storage::streams::IOutputStream as RtType>::Abi) -> HRESULT
}}
impl IUsbInterruptOutPipe {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<UsbInterruptOutEndpointDescriptor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointDescriptor)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbInterruptOutEndpointDescriptor::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ClearStallAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_write_options(&self, value: UsbWriteOptions) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_WriteOptions)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_options(&self) -> Result<UsbWriteOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_WriteOptions)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<super::super::storage::streams::IOutputStream>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_OutputStream)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IOutputStream::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptOutPipe: IUsbInterruptOutPipe}
RT_ENUM! { enum UsbReadOptions: u32 {
    None = 0, AutoClearStall = 1, OverrideAutomaticBufferManagement = 2, IgnoreShortPacket = 4, AllowPartialReads = 8,
}}
DEFINE_IID!(IID_IUsbSetupPacket, 273391922, 51087, 19537, 182, 84, 228, 157, 2, 242, 203, 3);
RT_INTERFACE!{interface IUsbSetupPacket(IUsbSetupPacketVtbl, IUsbSetupPacket_Abi): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacket] {
    fn get_RequestType(&self, out: *mut <UsbControlRequestType as RtType>::Abi) -> HRESULT,
    fn put_RequestType(&self, value: <UsbControlRequestType as RtType>::Abi) -> HRESULT,
    fn get_Request(&self, out: *mut u8) -> HRESULT,
    fn put_Request(&self, value: u8) -> HRESULT,
    fn get_Value(&self, out: *mut u32) -> HRESULT,
    fn put_Value(&self, value: u32) -> HRESULT,
    fn get_Index(&self, out: *mut u32) -> HRESULT,
    fn put_Index(&self, value: u32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn put_Length(&self, value: u32) -> HRESULT
}}
impl IUsbSetupPacket {
    #[inline] pub fn get_request_type(&self) -> Result<Option<UsbControlRequestType>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RequestType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbControlRequestType::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_request_type(&self, value: &UsbControlRequestType) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_RequestType)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_request(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Request)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Request)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Index)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Index)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Length)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Length)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbSetupPacket: IUsbSetupPacket}
impl RtActivatable<IUsbSetupPacketFactory> for UsbSetupPacket {}
impl RtActivatable<IActivationFactory> for UsbSetupPacket {}
impl UsbSetupPacket {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_eight_byte_buffer(eightByteBuffer: &super::super::storage::streams::IBuffer) -> Result<UsbSetupPacket> {
        <Self as RtActivatable<IUsbSetupPacketFactory>>::get_activation_factory().create_with_eight_byte_buffer(eightByteBuffer)
    }
}
DEFINE_CLSID!(UsbSetupPacket(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,83,101,116,117,112,80,97,99,107,101,116,0]) [CLSID_UsbSetupPacket]);
DEFINE_IID!(IID_IUsbSetupPacketFactory, 3374677328, 6958, 19009, 162, 167, 51, 143, 12, 239, 60, 20);
RT_INTERFACE!{static interface IUsbSetupPacketFactory(IUsbSetupPacketFactoryVtbl, IUsbSetupPacketFactory_Abi): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacketFactory] {
    #[cfg(feature="windows-storage")] fn CreateWithEightByteBuffer(&self, eightByteBuffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <UsbSetupPacket as RtType>::Abi) -> HRESULT
}}
impl IUsbSetupPacketFactory {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_eight_byte_buffer(&self, eightByteBuffer: &super::super::storage::streams::IBuffer) -> Result<UsbSetupPacket> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWithEightByteBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(eightByteBuffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(UsbSetupPacket::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbTransferDirection: i32 {
    Out = 0, In = 1,
}}
RT_ENUM! { enum UsbWriteOptions: u32 {
    None = 0, AutoClearStall = 1, ShortPacketTerminate = 2,
}}
} // Windows.Devices.Usb
pub mod wifi { // Windows.Devices.WiFi
use crate::prelude::*;
RT_ENUM! { enum WiFiAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
DEFINE_IID!(IID_IWiFiAdapter, 2797921315, 15733, 17316, 185, 222, 17, 226, 107, 114, 217, 176);
RT_INTERFACE!{interface IWiFiAdapter(IWiFiAdapterVtbl, IWiFiAdapter_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiAdapter] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_NetworkAdapter(&self, out: *mut <super::super::networking::connectivity::NetworkAdapter as RtType>::Abi) -> HRESULT,
    fn ScanAsync(&self, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn get_NetworkReport(&self, out: *mut <WiFiNetworkReport as RtType>::Abi) -> HRESULT,
    fn add_AvailableNetworksChanged(&self, args: <foundation::TypedEventHandler<WiFiAdapter, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableNetworksChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn ConnectAsync(&self, availableNetwork: <WiFiAvailableNetwork as RtType>::Abi, reconnectionKind: WiFiReconnectionKind, out: *mut <foundation::IAsyncOperation<WiFiConnectionResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAsync(&self, availableNetwork: <WiFiAvailableNetwork as RtType>::Abi, reconnectionKind: WiFiReconnectionKind, passwordCredential: <super::super::security::credentials::PasswordCredential as RtType>::Abi, out: *mut <foundation::IAsyncOperation<WiFiConnectionResult> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAndSsidAsync(&self, availableNetwork: <WiFiAvailableNetwork as RtType>::Abi, reconnectionKind: WiFiReconnectionKind, passwordCredential: <super::super::security::credentials::PasswordCredential as RtType>::Abi, ssid: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiConnectionResult> as RtType>::Abi) -> HRESULT,
    fn Disconnect(&self) -> HRESULT
}}
impl IWiFiAdapter {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_network_adapter(&self) -> Result<Option<super::super::networking::connectivity::NetworkAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NetworkAdapter)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::networking::connectivity::NetworkAdapter::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn scan_async(&self) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ScanAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_network_report(&self) -> Result<Option<WiFiNetworkReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_NetworkReport)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiNetworkReport::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_available_networks_changed(&self, args: &foundation::TypedEventHandler<WiFiAdapter, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AvailableNetworksChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(args) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_networks_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AvailableNetworksChanged)(self.0.as_abi() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind) -> Result<foundation::IAsyncOperation<WiFiConnectionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(availableNetwork) as *const _ as *mut _, reconnectionKind, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_async(&self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: &super::super::security::credentials::PasswordCredential) -> Result<foundation::IAsyncOperation<WiFiConnectionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectWithPasswordCredentialAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(availableNetwork) as *const _ as *mut _, reconnectionKind, get_abi(passwordCredential) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_and_ssid_async(&self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: &super::super::security::credentials::PasswordCredential, ssid: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiConnectionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectWithPasswordCredentialAndSsidAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(availableNetwork) as *const _ as *mut _, reconnectionKind, get_abi(passwordCredential) as *const _ as *mut _, ssid.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn disconnect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Disconnect)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiAdapter: IWiFiAdapter}
impl RtActivatable<IWiFiAdapterStatics> for WiFiAdapter {}
impl WiFiAdapter {
    #[inline] pub fn find_all_adapters_async() -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().find_all_adapters_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiAdapter>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn request_access_async() -> Result<foundation::IAsyncOperation<WiFiAccessStatus>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(WiFiAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,46,87,105,70,105,65,100,97,112,116,101,114,0]) [CLSID_WiFiAdapter]);
DEFINE_IID!(IID_IWiFiAdapter2, 1539592221, 33252, 17725, 148, 48, 31, 202, 251, 173, 214, 182);
RT_INTERFACE!{interface IWiFiAdapter2(IWiFiAdapter2Vtbl, IWiFiAdapter2_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiAdapter2] {
    fn GetWpsConfigurationAsync(&self, availableNetwork: <WiFiAvailableNetwork as RtType>::Abi, out: *mut <foundation::IAsyncOperation<WiFiWpsConfigurationResult> as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAndSsidAndConnectionMethodAsync(&self, availableNetwork: <WiFiAvailableNetwork as RtType>::Abi, reconnectionKind: WiFiReconnectionKind, passwordCredential: <super::super::security::credentials::PasswordCredential as RtType>::Abi, ssid: HSTRING, connectionMethod: WiFiConnectionMethod, out: *mut <foundation::IAsyncOperation<WiFiConnectionResult> as RtType>::Abi) -> HRESULT
}}
impl IWiFiAdapter2 {
    #[inline] pub fn get_wps_configuration_async(&self, availableNetwork: &WiFiAvailableNetwork) -> Result<foundation::IAsyncOperation<WiFiWpsConfigurationResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetWpsConfigurationAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(availableNetwork) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_and_ssid_and_connection_method_async(&self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: &super::super::security::credentials::PasswordCredential, ssid: &HStringArg, connectionMethod: WiFiConnectionMethod) -> Result<foundation::IAsyncOperation<WiFiConnectionResult>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectWithPasswordCredentialAndSsidAndConnectionMethodAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(availableNetwork) as *const _ as *mut _, reconnectionKind, get_abi(passwordCredential) as *const _ as *mut _, ssid.get(), connectionMethod, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiAdapterStatics, 3659922909, 53836, 17379, 170, 189, 196, 101, 159, 115, 15, 153);
RT_INTERFACE!{static interface IWiFiAdapterStatics(IWiFiAdapterStaticsVtbl, IWiFiAdapterStatics_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiAdapterStatics] {
    fn FindAllAdaptersAsync(&self, out: *mut <foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>> as RtType>::Abi) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiAdapter> as RtType>::Abi) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut <foundation::IAsyncOperation<WiFiAccessStatus> as RtType>::Abi) -> HRESULT
}}
impl IWiFiAdapterStatics {
    #[inline] pub fn find_all_adapters_async(&self) -> Result<foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FindAllAdaptersAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiAdapter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<foundation::IAsyncOperation<WiFiAccessStatus>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).RequestAccessAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiAvailableNetwork, 652829254, 6206, 18180, 152, 38, 113, 180, 162, 240, 246, 104);
RT_INTERFACE!{interface IWiFiAvailableNetwork(IWiFiAvailableNetworkVtbl, IWiFiAvailableNetwork_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiAvailableNetwork] {
    fn get_Uptime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Ssid(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bssid(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ChannelCenterFrequencyInKilohertz(&self, out: *mut i32) -> HRESULT,
    fn get_NetworkRssiInDecibelMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_SignalBars(&self, out: *mut u8) -> HRESULT,
    fn get_NetworkKind(&self, out: *mut WiFiNetworkKind) -> HRESULT,
    fn get_PhyKind(&self, out: *mut WiFiPhyKind) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_SecuritySettings(&self, out: *mut <super::super::networking::connectivity::NetworkSecuritySettings as RtType>::Abi) -> HRESULT,
    fn get_BeaconInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_IsWiFiDirect(&self, out: *mut bool) -> HRESULT
}}
impl IWiFiAvailableNetwork {
    #[inline] pub fn get_uptime(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Uptime)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ssid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Bssid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_center_frequency_in_kilohertz(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ChannelCenterFrequencyInKilohertz)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_rssi_in_decibel_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NetworkRssiInDecibelMilliwatts)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_bars(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SignalBars)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_kind(&self) -> Result<WiFiNetworkKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_NetworkKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phy_kind(&self) -> Result<WiFiPhyKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PhyKind)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_security_settings(&self) -> Result<Option<super::super::networking::connectivity::NetworkSecuritySettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SecuritySettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::networking::connectivity::NetworkSecuritySettings::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_beacon_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_BeaconInterval)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_wi_fi_direct(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsWiFiDirect)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiAvailableNetwork: IWiFiAvailableNetwork}
RT_ENUM! { enum WiFiConnectionMethod: i32 {
    Default = 0, WpsPin = 1, WpsPushButton = 2,
}}
DEFINE_IID!(IID_IWiFiConnectionResult, 339468249, 50045, 16574, 165, 200, 133, 123, 206, 133, 169, 49);
RT_INTERFACE!{interface IWiFiConnectionResult(IWiFiConnectionResultVtbl, IWiFiConnectionResult_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiConnectionResult] {
    fn get_ConnectionStatus(&self, out: *mut WiFiConnectionStatus) -> HRESULT
}}
impl IWiFiConnectionResult {
    #[inline] pub fn get_connection_status(&self) -> Result<WiFiConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiConnectionResult: IWiFiConnectionResult}
RT_ENUM! { enum WiFiConnectionStatus: i32 {
    UnspecifiedFailure = 0, Success = 1, AccessRevoked = 2, InvalidCredential = 3, NetworkNotAvailable = 4, Timeout = 5, UnsupportedAuthenticationProtocol = 6,
}}
RT_ENUM! { enum WiFiNetworkKind: i32 {
    Any = 0, Infrastructure = 1, Adhoc = 2,
}}
DEFINE_IID!(IID_IWiFiNetworkReport, 2502221522, 22801, 17502, 129, 148, 190, 79, 26, 112, 72, 149);
RT_INTERFACE!{interface IWiFiNetworkReport(IWiFiNetworkReportVtbl, IWiFiNetworkReport_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiNetworkReport] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AvailableNetworks(&self, out: *mut <foundation::collections::IVectorView<WiFiAvailableNetwork> as RtType>::Abi) -> HRESULT
}}
impl IWiFiNetworkReport {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Timestamp)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_available_networks(&self) -> Result<Option<foundation::collections::IVectorView<WiFiAvailableNetwork>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_AvailableNetworks)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiNetworkReport: IWiFiNetworkReport}
RT_ENUM! { enum WiFiPhyKind: i32 {
    Unknown = 0, Fhss = 1, Dsss = 2, IRBaseband = 3, Ofdm = 4, Hrdsss = 5, Erp = 6, HT = 7, Vht = 8, Dmg = 9, HE = 10,
}}
RT_ENUM! { enum WiFiReconnectionKind: i32 {
    Automatic = 0, Manual = 1,
}}
DEFINE_IID!(IID_IWiFiWpsConfigurationResult, 1739888753, 6126, 17105, 177, 79, 90, 17, 241, 34, 111, 181);
RT_INTERFACE!{interface IWiFiWpsConfigurationResult(IWiFiWpsConfigurationResultVtbl, IWiFiWpsConfigurationResult_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiWpsConfigurationResult] {
    fn get_Status(&self, out: *mut WiFiWpsConfigurationStatus) -> HRESULT,
    fn get_SupportedWpsKinds(&self, out: *mut <foundation::collections::IVectorView<WiFiWpsKind> as RtType>::Abi) -> HRESULT
}}
impl IWiFiWpsConfigurationResult {
    #[inline] pub fn get_status(&self) -> Result<WiFiWpsConfigurationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_wps_kinds(&self) -> Result<Option<foundation::collections::IVectorView<WiFiWpsKind>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedWpsKinds)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiWpsConfigurationResult: IWiFiWpsConfigurationResult}
RT_ENUM! { enum WiFiWpsConfigurationStatus: i32 {
    UnspecifiedFailure = 0, Success = 1, Timeout = 2,
}}
RT_ENUM! { enum WiFiWpsKind: i32 {
    Unknown = 0, Pin = 1, PushButton = 2, Nfc = 3, Ethernet = 4, Usb = 5,
}}
} // Windows.Devices.WiFi
pub mod wifidirect { // Windows.Devices.WiFiDirect
use crate::prelude::*;
DEFINE_IID!(IID_IWiFiDirectAdvertisement, 2874219053, 10758, 18849, 165, 132, 97, 67, 92, 121, 5, 166);
RT_INTERFACE!{interface IWiFiDirectAdvertisement(IWiFiDirectAdvertisementVtbl, IWiFiDirectAdvertisement_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement] {
    fn get_InformationElements(&self, out: *mut <foundation::collections::IVector<WiFiDirectInformationElement> as RtType>::Abi) -> HRESULT,
    fn put_InformationElements(&self, value: <foundation::collections::IVector<WiFiDirectInformationElement> as RtType>::Abi) -> HRESULT,
    fn get_ListenStateDiscoverability(&self, out: *mut WiFiDirectAdvertisementListenStateDiscoverability) -> HRESULT,
    fn put_ListenStateDiscoverability(&self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> HRESULT,
    fn get_IsAutonomousGroupOwnerEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutonomousGroupOwnerEnabled(&self, value: bool) -> HRESULT,
    fn get_LegacySettings(&self, out: *mut <WiFiDirectLegacySettings as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectAdvertisement {
    #[inline] pub fn get_information_elements(&self) -> Result<Option<foundation::collections::IVector<WiFiDirectInformationElement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_InformationElements)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_information_elements(&self, value: &foundation::collections::IVector<WiFiDirectInformationElement>) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_InformationElements)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_listen_state_discoverability(&self) -> Result<WiFiDirectAdvertisementListenStateDiscoverability> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ListenStateDiscoverability)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_listen_state_discoverability(&self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ListenStateDiscoverability)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_autonomous_group_owner_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsAutonomousGroupOwnerEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_autonomous_group_owner_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsAutonomousGroupOwnerEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_legacy_settings(&self) -> Result<Option<WiFiDirectLegacySettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_LegacySettings)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectLegacySettings::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisement: IWiFiDirectAdvertisement}
DEFINE_IID!(IID_IWiFiDirectAdvertisement2, 3076106822, 55318, 18715, 145, 122, 180, 13, 125, 196, 3, 162);
RT_INTERFACE!{interface IWiFiDirectAdvertisement2(IWiFiDirectAdvertisement2Vtbl, IWiFiDirectAdvertisement2_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement2] {
    fn get_SupportedConfigurationMethods(&self, out: *mut <foundation::collections::IVector<WiFiDirectConfigurationMethod> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectAdvertisement2 {
    #[inline] pub fn get_supported_configuration_methods(&self) -> Result<Option<foundation::collections::IVector<WiFiDirectConfigurationMethod>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedConfigurationMethods)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectAdvertisementListenStateDiscoverability: i32 {
    None = 0, Normal = 1, Intensive = 2,
}}
DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisher, 3009031450, 39711, 17881, 146, 90, 105, 77, 102, 223, 104, 239);
RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisher(IWiFiDirectAdvertisementPublisherVtbl, IWiFiDirectAdvertisementPublisher_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisher] {
    fn get_Advertisement(&self, out: *mut <WiFiDirectAdvertisement as RtType>::Abi) -> HRESULT,
    fn get_Status(&self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> HRESULT,
    fn add_StatusChanged(&self, handler: <foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IWiFiDirectAdvertisementPublisher {
    #[inline] pub fn get_advertisement(&self) -> Result<Option<WiFiDirectAdvertisement>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Advertisement)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectAdvertisement::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_StatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_StatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisementPublisher: IWiFiDirectAdvertisementPublisher}
impl RtActivatable<IActivationFactory> for WiFiDirectAdvertisementPublisher {}
DEFINE_CLSID!(WiFiDirectAdvertisementPublisher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,0]) [CLSID_WiFiDirectAdvertisementPublisher]);
RT_ENUM! { enum WiFiDirectAdvertisementPublisherStatus: i32 {
    Created = 0, Started = 1, Stopped = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs, 2868766012, 21633, 18150, 144, 221, 50, 17, 101, 24, 241, 146);
RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisherStatusChangedEventArgs(IWiFiDirectAdvertisementPublisherStatusChangedEventArgsVtbl, IWiFiDirectAdvertisementPublisherStatusChangedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut WiFiDirectError) -> HRESULT
}}
impl IWiFiDirectAdvertisementPublisherStatusChangedEventArgs {
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<WiFiDirectError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Error)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisementPublisherStatusChangedEventArgs: IWiFiDirectAdvertisementPublisherStatusChangedEventArgs}
RT_ENUM! { enum WiFiDirectConfigurationMethod: i32 {
    ProvidePin = 0, DisplayPin = 1, PushButton = 2,
}}
DEFINE_IID!(IID_IWiFiDirectConnectionListener, 1771838221, 36115, 20201, 185, 236, 156, 114, 248, 37, 31, 125);
RT_INTERFACE!{interface IWiFiDirectConnectionListener(IWiFiDirectConnectionListenerVtbl, IWiFiDirectConnectionListener_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionListener] {
    fn add_ConnectionRequested(&self, handler: <foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWiFiDirectConnectionListener {
    #[inline] pub fn add_connection_requested(&self, handler: &foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConnectionRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConnectionRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionListener: IWiFiDirectConnectionListener}
impl RtActivatable<IActivationFactory> for WiFiDirectConnectionListener {}
DEFINE_CLSID!(WiFiDirectConnectionListener(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,67,111,110,110,101,99,116,105,111,110,76,105,115,116,101,110,101,114,0]) [CLSID_WiFiDirectConnectionListener]);
DEFINE_IID!(IID_IWiFiDirectConnectionParameters, 3001373701, 22274, 19222, 160, 44, 187, 205, 33, 239, 96, 152);
RT_INTERFACE!{interface IWiFiDirectConnectionParameters(IWiFiDirectConnectionParametersVtbl, IWiFiDirectConnectionParameters_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters] {
    fn get_GroupOwnerIntent(&self, out: *mut i16) -> HRESULT,
    fn put_GroupOwnerIntent(&self, value: i16) -> HRESULT
}}
impl IWiFiDirectConnectionParameters {
    #[inline] pub fn get_group_owner_intent(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_GroupOwnerIntent)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_group_owner_intent(&self, value: i16) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_GroupOwnerIntent)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionParameters: IWiFiDirectConnectionParameters}
impl RtActivatable<IWiFiDirectConnectionParametersStatics> for WiFiDirectConnectionParameters {}
impl RtActivatable<IActivationFactory> for WiFiDirectConnectionParameters {}
impl WiFiDirectConnectionParameters {
    #[inline] pub fn get_device_pairing_kinds(configurationMethod: WiFiDirectConfigurationMethod) -> Result<super::enumeration::DevicePairingKinds> {
        <Self as RtActivatable<IWiFiDirectConnectionParametersStatics>>::get_activation_factory().get_device_pairing_kinds(configurationMethod)
    }
}
DEFINE_CLSID!(WiFiDirectConnectionParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,67,111,110,110,101,99,116,105,111,110,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_WiFiDirectConnectionParameters]);
DEFINE_IID!(IID_IWiFiDirectConnectionParameters2, 2872774590, 43650, 17588, 136, 200, 227, 5, 107, 137, 128, 29);
RT_INTERFACE!{interface IWiFiDirectConnectionParameters2(IWiFiDirectConnectionParameters2Vtbl, IWiFiDirectConnectionParameters2_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters2] {
    fn get_PreferenceOrderedConfigurationMethods(&self, out: *mut <foundation::collections::IVector<WiFiDirectConfigurationMethod> as RtType>::Abi) -> HRESULT,
    fn get_PreferredPairingProcedure(&self, out: *mut WiFiDirectPairingProcedure) -> HRESULT,
    fn put_PreferredPairingProcedure(&self, value: WiFiDirectPairingProcedure) -> HRESULT
}}
impl IWiFiDirectConnectionParameters2 {
    #[inline] pub fn get_preference_ordered_configuration_methods(&self) -> Result<Option<foundation::collections::IVector<WiFiDirectConfigurationMethod>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferenceOrderedConfigurationMethods)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_pairing_procedure(&self) -> Result<WiFiDirectPairingProcedure> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferredPairingProcedure)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_pairing_procedure(&self, value: WiFiDirectPairingProcedure) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreferredPairingProcedure)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectConnectionParametersStatics, 1502278803, 30274, 17775, 185, 216, 232, 169, 235, 31, 64, 26);
RT_INTERFACE!{static interface IWiFiDirectConnectionParametersStatics(IWiFiDirectConnectionParametersStaticsVtbl, IWiFiDirectConnectionParametersStatics_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParametersStatics] {
    fn GetDevicePairingKinds(&self, configurationMethod: WiFiDirectConfigurationMethod, out: *mut super::enumeration::DevicePairingKinds) -> HRESULT
}}
impl IWiFiDirectConnectionParametersStatics {
    #[inline] pub fn get_device_pairing_kinds(&self, configurationMethod: WiFiDirectConfigurationMethod) -> Result<super::enumeration::DevicePairingKinds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).GetDevicePairingKinds)(self.0.as_abi() as *const _ as *mut _, configurationMethod, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectConnectionRequest, 2394527237, 37199, 18883, 166, 20, 209, 141, 197, 177, 155, 67);
RT_INTERFACE!{interface IWiFiDirectConnectionRequest(IWiFiDirectConnectionRequestVtbl, IWiFiDirectConnectionRequest_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequest] {
    fn get_DeviceInformation(&self, out: *mut <super::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectConnectionRequest {
    #[inline] pub fn get_device_information(&self) -> Result<Option<super::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionRequest: IWiFiDirectConnectionRequest}
DEFINE_IID!(IID_IWiFiDirectConnectionRequestedEventArgs, 4187824318, 54157, 18511, 130, 21, 231, 182, 90, 191, 36, 76);
RT_INTERFACE!{interface IWiFiDirectConnectionRequestedEventArgs(IWiFiDirectConnectionRequestedEventArgsVtbl, IWiFiDirectConnectionRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequestedEventArgs] {
    fn GetConnectionRequest(&self, out: *mut <WiFiDirectConnectionRequest as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectConnectionRequestedEventArgs {
    #[inline] pub fn get_connection_request(&self) -> Result<Option<WiFiDirectConnectionRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetConnectionRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectConnectionRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionRequestedEventArgs: IWiFiDirectConnectionRequestedEventArgs}
RT_ENUM! { enum WiFiDirectConnectionStatus: i32 {
    Disconnected = 0, Connected = 1,
}}
DEFINE_IID!(IID_IWiFiDirectDevice, 1927195304, 29419, 19886, 138, 40, 133, 19, 53, 93, 39, 119);
RT_INTERFACE!{interface IWiFiDirectDevice(IWiFiDirectDeviceVtbl, IWiFiDirectDevice_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDevice] {
    fn get_ConnectionStatus(&self, out: *mut WiFiDirectConnectionStatus) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: <foundation::TypedEventHandler<WiFiDirectDevice, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-networking")] fn GetConnectionEndpointPairs(&self, out: *mut <foundation::collections::IVectorView<super::super::networking::EndpointPair> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectDevice {
    #[inline] pub fn get_connection_status(&self) -> Result<WiFiDirectConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ConnectionStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &foundation::TypedEventHandler<WiFiDirectDevice, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_ConnectionStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_endpoint_pairs(&self) -> Result<Option<foundation::collections::IVectorView<super::super::networking::EndpointPair>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetConnectionEndpointPairs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectDevice: IWiFiDirectDevice}
impl RtActivatable<IWiFiDirectDeviceStatics> for WiFiDirectDevice {}
impl RtActivatable<IWiFiDirectDeviceStatics2> for WiFiDirectDevice {}
impl WiFiDirectDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectDevice>> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector2(type_: WiFiDirectDeviceSelectorType) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics2>>::get_activation_factory().get_device_selector(type_)
    }
    #[inline] pub fn from_id_async2(deviceId: &HStringArg, connectionParameters: &WiFiDirectConnectionParameters) -> Result<foundation::IAsyncOperation<WiFiDirectDevice>> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics2>>::get_activation_factory().from_id_async(deviceId, connectionParameters)
    }
}
DEFINE_CLSID!(WiFiDirectDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,68,101,118,105,99,101,0]) [CLSID_WiFiDirectDevice]);
RT_ENUM! { enum WiFiDirectDeviceSelectorType: i32 {
    DeviceInterface = 0, AssociationEndpoint = 1,
}}
DEFINE_IID!(IID_IWiFiDirectDeviceStatics, 3899438460, 15020, 18513, 167, 146, 72, 42, 175, 147, 27, 4);
RT_INTERFACE!{static interface IWiFiDirectDeviceStatics(IWiFiDirectDeviceStaticsVtbl, IWiFiDirectDeviceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiDirectDevice> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectDeviceStatics {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectDeviceStatics2, 445988425, 45315, 17278, 146, 38, 171, 103, 151, 19, 66, 249);
RT_INTERFACE!{static interface IWiFiDirectDeviceStatics2(IWiFiDirectDeviceStatics2Vtbl, IWiFiDirectDeviceStatics2_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics2] {
    fn GetDeviceSelector(&self, type_: WiFiDirectDeviceSelectorType, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, connectionParameters: <WiFiDirectConnectionParameters as RtType>::Abi, out: *mut <foundation::IAsyncOperation<WiFiDirectDevice> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectDeviceStatics2 {
    #[inline] pub fn get_device_selector(&self, type_: WiFiDirectDeviceSelectorType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetDeviceSelector)(self.0.as_abi() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, connectionParameters: &WiFiDirectConnectionParameters) -> Result<foundation::IAsyncOperation<WiFiDirectDevice>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), get_abi(connectionParameters) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2,
}}
DEFINE_IID!(IID_IWiFiDirectInformationElement, 2952491734, 30395, 18814, 172, 139, 220, 114, 131, 139, 195, 9);
RT_INTERFACE!{interface IWiFiDirectInformationElement(IWiFiDirectInformationElementVtbl, IWiFiDirectInformationElement_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElement] {
    #[cfg(feature="windows-storage")] fn get_Oui(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Oui(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_OuiType(&self, out: *mut u8) -> HRESULT,
    fn put_OuiType(&self, value: u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Value(&self, value: <super::super::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectInformationElement {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_oui(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Oui)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_oui(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Oui)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_oui_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_OuiType)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_oui_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_OuiType)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<super::super::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Value)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_value(&self, value: &super::super::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Value)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectInformationElement: IWiFiDirectInformationElement}
impl RtActivatable<IWiFiDirectInformationElementStatics> for WiFiDirectInformationElement {}
impl RtActivatable<IActivationFactory> for WiFiDirectInformationElement {}
impl WiFiDirectInformationElement {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(buffer: &super::super::storage::streams::IBuffer) -> Result<Option<foundation::collections::IVector<WiFiDirectInformationElement>>> {
        <Self as RtActivatable<IWiFiDirectInformationElementStatics>>::get_activation_factory().create_from_buffer(buffer)
    }
    #[inline] pub fn create_from_device_information(deviceInformation: &super::enumeration::DeviceInformation) -> Result<Option<foundation::collections::IVector<WiFiDirectInformationElement>>> {
        <Self as RtActivatable<IWiFiDirectInformationElementStatics>>::get_activation_factory().create_from_device_information(deviceInformation)
    }
}
DEFINE_CLSID!(WiFiDirectInformationElement(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,73,110,102,111,114,109,97,116,105,111,110,69,108,101,109,101,110,116,0]) [CLSID_WiFiDirectInformationElement]);
DEFINE_IID!(IID_IWiFiDirectInformationElementStatics, 3687853846, 4517, 20064, 140, 170, 52, 119, 33, 72, 55, 138);
RT_INTERFACE!{static interface IWiFiDirectInformationElementStatics(IWiFiDirectInformationElementStaticsVtbl, IWiFiDirectInformationElementStatics_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElementStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromBuffer(&self, buffer: <super::super::storage::streams::IBuffer as RtType>::Abi, out: *mut <foundation::collections::IVector<WiFiDirectInformationElement> as RtType>::Abi) -> HRESULT,
    fn CreateFromDeviceInformation(&self, deviceInformation: <super::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::collections::IVector<WiFiDirectInformationElement> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectInformationElementStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(&self, buffer: &super::super::storage::streams::IBuffer) -> Result<Option<foundation::collections::IVector<WiFiDirectInformationElement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromBuffer)(self.0.as_abi() as *const _ as *mut _, get_abi(buffer) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_information(&self, deviceInformation: &super::enumeration::DeviceInformation) -> Result<Option<foundation::collections::IVector<WiFiDirectInformationElement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateFromDeviceInformation)(self.0.as_abi() as *const _ as *mut _, get_abi(deviceInformation) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectLegacySettings, 2790251450, 62205, 17767, 169, 27, 245, 194, 245, 50, 16, 87);
RT_INTERFACE!{interface IWiFiDirectLegacySettings(IWiFiDirectLegacySettingsVtbl, IWiFiDirectLegacySettings_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectLegacySettings] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_Ssid(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Ssid(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-security")] fn get_Passphrase(&self, out: *mut <super::super::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-security")] fn put_Passphrase(&self, value: <super::super::security::credentials::PasswordCredential as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectLegacySettings {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsEnabled)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_IsEnabled)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Ssid)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_ssid(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Ssid)(self.0.as_abi() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_passphrase(&self) -> Result<Option<super::super::security::credentials::PasswordCredential>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Passphrase)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::security::credentials::PasswordCredential::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_passphrase(&self, value: &super::super::security::credentials::PasswordCredential) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_Passphrase)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectLegacySettings: IWiFiDirectLegacySettings}
RT_ENUM! { enum WiFiDirectPairingProcedure: i32 {
    GroupOwnerNegotiation = 0, Invitation = 1,
}}
pub mod services { // Windows.Devices.WiFiDirect.Services
use crate::prelude::*;
DEFINE_IID!(IID_IWiFiDirectService, 1353366456, 24433, 17900, 132, 241, 161, 228, 252, 120, 121, 163);
RT_INTERFACE!{interface IWiFiDirectService(IWiFiDirectServiceVtbl, IWiFiDirectService_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectService] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_RemoteServiceInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_SupportedConfigurationMethods(&self, out: *mut <foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod> as RtType>::Abi) -> HRESULT,
    fn get_PreferGroupOwnerMode(&self, out: *mut bool) -> HRESULT,
    fn put_PreferGroupOwnerMode(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SessionInfo(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_ServiceError(&self, out: *mut WiFiDirectServiceError) -> HRESULT,
    fn add_SessionDeferred(&self, handler: <foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionDeferred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetProvisioningInfoAsync(&self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod, out: *mut <foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo> as RtType>::Abi) -> HRESULT,
    fn ConnectAsync(&self, out: *mut <foundation::IAsyncOperation<WiFiDirectServiceSession> as RtType>::Abi) -> HRESULT,
    fn ConnectAsyncWithPin(&self, pin: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiDirectServiceSession> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectService {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_remote_service_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_RemoteServiceInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_configuration_methods(&self) -> Result<Option<foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SupportedConfigurationMethods)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_prefer_group_owner_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferGroupOwnerMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_prefer_group_owner_mode(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreferGroupOwnerMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_session_info(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_SessionInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_error(&self) -> Result<WiFiDirectServiceError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_session_deferred(&self, handler: &foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionDeferred)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_deferred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionDeferred)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_provisioning_info_async(&self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod) -> Result<foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetProvisioningInfoAsync)(self.0.as_abi() as *const _ as *mut _, selectedConfigurationMethod, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self) -> Result<foundation::IAsyncOperation<WiFiDirectServiceSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsync)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async_with_pin(&self, pin: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectServiceSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsyncWithPin)(self.0.as_abi() as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectService: IWiFiDirectService}
impl RtActivatable<IWiFiDirectServiceStatics> for WiFiDirectService {}
impl WiFiDirectService {
    #[inline] pub fn get_selector(serviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().get_selector(serviceName)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn get_selector_with_filter(serviceName: &HStringArg, serviceInfoFilter: &crate::windows::storage::streams::IBuffer) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().get_selector_with_filter(serviceName, serviceInfoFilter)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectService>> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(WiFiDirectService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,0]) [CLSID_WiFiDirectService]);
RT_ENUM! { enum WiFiDirectServiceAdvertisementStatus: i32 {
    Created = 0, Started = 1, Stopped = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IWiFiDirectServiceAdvertiser, 2762612449, 40335, 20303, 147, 238, 125, 222, 162, 227, 127, 70);
RT_INTERFACE!{interface IWiFiDirectServiceAdvertiser(IWiFiDirectServiceAdvertiserVtbl, IWiFiDirectServiceAdvertiser_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiser] {
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceNamePrefixes(&self, out: *mut <foundation::collections::IVector<HString> as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_ServiceInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_ServiceInfo(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_AutoAcceptSession(&self, out: *mut bool) -> HRESULT,
    fn put_AutoAcceptSession(&self, value: bool) -> HRESULT,
    fn get_PreferGroupOwnerMode(&self, out: *mut bool) -> HRESULT,
    fn put_PreferGroupOwnerMode(&self, value: bool) -> HRESULT,
    fn get_PreferredConfigurationMethods(&self, out: *mut <foundation::collections::IVector<WiFiDirectServiceConfigurationMethod> as RtType>::Abi) -> HRESULT,
    fn get_ServiceStatus(&self, out: *mut WiFiDirectServiceStatus) -> HRESULT,
    fn put_ServiceStatus(&self, value: WiFiDirectServiceStatus) -> HRESULT,
    fn get_CustomServiceStatusCode(&self, out: *mut u32) -> HRESULT,
    fn put_CustomServiceStatusCode(&self, value: u32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DeferredSessionInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_DeferredSessionInfo(&self, value: <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT,
    fn get_AdvertisementStatus(&self, out: *mut WiFiDirectServiceAdvertisementStatus) -> HRESULT,
    fn get_ServiceError(&self, out: *mut WiFiDirectServiceError) -> HRESULT,
    fn add_SessionRequested(&self, handler: <foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AutoAcceptSessionConnected(&self, handler: <foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AutoAcceptSessionConnected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AdvertisementStatusChanged(&self, handler: <foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AdvertisementStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn ConnectAsync(&self, deviceInfo: <super::super::enumeration::DeviceInformation as RtType>::Abi, out: *mut <foundation::IAsyncOperation<WiFiDirectServiceSession> as RtType>::Abi) -> HRESULT,
    fn ConnectAsyncWithPin(&self, deviceInfo: <super::super::enumeration::DeviceInformation as RtType>::Abi, pin: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiDirectServiceSession> as RtType>::Abi) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl IWiFiDirectServiceAdvertiser {
    #[inline] pub fn get_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_name_prefixes(&self) -> Result<Option<foundation::collections::IVector<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceNamePrefixes)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_service_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_service_info(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ServiceInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_accept_session(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AutoAcceptSession)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_accept_session(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_AutoAcceptSession)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_prefer_group_owner_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferGroupOwnerMode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_prefer_group_owner_mode(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_PreferGroupOwnerMode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_configuration_methods(&self) -> Result<Option<foundation::collections::IVector<WiFiDirectServiceConfigurationMethod>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_PreferredConfigurationMethods)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVector::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_status(&self) -> Result<WiFiDirectServiceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_service_status(&self, value: WiFiDirectServiceStatus) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_ServiceStatus)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_service_status_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_CustomServiceStatusCode)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_service_status_code(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_CustomServiceStatusCode)(self.0.as_abi() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_deferred_session_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeferredSessionInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_deferred_session_info(&self, value: &crate::windows::storage::streams::IBuffer) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).put_DeferredSessionInfo)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_status(&self) -> Result<WiFiDirectServiceAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisementStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_error(&self) -> Result<WiFiDirectServiceError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceError)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_session_requested(&self, handler: &foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionRequested)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionRequested)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_auto_accept_session_connected(&self, handler: &foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AutoAcceptSessionConnected)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_auto_accept_session_connected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AutoAcceptSessionConnected)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_advertisement_status_changed(&self, handler: &foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_AdvertisementStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_advertisement_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_AdvertisementStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self, deviceInfo: &super::super::enumeration::DeviceInformation) -> Result<foundation::IAsyncOperation<WiFiDirectServiceSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(deviceInfo) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async_with_pin(&self, deviceInfo: &super::super::enumeration::DeviceInformation, pin: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectServiceSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).ConnectAsyncWithPin)(self.0.as_abi() as *const _ as *mut _, get_abi(deviceInfo) as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Start)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).Stop)(self.0.as_abi() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceAdvertiser: IWiFiDirectServiceAdvertiser}
impl RtActivatable<IWiFiDirectServiceAdvertiserFactory> for WiFiDirectServiceAdvertiser {}
impl WiFiDirectServiceAdvertiser {
    #[inline] pub fn create_wi_fi_direct_service_advertiser(serviceName: &HStringArg) -> Result<WiFiDirectServiceAdvertiser> {
        <Self as RtActivatable<IWiFiDirectServiceAdvertiserFactory>>::get_activation_factory().create_wi_fi_direct_service_advertiser(serviceName)
    }
}
DEFINE_CLSID!(WiFiDirectServiceAdvertiser(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,65,100,118,101,114,116,105,115,101,114,0]) [CLSID_WiFiDirectServiceAdvertiser]);
DEFINE_IID!(IID_IWiFiDirectServiceAdvertiserFactory, 822520845, 46150, 20243, 159, 154, 138, 233, 37, 254, 186, 43);
RT_INTERFACE!{static interface IWiFiDirectServiceAdvertiserFactory(IWiFiDirectServiceAdvertiserFactoryVtbl, IWiFiDirectServiceAdvertiserFactory_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiserFactory] {
    fn CreateWiFiDirectServiceAdvertiser(&self, serviceName: HSTRING, out: *mut <WiFiDirectServiceAdvertiser as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceAdvertiserFactory {
    #[inline] pub fn create_wi_fi_direct_service_advertiser(&self, serviceName: &HStringArg) -> Result<WiFiDirectServiceAdvertiser> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).CreateWiFiDirectServiceAdvertiser)(self.0.as_abi() as *const _ as *mut _, serviceName.get(), &mut out);
        if hr == S_OK { Ok(WiFiDirectServiceAdvertiser::wrap_nonnull(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs, 3705266206, 33759, 17381, 143, 67, 203, 232, 71, 158, 132, 235);
RT_INTERFACE!{interface IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs(IWiFiDirectServiceAutoAcceptSessionConnectedEventArgsVtbl, IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs] {
    fn get_Session(&self, out: *mut <WiFiDirectServiceSession as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs {
    #[inline] pub fn get_session(&self) -> Result<Option<WiFiDirectServiceSession>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_Session)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectServiceSession::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceAutoAcceptSessionConnectedEventArgs: IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs}
RT_ENUM! { enum WiFiDirectServiceConfigurationMethod: i32 {
    Default = 0, PinDisplay = 1, PinEntry = 2,
}}
RT_ENUM! { enum WiFiDirectServiceError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2, UnsupportedHardware = 3, NoHardware = 4,
}}
RT_ENUM! { enum WiFiDirectServiceIPProtocol: i32 {
    Tcp = 6, Udp = 17,
}}
DEFINE_IID!(IID_IWiFiDirectServiceProvisioningInfo, 2346417406, 38873, 17826, 142, 153, 219, 80, 145, 15, 182, 166);
RT_INTERFACE!{interface IWiFiDirectServiceProvisioningInfo(IWiFiDirectServiceProvisioningInfoVtbl, IWiFiDirectServiceProvisioningInfo_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceProvisioningInfo] {
    fn get_SelectedConfigurationMethod(&self, out: *mut WiFiDirectServiceConfigurationMethod) -> HRESULT,
    fn get_IsGroupFormationNeeded(&self, out: *mut bool) -> HRESULT
}}
impl IWiFiDirectServiceProvisioningInfo {
    #[inline] pub fn get_selected_configuration_method(&self) -> Result<WiFiDirectServiceConfigurationMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SelectedConfigurationMethod)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_group_formation_needed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_IsGroupFormationNeeded)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceProvisioningInfo: IWiFiDirectServiceProvisioningInfo}
DEFINE_IID!(IID_IWiFiDirectServiceRemotePortAddedEventArgs, 3570318017, 16339, 20238, 183, 189, 120, 41, 6, 244, 68, 17);
RT_INTERFACE!{interface IWiFiDirectServiceRemotePortAddedEventArgs(IWiFiDirectServiceRemotePortAddedEventArgsVtbl, IWiFiDirectServiceRemotePortAddedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceRemotePortAddedEventArgs] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_EndpointPairs(&self, out: *mut <foundation::collections::IVectorView<crate::windows::networking::EndpointPair> as RtType>::Abi) -> HRESULT,
    fn get_Protocol(&self, out: *mut WiFiDirectServiceIPProtocol) -> HRESULT
}}
impl IWiFiDirectServiceRemotePortAddedEventArgs {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_endpoint_pairs(&self) -> Result<Option<foundation::collections::IVectorView<crate::windows::networking::EndpointPair>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_EndpointPairs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol(&self) -> Result<WiFiDirectServiceIPProtocol> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Protocol)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceRemotePortAddedEventArgs: IWiFiDirectServiceRemotePortAddedEventArgs}
DEFINE_IID!(IID_IWiFiDirectServiceSession, 2165580131, 58406, 18379, 134, 64, 225, 179, 88, 139, 242, 111);
RT_INTERFACE!{interface IWiFiDirectServiceSession(IWiFiDirectServiceSessionVtbl, IWiFiDirectServiceSession_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSession] {
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut WiFiDirectServiceSessionStatus) -> HRESULT,
    fn get_ErrorStatus(&self, out: *mut WiFiDirectServiceSessionErrorStatus) -> HRESULT,
    fn get_SessionId(&self, out: *mut u32) -> HRESULT,
    fn get_AdvertisementId(&self, out: *mut u32) -> HRESULT,
    fn get_ServiceAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionAddress(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-networking")] fn GetConnectionEndpointPairs(&self, out: *mut <foundation::collections::IVectorView<crate::windows::networking::EndpointPair> as RtType>::Abi) -> HRESULT,
    fn add_SessionStatusChanged(&self, handler: <foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-networking")] fn AddStreamSocketListenerAsync(&self, value: <crate::windows::networking::sockets::StreamSocketListener as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-networking")] fn AddDatagramSocketAsync(&self, value: <crate::windows::networking::sockets::DatagramSocket as RtType>::Abi, out: *mut <foundation::IAsyncAction as RtType>::Abi) -> HRESULT,
    fn add_RemotePortAdded(&self, handler: <foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs> as RtType>::Abi, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RemotePortAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWiFiDirectServiceSession {
    #[inline] pub fn get_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceName)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectServiceSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_Status)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_status(&self) -> Result<WiFiDirectServiceSessionErrorStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_ErrorStatus)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_session_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).get_AdvertisementId)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ServiceAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionAddress)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_endpoint_pairs(&self) -> Result<Option<foundation::collections::IVectorView<crate::windows::networking::EndpointPair>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetConnectionEndpointPairs)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::collections::IVectorView::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_session_status_changed(&self, handler: &foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_SessionStatusChanged)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_SessionStatusChanged)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn add_stream_socket_listener_async(&self, value: &crate::windows::networking::sockets::StreamSocketListener) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddStreamSocketListenerAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn add_datagram_socket_async(&self, value: &crate::windows::networking::sockets::DatagramSocket) -> Result<foundation::IAsyncAction> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).AddDatagramSocketAsync)(self.0.as_abi() as *const _ as *mut _, get_abi(value) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(foundation::IAsyncAction::wrap_nonnull(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_remote_port_added(&self, handler: &foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.0.as_abi().lpVtbl).add_RemotePortAdded)(self.0.as_abi() as *const _ as *mut _, get_abi(handler) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_remote_port_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.0.as_abi().lpVtbl).remove_RemotePortAdded)(self.0.as_abi() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSession: IWiFiDirectServiceSession}
DEFINE_IID!(IID_IWiFiDirectServiceSessionDeferredEventArgs, 2382109055, 4609, 20255, 182, 244, 93, 241, 183, 185, 251, 46);
RT_INTERFACE!{interface IWiFiDirectServiceSessionDeferredEventArgs(IWiFiDirectServiceSessionDeferredEventArgsVtbl, IWiFiDirectServiceSessionDeferredEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionDeferredEventArgs] {
    #[cfg(feature="windows-storage")] fn get_DeferredSessionInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceSessionDeferredEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_deferred_session_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeferredSessionInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionDeferredEventArgs: IWiFiDirectServiceSessionDeferredEventArgs}
RT_ENUM! { enum WiFiDirectServiceSessionErrorStatus: i32 {
    Ok = 0, Disassociated = 1, LocalClose = 2, RemoteClose = 3, SystemFailure = 4, NoResponseFromRemote = 5,
}}
DEFINE_IID!(IID_IWiFiDirectServiceSessionRequest, 2699197579, 20683, 19032, 155, 207, 228, 114, 185, 159, 186, 4);
RT_INTERFACE!{interface IWiFiDirectServiceSessionRequest(IWiFiDirectServiceSessionRequestVtbl, IWiFiDirectServiceSessionRequest_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequest] {
    fn get_DeviceInformation(&self, out: *mut <super::super::enumeration::DeviceInformation as RtType>::Abi) -> HRESULT,
    fn get_ProvisioningInfo(&self, out: *mut <WiFiDirectServiceProvisioningInfo as RtType>::Abi) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut <crate::windows::storage::streams::IBuffer as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceSessionRequest {
    #[inline] pub fn get_device_information(&self) -> Result<Option<super::super::enumeration::DeviceInformation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_DeviceInformation)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(super::super::enumeration::DeviceInformation::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provisioning_info(&self) -> Result<Option<WiFiDirectServiceProvisioningInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_ProvisioningInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectServiceProvisioningInfo::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<crate::windows::storage::streams::IBuffer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).get_SessionInfo)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(crate::windows::storage::streams::IBuffer::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionRequest: IWiFiDirectServiceSessionRequest}
DEFINE_IID!(IID_IWiFiDirectServiceSessionRequestedEventArgs, 1958595601, 21462, 18841, 180, 248, 108, 142, 204, 23, 113, 231);
RT_INTERFACE!{interface IWiFiDirectServiceSessionRequestedEventArgs(IWiFiDirectServiceSessionRequestedEventArgsVtbl, IWiFiDirectServiceSessionRequestedEventArgs_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequestedEventArgs] {
    fn GetSessionRequest(&self, out: *mut <WiFiDirectServiceSessionRequest as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceSessionRequestedEventArgs {
    #[inline] pub fn get_session_request(&self) -> Result<Option<WiFiDirectServiceSessionRequest>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSessionRequest)(self.0.as_abi() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(WiFiDirectServiceSessionRequest::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionRequestedEventArgs: IWiFiDirectServiceSessionRequestedEventArgs}
RT_ENUM! { enum WiFiDirectServiceSessionStatus: i32 {
    Closed = 0, Initiated = 1, Requested = 2, Open = 3,
}}
DEFINE_IID!(IID_IWiFiDirectServiceStatics, 2108948549, 64884, 18056, 183, 37, 93, 206, 134, 172, 242, 51);
RT_INTERFACE!{static interface IWiFiDirectServiceStatics(IWiFiDirectServiceStaticsVtbl, IWiFiDirectServiceStatics_Abi): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceStatics] {
    fn GetSelector(&self, serviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetSelectorWithFilter(&self, serviceName: HSTRING, serviceInfoFilter: <crate::windows::storage::streams::IBuffer as RtType>::Abi, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut <foundation::IAsyncOperation<WiFiDirectService> as RtType>::Abi) -> HRESULT
}}
impl IWiFiDirectServiceStatics {
    #[inline] pub fn get_selector(&self, serviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSelector)(self.0.as_abi() as *const _ as *mut _, serviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_selector_with_filter(&self, serviceName: &HStringArg, serviceInfoFilter: &crate::windows::storage::streams::IBuffer) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).GetSelectorWithFilter)(self.0.as_abi() as *const _ as *mut _, serviceName.get(), get_abi(serviceInfoFilter) as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<foundation::IAsyncOperation<WiFiDirectService>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.0.as_abi().lpVtbl).FromIdAsync)(self.0.as_abi() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(foundation::IAsyncOperation::wrap_nonnull(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectServiceStatus: i32 {
    Available = 0, Busy = 1, Custom = 2,
}}
} // Windows.Devices.WiFiDirect.Services
} // Windows.Devices.WiFiDirect
