// DO NOT MODIFY THIS FILE - IT IS AUTOMATICALLY GENERATED!
#![allow(non_camel_case_types, unused_imports)]
pub mod windows { // Windows
#[cfg(feature="windows.devices")]
pub mod devices { // Windows.Devices
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct DevicesLowLevelContract {
			
		}}
		DEFINE_IID!(IID_ILowLevelDevicesAggregateProvider, 2805880348, 43713, 20167, 168, 82, 71, 159, 112, 96, 208, 31);
		RT_INTERFACE!{interface ILowLevelDevicesAggregateProvider(ILowLevelDevicesAggregateProviderVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProvider] {
			fn get_AdcControllerProvider(&mut self, out: *mut *mut adc::provider::IAdcControllerProvider) -> ::w::HRESULT,
			fn get_PwmControllerProvider(&mut self, out: *mut *mut pwm::provider::IPwmControllerProvider) -> ::w::HRESULT,
			fn get_GpioControllerProvider(&mut self, out: *mut *mut gpio::provider::IGpioControllerProvider) -> ::w::HRESULT,
			fn get_I2cControllerProvider(&mut self, out: *mut *mut i2c::provider::II2cControllerProvider) -> ::w::HRESULT,
			fn get_SpiControllerProvider(&mut self, out: *mut *mut spi::provider::ISpiControllerProvider) -> ::w::HRESULT
		}}
		impl ILowLevelDevicesAggregateProvider {
			#[inline] pub unsafe fn get_adc_controller_provider(&mut self) -> RtResult<ComPtr<adc::provider::IAdcControllerProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AdcControllerProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pwm_controller_provider(&mut self) -> RtResult<ComPtr<pwm::provider::IPwmControllerProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PwmControllerProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gpio_controller_provider(&mut self) -> RtResult<ComPtr<gpio::provider::IGpioControllerProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_GpioControllerProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_i2c_controller_provider(&mut self) -> RtResult<ComPtr<i2c::provider::II2cControllerProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_I2cControllerProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_spi_controller_provider(&mut self) -> RtResult<ComPtr<spi::provider::ISpiControllerProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SpiControllerProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILowLevelDevicesAggregateProviderFactory, 2596580086, 13427, 18014, 150, 213, 54, 40, 26, 44, 87, 175);
		RT_INTERFACE!{static interface ILowLevelDevicesAggregateProviderFactory(ILowLevelDevicesAggregateProviderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProviderFactory] {
			fn Create(&mut self, adc: *mut adc::provider::IAdcControllerProvider, pwm: *mut pwm::provider::IPwmControllerProvider, gpio: *mut gpio::provider::IGpioControllerProvider, i2c: *mut i2c::provider::II2cControllerProvider, spi: *mut spi::provider::ISpiControllerProvider, out: *mut *mut LowLevelDevicesAggregateProvider) -> ::w::HRESULT
		}}
		impl ILowLevelDevicesAggregateProviderFactory {
			#[inline] pub unsafe fn create(&mut self, adc: &adc::provider::IAdcControllerProvider, pwm: &pwm::provider::IPwmControllerProvider, gpio: &gpio::provider::IGpioControllerProvider, i2c: &i2c::provider::II2cControllerProvider, spi: &spi::provider::ISpiControllerProvider) -> RtResult<ComPtr<LowLevelDevicesAggregateProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, adc as *const _ as *mut _, pwm as *const _ as *mut _, gpio as *const _ as *mut _, i2c as *const _ as *mut _, spi as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LowLevelDevicesAggregateProvider: ILowLevelDevicesAggregateProvider [ILowLevelDevicesAggregateProviderFactory] [CLSID_LowLevelDevicesAggregateProvider]}
		DEFINE_CLSID!(CLSID_LowLevelDevicesAggregateProvider = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,65,103,103,114,101,103,97,116,101,80,114,111,118,105,100,101,114,0]);
		DEFINE_IID!(IID_ILowLevelDevicesController, 784481748, 6043, 17886, 155, 57, 58, 224, 37, 39, 222, 82);
		RT_INTERFACE!{interface ILowLevelDevicesController(ILowLevelDevicesControllerVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesController] {
			
		}}
		DEFINE_IID!(IID_ILowLevelDevicesControllerStatics, 155095658, 64715, 17300, 166, 151, 25, 222, 99, 124, 45, 179);
		RT_INTERFACE!{static interface ILowLevelDevicesControllerStatics(ILowLevelDevicesControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesControllerStatics] {
			fn get_DefaultProvider(&mut self, out: *mut *mut ILowLevelDevicesAggregateProvider) -> ::w::HRESULT,
			fn put_DefaultProvider(&mut self, value: *mut ILowLevelDevicesAggregateProvider) -> ::w::HRESULT
		}}
		impl ILowLevelDevicesControllerStatics {
			#[inline] pub unsafe fn get_default_provider(&mut self) -> RtResult<ComPtr<ILowLevelDevicesAggregateProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultProvider)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_default_provider(&mut self, value: &ILowLevelDevicesAggregateProvider) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DefaultProvider)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LowLevelDevicesController: ILowLevelDevicesController}
		RT_ACTIVATABLE!{ILowLevelDevicesControllerStatics [CLSID_LowLevelDevicesController]}
		DEFINE_CLSID!(CLSID_LowLevelDevicesController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,67,111,110,116,114,111,108,108,101,114,0]);
pub mod adc { // Windows.Devices.Adc
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum AdcChannelMode: i32 {
			SingleEnded (AdcChannelMode_SingleEnded) = 0, Differential (AdcChannelMode_Differential) = 1,
		}}
		DEFINE_IID!(IID_IAdcController, 712434864, 43158, 16921, 134, 182, 234, 140, 220, 233, 143, 86);
		RT_INTERFACE!{interface IAdcController(IAdcControllerVtbl): IInspectable(IInspectableVtbl) [IID_IAdcController] {
			fn get_ChannelCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ResolutionInBits(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MinValue(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MaxValue(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ChannelMode(&mut self, out: *mut AdcChannelMode) -> ::w::HRESULT,
			fn put_ChannelMode(&mut self, value: AdcChannelMode) -> ::w::HRESULT,
			fn IsChannelModeSupported(&mut self, channelMode: AdcChannelMode, out: *mut bool) -> ::w::HRESULT,
			fn OpenChannel(&mut self, channelNumber: i32, out: *mut *mut AdcChannel) -> ::w::HRESULT
		}}
		impl IAdcController {
			#[inline] pub unsafe fn get_channel_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChannelCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_resolution_in_bits(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ResolutionInBits)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_value(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_value(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_channel_mode(&mut self) -> RtResult<AdcChannelMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChannelMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_channel_mode(&mut self, value: AdcChannelMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ChannelMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_channel_mode_supported(&mut self, channelMode: AdcChannelMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsChannelModeSupported)(self, channelMode, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_channel(&mut self, channelNumber: i32) -> RtResult<ComPtr<AdcChannel>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenChannel)(self, channelNumber, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AdcChannel: IAdcChannel}
		DEFINE_IID!(IID_IAdcControllerStatics, 3437858316, 504, 18577, 188, 59, 190, 83, 239, 39, 156, 164);
		RT_INTERFACE!{static interface IAdcControllerStatics(IAdcControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics] {
			fn GetControllersAsync(&mut self, provider: *mut provider::IAdcProvider, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AdcController>>) -> ::w::HRESULT
		}}
		impl IAdcControllerStatics {
			#[inline] pub unsafe fn get_controllers_async(&mut self, provider: &provider::IAdcProvider) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AdcController>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, provider as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AdcController: IAdcController}
		RT_ACTIVATABLE!{IAdcControllerStatics2 [CLSID_AdcController]}
		RT_ACTIVATABLE!{IAdcControllerStatics [CLSID_AdcController]}
		DEFINE_CLSID!(CLSID_AdcController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,100,99,46,65,100,99,67,111,110,116,114,111,108,108,101,114,0]);
		DEFINE_IID!(IID_IAdcControllerStatics2, 2730048285, 38779, 20314, 165, 254, 166, 171, 175, 254, 100, 132);
		RT_INTERFACE!{static interface IAdcControllerStatics2(IAdcControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics2] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<AdcController>) -> ::w::HRESULT
		}}
		impl IAdcControllerStatics2 {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AdcController>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAdcChannel, 67892244, 9608, 19030, 171, 239, 115, 162, 96, 172, 198, 10);
		RT_INTERFACE!{interface IAdcChannel(IAdcChannelVtbl): IInspectable(IInspectableVtbl) [IID_IAdcChannel] {
			fn get_Controller(&mut self, out: *mut *mut AdcController) -> ::w::HRESULT,
			fn ReadValue(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn ReadRatio(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IAdcChannel {
			#[inline] pub unsafe fn get_controller(&mut self) -> RtResult<ComPtr<AdcController>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Controller)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ReadValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_ratio(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ReadRatio)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.Adc.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum ProviderAdcChannelMode: i32 {
			SingleEnded (ProviderAdcChannelMode_SingleEnded) = 0, Differential (ProviderAdcChannelMode_Differential) = 1,
		}}
		DEFINE_IID!(IID_IAdcControllerProvider, 3193198632, 33133, 19941, 160, 72, 171, 160, 105, 88, 170, 168);
		RT_INTERFACE!{interface IAdcControllerProvider(IAdcControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerProvider] {
			fn get_ChannelCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ResolutionInBits(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MinValue(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MaxValue(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ChannelMode(&mut self, out: *mut ProviderAdcChannelMode) -> ::w::HRESULT,
			fn put_ChannelMode(&mut self, value: ProviderAdcChannelMode) -> ::w::HRESULT,
			fn IsChannelModeSupported(&mut self, channelMode: ProviderAdcChannelMode, out: *mut bool) -> ::w::HRESULT,
			fn AcquireChannel(&mut self, channel: i32) -> ::w::HRESULT,
			fn ReleaseChannel(&mut self, channel: i32) -> ::w::HRESULT,
			fn ReadValue(&mut self, channelNumber: i32, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAdcControllerProvider {
			#[inline] pub unsafe fn get_channel_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChannelCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_resolution_in_bits(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ResolutionInBits)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_value(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_value(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_channel_mode(&mut self) -> RtResult<ProviderAdcChannelMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChannelMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_channel_mode(&mut self, value: ProviderAdcChannelMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ChannelMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_channel_mode_supported(&mut self, channelMode: ProviderAdcChannelMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsChannelModeSupported)(self, channelMode, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn acquire_channel(&mut self, channel: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AcquireChannel)(self, channel);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn release_channel(&mut self, channel: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ReleaseChannel)(self, channel);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value(&mut self, channelNumber: i32) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ReadValue)(self, channelNumber, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAdcProvider, 680867432, 37721, 19543, 188, 136, 226, 117, 232, 22, 56, 201);
		RT_INTERFACE!{interface IAdcProvider(IAdcProviderVtbl): IInspectable(IInspectableVtbl) [IID_IAdcProvider] {
			fn GetControllers(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<IAdcControllerProvider>) -> ::w::HRESULT
		}}
		impl IAdcProvider {
			#[inline] pub unsafe fn get_controllers(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<IAdcControllerProvider>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Adc.Provider
} // Windows.Devices.Adc
pub mod gpio { // Windows.Devices.Gpio
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum GpioSharingMode: i32 {
			Exclusive (GpioSharingMode_Exclusive) = 0, SharedReadOnly (GpioSharingMode_SharedReadOnly) = 1,
		}}
		RT_ENUM! { enum GpioOpenStatus: i32 {
			PinOpened (GpioOpenStatus_PinOpened) = 0, PinUnavailable (GpioOpenStatus_PinUnavailable) = 1, SharingViolation (GpioOpenStatus_SharingViolation) = 2,
		}}
		RT_ENUM! { enum GpioPinDriveMode: i32 {
			Input (GpioPinDriveMode_Input) = 0, Output (GpioPinDriveMode_Output) = 1, InputPullUp (GpioPinDriveMode_InputPullUp) = 2, InputPullDown (GpioPinDriveMode_InputPullDown) = 3, OutputOpenDrain (GpioPinDriveMode_OutputOpenDrain) = 4, OutputOpenDrainPullUp (GpioPinDriveMode_OutputOpenDrainPullUp) = 5, OutputOpenSource (GpioPinDriveMode_OutputOpenSource) = 6, OutputOpenSourcePullDown (GpioPinDriveMode_OutputOpenSourcePullDown) = 7,
		}}
		RT_ENUM! { enum GpioPinValue: i32 {
			Low (GpioPinValue_Low) = 0, High (GpioPinValue_High) = 1,
		}}
		RT_ENUM! { enum GpioPinEdge: i32 {
			FallingEdge (GpioPinEdge_FallingEdge) = 0, RisingEdge (GpioPinEdge_RisingEdge) = 1,
		}}
		DEFINE_IID!(IID_IGpioPinValueChangedEventArgs, 825731809, 28733, 16473, 189, 36, 181, 178, 93, 255, 184, 78);
		RT_INTERFACE!{interface IGpioPinValueChangedEventArgs(IGpioPinValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinValueChangedEventArgs] {
			fn get_Edge(&mut self, out: *mut GpioPinEdge) -> ::w::HRESULT
		}}
		impl IGpioPinValueChangedEventArgs {
			#[inline] pub unsafe fn get_edge(&mut self) -> RtResult<GpioPinEdge> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Edge)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GpioPinValueChangedEventArgs: IGpioPinValueChangedEventArgs}
		RT_CLASS!{class GpioPin: IGpioPin}
		DEFINE_IID!(IID_IGpioController, 675287779, 29793, 18076, 168, 188, 97, 214, 157, 8, 165, 60);
		RT_INTERFACE!{interface IGpioController(IGpioControllerVtbl): IInspectable(IInspectableVtbl) [IID_IGpioController] {
			fn get_PinCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn OpenPin(&mut self, pinNumber: i32, out: *mut *mut GpioPin) -> ::w::HRESULT,
			fn OpenPinWithSharingMode(&mut self, pinNumber: i32, sharingMode: GpioSharingMode, out: *mut *mut GpioPin) -> ::w::HRESULT,
			fn TryOpenPin(&mut self, pinNumber: i32, sharingMode: GpioSharingMode, pin: *mut *mut GpioPin, openStatus: *mut GpioOpenStatus, out: *mut bool) -> ::w::HRESULT
		}}
		impl IGpioController {
			#[inline] pub unsafe fn get_pin_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_pin(&mut self, pinNumber: i32) -> RtResult<ComPtr<GpioPin>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenPin)(self, pinNumber, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_pin_with_sharing_mode(&mut self, pinNumber: i32, sharingMode: GpioSharingMode) -> RtResult<ComPtr<GpioPin>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenPinWithSharingMode)(self, pinNumber, sharingMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_open_pin(&mut self, pinNumber: i32, sharingMode: GpioSharingMode) -> RtResult<(ComPtr<GpioPin>, GpioOpenStatus, bool)> {
				let mut pin = ::std::ptr::null_mut(); let mut openStatus = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryOpenPin)(self, pinNumber, sharingMode, &mut pin, &mut openStatus, &mut out);
				if hr == ::w::S_OK { Ok((ComPtr::wrap(pin), openStatus, out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGpioControllerStatics, 785839150, 31479, 16662, 149, 51, 196, 61, 153, 161, 251, 100);
		RT_INTERFACE!{static interface IGpioControllerStatics(IGpioControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics] {
			fn GetDefault(&mut self, out: *mut *mut GpioController) -> ::w::HRESULT
		}}
		impl IGpioControllerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<GpioController>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GpioController: IGpioController}
		RT_ACTIVATABLE!{IGpioControllerStatics2 [CLSID_GpioController]}
		RT_ACTIVATABLE!{IGpioControllerStatics [CLSID_GpioController]}
		DEFINE_CLSID!(CLSID_GpioController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,111,110,116,114,111,108,108,101,114,0]);
		DEFINE_IID!(IID_IGpioControllerStatics2, 2435546400, 27812, 16646, 163, 115, 255, 253, 52, 107, 14, 91);
		RT_INTERFACE!{static interface IGpioControllerStatics2(IGpioControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics2] {
			fn GetControllersAsync(&mut self, provider: *mut provider::IGpioProvider, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<GpioController>>) -> ::w::HRESULT,
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<GpioController>) -> ::w::HRESULT
		}}
		impl IGpioControllerStatics2 {
			#[inline] pub unsafe fn get_controllers_async(&mut self, provider: &provider::IGpioProvider) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<GpioController>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, provider as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<GpioController>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGpioPin, 299479175, 44974, 18320, 158, 233, 224, 234, 201, 66, 210, 1);
		RT_INTERFACE!{interface IGpioPin(IGpioPinVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPin] {
			fn add_ValueChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ValueChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_DebounceTimeout(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_DebounceTimeout(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_PinNumber(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut GpioSharingMode) -> ::w::HRESULT,
			fn IsDriveModeSupported(&mut self, driveMode: GpioPinDriveMode, out: *mut bool) -> ::w::HRESULT,
			fn GetDriveMode(&mut self, out: *mut GpioPinDriveMode) -> ::w::HRESULT,
			fn SetDriveMode(&mut self, value: GpioPinDriveMode) -> ::w::HRESULT,
			fn Write(&mut self, value: GpioPinValue) -> ::w::HRESULT,
			fn Read(&mut self, out: *mut GpioPinValue) -> ::w::HRESULT
		}}
		impl IGpioPin {
			#[inline] pub unsafe fn add_value_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ValueChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_value_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ValueChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_debounce_timeout(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DebounceTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_debounce_timeout(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DebounceTimeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pin_number(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<GpioSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_drive_mode_supported(&mut self, driveMode: GpioPinDriveMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsDriveModeSupported)(self, driveMode, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_drive_mode(&mut self) -> RtResult<GpioPinDriveMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetDriveMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_drive_mode(&mut self, value: GpioPinDriveMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetDriveMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, value: GpioPinValue) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self) -> RtResult<GpioPinValue> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).Read)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.Gpio.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum ProviderGpioSharingMode: i32 {
			Exclusive (ProviderGpioSharingMode_Exclusive) = 0, SharedReadOnly (ProviderGpioSharingMode_SharedReadOnly) = 1,
		}}
		RT_ENUM! { enum ProviderGpioPinDriveMode: i32 {
			Input (ProviderGpioPinDriveMode_Input) = 0, Output (ProviderGpioPinDriveMode_Output) = 1, InputPullUp (ProviderGpioPinDriveMode_InputPullUp) = 2, InputPullDown (ProviderGpioPinDriveMode_InputPullDown) = 3, OutputOpenDrain (ProviderGpioPinDriveMode_OutputOpenDrain) = 4, OutputOpenDrainPullUp (ProviderGpioPinDriveMode_OutputOpenDrainPullUp) = 5, OutputOpenSource (ProviderGpioPinDriveMode_OutputOpenSource) = 6, OutputOpenSourcePullDown (ProviderGpioPinDriveMode_OutputOpenSourcePullDown) = 7,
		}}
		RT_ENUM! { enum ProviderGpioPinValue: i32 {
			Low (ProviderGpioPinValue_Low) = 0, High (ProviderGpioPinValue_High) = 1,
		}}
		RT_ENUM! { enum ProviderGpioPinEdge: i32 {
			FallingEdge (ProviderGpioPinEdge_FallingEdge) = 0, RisingEdge (ProviderGpioPinEdge_RisingEdge) = 1,
		}}
		DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgsFactory, 1053494105, 22156, 17298, 178, 74, 138, 89, 169, 2, 177, 241);
		RT_INTERFACE!{static interface IGpioPinProviderValueChangedEventArgsFactory(IGpioPinProviderValueChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgsFactory] {
			fn Create(&mut self, edge: ProviderGpioPinEdge, out: *mut *mut GpioPinProviderValueChangedEventArgs) -> ::w::HRESULT
		}}
		impl IGpioPinProviderValueChangedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, edge: ProviderGpioPinEdge) -> RtResult<ComPtr<GpioPinProviderValueChangedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, edge, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GpioPinProviderValueChangedEventArgs: IGpioPinProviderValueChangedEventArgs [IGpioPinProviderValueChangedEventArgsFactory] [CLSID_GpioPinProviderValueChangedEventArgs]}
		DEFINE_CLSID!(CLSID_GpioPinProviderValueChangedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,80,114,111,118,105,100,101,114,46,71,112,105,111,80,105,110,80,114,111,118,105,100,101,114,86,97,108,117,101,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgs, 849794802, 15707, 17613, 143, 190, 19, 166, 159, 46, 219, 36);
		RT_INTERFACE!{interface IGpioPinProviderValueChangedEventArgs(IGpioPinProviderValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgs] {
			fn get_Edge(&mut self, out: *mut ProviderGpioPinEdge) -> ::w::HRESULT
		}}
		impl IGpioPinProviderValueChangedEventArgs {
			#[inline] pub unsafe fn get_edge(&mut self) -> RtResult<ProviderGpioPinEdge> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Edge)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGpioPinProvider, 1110723767, 27324, 16639, 156, 231, 115, 184, 83, 1, 185, 0);
		RT_INTERFACE!{interface IGpioPinProvider(IGpioPinProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProvider] {
			fn add_ValueChanged(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ValueChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_DebounceTimeout(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_DebounceTimeout(&mut self, value: ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_PinNumber(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut ProviderGpioSharingMode) -> ::w::HRESULT,
			fn IsDriveModeSupported(&mut self, driveMode: ProviderGpioPinDriveMode, out: *mut bool) -> ::w::HRESULT,
			fn GetDriveMode(&mut self, out: *mut ProviderGpioPinDriveMode) -> ::w::HRESULT,
			fn SetDriveMode(&mut self, value: ProviderGpioPinDriveMode) -> ::w::HRESULT,
			fn Write(&mut self, value: ProviderGpioPinValue) -> ::w::HRESULT,
			fn Read(&mut self, out: *mut ProviderGpioPinValue) -> ::w::HRESULT
		}}
		impl IGpioPinProvider {
			#[inline] pub unsafe fn add_value_changed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ValueChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_value_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ValueChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_debounce_timeout(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DebounceTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_debounce_timeout(&mut self, value: ::rt::gen::windows::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DebounceTimeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pin_number(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<ProviderGpioSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_drive_mode_supported(&mut self, driveMode: ProviderGpioPinDriveMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsDriveModeSupported)(self, driveMode, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_drive_mode(&mut self) -> RtResult<ProviderGpioPinDriveMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetDriveMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_drive_mode(&mut self, value: ProviderGpioPinDriveMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetDriveMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, value: ProviderGpioPinValue) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self) -> RtResult<ProviderGpioPinValue> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).Read)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGpioControllerProvider, 2903625415, 6634, 19233, 135, 79, 185, 26, 237, 74, 37, 219);
		RT_INTERFACE!{interface IGpioControllerProvider(IGpioControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerProvider] {
			fn get_PinCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn OpenPinProvider(&mut self, pin: i32, sharingMode: ProviderGpioSharingMode, out: *mut *mut IGpioPinProvider) -> ::w::HRESULT
		}}
		impl IGpioControllerProvider {
			#[inline] pub unsafe fn get_pin_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_pin_provider(&mut self, pin: i32, sharingMode: ProviderGpioSharingMode) -> RtResult<ComPtr<IGpioPinProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenPinProvider)(self, pin, sharingMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGpioProvider, 1156065031, 2250, 17226, 175, 224, 214, 21, 128, 68, 111, 126);
		RT_INTERFACE!{interface IGpioProvider(IGpioProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioProvider] {
			fn GetControllers(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<IGpioControllerProvider>) -> ::w::HRESULT
		}}
		impl IGpioProvider {
			#[inline] pub unsafe fn get_controllers(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<IGpioControllerProvider>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Gpio.Provider
} // Windows.Devices.Gpio
pub mod i2c { // Windows.Devices.I2c
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum I2cBusSpeed: i32 {
			StandardMode (I2cBusSpeed_StandardMode) = 0, FastMode (I2cBusSpeed_FastMode) = 1,
		}}
		RT_ENUM! { enum I2cTransferStatus: i32 {
			FullTransfer (I2cTransferStatus_FullTransfer) = 0, PartialTransfer (I2cTransferStatus_PartialTransfer) = 1, SlaveAddressNotAcknowledged (I2cTransferStatus_SlaveAddressNotAcknowledged) = 2,
		}}
		RT_ENUM! { enum I2cSharingMode: i32 {
			Exclusive (I2cSharingMode_Exclusive) = 0, Shared (I2cSharingMode_Shared) = 1,
		}}
		RT_STRUCT! { struct I2cTransferResult {
			Status: I2cTransferStatus, BytesTransferred: u32,
		}}
		DEFINE_IID!(IID_II2cConnectionSettingsFactory, 2176157363, 38547, 16817, 162, 67, 222, 212, 246, 230, 105, 38);
		RT_INTERFACE!{static interface II2cConnectionSettingsFactory(II2cConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettingsFactory] {
			fn Create(&mut self, slaveAddress: i32, out: *mut *mut I2cConnectionSettings) -> ::w::HRESULT
		}}
		impl II2cConnectionSettingsFactory {
			#[inline] pub unsafe fn create(&mut self, slaveAddress: i32) -> RtResult<ComPtr<I2cConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, slaveAddress, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class I2cConnectionSettings: II2cConnectionSettings [II2cConnectionSettingsFactory] [CLSID_I2cConnectionSettings]}
		DEFINE_CLSID!(CLSID_I2cConnectionSettings = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]);
		DEFINE_IID!(IID_II2cConnectionSettings, 4074443527, 43887, 17977, 167, 103, 84, 83, 109, 195, 70, 15);
		RT_INTERFACE!{interface II2cConnectionSettings(II2cConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettings] {
			fn get_SlaveAddress(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_SlaveAddress(&mut self, value: i32) -> ::w::HRESULT,
			fn get_BusSpeed(&mut self, out: *mut I2cBusSpeed) -> ::w::HRESULT,
			fn put_BusSpeed(&mut self, value: I2cBusSpeed) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut I2cSharingMode) -> ::w::HRESULT,
			fn put_SharingMode(&mut self, value: I2cSharingMode) -> ::w::HRESULT
		}}
		impl II2cConnectionSettings {
			#[inline] pub unsafe fn get_slave_address(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SlaveAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_slave_address(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SlaveAddress)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bus_speed(&mut self) -> RtResult<I2cBusSpeed> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BusSpeed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_bus_speed(&mut self, value: I2cBusSpeed) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BusSpeed)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<I2cSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_sharing_mode(&mut self, value: I2cSharingMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SharingMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_II2cDeviceStatics, 2443394019, 29492, 17682, 150, 188, 251, 174, 148, 89, 245, 246);
		RT_INTERFACE!{static interface II2cDeviceStatics(II2cDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_II2cDeviceStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromFriendlyName(&mut self, friendlyName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, settings: *mut I2cConnectionSettings, out: *mut *mut super::super::foundation::IAsyncOperation<I2cDevice>) -> ::w::HRESULT
		}}
		impl II2cDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_friendly_name(&mut self, friendlyName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromFriendlyName)(self, friendlyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg, settings: &I2cConnectionSettings) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<I2cDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class I2cDevice: II2cDevice}
		RT_ACTIVATABLE!{II2cDeviceStatics [CLSID_I2cDevice]}
		DEFINE_CLSID!(CLSID_I2cDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_II2cController, 3297423794, 34720, 16742, 142, 62, 180, 184, 249, 124, 215, 41);
		RT_INTERFACE!{interface II2cController(II2cControllerVtbl): IInspectable(IInspectableVtbl) [IID_II2cController] {
			fn GetDevice(&mut self, settings: *mut I2cConnectionSettings, out: *mut *mut I2cDevice) -> ::w::HRESULT
		}}
		impl II2cController {
			#[inline] pub unsafe fn get_device(&mut self, settings: &I2cConnectionSettings) -> RtResult<ComPtr<I2cDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDevice)(self, settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_II2cControllerStatics, 1090257765, 24325, 20094, 132, 189, 16, 13, 184, 224, 174, 197);
		RT_INTERFACE!{static interface II2cControllerStatics(II2cControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_II2cControllerStatics] {
			fn GetControllersAsync(&mut self, provider: *mut provider::II2cProvider, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<I2cController>>) -> ::w::HRESULT,
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<I2cController>) -> ::w::HRESULT
		}}
		impl II2cControllerStatics {
			#[inline] pub unsafe fn get_controllers_async(&mut self, provider: &provider::II2cProvider) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<I2cController>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, provider as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<I2cController>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class I2cController: II2cController}
		RT_ACTIVATABLE!{II2cControllerStatics [CLSID_I2cController]}
		DEFINE_CLSID!(CLSID_I2cController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,116,114,111,108,108,101,114,0]);
		DEFINE_IID!(IID_II2cDevice, 2251735350, 47557, 20336, 148, 73, 204, 70, 220, 111, 87, 235);
		RT_INTERFACE!{interface II2cDevice(II2cDeviceVtbl): IInspectable(IInspectableVtbl) [IID_II2cDevice] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ConnectionSettings(&mut self, out: *mut *mut I2cConnectionSettings) -> ::w::HRESULT,
			fn Write(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn WritePartial(&mut self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> ::w::HRESULT,
			fn Read(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn ReadPartial(&mut self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> ::w::HRESULT,
			fn WriteRead(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT,
			fn WriteReadPartial(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut I2cTransferResult) -> ::w::HRESULT
		}}
		impl II2cDevice {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_settings(&mut self) -> RtResult<ComPtr<I2cConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionSettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, buffer: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, buffer.len() as u32, buffer.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_partial(&mut self, buffer: &[u8]) -> RtResult<I2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).WritePartial)(self, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Read)(self, bufferSize, buffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_partial(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<I2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ReadPartial)(self, bufferSize, buffer, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_read(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).WriteRead)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_read_partial(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<I2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).WriteReadPartial)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.I2c.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum ProviderI2cBusSpeed: i32 {
			StandardMode (ProviderI2cBusSpeed_StandardMode) = 0, FastMode (ProviderI2cBusSpeed_FastMode) = 1,
		}}
		RT_ENUM! { enum ProviderI2cTransferStatus: i32 {
			FullTransfer (ProviderI2cTransferStatus_FullTransfer) = 0, PartialTransfer (ProviderI2cTransferStatus_PartialTransfer) = 1, SlaveAddressNotAcknowledged (ProviderI2cTransferStatus_SlaveAddressNotAcknowledged) = 2,
		}}
		RT_ENUM! { enum ProviderI2cSharingMode: i32 {
			Exclusive (ProviderI2cSharingMode_Exclusive) = 0, Shared (ProviderI2cSharingMode_Shared) = 1,
		}}
		RT_STRUCT! { struct ProviderI2cTransferResult {
			Status: ProviderI2cTransferStatus, BytesTransferred: u32,
		}}
		DEFINE_IID!(IID_IProviderI2cConnectionSettings, 3923463732, 58640, 17591, 128, 157, 242, 248, 91, 85, 83, 57);
		RT_INTERFACE!{interface IProviderI2cConnectionSettings(IProviderI2cConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProviderI2cConnectionSettings] {
			fn get_SlaveAddress(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_SlaveAddress(&mut self, value: i32) -> ::w::HRESULT,
			fn get_BusSpeed(&mut self, out: *mut ProviderI2cBusSpeed) -> ::w::HRESULT,
			fn put_BusSpeed(&mut self, value: ProviderI2cBusSpeed) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut ProviderI2cSharingMode) -> ::w::HRESULT,
			fn put_SharingMode(&mut self, value: ProviderI2cSharingMode) -> ::w::HRESULT
		}}
		impl IProviderI2cConnectionSettings {
			#[inline] pub unsafe fn get_slave_address(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SlaveAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_slave_address(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SlaveAddress)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bus_speed(&mut self) -> RtResult<ProviderI2cBusSpeed> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BusSpeed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_bus_speed(&mut self, value: ProviderI2cBusSpeed) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BusSpeed)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<ProviderI2cSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_sharing_mode(&mut self, value: ProviderI2cSharingMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SharingMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ProviderI2cConnectionSettings: IProviderI2cConnectionSettings}
		DEFINE_IID!(IID_II2cControllerProvider, 1640151938, 17680, 16739, 168, 124, 78, 21, 169, 85, 137, 128);
		RT_INTERFACE!{interface II2cControllerProvider(II2cControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cControllerProvider] {
			fn GetDeviceProvider(&mut self, settings: *mut ProviderI2cConnectionSettings, out: *mut *mut II2cDeviceProvider) -> ::w::HRESULT
		}}
		impl II2cControllerProvider {
			#[inline] pub unsafe fn get_device_provider(&mut self, settings: &ProviderI2cConnectionSettings) -> RtResult<ComPtr<II2cDeviceProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceProvider)(self, settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_II2cProvider, 1863518270, 48994, 20450, 169, 90, 240, 137, 153, 102, 152, 24);
		RT_INTERFACE!{interface II2cProvider(II2cProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cProvider] {
			fn GetControllersAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<II2cControllerProvider>>) -> ::w::HRESULT
		}}
		impl II2cProvider {
			#[inline] pub unsafe fn get_controllers_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<II2cControllerProvider>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_II2cDeviceProvider, 2905876052, 22504, 17726, 131, 41, 209, 228, 71, 209, 3, 169);
		RT_INTERFACE!{interface II2cDeviceProvider(II2cDeviceProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cDeviceProvider] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn Write(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn WritePartial(&mut self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> ::w::HRESULT,
			fn Read(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn ReadPartial(&mut self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> ::w::HRESULT,
			fn WriteRead(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT,
			fn WriteReadPartial(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut ProviderI2cTransferResult) -> ::w::HRESULT
		}}
		impl II2cDeviceProvider {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, buffer: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, buffer.len() as u32, buffer.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_partial(&mut self, buffer: &[u8]) -> RtResult<ProviderI2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).WritePartial)(self, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Read)(self, bufferSize, buffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_partial(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<ProviderI2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ReadPartial)(self, bufferSize, buffer, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_read(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).WriteRead)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_read_partial(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<ProviderI2cTransferResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).WriteReadPartial)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
} // Windows.Devices.I2c.Provider
} // Windows.Devices.I2c
pub mod pwm { // Windows.Devices.Pwm
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum PwmPulsePolarity: i32 {
			ActiveHigh (PwmPulsePolarity_ActiveHigh) = 0, ActiveLow (PwmPulsePolarity_ActiveLow) = 1,
		}}
		DEFINE_IID!(IID_IPwmController, 3294583941, 53992, 17103, 155, 214, 207, 94, 208, 41, 230, 167);
		RT_INTERFACE!{interface IPwmController(IPwmControllerVtbl): IInspectable(IInspectableVtbl) [IID_IPwmController] {
			fn get_PinCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ActualFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn SetDesiredFrequency(&mut self, desiredFrequency: f64, out: *mut f64) -> ::w::HRESULT,
			fn get_MinFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_MaxFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn OpenPin(&mut self, pinNumber: i32, out: *mut *mut PwmPin) -> ::w::HRESULT
		}}
		impl IPwmController {
			#[inline] pub unsafe fn get_pin_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_actual_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ActualFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_desired_frequency(&mut self, desiredFrequency: f64) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).SetDesiredFrequency)(self, desiredFrequency, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_pin(&mut self, pinNumber: i32) -> RtResult<ComPtr<PwmPin>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenPin)(self, pinNumber, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PwmPin: IPwmPin}
		DEFINE_IID!(IID_IPwmControllerStatics, 1113832865, 35142, 17412, 189, 72, 129, 221, 18, 74, 244, 217);
		RT_INTERFACE!{static interface IPwmControllerStatics(IPwmControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics] {
			fn GetControllersAsync(&mut self, provider: *mut provider::IPwmProvider, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PwmController>>) -> ::w::HRESULT
		}}
		impl IPwmControllerStatics {
			#[inline] pub unsafe fn get_controllers_async(&mut self, provider: &provider::IPwmProvider) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PwmController>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, provider as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PwmController: IPwmController}
		RT_ACTIVATABLE!{IPwmControllerStatics [CLSID_PwmController]}
		RT_ACTIVATABLE!{IPwmControllerStatics2 [CLSID_PwmController]}
		DEFINE_CLSID!(CLSID_PwmController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,119,109,46,80,119,109,67,111,110,116,114,111,108,108,101,114,0]);
		DEFINE_IID!(IID_IPwmControllerStatics2, 1157389087, 61721, 19421, 151, 173, 247, 110, 249, 134, 115, 109);
		RT_INTERFACE!{static interface IPwmControllerStatics2(IPwmControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics2] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<PwmController>) -> ::w::HRESULT
		}}
		impl IPwmControllerStatics2 {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PwmController>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPwmPin, 580333000, 50895, 18465, 183, 249, 198, 69, 79, 182, 175, 121);
		RT_INTERFACE!{interface IPwmPin(IPwmPinVtbl): IInspectable(IInspectableVtbl) [IID_IPwmPin] {
			fn get_Controller(&mut self, out: *mut *mut PwmController) -> ::w::HRESULT,
			fn GetActiveDutyCyclePercentage(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn SetActiveDutyCyclePercentage(&mut self, dutyCyclePercentage: f64) -> ::w::HRESULT,
			fn get_Polarity(&mut self, out: *mut PwmPulsePolarity) -> ::w::HRESULT,
			fn put_Polarity(&mut self, value: PwmPulsePolarity) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT,
			fn get_IsStarted(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IPwmPin {
			#[inline] pub unsafe fn get_controller(&mut self) -> RtResult<ComPtr<PwmController>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Controller)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active_duty_cycle_percentage(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetActiveDutyCyclePercentage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_active_duty_cycle_percentage(&mut self, dutyCyclePercentage: f64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetActiveDutyCyclePercentage)(self, dutyCyclePercentage);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_polarity(&mut self) -> RtResult<PwmPulsePolarity> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Polarity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_polarity(&mut self, value: PwmPulsePolarity) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Polarity)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_started(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStarted)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.Pwm.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IPwmControllerProvider, 318789947, 58083, 16548, 183, 217, 72, 223, 240, 55, 122, 82);
		RT_INTERFACE!{interface IPwmControllerProvider(IPwmControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerProvider] {
			fn get_PinCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ActualFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn SetDesiredFrequency(&mut self, frequency: f64, out: *mut f64) -> ::w::HRESULT,
			fn get_MaxFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_MinFrequency(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn AcquirePin(&mut self, pin: i32) -> ::w::HRESULT,
			fn ReleasePin(&mut self, pin: i32) -> ::w::HRESULT,
			fn EnablePin(&mut self, pin: i32) -> ::w::HRESULT,
			fn DisablePin(&mut self, pin: i32) -> ::w::HRESULT,
			fn SetPulseParameters(&mut self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> ::w::HRESULT
		}}
		impl IPwmControllerProvider {
			#[inline] pub unsafe fn get_pin_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_actual_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ActualFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_desired_frequency(&mut self, frequency: f64) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).SetDesiredFrequency)(self, frequency, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_frequency(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn acquire_pin(&mut self, pin: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AcquirePin)(self, pin);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn release_pin(&mut self, pin: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ReleasePin)(self, pin);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn enable_pin(&mut self, pin: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).EnablePin)(self, pin);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disable_pin(&mut self, pin: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).DisablePin)(self, pin);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_pulse_parameters(&mut self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetPulseParameters)(self, pin, dutyCycle, invertPolarity);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPwmProvider, 2737836584, 21233, 18352, 147, 73, 102, 186, 67, 210, 89, 2);
		RT_INTERFACE!{interface IPwmProvider(IPwmProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPwmProvider] {
			fn GetControllers(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<IPwmControllerProvider>) -> ::w::HRESULT
		}}
		impl IPwmProvider {
			#[inline] pub unsafe fn get_controllers(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<IPwmControllerProvider>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Pwm.Provider
} // Windows.Devices.Pwm
pub mod spi { // Windows.Devices.Spi
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum SpiMode: i32 {
			Mode0 (SpiMode_Mode0) = 0, Mode1 (SpiMode_Mode1) = 1, Mode2 (SpiMode_Mode2) = 2, Mode3 (SpiMode_Mode3) = 3,
		}}
		RT_ENUM! { enum SpiSharingMode: i32 {
			Exclusive (SpiSharingMode_Exclusive) = 0, Shared (SpiSharingMode_Shared) = 1,
		}}
		DEFINE_IID!(IID_ISpiConnectionSettingsFactory, 4288219166, 4292, 17591, 159, 234, 167, 72, 181, 164, 111, 49);
		RT_INTERFACE!{static interface ISpiConnectionSettingsFactory(ISpiConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettingsFactory] {
			fn Create(&mut self, chipSelectLine: i32, out: *mut *mut SpiConnectionSettings) -> ::w::HRESULT
		}}
		impl ISpiConnectionSettingsFactory {
			#[inline] pub unsafe fn create(&mut self, chipSelectLine: i32) -> RtResult<ComPtr<SpiConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, chipSelectLine, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SpiConnectionSettings: ISpiConnectionSettings [ISpiConnectionSettingsFactory] [CLSID_SpiConnectionSettings]}
		DEFINE_CLSID!(CLSID_SpiConnectionSettings = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]);
		DEFINE_IID!(IID_ISpiConnectionSettings, 1384358783, 63797, 19359, 167, 167, 58, 120, 144, 175, 165, 206);
		RT_INTERFACE!{interface ISpiConnectionSettings(ISpiConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettings] {
			fn get_ChipSelectLine(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_ChipSelectLine(&mut self, value: i32) -> ::w::HRESULT,
			fn get_Mode(&mut self, out: *mut SpiMode) -> ::w::HRESULT,
			fn put_Mode(&mut self, value: SpiMode) -> ::w::HRESULT,
			fn get_DataBitLength(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_DataBitLength(&mut self, value: i32) -> ::w::HRESULT,
			fn get_ClockFrequency(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_ClockFrequency(&mut self, value: i32) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut SpiSharingMode) -> ::w::HRESULT,
			fn put_SharingMode(&mut self, value: SpiSharingMode) -> ::w::HRESULT
		}}
		impl ISpiConnectionSettings {
			#[inline] pub unsafe fn get_chip_select_line(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChipSelectLine)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_chip_select_line(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ChipSelectLine)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_mode(&mut self) -> RtResult<SpiMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Mode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_mode(&mut self, value: SpiMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Mode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_bit_length(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataBitLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_bit_length(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataBitLength)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_clock_frequency(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClockFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_clock_frequency(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ClockFrequency)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<SpiSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_sharing_mode(&mut self, value: SpiSharingMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SharingMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISpiBusInfo, 2569618506, 21746, 18630, 185, 82, 156, 50, 252, 2, 198, 105);
		RT_INTERFACE!{interface ISpiBusInfo(ISpiBusInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISpiBusInfo] {
			fn get_ChipSelectLineCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MinClockFrequency(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MaxClockFrequency(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SupportedDataBitLengths(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<i32>) -> ::w::HRESULT
		}}
		impl ISpiBusInfo {
			#[inline] pub unsafe fn get_chip_select_line_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChipSelectLineCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_clock_frequency(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinClockFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_clock_frequency(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxClockFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_data_bit_lengths(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedDataBitLengths)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SpiBusInfo: ISpiBusInfo}
		DEFINE_IID!(IID_ISpiDeviceStatics, 2725832025, 22304, 19775, 189, 147, 86, 245, 255, 90, 88, 121);
		RT_INTERFACE!{static interface ISpiDeviceStatics(ISpiDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDeviceStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromFriendlyName(&mut self, friendlyName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetBusInfo(&mut self, busId: ::w::HSTRING, out: *mut *mut SpiBusInfo) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, busId: ::w::HSTRING, settings: *mut SpiConnectionSettings, out: *mut *mut super::super::foundation::IAsyncOperation<SpiDevice>) -> ::w::HRESULT
		}}
		impl ISpiDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_friendly_name(&mut self, friendlyName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromFriendlyName)(self, friendlyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bus_info(&mut self, busId: &HStringArg) -> RtResult<ComPtr<SpiBusInfo>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBusInfo)(self, busId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, busId: &HStringArg, settings: &SpiConnectionSettings) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SpiDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, busId.get(), settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SpiDevice: ISpiDevice}
		RT_ACTIVATABLE!{ISpiDeviceStatics [CLSID_SpiDevice]}
		DEFINE_CLSID!(CLSID_SpiDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_ISpiController, 2832451625, 39061, 16729, 169, 52, 135, 65, 241, 238, 109, 39);
		RT_INTERFACE!{interface ISpiController(ISpiControllerVtbl): IInspectable(IInspectableVtbl) [IID_ISpiController] {
			fn GetDevice(&mut self, settings: *mut SpiConnectionSettings, out: *mut *mut SpiDevice) -> ::w::HRESULT
		}}
		impl ISpiController {
			#[inline] pub unsafe fn get_device(&mut self, settings: &SpiConnectionSettings) -> RtResult<ComPtr<SpiDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDevice)(self, settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISpiControllerStatics, 223488482, 5003, 20040, 185, 100, 79, 47, 121, 185, 197, 162);
		RT_INTERFACE!{static interface ISpiControllerStatics(ISpiControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiControllerStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SpiController>) -> ::w::HRESULT,
			fn GetControllersAsync(&mut self, provider: *mut provider::ISpiProvider, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<SpiController>>) -> ::w::HRESULT
		}}
		impl ISpiControllerStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SpiController>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_controllers_async(&mut self, provider: &provider::ISpiProvider) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<SpiController>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, provider as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SpiController: ISpiController}
		RT_ACTIVATABLE!{ISpiControllerStatics [CLSID_SpiController]}
		DEFINE_CLSID!(CLSID_SpiController = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,116,114,111,108,108,101,114,0]);
		DEFINE_IID!(IID_ISpiDevice, 97858925, 4534, 19769, 132, 213, 149, 223, 180, 201, 242, 206);
		RT_INTERFACE!{interface ISpiDevice(ISpiDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDevice] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ConnectionSettings(&mut self, out: *mut *mut SpiConnectionSettings) -> ::w::HRESULT,
			fn Write(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn Read(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn TransferSequential(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT,
			fn TransferFullDuplex(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT
		}}
		impl ISpiDevice {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_settings(&mut self) -> RtResult<ComPtr<SpiConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionSettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, buffer: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, buffer.len() as u32, buffer.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Read)(self, bufferSize, buffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn transfer_sequential(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TransferSequential)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn transfer_full_duplex(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TransferFullDuplex)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.Spi.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum ProviderSpiMode: i32 {
			Mode0 (ProviderSpiMode_Mode0) = 0, Mode1 (ProviderSpiMode_Mode1) = 1, Mode2 (ProviderSpiMode_Mode2) = 2, Mode3 (ProviderSpiMode_Mode3) = 3,
		}}
		RT_ENUM! { enum ProviderSpiSharingMode: i32 {
			Exclusive (ProviderSpiSharingMode_Exclusive) = 0, Shared (ProviderSpiSharingMode_Shared) = 1,
		}}
		DEFINE_IID!(IID_IProviderSpiConnectionSettingsFactory, 1715825498, 3193, 17379, 159, 60, 229, 151, 128, 172, 24, 250);
		RT_INTERFACE!{static interface IProviderSpiConnectionSettingsFactory(IProviderSpiConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettingsFactory] {
			fn Create(&mut self, chipSelectLine: i32, out: *mut *mut ProviderSpiConnectionSettings) -> ::w::HRESULT
		}}
		impl IProviderSpiConnectionSettingsFactory {
			#[inline] pub unsafe fn create(&mut self, chipSelectLine: i32) -> RtResult<ComPtr<ProviderSpiConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, chipSelectLine, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ProviderSpiConnectionSettings: IProviderSpiConnectionSettings [IProviderSpiConnectionSettingsFactory] [CLSID_ProviderSpiConnectionSettings]}
		DEFINE_CLSID!(CLSID_ProviderSpiConnectionSettings = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,80,114,111,118,105,100,101,114,46,80,114,111,118,105,100,101,114,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]);
		DEFINE_IID!(IID_IProviderSpiConnectionSettings, 4127409488, 42306, 20160, 150, 1, 164, 221, 104, 248, 105, 123);
		RT_INTERFACE!{interface IProviderSpiConnectionSettings(IProviderSpiConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettings] {
			fn get_ChipSelectLine(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_ChipSelectLine(&mut self, value: i32) -> ::w::HRESULT,
			fn get_Mode(&mut self, out: *mut ProviderSpiMode) -> ::w::HRESULT,
			fn put_Mode(&mut self, value: ProviderSpiMode) -> ::w::HRESULT,
			fn get_DataBitLength(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_DataBitLength(&mut self, value: i32) -> ::w::HRESULT,
			fn get_ClockFrequency(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_ClockFrequency(&mut self, value: i32) -> ::w::HRESULT,
			fn get_SharingMode(&mut self, out: *mut ProviderSpiSharingMode) -> ::w::HRESULT,
			fn put_SharingMode(&mut self, value: ProviderSpiSharingMode) -> ::w::HRESULT
		}}
		impl IProviderSpiConnectionSettings {
			#[inline] pub unsafe fn get_chip_select_line(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChipSelectLine)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_chip_select_line(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ChipSelectLine)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_mode(&mut self) -> RtResult<ProviderSpiMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Mode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_mode(&mut self, value: ProviderSpiMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Mode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_bit_length(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataBitLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_bit_length(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataBitLength)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_clock_frequency(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClockFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_clock_frequency(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ClockFrequency)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sharing_mode(&mut self) -> RtResult<ProviderSpiSharingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SharingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_sharing_mode(&mut self, value: ProviderSpiSharingMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SharingMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISpiControllerProvider, 3244844292, 718, 16934, 163, 133, 79, 17, 251, 4, 180, 27);
		RT_INTERFACE!{interface ISpiControllerProvider(ISpiControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiControllerProvider] {
			fn GetDeviceProvider(&mut self, settings: *mut ProviderSpiConnectionSettings, out: *mut *mut ISpiDeviceProvider) -> ::w::HRESULT
		}}
		impl ISpiControllerProvider {
			#[inline] pub unsafe fn get_device_provider(&mut self, settings: &ProviderSpiConnectionSettings) -> RtResult<ComPtr<ISpiDeviceProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceProvider)(self, settings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISpiProvider, 2528403938, 30676, 18638, 170, 160, 117, 113, 90, 131, 98, 207);
		RT_INTERFACE!{interface ISpiProvider(ISpiProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiProvider] {
			fn GetControllersAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<ISpiControllerProvider>>) -> ::w::HRESULT
		}}
		impl ISpiProvider {
			#[inline] pub unsafe fn get_controllers_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<ISpiControllerProvider>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetControllersAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISpiDeviceProvider, 219952195, 12363, 16476, 180, 247, 245, 171, 16, 116, 70, 30);
		RT_INTERFACE!{interface ISpiDeviceProvider(ISpiDeviceProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDeviceProvider] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ConnectionSettings(&mut self, out: *mut *mut ProviderSpiConnectionSettings) -> ::w::HRESULT,
			fn Write(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn Read(&mut self, bufferSize: u32, buffer: *mut u8) -> ::w::HRESULT,
			fn TransferSequential(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT,
			fn TransferFullDuplex(&mut self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> ::w::HRESULT
		}}
		impl ISpiDeviceProvider {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_settings(&mut self) -> RtResult<ComPtr<ProviderSpiConnectionSettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionSettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write(&mut self, buffer: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Write)(self, buffer.len() as u32, buffer.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read(&mut self, bufferSize: u32, buffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Read)(self, bufferSize, buffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn transfer_sequential(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TransferSequential)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn transfer_full_duplex(&mut self, writeBuffer: &[u8], readBufferSize: u32, readBuffer: *mut u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TransferFullDuplex)(self, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBufferSize, readBuffer);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Spi.Provider
} // Windows.Devices.Spi
pub mod custom { // Windows.Devices.Custom
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct CustomDeviceContract {
			
		}}
		DEFINE_IID!(IID_IKnownDeviceTypesStatics, 3998513602, 21576, 17882, 173, 27, 36, 148, 140, 35, 144, 148);
		RT_INTERFACE!{static interface IKnownDeviceTypesStatics(IKnownDeviceTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownDeviceTypesStatics] {
			fn get_Unknown(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IKnownDeviceTypesStatics {
			#[inline] pub unsafe fn get_unknown(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Unknown)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IKnownDeviceTypesStatics [CLSID_KnownDeviceTypes]}
		DEFINE_CLSID!(CLSID_KnownDeviceTypes = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,75,110,111,119,110,68,101,118,105,99,101,84,121,112,101,115,0]);
		RT_ENUM! { enum IOControlAccessMode: i32 {
			Any (IOControlAccessMode_Any) = 0, Read (IOControlAccessMode_Read) = 1, Write (IOControlAccessMode_Write) = 2, ReadWrite (IOControlAccessMode_ReadWrite) = 3,
		}}
		RT_ENUM! { enum IOControlBufferingMethod: i32 {
			Buffered (IOControlBufferingMethod_Buffered) = 0, DirectInput (IOControlBufferingMethod_DirectInput) = 1, DirectOutput (IOControlBufferingMethod_DirectOutput) = 2, Neither (IOControlBufferingMethod_Neither) = 3,
		}}
		DEFINE_IID!(IID_IIOControlCode, 244668903, 24776, 17269, 167, 97, 127, 136, 8, 6, 108, 96);
		RT_INTERFACE!{interface IIOControlCode(IIOControlCodeVtbl): IInspectable(IInspectableVtbl) [IID_IIOControlCode] {
			fn get_AccessMode(&mut self, out: *mut IOControlAccessMode) -> ::w::HRESULT,
			fn get_BufferingMethod(&mut self, out: *mut IOControlBufferingMethod) -> ::w::HRESULT,
			fn get_Function(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_DeviceType(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ControlCode(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IIOControlCode {
			#[inline] pub unsafe fn get_access_mode(&mut self) -> RtResult<IOControlAccessMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AccessMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_buffering_method(&mut self) -> RtResult<IOControlBufferingMethod> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BufferingMethod)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_function(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Function)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_type(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DeviceType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_control_code(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ControlCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IIOControlCodeFactory, 2238348528, 19473, 17582, 175, 198, 184, 212, 162, 18, 120, 143);
		RT_INTERFACE!{static interface IIOControlCodeFactory(IIOControlCodeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IIOControlCodeFactory] {
			fn CreateIOControlCode(&mut self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod, out: *mut *mut IOControlCode) -> ::w::HRESULT
		}}
		impl IIOControlCodeFactory {
			#[inline] pub unsafe fn create_iocontrol_code(&mut self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod) -> RtResult<ComPtr<IOControlCode>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateIOControlCode)(self, deviceType, function, accessMode, bufferingMethod, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class IOControlCode: IIOControlCode [IIOControlCodeFactory] [CLSID_IOControlCode]}
		DEFINE_CLSID!(CLSID_IOControlCode = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,73,79,67,111,110,116,114,111,108,67,111,100,101,0]);
		RT_ENUM! { enum DeviceAccessMode: i32 {
			Read (DeviceAccessMode_Read) = 0, Write (DeviceAccessMode_Write) = 1, ReadWrite (DeviceAccessMode_ReadWrite) = 2,
		}}
		RT_ENUM! { enum DeviceSharingMode: i32 {
			Shared (DeviceSharingMode_Shared) = 0, Exclusive (DeviceSharingMode_Exclusive) = 1,
		}}
		DEFINE_IID!(IID_ICustomDeviceStatics, 3357672210, 61260, 18097, 165, 142, 238, 179, 8, 220, 137, 23);
		RT_INTERFACE!{static interface ICustomDeviceStatics(ICustomDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomDeviceStatics] {
			fn GetDeviceSelector(&mut self, classGuid: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode, out: *mut *mut super::super::foundation::IAsyncOperation<CustomDevice>) -> ::w::HRESULT
		}}
		impl ICustomDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self, classGuid: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, classGuid, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<CustomDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), desiredAccess, sharingMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CustomDevice: ICustomDevice}
		RT_ACTIVATABLE!{ICustomDeviceStatics [CLSID_CustomDevice]}
		DEFINE_CLSID!(CLSID_CustomDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_ICustomDevice, 3710919967, 50315, 17341, 188, 177, 222, 200, 143, 21, 20, 62);
		RT_INTERFACE!{interface ICustomDevice(ICustomDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ICustomDevice] {
			#[cfg(feature="windows.storage")] fn get_InputStream(&mut self, out: *mut *mut super::super::storage::streams::IInputStream) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_OutputStream(&mut self, out: *mut *mut super::super::storage::streams::IOutputStream) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn SendIOControlAsync(&mut self, ioControlCode: *mut IIOControlCode, inputBuffer: *mut super::super::storage::streams::IBuffer, outputBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn TrySendIOControlAsync(&mut self, ioControlCode: *mut IIOControlCode, inputBuffer: *mut super::super::storage::streams::IBuffer, outputBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT
		}}
		impl ICustomDevice {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_input_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IInputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_output_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IOutputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn send_iocontrol_async(&mut self, ioControlCode: &IIOControlCode, inputBuffer: &super::super::storage::streams::IBuffer, outputBuffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendIOControlAsync)(self, ioControlCode as *const _ as *mut _, inputBuffer as *const _ as *mut _, outputBuffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn try_send_iocontrol_async(&mut self, ioControlCode: &IIOControlCode, inputBuffer: &super::super::storage::streams::IBuffer, outputBuffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TrySendIOControlAsync)(self, ioControlCode as *const _ as *mut _, inputBuffer as *const _ as *mut _, outputBuffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Custom
pub mod printers { // Windows.Devices.Printers
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct PrintersContract {
			
		}}
		DEFINE_IID!(IID_IPrint3DDeviceStatics, 4259537418, 26573, 16823, 163, 68, 81, 80, 161, 253, 117, 181);
		RT_INTERFACE!{static interface IPrint3DDeviceStatics(IPrint3DDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DDeviceStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Print3DDevice>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPrint3DDeviceStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Print3DDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Print3DDevice: IPrint3DDevice}
		RT_ACTIVATABLE!{IPrint3DDeviceStatics [CLSID_Print3DDevice]}
		DEFINE_CLSID!(CLSID_Print3DDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,80,114,105,110,116,51,68,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IPrint3DDevice, 68959513, 38675, 17058, 152, 19, 125, 195, 51, 116, 40, 211);
		RT_INTERFACE!{interface IPrint3DDevice(IPrint3DDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DDevice] {
			fn get_PrintSchema(&mut self, out: *mut *mut PrintSchema) -> ::w::HRESULT
		}}
		impl IPrint3DDevice {
			#[inline] pub unsafe fn get_print_schema(&mut self) -> RtResult<ComPtr<PrintSchema>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PrintSchema)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintSchema: IPrintSchema}
		DEFINE_IID!(IID_IPrintSchema, 3266937622, 9912, 19451, 129, 56, 159, 150, 44, 34, 163, 91);
		RT_INTERFACE!{interface IPrintSchema(IPrintSchemaVtbl): IInspectable(IInspectableVtbl) [IID_IPrintSchema] {
			#[cfg(feature="windows.storage")] fn GetDefaultPrintTicketAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn GetCapabilitiesAsync(&mut self, constrainTicket: *mut super::super::storage::streams::IRandomAccessStreamWithContentType, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn MergeAndValidateWithDefaultPrintTicketAsync(&mut self, deltaTicket: *mut super::super::storage::streams::IRandomAccessStreamWithContentType, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> ::w::HRESULT
		}}
		impl IPrintSchema {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_default_print_ticket_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultPrintTicketAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_capabilities_async(&mut self, constrainTicket: &super::super::storage::streams::IRandomAccessStreamWithContentType) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCapabilitiesAsync)(self, constrainTicket as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn merge_and_validate_with_default_print_ticket_async(&mut self, deltaTicket: &super::super::storage::streams::IRandomAccessStreamWithContentType) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).MergeAndValidateWithDefaultPrintTicketAsync)(self, deltaTicket as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
pub mod extensions { // Windows.Devices.Printers.Extensions
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum Print3DWorkflowStatus: i32 {
			Abandoned (Print3DWorkflowStatus_Abandoned) = 0, Canceled (Print3DWorkflowStatus_Canceled) = 1, Failed (Print3DWorkflowStatus_Failed) = 2, Slicing (Print3DWorkflowStatus_Slicing) = 3, Submitted (Print3DWorkflowStatus_Submitted) = 4,
		}}
		RT_ENUM! { enum Print3DWorkflowDetail: i32 {
			Unknown (Print3DWorkflowDetail_Unknown) = 0, ModelExceedsPrintBed (Print3DWorkflowDetail_ModelExceedsPrintBed) = 1, UploadFailed (Print3DWorkflowDetail_UploadFailed) = 2, InvalidMaterialSelection (Print3DWorkflowDetail_InvalidMaterialSelection) = 3, InvalidModel (Print3DWorkflowDetail_InvalidModel) = 4, ModelNotManifold (Print3DWorkflowDetail_ModelNotManifold) = 5, InvalidPrintTicket (Print3DWorkflowDetail_InvalidPrintTicket) = 6,
		}}
		DEFINE_IID!(IID_IPrint3DWorkflowPrintRequestedEventArgs, 435734616, 23240, 19285, 138, 95, 230, 21, 103, 218, 251, 77);
		RT_INTERFACE!{interface IPrint3DWorkflowPrintRequestedEventArgs(IPrint3DWorkflowPrintRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrintRequestedEventArgs] {
			fn get_Status(&mut self, out: *mut Print3DWorkflowStatus) -> ::w::HRESULT,
			fn SetExtendedStatus(&mut self, value: Print3DWorkflowDetail) -> ::w::HRESULT,
			fn SetSource(&mut self, source: *mut IInspectable) -> ::w::HRESULT,
			fn SetSourceChanged(&mut self, value: bool) -> ::w::HRESULT
		}}
		impl IPrint3DWorkflowPrintRequestedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<Print3DWorkflowStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_extended_status(&mut self, value: Print3DWorkflowDetail) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetExtendedStatus)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_source(&mut self, source: &IInspectable) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetSource)(self, source as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_source_changed(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetSourceChanged)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPrint3DWorkflowPrinterChangedEventArgs, 1159881730, 38396, 18503, 147, 179, 19, 77, 191, 92, 96, 247);
		RT_INTERFACE!{interface IPrint3DWorkflowPrinterChangedEventArgs(IPrint3DWorkflowPrinterChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrinterChangedEventArgs] {
			fn get_NewDeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPrint3DWorkflowPrinterChangedEventArgs {
			#[inline] pub unsafe fn get_new_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_NewDeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Print3DWorkflowPrintRequestedEventArgs: IPrint3DWorkflowPrintRequestedEventArgs}
		RT_CLASS!{class Print3DWorkflowPrinterChangedEventArgs: IPrint3DWorkflowPrinterChangedEventArgs}
		DEFINE_IID!(IID_IPrint3DWorkflow, 3312415933, 13929, 19046, 171, 66, 200, 21, 25, 48, 205, 52);
		RT_INTERFACE!{interface IPrint3DWorkflow(IPrint3DWorkflowVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow] {
			fn get_DeviceID(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetPrintModelPackage(&mut self, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn get_IsPrintReady(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsPrintReady(&mut self, value: bool) -> ::w::HRESULT,
			fn add_PrintRequested(&mut self, eventHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PrintRequested(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IPrint3DWorkflow {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceID)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_print_model_package(&mut self) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetPrintModelPackage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_print_ready(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPrintReady)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_print_ready(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsPrintReady)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_print_requested(&mut self, eventHandler: &::rt::gen::windows::foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PrintRequested)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_print_requested(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PrintRequested)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Print3DWorkflow: IPrint3DWorkflow}
		DEFINE_IID!(IID_IPrint3DWorkflow2, 2728838479, 35521, 18712, 151, 65, 227, 79, 48, 4, 35, 158);
		RT_INTERFACE!{interface IPrint3DWorkflow2(IPrint3DWorkflow2Vtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow2] {
			fn add_PrinterChanged(&mut self, eventHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PrinterChanged(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IPrint3DWorkflow2 {
			#[inline] pub unsafe fn add_printer_changed(&mut self, eventHandler: &::rt::gen::windows::foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PrinterChanged)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_printer_changed(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PrinterChanged)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_STRUCT! { struct ExtensionsContract {
			
		}}
		DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedDeferral, 3914978664, 63273, 17572, 135, 29, 189, 6, 40, 105, 106, 51);
		RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedDeferral(IPrintTaskConfigurationSaveRequestedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedDeferral] {
			fn Complete(&mut self) -> ::w::HRESULT
		}}
		impl IPrintTaskConfigurationSaveRequestedDeferral {
			#[inline] pub unsafe fn complete(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Complete)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintTaskConfigurationSaveRequestedDeferral: IPrintTaskConfigurationSaveRequestedDeferral}
		DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequest, 4004458443, 25118, 19298, 172, 119, 178, 129, 204, 224, 141, 96);
		RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequest(IPrintTaskConfigurationSaveRequestVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequest] {
			fn Cancel(&mut self) -> ::w::HRESULT,
			fn Save(&mut self, printerExtensionContext: *mut IInspectable) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut PrintTaskConfigurationSaveRequestedDeferral) -> ::w::HRESULT,
			fn get_Deadline(&mut self, out: *mut ::rt::gen::windows::foundation::DateTime) -> ::w::HRESULT
		}}
		impl IPrintTaskConfigurationSaveRequest {
			#[inline] pub unsafe fn cancel(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Cancel)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn save(&mut self, printerExtensionContext: &IInspectable) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Save)(self, printerExtensionContext as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<PrintTaskConfigurationSaveRequestedDeferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deadline(&mut self) -> RtResult<::rt::gen::windows::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Deadline)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintTaskConfigurationSaveRequest: IPrintTaskConfigurationSaveRequest}
		DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedEventArgs, 3765184633, 3425, 18744, 145, 208, 150, 164, 91, 238, 132, 121);
		RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedEventArgs(IPrintTaskConfigurationSaveRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedEventArgs] {
			fn get_Request(&mut self, out: *mut *mut PrintTaskConfigurationSaveRequest) -> ::w::HRESULT
		}}
		impl IPrintTaskConfigurationSaveRequestedEventArgs {
			#[inline] pub unsafe fn get_request(&mut self) -> RtResult<ComPtr<PrintTaskConfigurationSaveRequest>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Request)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintTaskConfigurationSaveRequestedEventArgs: IPrintTaskConfigurationSaveRequestedEventArgs}
		DEFINE_IID!(IID_IPrintTaskConfiguration, 3821151313, 15012, 18565, 146, 64, 49, 31, 95, 143, 190, 157);
		RT_INTERFACE!{interface IPrintTaskConfiguration(IPrintTaskConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfiguration] {
			fn get_PrinterExtensionContext(&mut self, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn add_SaveRequested(&mut self, eventHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SaveRequested(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IPrintTaskConfiguration {
			#[inline] pub unsafe fn get_printer_extension_context(&mut self) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PrinterExtensionContext)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_save_requested(&mut self, eventHandler: &::rt::gen::windows::foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SaveRequested)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_save_requested(&mut self, eventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SaveRequested)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintTaskConfiguration: IPrintTaskConfiguration}
		DEFINE_IID!(IID_IPrintNotificationEventDetails, 3759033482, 18472, 19873, 139, 184, 134, 114, 223, 133, 21, 231);
		RT_INTERFACE!{interface IPrintNotificationEventDetails(IPrintNotificationEventDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintNotificationEventDetails] {
			fn get_PrinterName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_EventData(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_EventData(&mut self, value: ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPrintNotificationEventDetails {
			#[inline] pub unsafe fn get_printer_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PrinterName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_event_data(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EventData)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_event_data(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_EventData)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PrintNotificationEventDetails: IPrintNotificationEventDetails}
		DEFINE_IID!(IID_IPrintExtensionContextStatic, 3876429761, 65401, 19108, 140, 155, 12, 147, 174, 223, 222, 138);
		RT_INTERFACE!{static interface IPrintExtensionContextStatic(IPrintExtensionContextStaticVtbl): IInspectable(IInspectableVtbl) [IID_IPrintExtensionContextStatic] {
			fn FromDeviceId(&mut self, deviceId: ::w::HSTRING, out: *mut *mut IInspectable) -> ::w::HRESULT
		}}
		impl IPrintExtensionContextStatic {
			#[inline] pub unsafe fn from_device_id(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromDeviceId)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IPrintExtensionContextStatic [CLSID_PrintExtensionContext]}
		DEFINE_CLSID!(CLSID_PrintExtensionContext = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,69,120,116,101,110,115,105,111,110,115,46,80,114,105,110,116,69,120,116,101,110,115,105,111,110,67,111,110,116,101,120,116,0]);
} // Windows.Devices.Printers.Extensions
} // Windows.Devices.Printers
pub mod power { // Windows.Devices.Power
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IBattery, 3163115462, 114, 18376, 139, 93, 97, 74, 170, 122, 67, 126);
		RT_INTERFACE!{interface IBattery(IBatteryVtbl): IInspectable(IInspectableVtbl) [IID_IBattery] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetReport(&mut self, out: *mut *mut BatteryReport) -> ::w::HRESULT,
			fn add_ReportUpdated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Battery, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReportUpdated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBattery {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<BatteryReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_report_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<Battery, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReportUpdated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_report_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReportUpdated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BatteryReport: IBatteryReport}
		RT_CLASS!{class Battery: IBattery}
		RT_ACTIVATABLE!{IBatteryStatics [CLSID_Battery]}
		DEFINE_CLSID!(CLSID_Battery = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,119,101,114,46,66,97,116,116,101,114,121,0]);
		DEFINE_IID!(IID_IBatteryReport, 3380972602, 19987, 16906, 168, 208, 36, 241, 143, 57, 84, 1);
		RT_INTERFACE!{interface IBatteryReport(IBatteryReportVtbl): IInspectable(IInspectableVtbl) [IID_IBatteryReport] {
			fn get_ChargeRateInMilliwatts(&mut self, out: *mut *mut super::super::foundation::IReference<i32>) -> ::w::HRESULT,
			fn get_DesignCapacityInMilliwattHours(&mut self, out: *mut *mut super::super::foundation::IReference<i32>) -> ::w::HRESULT,
			fn get_FullChargeCapacityInMilliwattHours(&mut self, out: *mut *mut super::super::foundation::IReference<i32>) -> ::w::HRESULT,
			fn get_RemainingCapacityInMilliwattHours(&mut self, out: *mut *mut super::super::foundation::IReference<i32>) -> ::w::HRESULT,
			#[cfg(feature="windows.system")] fn get_Status(&mut self, out: *mut super::super::system::power::BatteryStatus) -> ::w::HRESULT
		}}
		impl IBatteryReport {
			#[inline] pub unsafe fn get_charge_rate_in_milliwatts(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ChargeRateInMilliwatts)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_design_capacity_in_milliwatt_hours(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DesignCapacityInMilliwattHours)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_full_charge_capacity_in_milliwatt_hours(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FullChargeCapacityInMilliwattHours)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_remaining_capacity_in_milliwatt_hours(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RemainingCapacityInMilliwattHours)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.system")] #[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::super::system::power::BatteryStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBatteryStatics, 2043507382, 40542, 17490, 190, 166, 223, 205, 84, 30, 89, 127);
		RT_INTERFACE!{static interface IBatteryStatics(IBatteryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBatteryStatics] {
			fn get_AggregateBattery(&mut self, out: *mut *mut Battery) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Battery>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBatteryStatics {
			#[inline] pub unsafe fn get_aggregate_battery(&mut self) -> RtResult<ComPtr<Battery>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AggregateBattery)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Battery>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Power
pub mod sms { // Windows.Devices.Sms
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum SmsMessageClass: i32 {
			None (SmsMessageClass_None) = 0, Class0 (SmsMessageClass_Class0) = 1, Class1 (SmsMessageClass_Class1) = 2, Class2 (SmsMessageClass_Class2) = 3, Class3 (SmsMessageClass_Class3) = 4,
		}}
		RT_ENUM! { enum SmsMessageType: i32 {
			Binary (SmsMessageType_Binary) = 0, Text (SmsMessageType_Text) = 1, Wap (SmsMessageType_Wap) = 2, App (SmsMessageType_App) = 3, Broadcast (SmsMessageType_Broadcast) = 4, Voicemail (SmsMessageType_Voicemail) = 5, Status (SmsMessageType_Status) = 6,
		}}
		RT_ENUM! { enum CellularClass: i32 {
			None (CellularClass_None) = 0, Gsm (CellularClass_Gsm) = 1, Cdma (CellularClass_Cdma) = 2,
		}}
		DEFINE_IID!(IID_ISmsMessageBase, 753991216, 65104, 20422, 170, 136, 76, 207, 226, 122, 41, 234);
		RT_INTERFACE!{interface ISmsMessageBase(ISmsMessageBaseVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageBase] {
			fn get_MessageType(&mut self, out: *mut SmsMessageType) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_CellularClass(&mut self, out: *mut CellularClass) -> ::w::HRESULT,
			fn get_MessageClass(&mut self, out: *mut SmsMessageClass) -> ::w::HRESULT,
			fn get_SimIccId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl ISmsMessageBase {
			#[inline] pub unsafe fn get_message_type(&mut self) -> RtResult<SmsMessageType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cellular_class(&mut self) -> RtResult<CellularClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CellularClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_class(&mut self) -> RtResult<SmsMessageClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sim_icc_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SimIccId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum SmsDataFormat: i32 {
			Unknown (SmsDataFormat_Unknown) = 0, CdmaSubmit (SmsDataFormat_CdmaSubmit) = 1, GsmSubmit (SmsDataFormat_GsmSubmit) = 2, CdmaDeliver (SmsDataFormat_CdmaDeliver) = 3, GsmDeliver (SmsDataFormat_GsmDeliver) = 4,
		}}
		RT_ENUM! { enum SmsEncoding: i32 {
			Unknown (SmsEncoding_Unknown) = 0, Optimal (SmsEncoding_Optimal) = 1, SevenBitAscii (SmsEncoding_SevenBitAscii) = 2, Unicode (SmsEncoding_Unicode) = 3, GsmSevenBit (SmsEncoding_GsmSevenBit) = 4, EightBit (SmsEncoding_EightBit) = 5, Latin (SmsEncoding_Latin) = 6, Korean (SmsEncoding_Korean) = 7, IA5 (SmsEncoding_IA5) = 8, ShiftJis (SmsEncoding_ShiftJis) = 9, LatinHebrew (SmsEncoding_LatinHebrew) = 10,
		}}
		DEFINE_IID!(IID_ISmsTextMessage2, 580966547, 17749, 18261, 181, 161, 231, 253, 132, 149, 95, 141);
		RT_INTERFACE!{interface ISmsTextMessage2(ISmsTextMessage2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage2] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_To(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_From(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Body(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Encoding(&mut self, out: *mut SmsEncoding) -> ::w::HRESULT,
			fn put_Encoding(&mut self, value: SmsEncoding) -> ::w::HRESULT,
			fn get_CallbackNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_CallbackNumber(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsDeliveryNotificationEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDeliveryNotificationEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_RetryAttemptCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_RetryAttemptCount(&mut self, value: i32) -> ::w::HRESULT,
			fn get_TeleserviceId(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ProtocolId(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl ISmsTextMessage2 {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_to(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_To)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_From)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_body(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Body)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_encoding(&mut self) -> RtResult<SmsEncoding> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Encoding)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_encoding(&mut self, value: SmsEncoding) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Encoding)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_callback_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CallbackNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_callback_number(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CallbackNumber)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_delivery_notification_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDeliveryNotificationEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_delivery_notification_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDeliveryNotificationEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_retry_attempt_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RetryAttemptCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_retry_attempt_count(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RetryAttemptCount)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_teleservice_id(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TeleserviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_id(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtocolId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsTextMessage2: ISmsTextMessage2}
		DEFINE_IID!(IID_ISmsWapMessage, 3448993603, 31317, 19771, 144, 33, 242, 46, 2, 45, 9, 197);
		RT_INTERFACE!{interface ISmsWapMessage(ISmsWapMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsWapMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_From(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ApplicationId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ContentType(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy5(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_BinaryBody(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_Headers(&mut self, out: *mut *mut super::super::foundation::collections::IMap<HString, HString>) -> ::w::HRESULT
		}}
		impl ISmsWapMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_From)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_application_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ApplicationId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_content_type(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ContentType)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_binary_body(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BinaryBody)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_headers(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMap<HString, HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Headers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsWapMessage: ISmsWapMessage}
		DEFINE_IID!(IID_ISmsAppMessage, 3904603284, 54176, 18954, 134, 215, 41, 16, 51, 168, 207, 84);
		RT_INTERFACE!{interface ISmsAppMessage(ISmsAppMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsAppMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_To(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_From(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Body(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_CallbackNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_CallbackNumber(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsDeliveryNotificationEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDeliveryNotificationEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_RetryAttemptCount(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_RetryAttemptCount(&mut self, value: i32) -> ::w::HRESULT,
			fn get_Encoding(&mut self, out: *mut SmsEncoding) -> ::w::HRESULT,
			fn put_Encoding(&mut self, value: SmsEncoding) -> ::w::HRESULT,
			fn get_PortNumber(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_PortNumber(&mut self, value: i32) -> ::w::HRESULT,
			fn get_TeleserviceId(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_TeleserviceId(&mut self, value: i32) -> ::w::HRESULT,
			fn get_ProtocolId(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_ProtocolId(&mut self, value: i32) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_BinaryBody(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_BinaryBody(&mut self, value: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl ISmsAppMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_to(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_To)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_From)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_body(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Body)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_callback_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CallbackNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_callback_number(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CallbackNumber)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_delivery_notification_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDeliveryNotificationEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_delivery_notification_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDeliveryNotificationEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_retry_attempt_count(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RetryAttemptCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_retry_attempt_count(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RetryAttemptCount)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_encoding(&mut self) -> RtResult<SmsEncoding> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Encoding)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_encoding(&mut self, value: SmsEncoding) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Encoding)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_port_number(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PortNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_port_number(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PortNumber)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_teleservice_id(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TeleserviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_teleservice_id(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_TeleserviceId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_id(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtocolId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_protocol_id(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ProtocolId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_binary_body(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BinaryBody)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_binary_body(&mut self, value: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BinaryBody)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsAppMessage: ISmsAppMessage}
		RT_ENUM! { enum SmsGeographicalScope: i32 {
			None (SmsGeographicalScope_None) = 0, CellWithImmediateDisplay (SmsGeographicalScope_CellWithImmediateDisplay) = 1, LocationArea (SmsGeographicalScope_LocationArea) = 2, Plmn (SmsGeographicalScope_Plmn) = 3, Cell (SmsGeographicalScope_Cell) = 4,
		}}
		RT_ENUM! { enum SmsBroadcastType: i32 {
			Other (SmsBroadcastType_Other) = 0, CmasPresidential (SmsBroadcastType_CmasPresidential) = 1, CmasExtreme (SmsBroadcastType_CmasExtreme) = 2, CmasSevere (SmsBroadcastType_CmasSevere) = 3, CmasAmber (SmsBroadcastType_CmasAmber) = 4, CmasTest (SmsBroadcastType_CmasTest) = 5, EUAlert1 (SmsBroadcastType_EUAlert1) = 6, EUAlert2 (SmsBroadcastType_EUAlert2) = 7, EUAlert3 (SmsBroadcastType_EUAlert3) = 8, EUAlertAmber (SmsBroadcastType_EUAlertAmber) = 9, EUAlertInfo (SmsBroadcastType_EUAlertInfo) = 10, EtwsEarthquake (SmsBroadcastType_EtwsEarthquake) = 11, EtwsTsunami (SmsBroadcastType_EtwsTsunami) = 12, EtwsTsunamiAndEarthquake (SmsBroadcastType_EtwsTsunamiAndEarthquake) = 13, LatAlertLocal (SmsBroadcastType_LatAlertLocal) = 14,
		}}
		DEFINE_IID!(IID_ISmsBroadcastMessage, 1974385649, 58551, 18548, 160, 156, 41, 86, 229, 146, 249, 87);
		RT_INTERFACE!{interface ISmsBroadcastMessage(ISmsBroadcastMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsBroadcastMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Channel(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_GeographicalScope(&mut self, out: *mut SmsGeographicalScope) -> ::w::HRESULT,
			fn get_MessageCode(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_UpdateNumber(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_BroadcastType(&mut self, out: *mut SmsBroadcastType) -> ::w::HRESULT,
			fn get_IsEmergencyAlert(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsUserPopupRequested(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl ISmsBroadcastMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geographical_scope(&mut self) -> RtResult<SmsGeographicalScope> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GeographicalScope)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_code(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_update_number(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpdateNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_broadcast_type(&mut self) -> RtResult<SmsBroadcastType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BroadcastType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_emergency_alert(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEmergencyAlert)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_user_popup_requested(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsUserPopupRequested)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsBroadcastMessage: ISmsBroadcastMessage}
		DEFINE_IID!(IID_ISmsVoicemailMessage, 656056486, 38321, 17663, 188, 184, 184, 253, 215, 224, 139, 195);
		RT_INTERFACE!{interface ISmsVoicemailMessage(ISmsVoicemailMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsVoicemailMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MessageCount(&mut self, out: *mut *mut super::super::foundation::IReference<i32>) -> ::w::HRESULT
		}}
		impl ISmsVoicemailMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_count(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MessageCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsVoicemailMessage: ISmsVoicemailMessage}
		DEFINE_IID!(IID_ISmsStatusMessage, 3872555842, 46859, 18039, 147, 121, 201, 120, 63, 223, 248, 244);
		RT_INTERFACE!{interface ISmsStatusMessage(ISmsStatusMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsStatusMessage] {
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_From(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MessageReferenceNumber(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ServiceCenterTimestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_DischargeTime(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT
		}}
		impl ISmsStatusMessage {
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_From)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_reference_number(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageReferenceNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_center_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceCenterTimestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_discharge_time(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DischargeTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsStatusMessage: ISmsStatusMessage}
		RT_STRUCT! { struct SmsEncodedLength {
			SegmentCount: u32, CharacterCountLastSegment: u32, CharactersPerSegment: u32, ByteCountLastSegment: u32, BytesPerSegment: u32,
		}}
		RT_ENUM! { enum SmsDeviceStatus: i32 {
			Off (SmsDeviceStatus_Off) = 0, Ready (SmsDeviceStatus_Ready) = 1, SimNotInserted (SmsDeviceStatus_SimNotInserted) = 2, BadSim (SmsDeviceStatus_BadSim) = 3, DeviceFailure (SmsDeviceStatus_DeviceFailure) = 4, SubscriptionNotActivated (SmsDeviceStatus_SubscriptionNotActivated) = 5, DeviceLocked (SmsDeviceStatus_DeviceLocked) = 6, DeviceBlocked (SmsDeviceStatus_DeviceBlocked) = 7,
		}}
		RT_ENUM! { enum SmsModemErrorCode: i32 {
			Other (SmsModemErrorCode_Other) = 0, MessagingNetworkError (SmsModemErrorCode_MessagingNetworkError) = 1, SmsOperationNotSupportedByDevice (SmsModemErrorCode_SmsOperationNotSupportedByDevice) = 2, SmsServiceNotSupportedByNetwork (SmsModemErrorCode_SmsServiceNotSupportedByNetwork) = 3, DeviceFailure (SmsModemErrorCode_DeviceFailure) = 4, MessageNotEncodedProperly (SmsModemErrorCode_MessageNotEncodedProperly) = 5, MessageTooLarge (SmsModemErrorCode_MessageTooLarge) = 6, DeviceNotReady (SmsModemErrorCode_DeviceNotReady) = 7, NetworkNotReady (SmsModemErrorCode_NetworkNotReady) = 8, InvalidSmscAddress (SmsModemErrorCode_InvalidSmscAddress) = 9, NetworkFailure (SmsModemErrorCode_NetworkFailure) = 10, FixedDialingNumberRestricted (SmsModemErrorCode_FixedDialingNumberRestricted) = 11,
		}}
		DEFINE_IID!(IID_ISmsSendMessageResult, 3675495154, 30921, 20459, 150, 34, 69, 35, 40, 8, 141, 98);
		RT_INTERFACE!{interface ISmsSendMessageResult(ISmsSendMessageResultVtbl): IInspectable(IInspectableVtbl) [IID_ISmsSendMessageResult] {
			fn get_IsSuccessful(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_MessageReferenceNumbers(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<i32>) -> ::w::HRESULT,
			fn get_CellularClass(&mut self, out: *mut CellularClass) -> ::w::HRESULT,
			fn get_ModemErrorCode(&mut self, out: *mut SmsModemErrorCode) -> ::w::HRESULT,
			fn get_IsErrorTransient(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_NetworkCauseCode(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_TransportFailureCause(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl ISmsSendMessageResult {
			#[inline] pub unsafe fn get_is_successful(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsSuccessful)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_reference_numbers(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MessageReferenceNumbers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cellular_class(&mut self) -> RtResult<CellularClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CellularClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_modem_error_code(&mut self) -> RtResult<SmsModemErrorCode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ModemErrorCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_error_transient(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsErrorTransient)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_network_cause_code(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NetworkCauseCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_transport_failure_cause(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TransportFailureCause)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsSendMessageResult: ISmsSendMessageResult}
		DEFINE_IID!(IID_ISmsDevice2Statics, 1707574053, 4145, 18718, 143, 182, 239, 153, 145, 175, 227, 99);
		RT_INTERFACE!{static interface ISmsDevice2Statics(ISmsDevice2StaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice2Statics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromId(&mut self, deviceId: ::w::HSTRING, out: *mut *mut SmsDevice2) -> ::w::HRESULT,
			fn GetDefault(&mut self, out: *mut *mut SmsDevice2) -> ::w::HRESULT,
			fn FromParentId(&mut self, parentDeviceId: ::w::HSTRING, out: *mut *mut SmsDevice2) -> ::w::HRESULT
		}}
		impl ISmsDevice2Statics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<SmsDevice2>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromId)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<SmsDevice2>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_parent_id(&mut self, parentDeviceId: &HStringArg) -> RtResult<ComPtr<SmsDevice2>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromParentId)(self, parentDeviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsDevice2: ISmsDevice2}
		RT_ACTIVATABLE!{ISmsDevice2Statics [CLSID_SmsDevice2]}
		DEFINE_CLSID!(CLSID_SmsDevice2 = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,50,0]);
		DEFINE_IID!(IID_ISmsDevice2, 3179961363, 58658, 18123, 184, 213, 158, 173, 48, 251, 108, 71);
		RT_INTERFACE!{interface ISmsDevice2(ISmsDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice2] {
			fn get_SmscAddress(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_SmscAddress(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ParentDeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AccountPhoneNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_CellularClass(&mut self, out: *mut CellularClass) -> ::w::HRESULT,
			fn get_DeviceStatus(&mut self, out: *mut SmsDeviceStatus) -> ::w::HRESULT,
			fn CalculateLength(&mut self, message: *mut ISmsMessageBase, out: *mut SmsEncodedLength) -> ::w::HRESULT,
			fn SendMessageAndGetResultAsync(&mut self, message: *mut ISmsMessageBase, out: *mut *mut super::super::foundation::IAsyncOperation<SmsSendMessageResult>) -> ::w::HRESULT,
			fn add_DeviceStatusChanged(&mut self, eventHandler: *mut super::super::foundation::TypedEventHandler<SmsDevice2, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DeviceStatusChanged(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISmsDevice2 {
			#[inline] pub unsafe fn get_smsc_address(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SmscAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_smsc_address(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SmscAddress)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_parent_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ParentDeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_account_phone_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AccountPhoneNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cellular_class(&mut self) -> RtResult<CellularClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CellularClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_status(&mut self) -> RtResult<SmsDeviceStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DeviceStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn calculate_length(&mut self, message: &ISmsMessageBase) -> RtResult<SmsEncodedLength> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).CalculateLength)(self, message as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn send_message_and_get_result_async(&mut self, message: &ISmsMessageBase) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmsSendMessageResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendMessageAndGetResultAsync)(self, message as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_device_status_changed(&mut self, eventHandler: &super::super::foundation::TypedEventHandler<SmsDevice2, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DeviceStatusChanged)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_device_status_changed(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DeviceStatusChanged)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsMessageReceivedTriggerDetails, 735038420, 9815, 16680, 173, 95, 227, 135, 113, 50, 189, 177);
		RT_INTERFACE!{interface ISmsMessageReceivedTriggerDetails(ISmsMessageReceivedTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedTriggerDetails] {
			fn get_MessageType(&mut self, out: *mut SmsMessageType) -> ::w::HRESULT,
			fn get_TextMessage(&mut self, out: *mut *mut SmsTextMessage2) -> ::w::HRESULT,
			fn get_WapMessage(&mut self, out: *mut *mut SmsWapMessage) -> ::w::HRESULT,
			fn get_AppMessage(&mut self, out: *mut *mut SmsAppMessage) -> ::w::HRESULT,
			fn get_BroadcastMessage(&mut self, out: *mut *mut SmsBroadcastMessage) -> ::w::HRESULT,
			fn get_VoicemailMessage(&mut self, out: *mut *mut SmsVoicemailMessage) -> ::w::HRESULT,
			fn get_StatusMessage(&mut self, out: *mut *mut SmsStatusMessage) -> ::w::HRESULT,
			fn Drop(&mut self) -> ::w::HRESULT,
			fn Accept(&mut self) -> ::w::HRESULT
		}}
		impl ISmsMessageReceivedTriggerDetails {
			#[inline] pub unsafe fn get_message_type(&mut self) -> RtResult<SmsMessageType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_text_message(&mut self) -> RtResult<ComPtr<SmsTextMessage2>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TextMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_wap_message(&mut self) -> RtResult<ComPtr<SmsWapMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_WapMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_app_message(&mut self) -> RtResult<ComPtr<SmsAppMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AppMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_broadcast_message(&mut self) -> RtResult<ComPtr<SmsBroadcastMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BroadcastMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_voicemail_message(&mut self) -> RtResult<ComPtr<SmsVoicemailMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VoicemailMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status_message(&mut self) -> RtResult<ComPtr<SmsStatusMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_StatusMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn drop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Drop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn accept(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Accept)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsMessageReceivedTriggerDetails: ISmsMessageReceivedTriggerDetails}
		RT_ENUM! { enum SmsFilterActionType: i32 {
			AcceptImmediately (SmsFilterActionType_AcceptImmediately) = 0, Drop (SmsFilterActionType_Drop) = 1, Peek (SmsFilterActionType_Peek) = 2, Accept (SmsFilterActionType_Accept) = 3,
		}}
		DEFINE_IID!(IID_ISmsFilterRule, 1088630702, 45129, 20412, 175, 233, 226, 166, 16, 239, 245, 92);
		RT_INTERFACE!{interface ISmsFilterRule(ISmsFilterRuleVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRule] {
			fn get_MessageType(&mut self, out: *mut SmsMessageType) -> ::w::HRESULT,
			fn get_ImsiPrefixes(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_DeviceIds(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_SenderNumbers(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_TextMessagePrefixes(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_PortNumbers(&mut self, out: *mut *mut super::super::foundation::collections::IVector<i32>) -> ::w::HRESULT,
			fn get_CellularClass(&mut self, out: *mut CellularClass) -> ::w::HRESULT,
			fn put_CellularClass(&mut self, value: CellularClass) -> ::w::HRESULT,
			fn get_ProtocolIds(&mut self, out: *mut *mut super::super::foundation::collections::IVector<i32>) -> ::w::HRESULT,
			fn get_TeleserviceIds(&mut self, out: *mut *mut super::super::foundation::collections::IVector<i32>) -> ::w::HRESULT,
			fn get_WapApplicationIds(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_WapContentTypes(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn get_BroadcastTypes(&mut self, out: *mut *mut super::super::foundation::collections::IVector<SmsBroadcastType>) -> ::w::HRESULT,
			fn get_BroadcastChannels(&mut self, out: *mut *mut super::super::foundation::collections::IVector<i32>) -> ::w::HRESULT
		}}
		impl ISmsFilterRule {
			#[inline] pub unsafe fn get_message_type(&mut self) -> RtResult<SmsMessageType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_imsi_prefixes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ImsiPrefixes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_ids(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sender_numbers(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SenderNumbers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_text_message_prefixes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TextMessagePrefixes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_port_numbers(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PortNumbers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cellular_class(&mut self) -> RtResult<CellularClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CellularClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_cellular_class(&mut self, value: CellularClass) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CellularClass)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_ids(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ProtocolIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_teleservice_ids(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TeleserviceIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_wap_application_ids(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_WapApplicationIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_wap_content_types(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_WapContentTypes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_broadcast_types(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<SmsBroadcastType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BroadcastTypes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_broadcast_channels(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BroadcastChannels)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsFilterRuleFactory, 12805384, 25238, 20265, 154, 173, 137, 32, 206, 186, 60, 232);
		RT_INTERFACE!{static interface ISmsFilterRuleFactory(ISmsFilterRuleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRuleFactory] {
			fn CreateFilterRule(&mut self, messageType: SmsMessageType, out: *mut *mut SmsFilterRule) -> ::w::HRESULT
		}}
		impl ISmsFilterRuleFactory {
			#[inline] pub unsafe fn create_filter_rule(&mut self, messageType: SmsMessageType) -> RtResult<ComPtr<SmsFilterRule>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFilterRule)(self, messageType, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsFilterRule: ISmsFilterRule [ISmsFilterRuleFactory] [CLSID_SmsFilterRule]}
		DEFINE_CLSID!(CLSID_SmsFilterRule = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,0]);
		DEFINE_IID!(IID_ISmsFilterRules, 1313336059, 31181, 18561, 152, 148, 85, 164, 19, 91, 35, 250);
		RT_INTERFACE!{interface ISmsFilterRules(ISmsFilterRulesVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRules] {
			fn get_ActionType(&mut self, out: *mut SmsFilterActionType) -> ::w::HRESULT,
			fn get_Rules(&mut self, out: *mut *mut super::super::foundation::collections::IVector<SmsFilterRule>) -> ::w::HRESULT
		}}
		impl ISmsFilterRules {
			#[inline] pub unsafe fn get_action_type(&mut self) -> RtResult<SmsFilterActionType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ActionType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rules(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<SmsFilterRule>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Rules)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsFilterRulesFactory, 2694391021, 28206, 17712, 159, 222, 70, 93, 2, 238, 208, 14);
		RT_INTERFACE!{static interface ISmsFilterRulesFactory(ISmsFilterRulesFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRulesFactory] {
			fn CreateFilterRules(&mut self, actionType: SmsFilterActionType, out: *mut *mut SmsFilterRules) -> ::w::HRESULT
		}}
		impl ISmsFilterRulesFactory {
			#[inline] pub unsafe fn create_filter_rules(&mut self, actionType: SmsFilterActionType) -> RtResult<ComPtr<SmsFilterRules>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFilterRules)(self, actionType, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsFilterRules: ISmsFilterRules [ISmsFilterRulesFactory] [CLSID_SmsFilterRules]}
		DEFINE_CLSID!(CLSID_SmsFilterRules = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,115,0]);
		DEFINE_IID!(IID_ISmsMessageRegistrationStatics, 1671451748, 10392, 18296, 160, 60, 111, 153, 73, 7, 214, 58);
		RT_INTERFACE!{static interface ISmsMessageRegistrationStatics(ISmsMessageRegistrationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistrationStatics] {
			fn get_AllRegistrations(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<SmsMessageRegistration>) -> ::w::HRESULT,
			fn Register(&mut self, id: ::w::HSTRING, filterRules: *mut SmsFilterRules, out: *mut *mut SmsMessageRegistration) -> ::w::HRESULT
		}}
		impl ISmsMessageRegistrationStatics {
			#[inline] pub unsafe fn get_all_registrations(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<SmsMessageRegistration>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AllRegistrations)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn register(&mut self, id: &HStringArg, filterRules: &SmsFilterRules) -> RtResult<ComPtr<SmsMessageRegistration>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Register)(self, id.get(), filterRules as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsMessageRegistration: ISmsMessageRegistration}
		RT_ACTIVATABLE!{ISmsMessageRegistrationStatics [CLSID_SmsMessageRegistration]}
		DEFINE_CLSID!(CLSID_SmsMessageRegistration = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,77,101,115,115,97,103,101,82,101,103,105,115,116,114,97,116,105,111,110,0]);
		DEFINE_IID!(IID_ISmsMessageRegistration, 387993662, 62287, 17515, 131, 179, 15, 241, 153, 35, 180, 9);
		RT_INTERFACE!{interface ISmsMessageRegistration(ISmsMessageRegistrationVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistration] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn Unregister(&mut self) -> ::w::HRESULT,
			fn add_MessageReceived(&mut self, eventHandler: *mut super::super::foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MessageReceived(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISmsMessageRegistration {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unregister(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Unregister)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_message_received(&mut self, eventHandler: &super::super::foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MessageReceived)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_message_received(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MessageReceived)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_STRUCT! { struct LegacySmsApiContract {
			
		}}
		DEFINE_IID!(IID_ISmsMessage, 3980156456, 27012, 19207, 129, 29, 141, 89, 6, 237, 60, 234);
		RT_INTERFACE!{interface ISmsMessage(ISmsMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessage] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MessageClass(&mut self, out: *mut SmsMessageClass) -> ::w::HRESULT
		}}
		impl ISmsMessage {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_class(&mut self) -> RtResult<SmsMessageClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsBinaryMessage, 1542776851, 15187, 19566, 182, 26, 216, 106, 99, 117, 86, 80);
		RT_INTERFACE!{interface ISmsBinaryMessage(ISmsBinaryMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsBinaryMessage] {
			fn get_Format(&mut self, out: *mut SmsDataFormat) -> ::w::HRESULT,
			fn put_Format(&mut self, value: SmsDataFormat) -> ::w::HRESULT,
			fn GetData(&mut self, outSize: *mut u32, out: *mut *mut u8) -> ::w::HRESULT,
			fn SetData(&mut self, valueSize: u32, value: *mut u8) -> ::w::HRESULT
		}}
		impl ISmsBinaryMessage {
			#[inline] pub unsafe fn get_format(&mut self) -> RtResult<SmsDataFormat> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Format)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_format(&mut self, value: SmsDataFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Format)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComArray<u8>> {
				let mut outSize = 0; let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetData)(self, &mut outSize, &mut out);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(outSize, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data(&mut self, value: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetData)(self, value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsBinaryMessage: ISmsBinaryMessage}
		DEFINE_IID!(IID_ISmsTextMessage, 3592196172, 42133, 18559, 154, 111, 151, 21, 72, 197, 188, 159);
		RT_INTERFACE!{interface ISmsTextMessage(ISmsTextMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_PartReferenceId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_PartNumber(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_PartCount(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_To(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_To(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_From(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_From(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Body(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Body(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Encoding(&mut self, out: *mut SmsEncoding) -> ::w::HRESULT,
			fn put_Encoding(&mut self, value: SmsEncoding) -> ::w::HRESULT,
			fn ToBinaryMessages(&mut self, format: SmsDataFormat, out: *mut *mut super::super::foundation::collections::IVectorView<ISmsBinaryMessage>) -> ::w::HRESULT
		}}
		impl ISmsTextMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_part_reference_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PartReferenceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_part_number(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PartNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_part_count(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PartCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_to(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_To)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_to(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_To)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_From)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_from(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_From)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Body)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_body(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Body)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_encoding(&mut self) -> RtResult<SmsEncoding> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Encoding)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_encoding(&mut self, value: SmsEncoding) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Encoding)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn to_binary_messages(&mut self, format: SmsDataFormat) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<ISmsBinaryMessage>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ToBinaryMessages)(self, format, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsTextMessageStatics, 2137572845, 15564, 18339, 140, 85, 56, 13, 59, 1, 8, 146);
		RT_INTERFACE!{static interface ISmsTextMessageStatics(ISmsTextMessageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessageStatics] {
			fn FromBinaryMessage(&mut self, binaryMessage: *mut SmsBinaryMessage, out: *mut *mut SmsTextMessage) -> ::w::HRESULT,
			fn FromBinaryData(&mut self, format: SmsDataFormat, valueSize: u32, value: *mut u8, out: *mut *mut SmsTextMessage) -> ::w::HRESULT
		}}
		impl ISmsTextMessageStatics {
			#[inline] pub unsafe fn from_binary_message(&mut self, binaryMessage: &SmsBinaryMessage) -> RtResult<ComPtr<SmsTextMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromBinaryMessage)(self, binaryMessage as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_binary_data(&mut self, format: SmsDataFormat, value: &[u8]) -> RtResult<ComPtr<SmsTextMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromBinaryData)(self, format, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsTextMessage: ISmsTextMessage}
		RT_ACTIVATABLE!{ISmsTextMessageStatics [CLSID_SmsTextMessage]}
		DEFINE_CLSID!(CLSID_SmsTextMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,84,101,120,116,77,101,115,115,97,103,101,0]);
		RT_ENUM! { enum SmsMessageFilter: i32 {
			All (SmsMessageFilter_All) = 0, Unread (SmsMessageFilter_Unread) = 1, Read (SmsMessageFilter_Read) = 2, Sent (SmsMessageFilter_Sent) = 3, Draft (SmsMessageFilter_Draft) = 4,
		}}
		RT_CLASS!{class DeleteSmsMessageOperation: super::super::foundation::IAsyncAction}
		RT_CLASS!{class DeleteSmsMessagesOperation: super::super::foundation::IAsyncAction}
		RT_CLASS!{class GetSmsMessageOperation: super::super::foundation::IAsyncOperation<ISmsMessage>}
		RT_CLASS!{class GetSmsMessagesOperation: super::super::foundation::IAsyncOperationWithProgress<super::super::foundation::collections::IVectorView<ISmsMessage>, i32>}
		DEFINE_IID!(IID_ISmsDeviceMessageStore, 2559177299, 61832, 17447, 141, 84, 206, 12, 36, 35, 197, 193);
		RT_INTERFACE!{interface ISmsDeviceMessageStore(ISmsDeviceMessageStoreVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceMessageStore] {
			fn DeleteMessageAsync(&mut self, messageId: u32, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn DeleteMessagesAsync(&mut self, messageFilter: SmsMessageFilter, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn GetMessageAsync(&mut self, messageId: u32, out: *mut *mut super::super::foundation::IAsyncOperation<ISmsMessage>) -> ::w::HRESULT,
			fn GetMessagesAsync(&mut self, messageFilter: SmsMessageFilter, out: *mut *mut super::super::foundation::IAsyncOperationWithProgress<super::super::foundation::collections::IVectorView<ISmsMessage>, i32>) -> ::w::HRESULT,
			fn get_MaxMessages(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl ISmsDeviceMessageStore {
			#[inline] pub unsafe fn delete_message_async(&mut self, messageId: u32) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DeleteMessageAsync)(self, messageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn delete_messages_async(&mut self, messageFilter: SmsMessageFilter) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DeleteMessagesAsync)(self, messageFilter, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_async(&mut self, messageId: u32) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ISmsMessage>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetMessageAsync)(self, messageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_messages_async(&mut self, messageFilter: SmsMessageFilter) -> RtResult<ComPtr<super::super::foundation::IAsyncOperationWithProgress<super::super::foundation::collections::IVectorView<ISmsMessage>, i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetMessagesAsync)(self, messageFilter, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_messages(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxMessages)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsDeviceMessageStore: ISmsDeviceMessageStore}
		RT_CLASS!{class SendSmsMessageOperation: super::super::foundation::IAsyncAction}
		DEFINE_IID!(IID_ISmsMessageReceivedEventArgs, 149424792, 47333, 16833, 163, 216, 211, 171, 250, 226, 38, 117);
		RT_INTERFACE!{interface ISmsMessageReceivedEventArgs(ISmsMessageReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedEventArgs] {
			fn get_TextMessage(&mut self, out: *mut *mut SmsTextMessage) -> ::w::HRESULT,
			fn get_BinaryMessage(&mut self, out: *mut *mut SmsBinaryMessage) -> ::w::HRESULT
		}}
		impl ISmsMessageReceivedEventArgs {
			#[inline] pub unsafe fn get_text_message(&mut self) -> RtResult<ComPtr<SmsTextMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TextMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_binary_message(&mut self) -> RtResult<ComPtr<SmsBinaryMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BinaryMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsMessageReceivedEventArgs: ISmsMessageReceivedEventArgs}
		DEFINE_IID!(IID_SmsMessageReceivedEventHandler, 192599049, 60461, 18382, 162, 83, 115, 43, 238, 235, 202, 205);
		RT_DELEGATE!{delegate SmsMessageReceivedEventHandler(SmsMessageReceivedEventHandlerVtbl, SmsMessageReceivedEventHandlerImpl) [IID_SmsMessageReceivedEventHandler] {
			fn Invoke(&mut self, sender: *mut SmsDevice, e: *mut SmsMessageReceivedEventArgs) -> ::w::HRESULT
		}}
		impl SmsMessageReceivedEventHandler {
			#[inline] pub unsafe fn invoke(&mut self, sender: &SmsDevice, e: &SmsMessageReceivedEventArgs) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, e as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsDevice: ISmsDevice}
		RT_ACTIVATABLE!{ISmsDeviceStatics [CLSID_SmsDevice]}
		RT_ACTIVATABLE!{ISmsDeviceStatics2 [CLSID_SmsDevice]}
		DEFINE_CLSID!(CLSID_SmsDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_SmsDeviceStatusChangedEventHandler, 2552959330, 15831, 17944, 175, 137, 12, 39, 45, 93, 6, 216);
		RT_DELEGATE!{delegate SmsDeviceStatusChangedEventHandler(SmsDeviceStatusChangedEventHandlerVtbl, SmsDeviceStatusChangedEventHandlerImpl) [IID_SmsDeviceStatusChangedEventHandler] {
			fn Invoke(&mut self, sender: *mut SmsDevice) -> ::w::HRESULT
		}}
		impl SmsDeviceStatusChangedEventHandler {
			#[inline] pub unsafe fn invoke(&mut self, sender: &SmsDevice) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GetSmsDeviceOperation: super::super::foundation::IAsyncOperation<SmsDevice>}
		DEFINE_IID!(IID_ISmsDeviceStatics, 4169992170, 55317, 19921, 162, 52, 69, 32, 206, 70, 4, 164);
		RT_INTERFACE!{static interface ISmsDeviceStatics(ISmsDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<SmsDevice>) -> ::w::HRESULT,
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SmsDevice>) -> ::w::HRESULT
		}}
		impl ISmsDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmsDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmsDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsDeviceStatics2, 748756103, 2163, 19631, 138, 125, 189, 71, 30, 133, 134, 209);
		RT_INTERFACE!{static interface ISmsDeviceStatics2(ISmsDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics2] {
			fn FromNetworkAccountIdAsync(&mut self, networkAccountId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<SmsDevice>) -> ::w::HRESULT
		}}
		impl ISmsDeviceStatics2 {
			#[inline] pub unsafe fn from_network_account_id_async(&mut self, networkAccountId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmsDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromNetworkAccountIdAsync)(self, networkAccountId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsDevice, 152539629, 34603, 20204, 156, 114, 171, 17, 98, 123, 52, 236);
		RT_INTERFACE!{interface ISmsDevice(ISmsDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice] {
			fn SendMessageAsync(&mut self, message: *mut ISmsMessage, out: *mut *mut SendSmsMessageOperation) -> ::w::HRESULT,
			fn CalculateLength(&mut self, message: *mut SmsTextMessage, out: *mut SmsEncodedLength) -> ::w::HRESULT,
			fn get_AccountPhoneNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_CellularClass(&mut self, out: *mut CellularClass) -> ::w::HRESULT,
			fn get_MessageStore(&mut self, out: *mut *mut SmsDeviceMessageStore) -> ::w::HRESULT,
			fn get_DeviceStatus(&mut self, out: *mut SmsDeviceStatus) -> ::w::HRESULT,
			fn add_SmsMessageReceived(&mut self, eventHandler: *mut SmsMessageReceivedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SmsMessageReceived(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SmsDeviceStatusChanged(&mut self, eventHandler: *mut SmsDeviceStatusChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SmsDeviceStatusChanged(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISmsDevice {
			#[inline] pub unsafe fn send_message_async(&mut self, message: &ISmsMessage) -> RtResult<ComPtr<SendSmsMessageOperation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendMessageAsync)(self, message as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn calculate_length(&mut self, message: &SmsTextMessage) -> RtResult<SmsEncodedLength> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).CalculateLength)(self, message as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_account_phone_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AccountPhoneNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cellular_class(&mut self) -> RtResult<CellularClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CellularClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_store(&mut self) -> RtResult<ComPtr<SmsDeviceMessageStore>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MessageStore)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_status(&mut self) -> RtResult<SmsDeviceStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DeviceStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_sms_message_received(&mut self, eventHandler: &SmsMessageReceivedEventHandler) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SmsMessageReceived)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_sms_message_received(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SmsMessageReceived)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_sms_device_status_changed(&mut self, eventHandler: &SmsDeviceStatusChangedEventHandler) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SmsDeviceStatusChanged)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_sms_device_status_changed(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SmsDeviceStatusChanged)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsReceivedEventDetails, 1538592533, 58477, 19586, 132, 125, 90, 3, 4, 193, 213, 61);
		RT_INTERFACE!{interface ISmsReceivedEventDetails(ISmsReceivedEventDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MessageIndex(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl ISmsReceivedEventDetails {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_message_index(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageIndex)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmsReceivedEventDetails2, 1088445574, 42932, 18289, 154, 231, 11, 95, 251, 18, 192, 58);
		RT_INTERFACE!{interface ISmsReceivedEventDetails2(ISmsReceivedEventDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails2] {
			fn get_MessageClass(&mut self, out: *mut SmsMessageClass) -> ::w::HRESULT,
			fn get_BinaryMessage(&mut self, out: *mut *mut SmsBinaryMessage) -> ::w::HRESULT
		}}
		impl ISmsReceivedEventDetails2 {
			#[inline] pub unsafe fn get_message_class(&mut self) -> RtResult<SmsMessageClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MessageClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_binary_message(&mut self) -> RtResult<ComPtr<SmsBinaryMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BinaryMessage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmsReceivedEventDetails: ISmsReceivedEventDetails}
} // Windows.Devices.Sms
pub mod alljoyn { // Windows.Devices.AllJoyn
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum AllJoynAuthenticationMechanism: i32 {
			None (AllJoynAuthenticationMechanism_None) = 0, SrpAnonymous (AllJoynAuthenticationMechanism_SrpAnonymous) = 1, SrpLogon (AllJoynAuthenticationMechanism_SrpLogon) = 2, EcdheNull (AllJoynAuthenticationMechanism_EcdheNull) = 3, EcdhePsk (AllJoynAuthenticationMechanism_EcdhePsk) = 4, EcdheEcdsa (AllJoynAuthenticationMechanism_EcdheEcdsa) = 5, EcdheSpeke (AllJoynAuthenticationMechanism_EcdheSpeke) = 6,
		}}
		DEFINE_IID!(IID_IAllJoynStatusStatics, 3501695358, 3369, 19881, 138, 198, 84, 197, 84, 190, 219, 197);
		RT_INTERFACE!{static interface IAllJoynStatusStatics(IAllJoynStatusStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynStatusStatics] {
			fn get_Ok(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Fail(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_OperationTimedOut(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_OtherEndClosed(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ConnectionRefused(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_AuthenticationFailed(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_AuthenticationRejectedByUser(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SslConnectFailed(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SslIdentityVerificationFailed(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InsufficientSecurity(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument1(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument2(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument3(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument4(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument5(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument6(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument7(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_InvalidArgument8(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAllJoynStatusStatics {
			#[inline] pub unsafe fn get_ok(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ok)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_fail(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Fail)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_operation_timed_out(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OperationTimedOut)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_other_end_closed(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OtherEndClosed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_refused(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConnectionRefused)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_authentication_failed(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationFailed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_authentication_rejected_by_user(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationRejectedByUser)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ssl_connect_failed(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SslConnectFailed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ssl_identity_verification_failed(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SslIdentityVerificationFailed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_insufficient_security(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InsufficientSecurity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument1(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument1)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument2(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument3(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument3)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument4(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument4)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument5(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument6(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument6)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument7(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument7)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_invalid_argument8(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InvalidArgument8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IAllJoynStatusStatics [CLSID_AllJoynStatus]}
		DEFINE_CLSID!(CLSID_AllJoynStatus = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,116,97,116,117,115,0]);
		RT_ENUM! { enum AllJoynBusAttachmentState: i32 {
			Disconnected (AllJoynBusAttachmentState_Disconnected) = 0, Connecting (AllJoynBusAttachmentState_Connecting) = 1, Connected (AllJoynBusAttachmentState_Connected) = 2, Disconnecting (AllJoynBusAttachmentState_Disconnecting) = 3,
		}}
		DEFINE_IID!(IID_IAllJoynBusAttachment, 4077515091, 7917, 17091, 162, 14, 67, 109, 65, 254, 98, 246);
		RT_INTERFACE!{interface IAllJoynBusAttachment(IAllJoynBusAttachmentVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment] {
			fn get_AboutData(&mut self, out: *mut *mut AllJoynAboutData) -> ::w::HRESULT,
			fn get_ConnectionSpecification(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_State(&mut self, out: *mut AllJoynBusAttachmentState) -> ::w::HRESULT,
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn PingAsync(&mut self, uniqueName: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<i32>) -> ::w::HRESULT,
			fn Connect(&mut self) -> ::w::HRESULT,
			fn Disconnect(&mut self) -> ::w::HRESULT,
			fn add_StateChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StateChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_AuthenticationMechanisms(&mut self, out: *mut *mut super::super::foundation::collections::IVector<AllJoynAuthenticationMechanism>) -> ::w::HRESULT,
			fn add_CredentialsRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CredentialsRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_CredentialsVerificationRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CredentialsVerificationRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_AuthenticationComplete(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AuthenticationComplete(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAllJoynBusAttachment {
			#[inline] pub unsafe fn get_about_data(&mut self) -> RtResult<ComPtr<AllJoynAboutData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AboutData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_specification(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionSpecification)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_state(&mut self) -> RtResult<AllJoynBusAttachmentState> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_State)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn ping_async(&mut self, uniqueName: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PingAsync)(self, uniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Connect)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disconnect(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Disconnect)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_state_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StateChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_state_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StateChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_authentication_mechanisms(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<AllJoynAuthenticationMechanism>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AuthenticationMechanisms)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_credentials_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CredentialsRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_credentials_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CredentialsRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_credentials_verification_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CredentialsVerificationRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_credentials_verification_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CredentialsVerificationRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_authentication_complete(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AuthenticationComplete)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_authentication_complete(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AuthenticationComplete)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynAboutData: IAllJoynAboutData}
		RT_CLASS!{class AllJoynBusAttachment: IAllJoynBusAttachment [IAllJoynBusAttachmentFactory] [CLSID_AllJoynBusAttachment]}
		RT_ACTIVATABLE!{IAllJoynBusAttachmentStatics [CLSID_AllJoynBusAttachment]}
		DEFINE_CLSID!(CLSID_AllJoynBusAttachment = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,65,116,116,97,99,104,109,101,110,116,0]);
		RT_CLASS!{class AllJoynBusAttachmentStateChangedEventArgs: IAllJoynBusAttachmentStateChangedEventArgs}
		RT_CLASS!{class AllJoynCredentialsRequestedEventArgs: IAllJoynCredentialsRequestedEventArgs}
		RT_CLASS!{class AllJoynCredentialsVerificationRequestedEventArgs: IAllJoynCredentialsVerificationRequestedEventArgs}
		RT_CLASS!{class AllJoynAuthenticationCompleteEventArgs: IAllJoynAuthenticationCompleteEventArgs}
		DEFINE_IID!(IID_IAllJoynBusAttachment2, 880069406, 9064, 17330, 180, 62, 106, 58, 193, 39, 141, 152);
		RT_INTERFACE!{interface IAllJoynBusAttachment2(IAllJoynBusAttachment2Vtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment2] {
			fn GetAboutDataAsync(&mut self, serviceInfo: *mut AllJoynServiceInfo, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynAboutDataView>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.globalization"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.globalization")] fn GetAboutDataWithLanguageAsync(&mut self, serviceInfo: *mut AllJoynServiceInfo, language: *mut super::super::globalization::Language, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynAboutDataView>) -> ::w::HRESULT,
			fn add_AcceptSessionJoinerRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AcceptSessionJoinerRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SessionJoined(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SessionJoined(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAllJoynBusAttachment2 {
			#[inline] pub unsafe fn get_about_data_async(&mut self, serviceInfo: &AllJoynServiceInfo) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynAboutDataView>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAboutDataAsync)(self, serviceInfo as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.globalization")] #[inline] pub unsafe fn get_about_data_with_language_async(&mut self, serviceInfo: &AllJoynServiceInfo, language: &super::super::globalization::Language) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynAboutDataView>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAboutDataWithLanguageAsync)(self, serviceInfo as *const _ as *mut _, language as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_accept_session_joiner_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AcceptSessionJoinerRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_accept_session_joiner_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AcceptSessionJoinerRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_session_joined(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SessionJoined)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_session_joined(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SessionJoined)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynServiceInfo: IAllJoynServiceInfo [IAllJoynServiceInfoFactory] [CLSID_AllJoynServiceInfo]}
		RT_ACTIVATABLE!{IAllJoynServiceInfoStatics [CLSID_AllJoynServiceInfo]}
		DEFINE_CLSID!(CLSID_AllJoynServiceInfo = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,0]);
		RT_CLASS!{class AllJoynAboutDataView: IAllJoynAboutDataView}
		RT_ACTIVATABLE!{IAllJoynAboutDataViewStatics [CLSID_AllJoynAboutDataView]}
		DEFINE_CLSID!(CLSID_AllJoynAboutDataView = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,98,111,117,116,68,97,116,97,86,105,101,119,0]);
		RT_CLASS!{class AllJoynAcceptSessionJoinerEventArgs: IAllJoynAcceptSessionJoinerEventArgs [IAllJoynAcceptSessionJoinerEventArgsFactory] [CLSID_AllJoynAcceptSessionJoinerEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynAcceptSessionJoinerEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,99,99,101,112,116,83,101,115,115,105,111,110,74,111,105,110,101,114,69,118,101,110,116,65,114,103,115,0]);
		RT_CLASS!{class AllJoynSessionJoinedEventArgs: IAllJoynSessionJoinedEventArgs [IAllJoynSessionJoinedEventArgsFactory] [CLSID_AllJoynSessionJoinedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynSessionJoinedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,74,111,105,110,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynBusAttachmentStatics, 2208124221, 4177, 16599, 135, 42, 141, 1, 65, 17, 91, 31);
		RT_INTERFACE!{static interface IAllJoynBusAttachmentStatics(IAllJoynBusAttachmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStatics] {
			fn GetDefault(&mut self, out: *mut *mut AllJoynBusAttachment) -> ::w::HRESULT,
			fn GetWatcher(&mut self, requiredInterfaces: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::enumeration::DeviceWatcher) -> ::w::HRESULT
		}}
		impl IAllJoynBusAttachmentStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<AllJoynBusAttachment>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_watcher(&mut self, requiredInterfaces: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::enumeration::DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetWatcher)(self, requiredInterfaces as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynBusAttachmentStateChangedEventArgs, 3626923508, 49194, 16876, 168, 213, 234, 177, 85, 137, 83, 170);
		RT_INTERFACE!{interface IAllJoynBusAttachmentStateChangedEventArgs(IAllJoynBusAttachmentStateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStateChangedEventArgs] {
			fn get_State(&mut self, out: *mut AllJoynBusAttachmentState) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAllJoynBusAttachmentStateChangedEventArgs {
			#[inline] pub unsafe fn get_state(&mut self) -> RtResult<AllJoynBusAttachmentState> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_State)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynCredentials, 2185646322, 41360, 16561, 171, 171, 52, 158, 194, 68, 223, 170);
		RT_INTERFACE!{interface IAllJoynCredentials(IAllJoynCredentialsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentials] {
			fn get_AuthenticationMechanism(&mut self, out: *mut AllJoynAuthenticationMechanism) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.security")] fn get_Certificate(&mut self, out: *mut *mut super::super::security::cryptography::certificates::Certificate) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.security")] fn put_Certificate(&mut self, value: *mut super::super::security::cryptography::certificates::Certificate) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.security")] fn get_PasswordCredential(&mut self, out: *mut *mut super::super::security::credentials::PasswordCredential) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.security")] fn put_PasswordCredential(&mut self, value: *mut super::super::security::credentials::PasswordCredential) -> ::w::HRESULT,
			fn get_Timeout(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_Timeout(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT
		}}
		impl IAllJoynCredentials {
			#[inline] pub unsafe fn get_authentication_mechanism(&mut self) -> RtResult<AllJoynAuthenticationMechanism> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationMechanism)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_certificate(&mut self) -> RtResult<ComPtr<super::super::security::cryptography::certificates::Certificate>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Certificate)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn set_certificate(&mut self, value: &super::super::security::cryptography::certificates::Certificate) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Certificate)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_password_credential(&mut self) -> RtResult<ComPtr<super::super::security::credentials::PasswordCredential>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PasswordCredential)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn set_password_credential(&mut self, value: &super::super::security::credentials::PasswordCredential) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PasswordCredential)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timeout(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_timeout(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Timeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynCredentials: IAllJoynCredentials}
		DEFINE_IID!(IID_IAllJoynCredentialsRequestedEventArgs, 1787290446, 45161, 19328, 158, 26, 65, 188, 131, 124, 101, 210);
		RT_INTERFACE!{interface IAllJoynCredentialsRequestedEventArgs(IAllJoynCredentialsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsRequestedEventArgs] {
			fn get_AttemptCount(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Credentials(&mut self, out: *mut *mut AllJoynCredentials) -> ::w::HRESULT,
			fn get_PeerUniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_RequestedUserName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut super::super::foundation::Deferral) -> ::w::HRESULT
		}}
		impl IAllJoynCredentialsRequestedEventArgs {
			#[inline] pub unsafe fn get_attempt_count(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AttemptCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_credentials(&mut self) -> RtResult<ComPtr<AllJoynCredentials>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Credentials)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_peer_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerUniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_requested_user_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RequestedUserName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<super::super::foundation::Deferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynCredentialsVerificationRequestedEventArgs, 2148169234, 47109, 17583, 162, 225, 121, 42, 182, 85, 162, 208);
		RT_INTERFACE!{interface IAllJoynCredentialsVerificationRequestedEventArgs(IAllJoynCredentialsVerificationRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsVerificationRequestedEventArgs] {
			fn get_AuthenticationMechanism(&mut self, out: *mut AllJoynAuthenticationMechanism) -> ::w::HRESULT,
			fn get_PeerUniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.security")] fn get_PeerCertificate(&mut self, out: *mut *mut super::super::security::cryptography::certificates::Certificate) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_PeerCertificateErrorSeverity(&mut self, out: *mut super::super::networking::sockets::SocketSslErrorSeverity) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.security")] fn get_PeerCertificateErrors(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy5(&mut self) -> (),
			#[cfg(feature="windows.security")] fn get_PeerIntermediateCertificates(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>) -> ::w::HRESULT,
			fn Accept(&mut self) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut super::super::foundation::Deferral) -> ::w::HRESULT
		}}
		impl IAllJoynCredentialsVerificationRequestedEventArgs {
			#[inline] pub unsafe fn get_authentication_mechanism(&mut self) -> RtResult<AllJoynAuthenticationMechanism> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationMechanism)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_peer_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerUniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_peer_certificate(&mut self) -> RtResult<ComPtr<super::super::security::cryptography::certificates::Certificate>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerCertificate)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_peer_certificate_error_severity(&mut self) -> RtResult<super::super::networking::sockets::SocketSslErrorSeverity> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PeerCertificateErrorSeverity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_peer_certificate_errors(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerCertificateErrors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_peer_intermediate_certificates(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerIntermediateCertificates)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn accept(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Accept)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<super::super::foundation::Deferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAuthenticationCompleteEventArgs, 2545184796, 5596, 19283, 182, 164, 125, 19, 67, 0, 215, 191);
		RT_INTERFACE!{interface IAllJoynAuthenticationCompleteEventArgs(IAllJoynAuthenticationCompleteEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAuthenticationCompleteEventArgs] {
			fn get_AuthenticationMechanism(&mut self, out: *mut AllJoynAuthenticationMechanism) -> ::w::HRESULT,
			fn get_PeerUniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Succeeded(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IAllJoynAuthenticationCompleteEventArgs {
			#[inline] pub unsafe fn get_authentication_mechanism(&mut self) -> RtResult<AllJoynAuthenticationMechanism> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationMechanism)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_peer_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PeerUniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_succeeded(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Succeeded)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynBusAttachmentFactory, 1680798116, 44421, 19935, 144, 174, 96, 68, 82, 178, 34, 136);
		RT_INTERFACE!{static interface IAllJoynBusAttachmentFactory(IAllJoynBusAttachmentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentFactory] {
			fn Create(&mut self, connectionSpecification: ::w::HSTRING, out: *mut *mut AllJoynBusAttachment) -> ::w::HRESULT
		}}
		impl IAllJoynBusAttachmentFactory {
			#[inline] pub unsafe fn create(&mut self, connectionSpecification: &HStringArg) -> RtResult<ComPtr<AllJoynBusAttachment>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, connectionSpecification.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSession, 3906018060, 49364, 16492, 136, 169, 169, 62, 250, 133, 212, 177);
		RT_INTERFACE!{interface IAllJoynSession(IAllJoynSessionVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSession] {
			fn get_Id(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn RemoveMemberAsync(&mut self, uniqueName: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<i32>) -> ::w::HRESULT,
			fn add_MemberAdded(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MemberAdded(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_MemberRemoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MemberRemoved(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Lost(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Lost(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAllJoynSession {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_member_async(&mut self, uniqueName: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<i32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RemoveMemberAsync)(self, uniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_member_added(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MemberAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_member_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MemberAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_member_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MemberRemoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_member_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MemberRemoved)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_lost(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Lost)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_lost(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Lost)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynSession: IAllJoynSession}
		RT_ACTIVATABLE!{IAllJoynSessionStatics [CLSID_AllJoynSession]}
		DEFINE_CLSID!(CLSID_AllJoynSession = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,0]);
		RT_CLASS!{class AllJoynSessionMemberAddedEventArgs: IAllJoynSessionMemberAddedEventArgs [IAllJoynSessionMemberAddedEventArgsFactory] [CLSID_AllJoynSessionMemberAddedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynSessionMemberAddedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,65,100,100,101,100,69,118,101,110,116,65,114,103,115,0]);
		RT_CLASS!{class AllJoynSessionMemberRemovedEventArgs: IAllJoynSessionMemberRemovedEventArgs [IAllJoynSessionMemberRemovedEventArgsFactory] [CLSID_AllJoynSessionMemberRemovedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynSessionMemberRemovedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]);
		RT_CLASS!{class AllJoynSessionLostEventArgs: IAllJoynSessionLostEventArgs [IAllJoynSessionLostEventArgsFactory] [CLSID_AllJoynSessionLostEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynSessionLostEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,76,111,115,116,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynSessionStatics, 2651182596, 41068, 18132, 180, 108, 11, 11, 84, 16, 91, 68);
		RT_INTERFACE!{static interface IAllJoynSessionStatics(IAllJoynSessionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionStatics] {
			fn GetFromServiceInfoAsync(&mut self, serviceInfo: *mut AllJoynServiceInfo, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynSession>) -> ::w::HRESULT,
			fn GetFromServiceInfoAndBusAttachmentAsync(&mut self, serviceInfo: *mut AllJoynServiceInfo, busAttachment: *mut AllJoynBusAttachment, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynSession>) -> ::w::HRESULT
		}}
		impl IAllJoynSessionStatics {
			#[inline] pub unsafe fn get_from_service_info_async(&mut self, serviceInfo: &AllJoynServiceInfo) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFromServiceInfoAsync)(self, serviceInfo as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_from_service_info_and_bus_attachment_async(&mut self, serviceInfo: &AllJoynServiceInfo, busAttachment: &AllJoynBusAttachment) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFromServiceInfoAndBusAttachmentAsync)(self, serviceInfo as *const _ as *mut _, busAttachment as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynProducer, 2634565241, 18075, 18778, 167, 16, 172, 80, 241, 35, 6, 159);
		RT_INTERFACE!{interface IAllJoynProducer(IAllJoynProducerVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducer] {
			fn SetBusObject(&mut self, busObject: *mut AllJoynBusObject) -> ::w::HRESULT
		}}
		impl IAllJoynProducer {
			#[inline] pub unsafe fn set_bus_object(&mut self, busObject: &AllJoynBusObject) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetBusObject)(self, busObject as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynBusObject: IAllJoynBusObject [IAllJoynBusObjectFactory] [CLSID_AllJoynBusObject]}
		DEFINE_CLSID!(CLSID_AllJoynBusObject = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,0]);
		DEFINE_IID!(IID_IAllJoynBusObject, 3908928094, 63290, 18700, 136, 4, 4, 224, 38, 100, 48, 71);
		RT_INTERFACE!{interface IAllJoynBusObject(IAllJoynBusObjectVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObject] {
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT,
			fn AddProducer(&mut self, producer: *mut IAllJoynProducer) -> ::w::HRESULT,
			fn get_BusAttachment(&mut self, out: *mut *mut AllJoynBusAttachment) -> ::w::HRESULT,
			fn get_Session(&mut self, out: *mut *mut AllJoynSession) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut super::super::foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAllJoynBusObject {
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_producer(&mut self, producer: &IAllJoynProducer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddProducer)(self, producer as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bus_attachment(&mut self) -> RtResult<ComPtr<AllJoynBusAttachment>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BusAttachment)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_session(&mut self) -> RtResult<ComPtr<AllJoynSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Session)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &super::super::foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynBusObjectStoppedEventArgs: IAllJoynBusObjectStoppedEventArgs [IAllJoynBusObjectStoppedEventArgsFactory] [CLSID_AllJoynBusObjectStoppedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynBusObjectStoppedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynBusObjectFactory, 741318411, 36354, 20380, 172, 39, 234, 109, 173, 93, 59, 80);
		RT_INTERFACE!{static interface IAllJoynBusObjectFactory(IAllJoynBusObjectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectFactory] {
			fn Create(&mut self, objectPath: ::w::HSTRING, out: *mut *mut AllJoynBusObject) -> ::w::HRESULT,
			fn CreateWithBusAttachment(&mut self, objectPath: ::w::HSTRING, busAttachment: *mut AllJoynBusAttachment, out: *mut *mut AllJoynBusObject) -> ::w::HRESULT
		}}
		impl IAllJoynBusObjectFactory {
			#[inline] pub unsafe fn create(&mut self, objectPath: &HStringArg) -> RtResult<ComPtr<AllJoynBusObject>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, objectPath.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_bus_attachment(&mut self, objectPath: &HStringArg, busAttachment: &AllJoynBusAttachment) -> RtResult<ComPtr<AllJoynBusObject>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithBusAttachment)(self, objectPath.get(), busAttachment as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynServiceInfo, 1287553545, 47422, 16770, 153, 155, 221, 208, 0, 249, 197, 117);
		RT_INTERFACE!{interface IAllJoynServiceInfo(IAllJoynServiceInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfo] {
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ObjectPath(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SessionPort(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IAllJoynServiceInfo {
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_object_path(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ObjectPath)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_session_port(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SessionPort)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynServiceInfoStatics, 1450727178, 24634, 18940, 183, 80, 14, 241, 54, 9, 33, 60);
		RT_INTERFACE!{static interface IAllJoynServiceInfoStatics(IAllJoynServiceInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynServiceInfo>) -> ::w::HRESULT
		}}
		impl IAllJoynServiceInfoStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynServiceInfo>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynServiceInfoFactory, 1971444413, 65027, 20299, 148, 164, 240, 47, 220, 189, 17, 184);
		RT_INTERFACE!{static interface IAllJoynServiceInfoFactory(IAllJoynServiceInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoFactory] {
			fn Create(&mut self, uniqueName: ::w::HSTRING, objectPath: ::w::HSTRING, sessionPort: u16, out: *mut *mut AllJoynServiceInfo) -> ::w::HRESULT
		}}
		impl IAllJoynServiceInfoFactory {
			#[inline] pub unsafe fn create(&mut self, uniqueName: &HStringArg, objectPath: &HStringArg, sessionPort: u16) -> RtResult<ComPtr<AllJoynServiceInfo>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, uniqueName.get(), objectPath.get(), sessionPort, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAboutDataViewStatics, 1475196552, 3166, 16750, 136, 181, 57, 179, 45, 37, 196, 125);
		RT_INTERFACE!{static interface IAllJoynAboutDataViewStatics(IAllJoynAboutDataViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataViewStatics] {
			fn GetDataBySessionPortAsync(&mut self, uniqueName: ::w::HSTRING, busAttachment: *mut AllJoynBusAttachment, sessionPort: u16, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynAboutDataView>) -> ::w::HRESULT,
			#[cfg(feature="windows.globalization")] fn GetDataBySessionPortWithLanguageAsync(&mut self, uniqueName: ::w::HSTRING, busAttachment: *mut AllJoynBusAttachment, sessionPort: u16, language: *mut super::super::globalization::Language, out: *mut *mut super::super::foundation::IAsyncOperation<AllJoynAboutDataView>) -> ::w::HRESULT
		}}
		impl IAllJoynAboutDataViewStatics {
			#[inline] pub unsafe fn get_data_by_session_port_async(&mut self, uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynAboutDataView>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDataBySessionPortAsync)(self, uniqueName.get(), busAttachment as *const _ as *mut _, sessionPort, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.globalization")] #[inline] pub unsafe fn get_data_by_session_port_with_language_async(&mut self, uniqueName: &HStringArg, busAttachment: &AllJoynBusAttachment, sessionPort: u16, language: &super::super::globalization::Language) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<AllJoynAboutDataView>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDataBySessionPortWithLanguageAsync)(self, uniqueName.get(), busAttachment as *const _ as *mut _, sessionPort, language as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAboutDataView, 1747128607, 25106, 18740, 156, 72, 225, 156, 164, 152, 66, 136);
		RT_INTERFACE!{interface IAllJoynAboutDataView(IAllJoynAboutDataViewVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataView] {
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn get_AJSoftwareVersion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AppId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DateOfManufacture(&mut self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.globalization"))] fn __Dummy5(&mut self) -> (),
			#[cfg(feature="windows.globalization")] fn get_DefaultLanguage(&mut self, out: *mut *mut super::super::globalization::Language) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_HardwareVersion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ModelNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SoftwareVersion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.globalization"))] fn __Dummy10(&mut self) -> (),
			#[cfg(feature="windows.globalization")] fn get_SupportedLanguages(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::globalization::Language>) -> ::w::HRESULT,
			fn get_SupportUrl(&mut self, out: *mut *mut super::super::foundation::Uri) -> ::w::HRESULT,
			fn get_AppName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Description(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Manufacturer(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAllJoynAboutDataView {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ajsoftware_version(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AJSoftwareVersion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_app_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AppId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_date_of_manufacture(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DateOfManufacture)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.globalization")] #[inline] pub unsafe fn get_default_language(&mut self) -> RtResult<ComPtr<super::super::globalization::Language>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultLanguage)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hardware_version(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HardwareVersion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_model_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ModelNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_software_version(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SoftwareVersion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.globalization")] #[inline] pub unsafe fn get_supported_languages(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::globalization::Language>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedLanguages)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_support_url(&mut self) -> RtResult<ComPtr<super::super::foundation::Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportUrl)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_app_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AppName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_description(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Description)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturer(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Manufacturer)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAboutData, 3853106944, 8098, 18489, 147, 239, 249, 223, 64, 72, 144, 247);
		RT_INTERFACE!{interface IAllJoynAboutData(IAllJoynAboutDataVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutData] {
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_DefaultAppName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_DefaultAppName(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_AppNames(&mut self, out: *mut *mut super::super::foundation::collections::IMap<HString, HString>) -> ::w::HRESULT,
			fn get_DateOfManufacture(&mut self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> ::w::HRESULT,
			fn put_DateOfManufacture(&mut self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> ::w::HRESULT,
			fn get_DefaultDescription(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_DefaultDescription(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Descriptions(&mut self, out: *mut *mut super::super::foundation::collections::IMap<HString, HString>) -> ::w::HRESULT,
			fn get_DefaultManufacturer(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_DefaultManufacturer(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Manufacturers(&mut self, out: *mut *mut super::super::foundation::collections::IMap<HString, HString>) -> ::w::HRESULT,
			fn get_ModelNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_ModelNumber(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_SoftwareVersion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_SoftwareVersion(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_SupportUrl(&mut self, out: *mut *mut super::super::foundation::Uri) -> ::w::HRESULT,
			fn put_SupportUrl(&mut self, value: *mut super::super::foundation::Uri) -> ::w::HRESULT,
			fn get_AppId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn put_AppId(&mut self, value: ::Guid) -> ::w::HRESULT
		}}
		impl IAllJoynAboutData {
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_app_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultAppName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_default_app_name(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DefaultAppName)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_app_names(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMap<HString, HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AppNames)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_date_of_manufacture(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DateOfManufacture)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_date_of_manufacture(&mut self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DateOfManufacture)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_description(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_default_description(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DefaultDescription)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_descriptions(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMap<HString, HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Descriptions)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_manufacturer(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultManufacturer)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_default_manufacturer(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DefaultManufacturer)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturers(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMap<HString, HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Manufacturers)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_model_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ModelNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_model_number(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ModelNumber)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_software_version(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SoftwareVersion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_software_version(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SoftwareVersion)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_support_url(&mut self) -> RtResult<ComPtr<super::super::foundation::Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportUrl)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_support_url(&mut self, value: &super::super::foundation::Uri) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SupportUrl)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_app_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AppId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_app_id(&mut self, value: ::Guid) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AppId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum AllJoynTrafficType: i32 {
			Unknown (AllJoynTrafficType_Unknown) = 0, Messages (AllJoynTrafficType_Messages) = 1, RawUnreliable (AllJoynTrafficType_RawUnreliable) = 2, RawReliable (AllJoynTrafficType_RawReliable) = 4,
		}}
		DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgs, 1325093733, 16010, 16983, 143, 16, 83, 156, 224, 213, 108, 15);
		RT_INTERFACE!{interface IAllJoynAcceptSessionJoinerEventArgs(IAllJoynAcceptSessionJoinerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgs] {
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SessionPort(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_TrafficType(&mut self, out: *mut AllJoynTrafficType) -> ::w::HRESULT,
			fn get_SamePhysicalNode(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_SameNetwork(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn Accept(&mut self) -> ::w::HRESULT
		}}
		impl IAllJoynAcceptSessionJoinerEventArgs {
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_session_port(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SessionPort)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_traffic_type(&mut self) -> RtResult<AllJoynTrafficType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TrafficType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_same_physical_node(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SamePhysicalNode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_same_network(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SameNetwork)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn accept(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Accept)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAcceptSessionJoiner, 1302861778, 52509, 16419, 167, 196, 22, 222, 248, 156, 40, 223);
		RT_INTERFACE!{interface IAllJoynAcceptSessionJoiner(IAllJoynAcceptSessionJoinerVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoiner] {
			fn Accept(&mut self) -> ::w::HRESULT
		}}
		impl IAllJoynAcceptSessionJoiner {
			#[inline] pub unsafe fn accept(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Accept)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgsFactory, 3024313280, 24901, 17054, 132, 219, 213, 191, 231, 114, 177, 79);
		RT_INTERFACE!{static interface IAllJoynAcceptSessionJoinerEventArgsFactory(IAllJoynAcceptSessionJoinerEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgsFactory] {
			fn Create(&mut self, uniqueName: ::w::HSTRING, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: *mut IAllJoynAcceptSessionJoiner, out: *mut *mut AllJoynAcceptSessionJoinerEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynAcceptSessionJoinerEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, uniqueName: &HStringArg, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: &IAllJoynAcceptSessionJoiner) -> RtResult<ComPtr<AllJoynAcceptSessionJoinerEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, uniqueName.get(), sessionPort, trafficType, proximity, acceptSessionJoiner as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgs, 1235384714, 3537, 18113, 156, 214, 39, 25, 14, 80, 58, 94);
		RT_INTERFACE!{interface IAllJoynSessionMemberAddedEventArgs(IAllJoynSessionMemberAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgs] {
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAllJoynSessionMemberAddedEventArgs {
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgsFactory, 874373970, 7475, 16545, 161, 211, 229, 119, 112, 32, 225, 241);
		RT_INTERFACE!{static interface IAllJoynSessionMemberAddedEventArgsFactory(IAllJoynSessionMemberAddedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgsFactory] {
			fn Create(&mut self, uniqueName: ::w::HSTRING, out: *mut *mut AllJoynSessionMemberAddedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynSessionMemberAddedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, uniqueName: &HStringArg) -> RtResult<ComPtr<AllJoynSessionMemberAddedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, uniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgs, 1083842975, 43594, 18579, 180, 48, 186, 161, 182, 60, 98, 25);
		RT_INTERFACE!{interface IAllJoynSessionMemberRemovedEventArgs(IAllJoynSessionMemberRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgs] {
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAllJoynSessionMemberRemovedEventArgs {
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgsFactory, 3302184424, 17080, 19303, 183, 87, 208, 207, 202, 213, 146, 128);
		RT_INTERFACE!{static interface IAllJoynSessionMemberRemovedEventArgsFactory(IAllJoynSessionMemberRemovedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgsFactory] {
			fn Create(&mut self, uniqueName: ::w::HSTRING, out: *mut *mut AllJoynSessionMemberRemovedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynSessionMemberRemovedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, uniqueName: &HStringArg) -> RtResult<ComPtr<AllJoynSessionMemberRemovedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, uniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum AllJoynSessionLostReason: i32 {
			None (AllJoynSessionLostReason_None) = 0, ProducerLeftSession (AllJoynSessionLostReason_ProducerLeftSession) = 1, ProducerClosedAbruptly (AllJoynSessionLostReason_ProducerClosedAbruptly) = 2, RemovedByProducer (AllJoynSessionLostReason_RemovedByProducer) = 3, LinkTimeout (AllJoynSessionLostReason_LinkTimeout) = 4, Other (AllJoynSessionLostReason_Other) = 5,
		}}
		DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgs, 2661243856, 46551, 18373, 141, 171, 176, 64, 204, 25, 40, 113);
		RT_INTERFACE!{interface IAllJoynSessionJoinedEventArgs(IAllJoynSessionJoinedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgs] {
			fn get_Session(&mut self, out: *mut *mut AllJoynSession) -> ::w::HRESULT
		}}
		impl IAllJoynSessionJoinedEventArgs {
			#[inline] pub unsafe fn get_session(&mut self) -> RtResult<ComPtr<AllJoynSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Session)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgsFactory, 1747244681, 54987, 19870, 160, 158, 53, 128, 104, 112, 177, 127);
		RT_INTERFACE!{static interface IAllJoynSessionJoinedEventArgsFactory(IAllJoynSessionJoinedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgsFactory] {
			fn Create(&mut self, session: *mut AllJoynSession, out: *mut *mut AllJoynSessionJoinedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynSessionJoinedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, session: &AllJoynSession) -> RtResult<ComPtr<AllJoynSessionJoinedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, session as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionLostEventArgs, 3882263690, 35768, 18772, 174, 103, 210, 250, 67, 209, 249, 107);
		RT_INTERFACE!{interface IAllJoynSessionLostEventArgs(IAllJoynSessionLostEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgs] {
			fn get_Reason(&mut self, out: *mut AllJoynSessionLostReason) -> ::w::HRESULT
		}}
		impl IAllJoynSessionLostEventArgs {
			#[inline] pub unsafe fn get_reason(&mut self) -> RtResult<AllJoynSessionLostReason> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Reason)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynSessionLostEventArgsFactory, 331087154, 54004, 18889, 152, 14, 40, 5, 225, 53, 134, 177);
		RT_INTERFACE!{static interface IAllJoynSessionLostEventArgsFactory(IAllJoynSessionLostEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgsFactory] {
			fn Create(&mut self, reason: AllJoynSessionLostReason, out: *mut *mut AllJoynSessionLostEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynSessionLostEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, reason: AllJoynSessionLostReason) -> RtResult<ComPtr<AllJoynSessionLostEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, reason, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgs, 1362138992, 18743, 18733, 128, 128, 35, 100, 57, 152, 124, 235);
		RT_INTERFACE!{interface IAllJoynProducerStoppedEventArgs(IAllJoynProducerStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgs] {
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAllJoynProducerStoppedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgsFactory, 1448253793, 45593, 19822, 159, 120, 250, 63, 153, 250, 143, 229);
		RT_INTERFACE!{static interface IAllJoynProducerStoppedEventArgsFactory(IAllJoynProducerStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgsFactory] {
			fn Create(&mut self, status: i32, out: *mut *mut AllJoynProducerStoppedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynProducerStoppedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, status: i32) -> RtResult<ComPtr<AllJoynProducerStoppedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, status, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynProducerStoppedEventArgs: IAllJoynProducerStoppedEventArgs [IAllJoynProducerStoppedEventArgsFactory] [CLSID_AllJoynProducerStoppedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynProducerStoppedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,80,114,111,100,117,99,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgs, 3725598997, 61326, 19778, 185, 59, 162, 174, 116, 81, 151, 102);
		RT_INTERFACE!{interface IAllJoynBusObjectStoppedEventArgs(IAllJoynBusObjectStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgs] {
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAllJoynBusObjectStoppedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgsFactory, 1797455176, 53411, 16981, 149, 58, 71, 114, 180, 2, 128, 115);
		RT_INTERFACE!{static interface IAllJoynBusObjectStoppedEventArgsFactory(IAllJoynBusObjectStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgsFactory] {
			fn Create(&mut self, status: i32, out: *mut *mut AllJoynBusObjectStoppedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynBusObjectStoppedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, status: i32) -> RtResult<ComPtr<AllJoynBusObjectStoppedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, status, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgs, 3388776507, 28701, 19112, 151, 221, 162, 187, 10, 143, 95, 163);
		RT_INTERFACE!{interface IAllJoynWatcherStoppedEventArgs(IAllJoynWatcherStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgs] {
			fn get_Status(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IAllJoynWatcherStoppedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgsFactory, 2274338216, 11600, 18401, 144, 74, 32, 191, 13, 72, 199, 130);
		RT_INTERFACE!{static interface IAllJoynWatcherStoppedEventArgsFactory(IAllJoynWatcherStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgsFactory] {
			fn Create(&mut self, status: i32, out: *mut *mut AllJoynWatcherStoppedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynWatcherStoppedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, status: i32) -> RtResult<ComPtr<AllJoynWatcherStoppedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, status, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynWatcherStoppedEventArgs: IAllJoynWatcherStoppedEventArgs [IAllJoynWatcherStoppedEventArgsFactory] [CLSID_AllJoynWatcherStoppedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynWatcherStoppedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,87,97,116,99,104,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgs, 811051359, 7487, 16883, 137, 105, 227, 39, 146, 98, 115, 150);
		RT_INTERFACE!{interface IAllJoynServiceInfoRemovedEventArgs(IAllJoynServiceInfoRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgs] {
			fn get_UniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAllJoynServiceInfoRemovedEventArgs {
			#[inline] pub unsafe fn get_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgsFactory, 230655527, 39679, 18773, 146, 39, 105, 83, 186, 244, 21, 105);
		RT_INTERFACE!{static interface IAllJoynServiceInfoRemovedEventArgsFactory(IAllJoynServiceInfoRemovedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgsFactory] {
			fn Create(&mut self, uniqueName: ::w::HSTRING, out: *mut *mut AllJoynServiceInfoRemovedEventArgs) -> ::w::HRESULT
		}}
		impl IAllJoynServiceInfoRemovedEventArgsFactory {
			#[inline] pub unsafe fn create(&mut self, uniqueName: &HStringArg) -> RtResult<ComPtr<AllJoynServiceInfoRemovedEventArgs>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, uniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynServiceInfoRemovedEventArgs: IAllJoynServiceInfoRemovedEventArgs [IAllJoynServiceInfoRemovedEventArgsFactory] [CLSID_AllJoynServiceInfoRemovedEventArgs]}
		DEFINE_CLSID!(CLSID_AllJoynServiceInfoRemovedEventArgs = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]);
		DEFINE_IID!(IID_IAllJoynMessageInfo, 4281008423, 11282, 18521, 170, 58, 199, 68, 97, 238, 129, 76);
		RT_INTERFACE!{interface IAllJoynMessageInfo(IAllJoynMessageInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfo] {
			fn get_SenderUniqueName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAllJoynMessageInfo {
			#[inline] pub unsafe fn get_sender_unique_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SenderUniqueName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAllJoynMessageInfoFactory, 879119402, 33417, 17364, 180, 168, 63, 77, 227, 89, 240, 67);
		RT_INTERFACE!{static interface IAllJoynMessageInfoFactory(IAllJoynMessageInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfoFactory] {
			fn Create(&mut self, senderUniqueName: ::w::HSTRING, out: *mut *mut AllJoynMessageInfo) -> ::w::HRESULT
		}}
		impl IAllJoynMessageInfoFactory {
			#[inline] pub unsafe fn create(&mut self, senderUniqueName: &HStringArg) -> RtResult<ComPtr<AllJoynMessageInfo>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, senderUniqueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AllJoynMessageInfo: IAllJoynMessageInfo [IAllJoynMessageInfoFactory] [CLSID_AllJoynMessageInfo]}
		DEFINE_CLSID!(CLSID_AllJoynMessageInfo = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,77,101,115,115,97,103,101,73,110,102,111,0]);
} // Windows.Devices.AllJoyn
pub mod background { // Windows.Devices.Background
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IDeviceUseDetails, 2102808897, 21886, 16724, 185, 148, 228, 247, 161, 31, 179, 35);
		RT_INTERFACE!{interface IDeviceUseDetails(IDeviceUseDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceUseDetails] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Arguments(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IDeviceUseDetails {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_arguments(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Arguments)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceUseDetails: IDeviceUseDetails}
		DEFINE_IID!(IID_IDeviceServicingDetails, 1252781609, 9028, 19140, 133, 39, 74, 142, 246, 144, 86, 69);
		RT_INTERFACE!{interface IDeviceServicingDetails(IDeviceServicingDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceServicingDetails] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Arguments(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ExpectedDuration(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT
		}}
		impl IDeviceServicingDetails {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_arguments(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Arguments)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_expected_duration(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExpectedDuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceServicingDetails: IDeviceServicingDetails}
} // Windows.Devices.Background
pub mod bluetooth { // Windows.Devices.Bluetooth
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum BluetoothCacheMode: i32 {
			Cached (BluetoothCacheMode_Cached) = 0, Uncached (BluetoothCacheMode_Uncached) = 1,
		}}
		RT_ENUM! { enum BluetoothMajorClass: i32 {
			Miscellaneous (BluetoothMajorClass_Miscellaneous) = 0, Computer (BluetoothMajorClass_Computer) = 1, Phone (BluetoothMajorClass_Phone) = 2, NetworkAccessPoint (BluetoothMajorClass_NetworkAccessPoint) = 3, AudioVideo (BluetoothMajorClass_AudioVideo) = 4, Peripheral (BluetoothMajorClass_Peripheral) = 5, Imaging (BluetoothMajorClass_Imaging) = 6, Wearable (BluetoothMajorClass_Wearable) = 7, Toy (BluetoothMajorClass_Toy) = 8, Health (BluetoothMajorClass_Health) = 9,
		}}
		RT_ENUM! { enum BluetoothMinorClass: i32 {
			Uncategorized (BluetoothMinorClass_Uncategorized) = 0, ComputerDesktop (BluetoothMinorClass_ComputerDesktop) = 1, ComputerServer (BluetoothMinorClass_ComputerServer) = 2, ComputerLaptop (BluetoothMinorClass_ComputerLaptop) = 3, ComputerHandheld (BluetoothMinorClass_ComputerHandheld) = 4, ComputerPalmSize (BluetoothMinorClass_ComputerPalmSize) = 5, ComputerWearable (BluetoothMinorClass_ComputerWearable) = 6, ComputerTablet (BluetoothMinorClass_ComputerTablet) = 7, PhoneCellular (BluetoothMinorClass_PhoneCellular) = 1, PhoneCordless (BluetoothMinorClass_PhoneCordless) = 2, PhoneSmartPhone (BluetoothMinorClass_PhoneSmartPhone) = 3, PhoneWired (BluetoothMinorClass_PhoneWired) = 4, PhoneIsdn (BluetoothMinorClass_PhoneIsdn) = 5, NetworkFullyAvailable (BluetoothMinorClass_NetworkFullyAvailable) = 0, NetworkUsed01To17Percent (BluetoothMinorClass_NetworkUsed01To17Percent) = 8, NetworkUsed17To33Percent (BluetoothMinorClass_NetworkUsed17To33Percent) = 16, NetworkUsed33To50Percent (BluetoothMinorClass_NetworkUsed33To50Percent) = 24, NetworkUsed50To67Percent (BluetoothMinorClass_NetworkUsed50To67Percent) = 32, NetworkUsed67To83Percent (BluetoothMinorClass_NetworkUsed67To83Percent) = 40, NetworkUsed83To99Percent (BluetoothMinorClass_NetworkUsed83To99Percent) = 48, NetworkNoServiceAvailable (BluetoothMinorClass_NetworkNoServiceAvailable) = 56, AudioVideoWearableHeadset (BluetoothMinorClass_AudioVideoWearableHeadset) = 1, AudioVideoHandsFree (BluetoothMinorClass_AudioVideoHandsFree) = 2, AudioVideoMicrophone (BluetoothMinorClass_AudioVideoMicrophone) = 4, AudioVideoLoudspeaker (BluetoothMinorClass_AudioVideoLoudspeaker) = 5, AudioVideoHeadphones (BluetoothMinorClass_AudioVideoHeadphones) = 6, AudioVideoPortableAudio (BluetoothMinorClass_AudioVideoPortableAudio) = 7, AudioVideoCarAudio (BluetoothMinorClass_AudioVideoCarAudio) = 8, AudioVideoSetTopBox (BluetoothMinorClass_AudioVideoSetTopBox) = 9, AudioVideoHifiAudioDevice (BluetoothMinorClass_AudioVideoHifiAudioDevice) = 10, AudioVideoVcr (BluetoothMinorClass_AudioVideoVcr) = 11, AudioVideoVideoCamera (BluetoothMinorClass_AudioVideoVideoCamera) = 12, AudioVideoCamcorder (BluetoothMinorClass_AudioVideoCamcorder) = 13, AudioVideoVideoMonitor (BluetoothMinorClass_AudioVideoVideoMonitor) = 14, AudioVideoVideoDisplayAndLoudspeaker (BluetoothMinorClass_AudioVideoVideoDisplayAndLoudspeaker) = 15, AudioVideoVideoConferencing (BluetoothMinorClass_AudioVideoVideoConferencing) = 16, AudioVideoGamingOrToy (BluetoothMinorClass_AudioVideoGamingOrToy) = 18, PeripheralJoystick (BluetoothMinorClass_PeripheralJoystick) = 1, PeripheralGamepad (BluetoothMinorClass_PeripheralGamepad) = 2, PeripheralRemoteControl (BluetoothMinorClass_PeripheralRemoteControl) = 3, PeripheralSensing (BluetoothMinorClass_PeripheralSensing) = 4, PeripheralDigitizerTablet (BluetoothMinorClass_PeripheralDigitizerTablet) = 5, PeripheralCardReader (BluetoothMinorClass_PeripheralCardReader) = 6, PeripheralDigitalPen (BluetoothMinorClass_PeripheralDigitalPen) = 7, PeripheralHandheldScanner (BluetoothMinorClass_PeripheralHandheldScanner) = 8, PeripheralHandheldGesture (BluetoothMinorClass_PeripheralHandheldGesture) = 9, WearableWristwatch (BluetoothMinorClass_WearableWristwatch) = 1, WearablePager (BluetoothMinorClass_WearablePager) = 2, WearableJacket (BluetoothMinorClass_WearableJacket) = 3, WearableHelmet (BluetoothMinorClass_WearableHelmet) = 4, WearableGlasses (BluetoothMinorClass_WearableGlasses) = 5, ToyRobot (BluetoothMinorClass_ToyRobot) = 1, ToyVehicle (BluetoothMinorClass_ToyVehicle) = 2, ToyDoll (BluetoothMinorClass_ToyDoll) = 3, ToyController (BluetoothMinorClass_ToyController) = 4, ToyGame (BluetoothMinorClass_ToyGame) = 5, HealthBloodPressureMonitor (BluetoothMinorClass_HealthBloodPressureMonitor) = 1, HealthThermometer (BluetoothMinorClass_HealthThermometer) = 2, HealthWeighingScale (BluetoothMinorClass_HealthWeighingScale) = 3, HealthGlucoseMeter (BluetoothMinorClass_HealthGlucoseMeter) = 4, HealthPulseOximeter (BluetoothMinorClass_HealthPulseOximeter) = 5, HealthHeartRateMonitor (BluetoothMinorClass_HealthHeartRateMonitor) = 6, HealthHealthDataDisplay (BluetoothMinorClass_HealthHealthDataDisplay) = 7, HealthStepCounter (BluetoothMinorClass_HealthStepCounter) = 8, HealthBodyCompositionAnalyzer (BluetoothMinorClass_HealthBodyCompositionAnalyzer) = 9, HealthPeakFlowMonitor (BluetoothMinorClass_HealthPeakFlowMonitor) = 10, HealthMedicationMonitor (BluetoothMinorClass_HealthMedicationMonitor) = 11, HealthKneeProsthesis (BluetoothMinorClass_HealthKneeProsthesis) = 12, HealthAnkleProsthesis (BluetoothMinorClass_HealthAnkleProsthesis) = 13, HealthGenericHealthManager (BluetoothMinorClass_HealthGenericHealthManager) = 14, HealthPersonalMobilityDevice (BluetoothMinorClass_HealthPersonalMobilityDevice) = 15,
		}}
		RT_ENUM! { enum BluetoothServiceCapabilities: u32 {
			None (BluetoothServiceCapabilities_None) = 0, LimitedDiscoverableMode (BluetoothServiceCapabilities_LimitedDiscoverableMode) = 1, PositioningService (BluetoothServiceCapabilities_PositioningService) = 8, NetworkingService (BluetoothServiceCapabilities_NetworkingService) = 16, RenderingService (BluetoothServiceCapabilities_RenderingService) = 32, CapturingService (BluetoothServiceCapabilities_CapturingService) = 64, ObjectTransferService (BluetoothServiceCapabilities_ObjectTransferService) = 128, AudioService (BluetoothServiceCapabilities_AudioService) = 256, TelephoneService (BluetoothServiceCapabilities_TelephoneService) = 512, InformationService (BluetoothServiceCapabilities_InformationService) = 1024,
		}}
		RT_ENUM! { enum BluetoothConnectionStatus: i32 {
			Disconnected (BluetoothConnectionStatus_Disconnected) = 0, Connected (BluetoothConnectionStatus_Connected) = 1,
		}}
		RT_ENUM! { enum BluetoothError: i32 {
			Success (BluetoothError_Success) = 0, RadioNotAvailable (BluetoothError_RadioNotAvailable) = 1, ResourceInUse (BluetoothError_ResourceInUse) = 2, DeviceNotConnected (BluetoothError_DeviceNotConnected) = 3, OtherError (BluetoothError_OtherError) = 4, DisabledByPolicy (BluetoothError_DisabledByPolicy) = 5, NotSupported (BluetoothError_NotSupported) = 6, DisabledByUser (BluetoothError_DisabledByUser) = 7, ConsentRequired (BluetoothError_ConsentRequired) = 8,
		}}
		RT_ENUM! { enum BluetoothAddressType: i32 {
			Public (BluetoothAddressType_Public) = 0, Random (BluetoothAddressType_Random) = 1,
		}}
		DEFINE_IID!(IID_IBluetoothDeviceStatics, 160554833, 22491, 18213, 187, 215, 132, 246, 67, 39, 236, 44);
		RT_INTERFACE!{static interface IBluetoothDeviceStatics(IBluetoothDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothDevice>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn FromHostNameAsync(&mut self, hostName: *mut super::super::networking::HostName, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothDevice>) -> ::w::HRESULT,
			fn FromBluetoothAddressAsync(&mut self, address: u64, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothDevice>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBluetoothDeviceStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn from_host_name_async(&mut self, hostName: &super::super::networking::HostName) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromHostNameAsync)(self, hostName as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_bluetooth_address_async(&mut self, address: u64) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromBluetoothAddressAsync)(self, address, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothDevice: IBluetoothDevice}
		RT_ACTIVATABLE!{IBluetoothDeviceStatics [CLSID_BluetoothDevice]}
		RT_ACTIVATABLE!{IBluetoothDeviceStatics2 [CLSID_BluetoothDevice]}
		DEFINE_CLSID!(CLSID_BluetoothDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IBluetoothDeviceStatics2, 3265170991, 19988, 17527, 170, 27, 184, 180, 126, 91, 126, 206);
		RT_INTERFACE!{static interface IBluetoothDeviceStatics2(IBluetoothDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics2] {
			fn GetDeviceSelectorFromPairingState(&mut self, pairingState: bool, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromConnectionStatus(&mut self, connectionStatus: BluetoothConnectionStatus, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromDeviceName(&mut self, deviceName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromBluetoothAddress(&mut self, bluetoothAddress: u64, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromClassOfDevice(&mut self, classOfDevice: *mut BluetoothClassOfDevice, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBluetoothDeviceStatics2 {
			#[inline] pub unsafe fn get_device_selector_from_pairing_state(&mut self, pairingState: bool) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromPairingState)(self, pairingState, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_connection_status(&mut self, connectionStatus: BluetoothConnectionStatus) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromConnectionStatus)(self, connectionStatus, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_device_name(&mut self, deviceName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromDeviceName)(self, deviceName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_bluetooth_address(&mut self, bluetoothAddress: u64) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self, bluetoothAddress, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_class_of_device(&mut self, classOfDevice: &BluetoothClassOfDevice) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromClassOfDevice)(self, classOfDevice as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothClassOfDevice: IBluetoothClassOfDevice}
		RT_ACTIVATABLE!{IBluetoothClassOfDeviceStatics [CLSID_BluetoothClassOfDevice]}
		DEFINE_CLSID!(CLSID_BluetoothClassOfDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,67,108,97,115,115,79,102,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IBluetoothDevice, 590721366, 37074, 18948, 174, 245, 14, 32, 185, 230, 183, 7);
		RT_INTERFACE!{interface IBluetoothDevice(IBluetoothDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_HostName(&mut self, out: *mut *mut super::super::networking::HostName) -> ::w::HRESULT,
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ClassOfDevice(&mut self, out: *mut *mut BluetoothClassOfDevice) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_SdpRecords(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			fn get_RfcommServices(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<rfcomm::RfcommDeviceService>) -> ::w::HRESULT,
			fn get_ConnectionStatus(&mut self, out: *mut BluetoothConnectionStatus) -> ::w::HRESULT,
			fn get_BluetoothAddress(&mut self, out: *mut u64) -> ::w::HRESULT,
			fn add_NameChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_NameChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SdpRecordsChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SdpRecordsChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ConnectionStatusChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ConnectionStatusChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBluetoothDevice {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_host_name(&mut self) -> RtResult<ComPtr<super::super::networking::HostName>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HostName)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_class_of_device(&mut self) -> RtResult<ComPtr<BluetoothClassOfDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ClassOfDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_sdp_records(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SdpRecords)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rfcomm_services(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<rfcomm::RfcommDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RfcommServices)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_status(&mut self) -> RtResult<BluetoothConnectionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConnectionStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bluetooth_address(&mut self) -> RtResult<u64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BluetoothAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_name_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_NameChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_name_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_NameChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_sdp_records_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SdpRecordsChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_sdp_records_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SdpRecordsChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_connection_status_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ConnectionStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_connection_status_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ConnectionStatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothDevice2, 20183380, 45398, 19920, 177, 245, 193, 27, 195, 26, 81, 99);
		RT_INTERFACE!{interface IBluetoothDevice2(IBluetoothDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice2] {
			fn get_DeviceInformation(&mut self, out: *mut *mut super::enumeration::DeviceInformation) -> ::w::HRESULT
		}}
		impl IBluetoothDevice2 {
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<super::enumeration::DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothDevice3, 1476392843, 25882, 17492, 185, 15, 235, 33, 239, 11, 13, 113);
		RT_INTERFACE!{interface IBluetoothDevice3(IBluetoothDevice3Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice3] {
			fn get_DeviceAccessInformation(&mut self, out: *mut *mut super::enumeration::DeviceAccessInformation) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>) -> ::w::HRESULT,
			fn GetRfcommServicesAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> ::w::HRESULT,
			fn GetRfcommServicesWithCacheModeAsync(&mut self, cacheMode: BluetoothCacheMode, out: *mut *mut super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> ::w::HRESULT,
			fn GetRfcommServicesForIdAsync(&mut self, serviceId: *mut rfcomm::RfcommServiceId, out: *mut *mut super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> ::w::HRESULT,
			fn GetRfcommServicesForIdWithCacheModeAsync(&mut self, serviceId: *mut rfcomm::RfcommServiceId, cacheMode: BluetoothCacheMode, out: *mut *mut super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> ::w::HRESULT
		}}
		impl IBluetoothDevice3 {
			#[inline] pub unsafe fn get_device_access_information(&mut self) -> RtResult<ComPtr<super::enumeration::DeviceAccessInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceAccessInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rfcomm_services_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRfcommServicesAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rfcomm_services_with_cache_mode_async(&mut self, cacheMode: BluetoothCacheMode) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRfcommServicesWithCacheModeAsync)(self, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rfcomm_services_for_id_async(&mut self, serviceId: &rfcomm::RfcommServiceId) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRfcommServicesForIdAsync)(self, serviceId as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rfcomm_services_for_id_with_cache_mode_async(&mut self, serviceId: &rfcomm::RfcommServiceId, cacheMode: BluetoothCacheMode) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRfcommServicesForIdWithCacheModeAsync)(self, serviceId as *const _ as *mut _, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAppearanceCategoriesStatics, 1833784574, 1130, 16773, 170, 182, 130, 76, 240, 97, 8, 97);
		RT_INTERFACE!{static interface IBluetoothLEAppearanceCategoriesStatics(IBluetoothLEAppearanceCategoriesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceCategoriesStatics] {
			fn get_Uncategorized(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Phone(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Computer(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Watch(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Clock(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Display(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_RemoteControl(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_EyeGlasses(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Tag(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Keyring(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_MediaPlayer(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_BarcodeScanner(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Thermometer(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_HeartRate(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_BloodPressure(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_HumanInterfaceDevice(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_GlucoseMeter(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_RunningWalking(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Cycling(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_PulseOximeter(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_WeightScale(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_OutdoorSportActivity(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IBluetoothLEAppearanceCategoriesStatics {
			#[inline] pub unsafe fn get_uncategorized(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uncategorized)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_phone(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Phone)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_computer(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Computer)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_watch(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Watch)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_clock(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Clock)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Display)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_remote_control(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RemoteControl)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_eye_glasses(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EyeGlasses)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tag(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Tag)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_keyring(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Keyring)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_media_player(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MediaPlayer)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_barcode_scanner(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BarcodeScanner)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_thermometer(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Thermometer)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heart_rate(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeartRate)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_human_interface_device(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HumanInterfaceDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glucose_meter(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GlucoseMeter)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_running_walking(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RunningWalking)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Cycling)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pulse_oximeter(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PulseOximeter)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_weight_scale(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_WeightScale)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_outdoor_sport_activity(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OutdoorSportActivity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IBluetoothLEAppearanceCategoriesStatics [CLSID_BluetoothLEAppearanceCategories]}
		DEFINE_CLSID!(CLSID_BluetoothLEAppearanceCategories = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,67,97,116,101,103,111,114,105,101,115,0]);
		DEFINE_IID!(IID_IBluetoothLEAppearanceSubcategoriesStatics, 3850085894, 8516, 16730, 131, 18, 113, 204, 242, 145, 248, 209);
		RT_INTERFACE!{static interface IBluetoothLEAppearanceSubcategoriesStatics(IBluetoothLEAppearanceSubcategoriesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceSubcategoriesStatics] {
			fn get_Generic(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_SportsWatch(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ThermometerEar(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_HeartRateBelt(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_BloodPressureArm(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_BloodPressureWrist(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Keyboard(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Mouse(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Joystick(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Gamepad(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_DigitizerTablet(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CardReader(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_DigitalPen(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_BarcodeScanner(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_RunningWalkingInShoe(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_RunningWalkingOnShoe(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_RunningWalkingOnHip(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CyclingComputer(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CyclingSpeedSensor(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CyclingCadenceSensor(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CyclingPowerSensor(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_CyclingSpeedCadenceSensor(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_OximeterFingertip(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_OximeterWristWorn(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_LocationDisplay(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_LocationNavigationDisplay(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_LocationPod(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_LocationNavigationPod(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IBluetoothLEAppearanceSubcategoriesStatics {
			#[inline] pub unsafe fn get_generic(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Generic)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sports_watch(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SportsWatch)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_thermometer_ear(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ThermometerEar)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heart_rate_belt(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeartRateBelt)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure_arm(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressureArm)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure_wrist(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressureWrist)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_keyboard(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Keyboard)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_mouse(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Mouse)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_joystick(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Joystick)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gamepad(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gamepad)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_digitizer_tablet(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DigitizerTablet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_card_reader(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CardReader)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_digital_pen(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DigitalPen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_barcode_scanner(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BarcodeScanner)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_running_walking_in_shoe(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RunningWalkingInShoe)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_running_walking_on_shoe(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RunningWalkingOnShoe)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_running_walking_on_hip(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RunningWalkingOnHip)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_computer(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingComputer)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_speed_sensor(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingSpeedSensor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_cadence_sensor(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingCadenceSensor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power_sensor(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPowerSensor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_speed_cadence_sensor(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingSpeedCadenceSensor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_oximeter_fingertip(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OximeterFingertip)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_oximeter_wrist_worn(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OximeterWristWorn)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_display(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationDisplay)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_navigation_display(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationNavigationDisplay)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_pod(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationPod)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_navigation_pod(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationNavigationPod)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IBluetoothLEAppearanceSubcategoriesStatics [CLSID_BluetoothLEAppearanceSubcategories]}
		DEFINE_CLSID!(CLSID_BluetoothLEAppearanceSubcategories = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,83,117,98,99,97,116,101,103,111,114,105,101,115,0]);
		DEFINE_IID!(IID_IBluetoothLEAppearance, 1562409458, 26280, 16984, 152, 94, 2, 180, 217, 80, 159, 24);
		RT_INTERFACE!{interface IBluetoothLEAppearance(IBluetoothLEAppearanceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearance] {
			fn get_RawValue(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Category(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_SubCategory(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IBluetoothLEAppearance {
			#[inline] pub unsafe fn get_raw_value(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RawValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_category(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Category)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sub_category(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SubCategory)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAppearanceStatics, 2710814919, 17668, 20298, 155, 165, 205, 16, 84, 229, 224, 101);
		RT_INTERFACE!{static interface IBluetoothLEAppearanceStatics(IBluetoothLEAppearanceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceStatics] {
			fn FromRawValue(&mut self, rawValue: u16, out: *mut *mut BluetoothLEAppearance) -> ::w::HRESULT,
			fn FromParts(&mut self, appearanceCategory: u16, appearanceSubCategory: u16, out: *mut *mut BluetoothLEAppearance) -> ::w::HRESULT
		}}
		impl IBluetoothLEAppearanceStatics {
			#[inline] pub unsafe fn from_raw_value(&mut self, rawValue: u16) -> RtResult<ComPtr<BluetoothLEAppearance>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromRawValue)(self, rawValue, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_parts(&mut self, appearanceCategory: u16, appearanceSubCategory: u16) -> RtResult<ComPtr<BluetoothLEAppearance>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromParts)(self, appearanceCategory, appearanceSubCategory, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAppearance: IBluetoothLEAppearance}
		RT_ACTIVATABLE!{IBluetoothLEAppearanceStatics [CLSID_BluetoothLEAppearance]}
		DEFINE_CLSID!(CLSID_BluetoothLEAppearance = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,0]);
		DEFINE_IID!(IID_IBluetoothLEDevice, 3052285819, 19160, 17986, 172, 72, 128, 160, 181, 0, 232, 135);
		RT_INTERFACE!{interface IBluetoothLEDevice(IBluetoothLEDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_GattServices(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<genericattributeprofile::GattDeviceService>) -> ::w::HRESULT,
			fn get_ConnectionStatus(&mut self, out: *mut BluetoothConnectionStatus) -> ::w::HRESULT,
			fn get_BluetoothAddress(&mut self, out: *mut u64) -> ::w::HRESULT,
			fn GetGattService(&mut self, serviceUuid: ::Guid, out: *mut *mut genericattributeprofile::GattDeviceService) -> ::w::HRESULT,
			fn add_NameChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_NameChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_GattServicesChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_GattServicesChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ConnectionStatusChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ConnectionStatusChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBluetoothLEDevice {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gatt_services(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<genericattributeprofile::GattDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_GattServices)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_status(&mut self) -> RtResult<BluetoothConnectionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConnectionStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bluetooth_address(&mut self) -> RtResult<u64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BluetoothAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gatt_service(&mut self, serviceUuid: ::Guid) -> RtResult<ComPtr<genericattributeprofile::GattDeviceService>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGattService)(self, serviceUuid, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_name_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_NameChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_name_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_NameChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_gatt_services_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_GattServicesChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_gatt_services_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_GattServicesChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_connection_status_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ConnectionStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_connection_status_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ConnectionStatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEDevice: IBluetoothLEDevice}
		RT_ACTIVATABLE!{IBluetoothLEDeviceStatics2 [CLSID_BluetoothLEDevice]}
		RT_ACTIVATABLE!{IBluetoothLEDeviceStatics [CLSID_BluetoothLEDevice]}
		DEFINE_CLSID!(CLSID_BluetoothLEDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IBluetoothLEDevice2, 653288115, 31470, 19761, 186, 186, 177, 185, 119, 95, 89, 22);
		RT_INTERFACE!{interface IBluetoothLEDevice2(IBluetoothLEDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice2] {
			fn get_DeviceInformation(&mut self, out: *mut *mut super::enumeration::DeviceInformation) -> ::w::HRESULT,
			fn get_Appearance(&mut self, out: *mut *mut BluetoothLEAppearance) -> ::w::HRESULT,
			fn get_BluetoothAddressType(&mut self, out: *mut BluetoothAddressType) -> ::w::HRESULT
		}}
		impl IBluetoothLEDevice2 {
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<super::enumeration::DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_appearance(&mut self) -> RtResult<ComPtr<BluetoothLEAppearance>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Appearance)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bluetooth_address_type(&mut self) -> RtResult<BluetoothAddressType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BluetoothAddressType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEDeviceStatics, 3369015833, 61622, 19440, 134, 137, 65, 48, 61, 226, 217, 244);
		RT_INTERFACE!{static interface IBluetoothLEDeviceStatics(IBluetoothLEDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothLEDevice>) -> ::w::HRESULT,
			fn FromBluetoothAddressAsync(&mut self, bluetoothAddress: u64, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothLEDevice>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBluetoothLEDeviceStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothLEDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_bluetooth_address_async(&mut self, bluetoothAddress: u64) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothLEDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromBluetoothAddressAsync)(self, bluetoothAddress, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEDeviceStatics2, 1595064427, 15276, 17384, 173, 22, 86, 50, 113, 189, 65, 194);
		RT_INTERFACE!{static interface IBluetoothLEDeviceStatics2(IBluetoothLEDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics2] {
			fn GetDeviceSelectorFromPairingState(&mut self, pairingState: bool, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromConnectionStatus(&mut self, connectionStatus: BluetoothConnectionStatus, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromDeviceName(&mut self, deviceName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromBluetoothAddress(&mut self, bluetoothAddress: u64, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType(&mut self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromAppearance(&mut self, appearance: *mut BluetoothLEAppearance, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromBluetoothAddressWithBluetoothAddressTypeAsync(&mut self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut *mut super::super::foundation::IAsyncOperation<BluetoothLEDevice>) -> ::w::HRESULT
		}}
		impl IBluetoothLEDeviceStatics2 {
			#[inline] pub unsafe fn get_device_selector_from_pairing_state(&mut self, pairingState: bool) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromPairingState)(self, pairingState, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_connection_status(&mut self, connectionStatus: BluetoothConnectionStatus) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromConnectionStatus)(self, connectionStatus, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_device_name(&mut self, deviceName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromDeviceName)(self, deviceName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_bluetooth_address(&mut self, bluetoothAddress: u64) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self, bluetoothAddress, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_bluetooth_address_with_bluetooth_address_type(&mut self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType)(self, bluetoothAddress, bluetoothAddressType, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_appearance(&mut self, appearance: &BluetoothLEAppearance) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromAppearance)(self, appearance as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_bluetooth_address_with_bluetooth_address_type_async(&mut self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BluetoothLEDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromBluetoothAddressWithBluetoothAddressTypeAsync)(self, bluetoothAddress, bluetoothAddressType, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothClassOfDevice, 3594527358, 55255, 18017, 148, 84, 101, 3, 156, 161, 122, 43);
		RT_INTERFACE!{interface IBluetoothClassOfDevice(IBluetoothClassOfDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDevice] {
			fn get_RawValue(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MajorClass(&mut self, out: *mut BluetoothMajorClass) -> ::w::HRESULT,
			fn get_MinorClass(&mut self, out: *mut BluetoothMinorClass) -> ::w::HRESULT,
			fn get_ServiceCapabilities(&mut self, out: *mut BluetoothServiceCapabilities) -> ::w::HRESULT
		}}
		impl IBluetoothClassOfDevice {
			#[inline] pub unsafe fn get_raw_value(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RawValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_major_class(&mut self) -> RtResult<BluetoothMajorClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MajorClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minor_class(&mut self) -> RtResult<BluetoothMinorClass> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinorClass)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_capabilities(&mut self) -> RtResult<BluetoothServiceCapabilities> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceCapabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothClassOfDeviceStatics, 3831575997, 4002, 16748, 145, 180, 193, 228, 140, 160, 97, 193);
		RT_INTERFACE!{static interface IBluetoothClassOfDeviceStatics(IBluetoothClassOfDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDeviceStatics] {
			fn FromRawValue(&mut self, rawValue: u32, out: *mut *mut BluetoothClassOfDevice) -> ::w::HRESULT,
			fn FromParts(&mut self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities, out: *mut *mut BluetoothClassOfDevice) -> ::w::HRESULT
		}}
		impl IBluetoothClassOfDeviceStatics {
			#[inline] pub unsafe fn from_raw_value(&mut self, rawValue: u32) -> RtResult<ComPtr<BluetoothClassOfDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromRawValue)(self, rawValue, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_parts(&mut self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities) -> RtResult<ComPtr<BluetoothClassOfDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromParts)(self, majorClass, minorClass, serviceCapabilities, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothSignalStrengthFilter, 3749409681, 27573, 19710, 144, 177, 93, 115, 36, 237, 207, 127);
		RT_INTERFACE!{interface IBluetoothSignalStrengthFilter(IBluetoothSignalStrengthFilterVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothSignalStrengthFilter] {
			fn get_InRangeThresholdInDBm(&mut self, out: *mut *mut super::super::foundation::IReference<i16>) -> ::w::HRESULT,
			fn put_InRangeThresholdInDBm(&mut self, value: *mut super::super::foundation::IReference<i16>) -> ::w::HRESULT,
			fn get_OutOfRangeThresholdInDBm(&mut self, out: *mut *mut super::super::foundation::IReference<i16>) -> ::w::HRESULT,
			fn put_OutOfRangeThresholdInDBm(&mut self, value: *mut super::super::foundation::IReference<i16>) -> ::w::HRESULT,
			fn get_OutOfRangeTimeout(&mut self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> ::w::HRESULT,
			fn put_OutOfRangeTimeout(&mut self, value: *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> ::w::HRESULT,
			fn get_SamplingInterval(&mut self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> ::w::HRESULT,
			fn put_SamplingInterval(&mut self, value: *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> ::w::HRESULT
		}}
		impl IBluetoothSignalStrengthFilter {
			#[inline] pub unsafe fn get_in_range_threshold_in_dbm(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i16>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InRangeThresholdInDBm)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_in_range_threshold_in_dbm(&mut self, value: &super::super::foundation::IReference<i16>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_InRangeThresholdInDBm)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_out_of_range_threshold_in_dbm(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<i16>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutOfRangeThresholdInDBm)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_out_of_range_threshold_in_dbm(&mut self, value: &super::super::foundation::IReference<i16>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_OutOfRangeThresholdInDBm)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_out_of_range_timeout(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<super::super::foundation::TimeSpan>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutOfRangeTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_out_of_range_timeout(&mut self, value: &super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_OutOfRangeTimeout)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sampling_interval(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<super::super::foundation::TimeSpan>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SamplingInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_sampling_interval(&mut self, value: &super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SamplingInterval)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothSignalStrengthFilter: IBluetoothSignalStrengthFilter}
pub mod rfcomm { // Windows.Devices.Bluetooth.Rfcomm
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_CLASS!{class RfcommDeviceService: IRfcommDeviceService}
		RT_ACTIVATABLE!{IRfcommDeviceServiceStatics [CLSID_RfcommDeviceService]}
		RT_ACTIVATABLE!{IRfcommDeviceServiceStatics2 [CLSID_RfcommDeviceService]}
		DEFINE_CLSID!(CLSID_RfcommDeviceService = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,68,101,118,105,99,101,83,101,114,118,105,99,101,0]);
		RT_CLASS!{class RfcommDeviceServicesResult: IRfcommDeviceServicesResult}
		RT_CLASS!{class RfcommServiceId: IRfcommServiceId}
		RT_ACTIVATABLE!{IRfcommServiceIdStatics [CLSID_RfcommServiceId]}
		DEFINE_CLSID!(CLSID_RfcommServiceId = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,73,100,0]);
		DEFINE_IID!(IID_IRfcommServiceIdStatics, 706191034, 43381, 18147, 181, 107, 8, 255, 215, 131, 165, 254);
		RT_INTERFACE!{static interface IRfcommServiceIdStatics(IRfcommServiceIdStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceIdStatics] {
			fn FromUuid(&mut self, uuid: ::Guid, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn FromShortId(&mut self, shortId: u32, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_SerialPort(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_ObexObjectPush(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_ObexFileTransfer(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_PhoneBookAccessPce(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_PhoneBookAccessPse(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			fn get_GenericFileTransfer(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT
		}}
		impl IRfcommServiceIdStatics {
			#[inline] pub unsafe fn from_uuid(&mut self, uuid: ::Guid) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromUuid)(self, uuid, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_short_id(&mut self, shortId: u32) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromShortId)(self, shortId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_serial_port(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SerialPort)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_obex_object_push(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ObexObjectPush)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_obex_file_transfer(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ObexFileTransfer)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_phone_book_access_pce(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PhoneBookAccessPce)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_phone_book_access_pse(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PhoneBookAccessPse)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_generic_file_transfer(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_GenericFileTransfer)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommServiceId, 576885252, 32258, 16407, 129, 54, 218, 27, 106, 27, 155, 191);
		RT_INTERFACE!{interface IRfcommServiceId(IRfcommServiceIdVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceId] {
			fn get_Uuid(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn AsShortId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn AsString(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IRfcommServiceId {
			#[inline] pub unsafe fn get_uuid(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uuid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn as_short_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).AsShortId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn as_string(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AsString)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceServicesResult, 994588812, 31951, 18574, 150, 37, 210, 89, 165, 115, 45, 85);
		RT_INTERFACE!{interface IRfcommDeviceServicesResult(IRfcommDeviceServicesResultVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServicesResult] {
			fn get_Error(&mut self, out: *mut super::BluetoothError) -> ::w::HRESULT,
			fn get_Services(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<RfcommDeviceService>) -> ::w::HRESULT
		}}
		impl IRfcommDeviceServicesResult {
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<super::BluetoothError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_services(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<RfcommDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Services)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceServiceStatics, 2762033647, 25197, 16812, 178, 83, 135, 172, 92, 39, 226, 138);
		RT_INTERFACE!{static interface IRfcommDeviceServiceStatics(IRfcommDeviceServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<RfcommDeviceService>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, serviceId: *mut RfcommServiceId, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IRfcommDeviceServiceStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<RfcommDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self, serviceId: &RfcommServiceId) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, serviceId as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceServiceStatics2, 2861347273, 59277, 19428, 128, 118, 10, 61, 135, 160, 160, 95);
		RT_INTERFACE!{static interface IRfcommDeviceServiceStatics2(IRfcommDeviceServiceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics2] {
			fn GetDeviceSelectorForBluetoothDevice(&mut self, bluetoothDevice: *mut super::BluetoothDevice, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorForBluetoothDeviceWithCacheMode(&mut self, bluetoothDevice: *mut super::BluetoothDevice, cacheMode: super::BluetoothCacheMode, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorForBluetoothDeviceAndServiceId(&mut self, bluetoothDevice: *mut super::BluetoothDevice, serviceId: *mut RfcommServiceId, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode(&mut self, bluetoothDevice: *mut super::BluetoothDevice, serviceId: *mut RfcommServiceId, cacheMode: super::BluetoothCacheMode, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IRfcommDeviceServiceStatics2 {
			#[inline] pub unsafe fn get_device_selector_for_bluetooth_device(&mut self, bluetoothDevice: &super::BluetoothDevice) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorForBluetoothDevice)(self, bluetoothDevice as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_for_bluetooth_device_with_cache_mode(&mut self, bluetoothDevice: &super::BluetoothDevice, cacheMode: super::BluetoothCacheMode) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorForBluetoothDeviceWithCacheMode)(self, bluetoothDevice as *const _ as *mut _, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_for_bluetooth_device_and_service_id(&mut self, bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceId)(self, bluetoothDevice as *const _ as *mut _, serviceId as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(&mut self, bluetoothDevice: &super::BluetoothDevice, serviceId: &RfcommServiceId, cacheMode: super::BluetoothCacheMode) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode)(self, bluetoothDevice as *const _ as *mut _, serviceId as *const _ as *mut _, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceService, 2927755039, 50593, 19520, 140, 40, 243, 239, 214, 144, 98, 243);
		RT_INTERFACE!{interface IRfcommDeviceService(IRfcommDeviceServiceVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService] {
			#[cfg(not(feature="windows.networking"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_ConnectionHostName(&mut self, out: *mut *mut ::rt::gen::windows::networking::HostName) -> ::w::HRESULT,
			fn get_ConnectionServiceName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ServiceId(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_ProtectionLevel(&mut self, out: *mut ::rt::gen::windows::networking::sockets::SocketProtectionLevel) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_MaxProtectionLevel(&mut self, out: *mut ::rt::gen::windows::networking::sockets::SocketProtectionLevel) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn GetSdpRawAttributesAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IMapView<u32, ::rt::gen::windows::storage::streams::IBuffer>>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn GetSdpRawAttributesWithCacheModeAsync(&mut self, cacheMode: super::BluetoothCacheMode, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IMapView<u32, ::rt::gen::windows::storage::streams::IBuffer>>) -> ::w::HRESULT
		}}
		impl IRfcommDeviceService {
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_connection_host_name(&mut self) -> RtResult<ComPtr<::rt::gen::windows::networking::HostName>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionHostName)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_connection_service_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConnectionServiceName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_id(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_protection_level(&mut self) -> RtResult<::rt::gen::windows::networking::sockets::SocketProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtectionLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_max_protection_level(&mut self) -> RtResult<::rt::gen::windows::networking::sockets::SocketProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxProtectionLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_sdp_raw_attributes_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IMapView<u32, ::rt::gen::windows::storage::streams::IBuffer>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSdpRawAttributesAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_sdp_raw_attributes_with_cache_mode_async(&mut self, cacheMode: super::BluetoothCacheMode) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IMapView<u32, ::rt::gen::windows::storage::streams::IBuffer>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSdpRawAttributesWithCacheModeAsync)(self, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceService2, 1399647508, 60365, 18942, 191, 159, 64, 239, 198, 137, 178, 13);
		RT_INTERFACE!{interface IRfcommDeviceService2(IRfcommDeviceService2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService2] {
			fn get_Device(&mut self, out: *mut *mut super::BluetoothDevice) -> ::w::HRESULT
		}}
		impl IRfcommDeviceService2 {
			#[inline] pub unsafe fn get_device(&mut self) -> RtResult<ComPtr<super::BluetoothDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Device)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommDeviceService3, 472034534, 56644, 19747, 134, 109, 143, 52, 134, 238, 100, 144);
		RT_INTERFACE!{interface IRfcommDeviceService3(IRfcommDeviceService3Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService3] {
			fn get_DeviceAccessInformation(&mut self, out: *mut *mut super::super::enumeration::DeviceAccessInformation) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>) -> ::w::HRESULT
		}}
		impl IRfcommDeviceService3 {
			#[inline] pub unsafe fn get_device_access_information(&mut self) -> RtResult<ComPtr<super::super::enumeration::DeviceAccessInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceAccessInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommServiceProviderStatics, 2559083267, 27082, 16698, 132, 247, 67, 68, 199, 41, 41, 151);
		RT_INTERFACE!{static interface IRfcommServiceProviderStatics(IRfcommServiceProviderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProviderStatics] {
			fn CreateAsync(&mut self, serviceId: *mut RfcommServiceId, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<RfcommServiceProvider>) -> ::w::HRESULT
		}}
		impl IRfcommServiceProviderStatics {
			#[inline] pub unsafe fn create_async(&mut self, serviceId: &RfcommServiceId) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<RfcommServiceProvider>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateAsync)(self, serviceId as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class RfcommServiceProvider: IRfcommServiceProvider}
		RT_ACTIVATABLE!{IRfcommServiceProviderStatics [CLSID_RfcommServiceProvider]}
		DEFINE_CLSID!(CLSID_RfcommServiceProvider = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,0]);
		DEFINE_IID!(IID_IRfcommServiceProvider, 3940285892, 45558, 17663, 159, 124, 231, 168, 42, 184, 104, 33);
		RT_INTERFACE!{interface IRfcommServiceProvider(IRfcommServiceProviderVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider] {
			fn get_ServiceId(&mut self, out: *mut *mut RfcommServiceId) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_SdpRawAttributes(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMap<u32, ::rt::gen::windows::storage::streams::IBuffer>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn StartAdvertising(&mut self, listener: *mut ::rt::gen::windows::networking::sockets::StreamSocketListener) -> ::w::HRESULT,
			fn StopAdvertising(&mut self) -> ::w::HRESULT
		}}
		impl IRfcommServiceProvider {
			#[inline] pub unsafe fn get_service_id(&mut self) -> RtResult<ComPtr<RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_sdp_raw_attributes(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IMap<u32, ::rt::gen::windows::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SdpRawAttributes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn start_advertising(&mut self, listener: &::rt::gen::windows::networking::sockets::StreamSocketListener) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StartAdvertising)(self, listener as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop_advertising(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StopAdvertising)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommServiceProvider2, 1936449478, 15489, 19742, 186, 242, 221, 187, 129, 40, 69, 18);
		RT_INTERFACE!{interface IRfcommServiceProvider2(IRfcommServiceProvider2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider2] {
			#[cfg(feature="windows.networking")] fn StartAdvertisingWithRadioDiscoverability(&mut self, listener: *mut ::rt::gen::windows::networking::sockets::StreamSocketListener, radioDiscoverable: bool) -> ::w::HRESULT
		}}
		impl IRfcommServiceProvider2 {
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn start_advertising_with_radio_discoverability(&mut self, listener: &::rt::gen::windows::networking::sockets::StreamSocketListener, radioDiscoverable: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StartAdvertisingWithRadioDiscoverability)(self, listener as *const _ as *mut _, radioDiscoverable);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Bluetooth.Rfcomm
pub mod genericattributeprofile { // Windows.Devices.Bluetooth.GenericAttributeProfile
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_CLASS!{class GattDeviceService: IGattDeviceService}
		RT_ACTIVATABLE!{IGattDeviceServiceStatics [CLSID_GattDeviceService]}
		DEFINE_CLSID!(CLSID_GattDeviceService = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,118,105,99,101,83,101,114,118,105,99,101,0]);
		RT_ENUM! { enum GattCharacteristicProperties: u32 {
			None (GattCharacteristicProperties_None) = 0, Broadcast (GattCharacteristicProperties_Broadcast) = 1, Read (GattCharacteristicProperties_Read) = 2, WriteWithoutResponse (GattCharacteristicProperties_WriteWithoutResponse) = 4, Write (GattCharacteristicProperties_Write) = 8, Notify (GattCharacteristicProperties_Notify) = 16, Indicate (GattCharacteristicProperties_Indicate) = 32, AuthenticatedSignedWrites (GattCharacteristicProperties_AuthenticatedSignedWrites) = 64, ExtendedProperties (GattCharacteristicProperties_ExtendedProperties) = 128, ReliableWrites (GattCharacteristicProperties_ReliableWrites) = 256, WritableAuxiliaries (GattCharacteristicProperties_WritableAuxiliaries) = 512,
		}}
		RT_ENUM! { enum GattClientCharacteristicConfigurationDescriptorValue: i32 {
			None (GattClientCharacteristicConfigurationDescriptorValue_None) = 0, Notify (GattClientCharacteristicConfigurationDescriptorValue_Notify) = 1, Indicate (GattClientCharacteristicConfigurationDescriptorValue_Indicate) = 2,
		}}
		RT_ENUM! { enum GattProtectionLevel: i32 {
			Plain (GattProtectionLevel_Plain) = 0, AuthenticationRequired (GattProtectionLevel_AuthenticationRequired) = 1, EncryptionRequired (GattProtectionLevel_EncryptionRequired) = 2, EncryptionAndAuthenticationRequired (GattProtectionLevel_EncryptionAndAuthenticationRequired) = 3,
		}}
		RT_ENUM! { enum GattWriteOption: i32 {
			WriteWithResponse (GattWriteOption_WriteWithResponse) = 0, WriteWithoutResponse (GattWriteOption_WriteWithoutResponse) = 1,
		}}
		RT_ENUM! { enum GattCommunicationStatus: i32 {
			Success (GattCommunicationStatus_Success) = 0, Unreachable (GattCommunicationStatus_Unreachable) = 1,
		}}
		DEFINE_IID!(IID_IGattDeviceServiceStatics, 426573858, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
		RT_INTERFACE!{static interface IGattDeviceServiceStatics(IGattDeviceServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceServiceStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattDeviceService>) -> ::w::HRESULT,
			fn GetDeviceSelectorFromUuid(&mut self, serviceUuid: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromShortId(&mut self, serviceShortId: u16, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn ConvertShortIdToUuid(&mut self, shortId: u16, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattDeviceServiceStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_uuid(&mut self, serviceUuid: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromUuid)(self, serviceUuid, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_short_id(&mut self, serviceShortId: u16) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromShortId)(self, serviceShortId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn convert_short_id_to_uuid(&mut self, shortId: u16) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ConvertShortIdToUuid)(self, shortId, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GattCharacteristic: IGattCharacteristic}
		RT_ACTIVATABLE!{IGattCharacteristicStatics [CLSID_GattCharacteristic]}
		DEFINE_CLSID!(CLSID_GattCharacteristic = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,0]);
		DEFINE_IID!(IID_IGattCharacteristicStatics, 1506496707, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
		RT_INTERFACE!{static interface IGattCharacteristicStatics(IGattCharacteristicStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicStatics] {
			fn ConvertShortIdToUuid(&mut self, shortId: u16, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattCharacteristicStatics {
			#[inline] pub unsafe fn convert_short_id_to_uuid(&mut self, shortId: u16) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ConvertShortIdToUuid)(self, shortId, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattCharacteristic, 1506496705, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
		RT_INTERFACE!{interface IGattCharacteristic(IGattCharacteristicVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic] {
			fn GetDescriptors(&mut self, descriptorUuid: ::Guid, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattDescriptor>) -> ::w::HRESULT,
			fn get_CharacteristicProperties(&mut self, out: *mut GattCharacteristicProperties) -> ::w::HRESULT,
			fn get_ProtectionLevel(&mut self, out: *mut GattProtectionLevel) -> ::w::HRESULT,
			fn put_ProtectionLevel(&mut self, value: GattProtectionLevel) -> ::w::HRESULT,
			fn get_UserDescription(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Uuid(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AttributeHandle(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_PresentationFormats(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattPresentationFormat>) -> ::w::HRESULT,
			fn ReadValueAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>) -> ::w::HRESULT,
			fn ReadValueWithCacheModeAsync(&mut self, cacheMode: super::BluetoothCacheMode, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy10(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn WriteValueAsync(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy11(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn WriteValueWithOptionAsync(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer, writeOption: GattWriteOption, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>) -> ::w::HRESULT,
			fn ReadClientCharacteristicConfigurationDescriptorAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult>) -> ::w::HRESULT,
			fn WriteClientCharacteristicConfigurationDescriptorAsync(&mut self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>) -> ::w::HRESULT,
			fn add_ValueChanged(&mut self, valueChangedHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ValueChanged(&mut self, valueChangedEventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IGattCharacteristic {
			#[inline] pub unsafe fn get_descriptors(&mut self, descriptorUuid: ::Guid) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDescriptors)(self, descriptorUuid, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_characteristic_properties(&mut self) -> RtResult<GattCharacteristicProperties> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacteristicProperties)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protection_level(&mut self) -> RtResult<GattProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtectionLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_protection_level(&mut self, value: GattProtectionLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ProtectionLevel)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_user_description(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UserDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uuid(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uuid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_attribute_handle(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AttributeHandle)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_presentation_formats(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattPresentationFormat>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PresentationFormats)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadValueAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value_with_cache_mode_async(&mut self, cacheMode: super::BluetoothCacheMode) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadValueWithCacheModeAsync)(self, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn write_value_async(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).WriteValueAsync)(self, value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn write_value_with_option_async(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer, writeOption: GattWriteOption) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).WriteValueWithOptionAsync)(self, value as *const _ as *mut _, writeOption, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_client_characteristic_configuration_descriptor_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadClientCharacteristicConfigurationDescriptorAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn write_client_characteristic_configuration_descriptor_async(&mut self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).WriteClientCharacteristicConfigurationDescriptorAsync)(self, clientCharacteristicConfigurationDescriptorValue, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_value_changed(&mut self, valueChangedHandler: &::rt::gen::windows::foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ValueChanged)(self, valueChangedHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_value_changed(&mut self, valueChangedEventCookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ValueChanged)(self, valueChangedEventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GattDescriptor: IGattDescriptor}
		RT_ACTIVATABLE!{IGattDescriptorStatics [CLSID_GattDescriptor]}
		DEFINE_CLSID!(CLSID_GattDescriptor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,0]);
		RT_CLASS!{class GattPresentationFormat: IGattPresentationFormat}
		RT_ACTIVATABLE!{IGattPresentationFormatStatics [CLSID_GattPresentationFormat]}
		DEFINE_CLSID!(CLSID_GattPresentationFormat = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,0]);
		RT_CLASS!{class GattReadResult: IGattReadResult}
		RT_CLASS!{class GattReadClientCharacteristicConfigurationDescriptorResult: IGattReadClientCharacteristicConfigurationDescriptorResult}
		RT_CLASS!{class GattValueChangedEventArgs: IGattValueChangedEventArgs}
		DEFINE_IID!(IID_IGattCharacteristic2, 2920985976, 60422, 18276, 183, 128, 152, 53, 161, 211, 93, 110);
		RT_INTERFACE!{interface IGattCharacteristic2(IGattCharacteristic2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic2] {
			fn get_Service(&mut self, out: *mut *mut GattDeviceService) -> ::w::HRESULT,
			fn GetAllDescriptors(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattDescriptor>) -> ::w::HRESULT
		}}
		impl IGattCharacteristic2 {
			#[inline] pub unsafe fn get_service(&mut self) -> RtResult<ComPtr<GattDeviceService>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Service)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_all_descriptors(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAllDescriptors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattDescriptorStatics, 2449825581, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
		RT_INTERFACE!{static interface IGattDescriptorStatics(IGattDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptorStatics] {
			fn ConvertShortIdToUuid(&mut self, shortId: u16, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattDescriptorStatics {
			#[inline] pub unsafe fn convert_short_id_to_uuid(&mut self, shortId: u16) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ConvertShortIdToUuid)(self, shortId, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattDescriptor, 2449825579, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
		RT_INTERFACE!{interface IGattDescriptor(IGattDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptor] {
			fn get_ProtectionLevel(&mut self, out: *mut GattProtectionLevel) -> ::w::HRESULT,
			fn put_ProtectionLevel(&mut self, value: GattProtectionLevel) -> ::w::HRESULT,
			fn get_Uuid(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AttributeHandle(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn ReadValueAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>) -> ::w::HRESULT,
			fn ReadValueWithCacheModeAsync(&mut self, cacheMode: super::BluetoothCacheMode, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn WriteValueAsync(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>) -> ::w::HRESULT
		}}
		impl IGattDescriptor {
			#[inline] pub unsafe fn get_protection_level(&mut self) -> RtResult<GattProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtectionLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_protection_level(&mut self, value: GattProtectionLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ProtectionLevel)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uuid(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uuid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_attribute_handle(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AttributeHandle)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadValueAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_value_with_cache_mode_async(&mut self, cacheMode: super::BluetoothCacheMode) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattReadResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadValueWithCacheModeAsync)(self, cacheMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn write_value_async(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).WriteValueAsync)(self, value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattPresentationFormatStatics, 426573856, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
		RT_INTERFACE!{static interface IGattPresentationFormatStatics(IGattPresentationFormatStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatStatics] {
			fn get_BluetoothSigAssignedNumbers(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IGattPresentationFormatStatics {
			#[inline] pub unsafe fn get_bluetooth_sig_assigned_numbers(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BluetoothSigAssignedNumbers)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattPresentationFormatTypesStatics, 4210145802, 12474, 16540, 190, 247, 207, 251, 109, 3, 184, 251);
		RT_INTERFACE!{static interface IGattPresentationFormatTypesStatics(IGattPresentationFormatTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatTypesStatics] {
			fn get_Boolean(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Bit2(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Nibble(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt8(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt12(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt16(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt24(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt32(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt48(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt64(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_UInt128(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt8(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt12(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt16(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt24(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt32(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt48(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt64(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SInt128(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Float32(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Float64(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SFloat(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Float(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_DUInt16(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Utf8(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Utf16(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Struct(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IGattPresentationFormatTypesStatics {
			#[inline] pub unsafe fn get_boolean(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Boolean)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bit2(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Bit2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_nibble(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Nibble)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint8(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint12(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt12)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint16(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint24(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt24)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint32(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint48(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt48)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint64(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt64)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint128(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UInt128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint8(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint12(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt12)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint16(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint24(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt24)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint32(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint48(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt48)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint64(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt64)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sint128(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SInt128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_float32(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Float32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_float64(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Float64)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sfloat(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SFloat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_float(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Float)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_duint16(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DUInt16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_utf8(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Utf8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_utf16(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Utf16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_struct(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Struct)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattPresentationFormat, 426573857, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
		RT_INTERFACE!{interface IGattPresentationFormat(IGattPresentationFormatVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormat] {
			fn get_FormatType(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Exponent(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Unit(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Namespace(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Description(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IGattPresentationFormat {
			#[inline] pub unsafe fn get_format_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_FormatType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_exponent(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Exponent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_unit(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Unit)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_namespace(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Namespace)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_description(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Description)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattValueChangedEventArgs, 3525040980, 1763, 20184, 162, 99, 172, 250, 200, 186, 115, 19);
		RT_INTERFACE!{interface IGattValueChangedEventArgs(IGattValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattValueChangedEventArgs] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_CharacteristicValue(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_Timestamp(&mut self, out: *mut ::rt::gen::windows::foundation::DateTime) -> ::w::HRESULT
		}}
		impl IGattValueChangedEventArgs {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_characteristic_value(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CharacteristicValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<::rt::gen::windows::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattServiceUuidsStatics, 1841655896, 39610, 17431, 184, 242, 220, 224, 22, 211, 78, 226);
		RT_INTERFACE!{static interface IGattServiceUuidsStatics(IGattServiceUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics] {
			fn get_Battery(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BloodPressure(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingSpeedAndCadence(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GenericAccess(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GenericAttribute(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_Glucose(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HealthThermometer(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HeartRate(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RunningSpeedAndCadence(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattServiceUuidsStatics {
			#[inline] pub unsafe fn get_battery(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Battery)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_speed_and_cadence(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingSpeedAndCadence)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_generic_access(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GenericAccess)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_generic_attribute(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GenericAttribute)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glucose(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Glucose)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_health_thermometer(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HealthThermometer)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heart_rate(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeartRate)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_running_speed_and_cadence(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RunningSpeedAndCadence)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattServiceUuidsStatics2, 3534656757, 15637, 20345, 156, 12, 234, 175, 166, 117, 21, 92);
		RT_INTERFACE!{static interface IGattServiceUuidsStatics2(IGattServiceUuidsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics2] {
			fn get_AlertNotification(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CurrentTime(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingPower(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DeviceInformation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HumanInterfaceDevice(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ImmediateAlert(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LinkLoss(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LocationAndNavigation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_NextDstChange(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_PhoneAlertStatus(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ReferenceTimeUpdate(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ScanParameters(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TxPower(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattServiceUuidsStatics2 {
			#[inline] pub unsafe fn get_alert_notification(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertNotification)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_current_time(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CurrentTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPower)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_human_interface_device(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HumanInterfaceDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_immediate_alert(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ImmediateAlert)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_link_loss(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LinkLoss)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_and_navigation(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationAndNavigation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_next_dst_change(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NextDstChange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_phone_alert_status(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PhoneAlertStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_reference_time_update(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReferenceTimeUpdate)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scan_parameters(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanParameters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tx_power(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TxPower)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattCharacteristicUuidsStatics, 1492796806, 45534, 18188, 183, 222, 13, 17, 255, 68, 244, 183);
		RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics(IGattCharacteristicUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics] {
			fn get_BatteryLevel(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BloodPressureFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BloodPressureMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BodySensorLocation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CscFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CscMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GlucoseFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GlucoseMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GlucoseMeasurementContext(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HeartRateControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HeartRateMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_IntermediateCuffPressure(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_IntermediateTemperature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_MeasurementInterval(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RecordAccessControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RscFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RscMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SCControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SensorLocation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TemperatureMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TemperatureType(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattCharacteristicUuidsStatics {
			#[inline] pub unsafe fn get_battery_level(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BatteryLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressureFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_blood_pressure_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BloodPressureMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_body_sensor_location(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BodySensorLocation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_csc_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CscFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_csc_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CscMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glucose_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GlucoseFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glucose_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GlucoseMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glucose_measurement_context(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GlucoseMeasurementContext)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heart_rate_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeartRateControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heart_rate_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeartRateMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_intermediate_cuff_pressure(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IntermediateCuffPressure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_intermediate_temperature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IntermediateTemperature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_measurement_interval(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MeasurementInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_record_access_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RecordAccessControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rsc_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RscFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rsc_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RscMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sccontrol_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SCControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sensor_location(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SensorLocation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_temperature_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TemperatureMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_temperature_type(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TemperatureType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattCharacteristicUuidsStatics2, 408269861, 54382, 18988, 156, 63, 237, 109, 234, 41, 231, 190);
		RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics2(IGattCharacteristicUuidsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics2] {
			fn get_AlertCategoryId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AlertCategoryIdBitMask(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AlertLevel(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AlertNotificationControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AlertStatus(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GapAppearance(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BootKeyboardInputReport(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BootKeyboardOutputReport(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_BootMouseInputReport(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CurrentTime(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingPowerControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingPowerFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingPowerMeasurement(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CyclingPowerVector(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DateTime(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DayDateTime(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DayOfWeek(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GapDeviceName(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_DstOffset(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ExactTime256(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_FirmwareRevisionString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HardwareRevisionString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HidControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_HidInformation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_Ieee1107320601RegulatoryCertificationDataList(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LnControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LnFeature(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LocalTimeInformation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_LocationAndSpeed(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ManufacturerNameString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ModelNumberString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_Navigation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_NewAlert(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GapPeripheralPreferredConnectionParameters(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GapPeripheralPrivacyFlag(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_PnpId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_PositionQuality(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ProtocolMode(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GapReconnectionAddress(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ReferenceTimeInformation(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_Report(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ReportMap(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RingerControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_RingerSetting(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ScanIntervalWindow(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ScanRefresh(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SerialNumberString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_GattServiceChanged(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SoftwareRevisionString(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SupportedNewAlertCategory(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SupportUnreadAlertCategory(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_SystemId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeAccuracy(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeSource(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeUpdateControlPoint(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeUpdateState(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeWithDst(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TimeZone(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_TxPowerLevel(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_UnreadAlertStatus(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattCharacteristicUuidsStatics2 {
			#[inline] pub unsafe fn get_alert_category_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertCategoryId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alert_category_id_bit_mask(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertCategoryIdBitMask)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alert_level(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alert_notification_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertNotificationControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alert_status(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlertStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gap_appearance(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GapAppearance)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boot_keyboard_input_report(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BootKeyboardInputReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boot_keyboard_output_report(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BootKeyboardOutputReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boot_mouse_input_report(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BootMouseInputReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_current_time(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CurrentTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPowerControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPowerFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power_measurement(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPowerMeasurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cycling_power_vector(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CyclingPowerVector)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_date_time(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DateTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_day_date_time(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DayDateTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_day_of_week(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DayOfWeek)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gap_device_name(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GapDeviceName)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_dst_offset(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DstOffset)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_exact_time256(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExactTime256)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_firmware_revision_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_FirmwareRevisionString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hardware_revision_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HardwareRevisionString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hid_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HidControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hid_information(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HidInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ieee1107320601_regulatory_certification_data_list(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ieee1107320601RegulatoryCertificationDataList)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ln_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LnControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ln_feature(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LnFeature)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_local_time_information(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocalTimeInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_and_speed(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationAndSpeed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturer_name_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ManufacturerNameString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_model_number_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ModelNumberString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_navigation(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Navigation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_new_alert(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NewAlert)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gap_peripheral_preferred_connection_parameters(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GapPeripheralPreferredConnectionParameters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gap_peripheral_privacy_flag(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GapPeripheralPrivacyFlag)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pnp_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PnpId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_position_quality(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PositionQuality)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_mode(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtocolMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gap_reconnection_address(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GapReconnectionAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_reference_time_information(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReferenceTimeInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_map(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportMap)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ringer_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RingerControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ringer_setting(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RingerSetting)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scan_interval_window(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanIntervalWindow)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scan_refresh(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanRefresh)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_serial_number_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SerialNumberString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gatt_service_changed(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GattServiceChanged)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_software_revision_string(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SoftwareRevisionString)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_new_alert_category(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SupportedNewAlertCategory)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_support_unread_alert_category(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SupportUnreadAlertCategory)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_system_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SystemId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_accuracy(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_source(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_update_control_point(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeUpdateControlPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_update_state(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeUpdateState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_with_dst(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeWithDst)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_zone(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TimeZone)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tx_power_level(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TxPowerLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_unread_alert_status(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UnreadAlertStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattDescriptorUuidsStatics, 2801296078, 40188, 17137, 145, 133, 255, 55, 183, 81, 129, 211);
		RT_INTERFACE!{static interface IGattDescriptorUuidsStatics(IGattDescriptorUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptorUuidsStatics] {
			fn get_CharacteristicAggregateFormat(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CharacteristicExtendedProperties(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CharacteristicPresentationFormat(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_CharacteristicUserDescription(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ClientCharacteristicConfiguration(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_ServerCharacteristicConfiguration(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl IGattDescriptorUuidsStatics {
			#[inline] pub unsafe fn get_characteristic_aggregate_format(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacteristicAggregateFormat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_characteristic_extended_properties(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacteristicExtendedProperties)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_characteristic_presentation_format(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacteristicPresentationFormat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_characteristic_user_description(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacteristicUserDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_client_characteristic_configuration(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClientCharacteristicConfiguration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_server_characteristic_configuration(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServerCharacteristicConfiguration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattReliableWriteTransaction, 1671851783, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
		RT_INTERFACE!{interface IGattReliableWriteTransaction(IGattReliableWriteTransactionVtbl): IInspectable(IInspectableVtbl) [IID_IGattReliableWriteTransaction] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn WriteValue(&mut self, characteristic: *mut GattCharacteristic, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn CommitAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>) -> ::w::HRESULT
		}}
		impl IGattReliableWriteTransaction {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn write_value(&mut self, characteristic: &GattCharacteristic, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).WriteValue)(self, characteristic as *const _ as *mut _, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn commit_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GattCommunicationStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CommitAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattReadResult, 1671851784, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
		RT_INTERFACE!{interface IGattReadResult(IGattReadResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadResult] {
			fn get_Status(&mut self, out: *mut GattCommunicationStatus) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Value(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IGattReadResult {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<GattCommunicationStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_value(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattReadClientCharacteristicConfigurationDescriptorResult, 1671851785, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
		RT_INTERFACE!{interface IGattReadClientCharacteristicConfigurationDescriptorResult(IGattReadClientCharacteristicConfigurationDescriptorResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadClientCharacteristicConfigurationDescriptorResult] {
			fn get_Status(&mut self, out: *mut GattCommunicationStatus) -> ::w::HRESULT,
			fn get_ClientCharacteristicConfigurationDescriptor(&mut self, out: *mut GattClientCharacteristicConfigurationDescriptorValue) -> ::w::HRESULT
		}}
		impl IGattReadClientCharacteristicConfigurationDescriptorResult {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<GattCommunicationStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_client_characteristic_configuration_descriptor(&mut self) -> RtResult<GattClientCharacteristicConfigurationDescriptorValue> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClientCharacteristicConfigurationDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IGattServiceUuidsStatics2 [CLSID_GattServiceUuids]}
		RT_ACTIVATABLE!{IGattServiceUuidsStatics [CLSID_GattServiceUuids]}
		DEFINE_CLSID!(CLSID_GattServiceUuids = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,85,117,105,100,115,0]);
		RT_ACTIVATABLE!{IGattCharacteristicUuidsStatics2 [CLSID_GattCharacteristicUuids]}
		RT_ACTIVATABLE!{IGattCharacteristicUuidsStatics [CLSID_GattCharacteristicUuids]}
		DEFINE_CLSID!(CLSID_GattCharacteristicUuids = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,85,117,105,100,115,0]);
		RT_ACTIVATABLE!{IGattDescriptorUuidsStatics [CLSID_GattDescriptorUuids]}
		DEFINE_CLSID!(CLSID_GattDescriptorUuids = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,85,117,105,100,115,0]);
		RT_CLASS!{class GattReliableWriteTransaction: IGattReliableWriteTransaction}
		RT_ACTIVATABLE!{IGattPresentationFormatTypesStatics [CLSID_GattPresentationFormatTypes]}
		DEFINE_CLSID!(CLSID_GattPresentationFormatTypes = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,84,121,112,101,115,0]);
		DEFINE_IID!(IID_IGattDeviceService, 2893773829, 45884, 18383, 153, 15, 107, 143, 85, 119, 223, 113);
		RT_INTERFACE!{interface IGattDeviceService(IGattDeviceServiceVtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceService] {
			fn GetCharacteristics(&mut self, characteristicUuid: ::Guid, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattCharacteristic>) -> ::w::HRESULT,
			fn GetIncludedServices(&mut self, serviceUuid: ::Guid, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Uuid(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn get_AttributeHandle(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IGattDeviceService {
			#[inline] pub unsafe fn get_characteristics(&mut self, characteristicUuid: ::Guid) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattCharacteristic>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCharacteristics)(self, characteristicUuid, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_included_services(&mut self, serviceUuid: ::Guid) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetIncludedServices)(self, serviceUuid, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uuid(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uuid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_attribute_handle(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AttributeHandle)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGattDeviceService2, 4233384459, 2829, 18184, 186, 224, 159, 253, 148, 137, 188, 89);
		RT_INTERFACE!{interface IGattDeviceService2(IGattDeviceService2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceService2] {
			fn get_Device(&mut self, out: *mut *mut super::BluetoothLEDevice) -> ::w::HRESULT,
			fn get_ParentServices(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>) -> ::w::HRESULT,
			fn GetAllCharacteristics(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattCharacteristic>) -> ::w::HRESULT,
			fn GetAllIncludedServices(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>) -> ::w::HRESULT
		}}
		impl IGattDeviceService2 {
			#[inline] pub unsafe fn get_device(&mut self) -> RtResult<ComPtr<super::BluetoothLEDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Device)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_parent_services(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ParentServices)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_all_characteristics(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattCharacteristic>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAllCharacteristics)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_all_included_services(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GattDeviceService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAllIncludedServices)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Bluetooth.GenericAttributeProfile
pub mod advertisement { // Windows.Devices.Bluetooth.Advertisement
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum BluetoothLEScanningMode: i32 {
			Passive (BluetoothLEScanningMode_Passive) = 0, Active (BluetoothLEScanningMode_Active) = 1,
		}}
		RT_ENUM! { enum BluetoothLEAdvertisementFlags: u32 {
			None (BluetoothLEAdvertisementFlags_None) = 0, LimitedDiscoverableMode (BluetoothLEAdvertisementFlags_LimitedDiscoverableMode) = 1, GeneralDiscoverableMode (BluetoothLEAdvertisementFlags_GeneralDiscoverableMode) = 2, ClassicNotSupported (BluetoothLEAdvertisementFlags_ClassicNotSupported) = 4, DualModeControllerCapable (BluetoothLEAdvertisementFlags_DualModeControllerCapable) = 8, DualModeHostCapable (BluetoothLEAdvertisementFlags_DualModeHostCapable) = 16,
		}}
		RT_ENUM! { enum BluetoothLEAdvertisementType: i32 {
			ConnectableUndirected (BluetoothLEAdvertisementType_ConnectableUndirected) = 0, ConnectableDirected (BluetoothLEAdvertisementType_ConnectableDirected) = 1, ScannableUndirected (BluetoothLEAdvertisementType_ScannableUndirected) = 2, NonConnectableUndirected (BluetoothLEAdvertisementType_NonConnectableUndirected) = 3, ScanResponse (BluetoothLEAdvertisementType_ScanResponse) = 4,
		}}
		RT_ENUM! { enum BluetoothLEAdvertisementWatcherStatus: i32 {
			Created (BluetoothLEAdvertisementWatcherStatus_Created) = 0, Started (BluetoothLEAdvertisementWatcherStatus_Started) = 1, Stopping (BluetoothLEAdvertisementWatcherStatus_Stopping) = 2, Stopped (BluetoothLEAdvertisementWatcherStatus_Stopped) = 3, Aborted (BluetoothLEAdvertisementWatcherStatus_Aborted) = 4,
		}}
		DEFINE_IID!(IID_IBluetoothLEAdvertisement, 107983543, 13265, 20093, 131, 103, 207, 129, 208, 247, 150, 83);
		RT_INTERFACE!{interface IBluetoothLEAdvertisement(IBluetoothLEAdvertisementVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisement] {
			fn get_Flags(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IReference<BluetoothLEAdvertisementFlags>) -> ::w::HRESULT,
			fn put_Flags(&mut self, value: *mut ::rt::gen::windows::foundation::IReference<BluetoothLEAdvertisementFlags>) -> ::w::HRESULT,
			fn get_LocalName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_LocalName(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_ServiceUuids(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<::Guid>) -> ::w::HRESULT,
			fn get_ManufacturerData(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<BluetoothLEManufacturerData>) -> ::w::HRESULT,
			fn get_DataSections(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<BluetoothLEAdvertisementDataSection>) -> ::w::HRESULT,
			fn GetManufacturerDataByCompanyId(&mut self, companyId: u16, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<BluetoothLEManufacturerData>) -> ::w::HRESULT,
			fn GetSectionsByType(&mut self, type_: u8, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection>) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisement {
			#[inline] pub unsafe fn get_flags(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IReference<BluetoothLEAdvertisementFlags>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Flags)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_flags(&mut self, value: &::rt::gen::windows::foundation::IReference<BluetoothLEAdvertisementFlags>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Flags)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_local_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LocalName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_local_name(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_LocalName)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_uuids(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<::Guid>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturer_data(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<BluetoothLEManufacturerData>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ManufacturerData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_sections(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<BluetoothLEAdvertisementDataSection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DataSections)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturer_data_by_company_id(&mut self, companyId: u16) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<BluetoothLEManufacturerData>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetManufacturerDataByCompanyId)(self, companyId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sections_by_type(&mut self, type_: u8) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSectionsByType)(self, type_, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEManufacturerData: IBluetoothLEManufacturerData [IBluetoothLEManufacturerDataFactory] [CLSID_BluetoothLEManufacturerData]}
		DEFINE_CLSID!(CLSID_BluetoothLEManufacturerData = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,77,97,110,117,102,97,99,116,117,114,101,114,68,97,116,97,0]);
		RT_CLASS!{class BluetoothLEAdvertisementDataSection: IBluetoothLEAdvertisementDataSection [IBluetoothLEAdvertisementDataSectionFactory] [CLSID_BluetoothLEAdvertisementDataSection]}
		DEFINE_CLSID!(CLSID_BluetoothLEAdvertisementDataSection = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,83,101,99,116,105,111,110,0]);
		RT_CLASS!{class BluetoothLEAdvertisement: IBluetoothLEAdvertisement}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementFilter, 320778451, 53326, 18353, 131, 126, 73, 64, 91, 246, 248, 15);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementFilter(IBluetoothLEAdvertisementFilterVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementFilter] {
			fn get_Advertisement(&mut self, out: *mut *mut BluetoothLEAdvertisement) -> ::w::HRESULT,
			fn put_Advertisement(&mut self, value: *mut BluetoothLEAdvertisement) -> ::w::HRESULT,
			fn get_BytePatterns(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<BluetoothLEAdvertisementBytePattern>) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementFilter {
			#[inline] pub unsafe fn get_advertisement(&mut self) -> RtResult<ComPtr<BluetoothLEAdvertisement>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Advertisement)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_advertisement(&mut self, value: &BluetoothLEAdvertisement) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Advertisement)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_byte_patterns(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<BluetoothLEAdvertisementBytePattern>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BytePatterns)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementBytePattern: IBluetoothLEAdvertisementBytePattern [IBluetoothLEAdvertisementBytePatternFactory] [CLSID_BluetoothLEAdvertisementBytePattern]}
		DEFINE_CLSID!(CLSID_BluetoothLEAdvertisementBytePattern = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,66,121,116,101,80,97,116,116,101,114,110,0]);
		RT_CLASS!{class BluetoothLEAdvertisementFilter: IBluetoothLEAdvertisementFilter}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs, 3712022605, 59321, 17379, 156, 4, 6, 133, 208, 133, 253, 140);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherStoppedEventArgs(IBluetoothLEAdvertisementWatcherStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs] {
			fn get_Error(&mut self, out: *mut super::BluetoothError) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementWatcherStoppedEventArgs {
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<super::BluetoothError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementWatcherStoppedEventArgs: IBluetoothLEAdvertisementWatcherStoppedEventArgs}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherFactory, 2595171670, 14764, 17726, 179, 42, 133, 198, 87, 224, 23, 241);
		RT_INTERFACE!{static interface IBluetoothLEAdvertisementWatcherFactory(IBluetoothLEAdvertisementWatcherFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherFactory] {
			fn Create(&mut self, advertisementFilter: *mut BluetoothLEAdvertisementFilter, out: *mut *mut BluetoothLEAdvertisementWatcher) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementWatcherFactory {
			#[inline] pub unsafe fn create(&mut self, advertisementFilter: &BluetoothLEAdvertisementFilter) -> RtResult<ComPtr<BluetoothLEAdvertisementWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, advertisementFilter as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementWatcher: IBluetoothLEAdvertisementWatcher [IBluetoothLEAdvertisementWatcherFactory] [CLSID_BluetoothLEAdvertisementWatcher]}
		DEFINE_CLSID!(CLSID_BluetoothLEAdvertisementWatcher = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,87,97,116,99,104,101,114,0]);
		DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcher, 2796303215, 62419, 17047, 141, 108, 200, 30, 166, 98, 63, 64);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcher(IBluetoothLEAdvertisementWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcher] {
			fn get_MinSamplingInterval(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_MaxSamplingInterval(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_MinOutOfRangeTimeout(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_MaxOutOfRangeTimeout(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut BluetoothLEAdvertisementWatcherStatus) -> ::w::HRESULT,
			fn get_ScanningMode(&mut self, out: *mut BluetoothLEScanningMode) -> ::w::HRESULT,
			fn put_ScanningMode(&mut self, value: BluetoothLEScanningMode) -> ::w::HRESULT,
			fn get_SignalStrengthFilter(&mut self, out: *mut *mut super::BluetoothSignalStrengthFilter) -> ::w::HRESULT,
			fn put_SignalStrengthFilter(&mut self, value: *mut super::BluetoothSignalStrengthFilter) -> ::w::HRESULT,
			fn get_AdvertisementFilter(&mut self, out: *mut *mut BluetoothLEAdvertisementFilter) -> ::w::HRESULT,
			fn put_AdvertisementFilter(&mut self, value: *mut BluetoothLEAdvertisementFilter) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT,
			fn add_Received(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Received(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementWatcher {
			#[inline] pub unsafe fn get_min_sampling_interval(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinSamplingInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_sampling_interval(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxSamplingInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_out_of_range_timeout(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinOutOfRangeTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_out_of_range_timeout(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxOutOfRangeTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<BluetoothLEAdvertisementWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scanning_mode(&mut self) -> RtResult<BluetoothLEScanningMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanningMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_scanning_mode(&mut self, value: BluetoothLEScanningMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ScanningMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_signal_strength_filter(&mut self) -> RtResult<ComPtr<super::BluetoothSignalStrengthFilter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SignalStrengthFilter)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_signal_strength_filter(&mut self, value: &super::BluetoothSignalStrengthFilter) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SignalStrengthFilter)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement_filter(&mut self) -> RtResult<ComPtr<BluetoothLEAdvertisementFilter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AdvertisementFilter)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_advertisement_filter(&mut self, value: &BluetoothLEAdvertisementFilter) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AdvertisementFilter)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_received(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Received)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_received(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Received)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementReceivedEventArgs: IBluetoothLEAdvertisementReceivedEventArgs}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementReceivedEventArgs, 664305119, 58774, 16830, 141, 67, 158, 103, 49, 212, 169, 19);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementReceivedEventArgs(IBluetoothLEAdvertisementReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementReceivedEventArgs] {
			fn get_RawSignalStrengthInDBm(&mut self, out: *mut i16) -> ::w::HRESULT,
			fn get_BluetoothAddress(&mut self, out: *mut u64) -> ::w::HRESULT,
			fn get_AdvertisementType(&mut self, out: *mut BluetoothLEAdvertisementType) -> ::w::HRESULT,
			fn get_Timestamp(&mut self, out: *mut ::rt::gen::windows::foundation::DateTime) -> ::w::HRESULT,
			fn get_Advertisement(&mut self, out: *mut *mut BluetoothLEAdvertisement) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementReceivedEventArgs {
			#[inline] pub unsafe fn get_raw_signal_strength_in_dbm(&mut self) -> RtResult<i16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RawSignalStrengthInDBm)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bluetooth_address(&mut self) -> RtResult<u64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BluetoothAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement_type(&mut self) -> RtResult<BluetoothLEAdvertisementType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AdvertisementType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<::rt::gen::windows::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement(&mut self) -> RtResult<ComPtr<BluetoothLEAdvertisement>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Advertisement)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSectionFactory, 3886287170, 43077, 16453, 191, 126, 62, 153, 113, 219, 138, 107);
		RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataSectionFactory(IBluetoothLEAdvertisementDataSectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSectionFactory] {
			#[cfg(feature="windows.storage")] fn Create(&mut self, dataType: u8, data: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEAdvertisementDataSection) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementDataSectionFactory {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create(&mut self, dataType: u8, data: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<ComPtr<BluetoothLEAdvertisementDataSection>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, dataType, data as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSection, 3609277204, 14915, 16633, 182, 240, 146, 191, 239, 195, 74, 227);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementDataSection(IBluetoothLEAdvertisementDataSectionVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSection] {
			fn get_DataType(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_DataType(&mut self, value: u8) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_Data(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementDataSection {
			#[inline] pub unsafe fn get_data_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_type(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataType)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_data(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Data)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEManufacturerDataFactory, 3231398392, 12698, 17438, 141, 229, 102, 168, 30, 135, 122, 108);
		RT_INTERFACE!{static interface IBluetoothLEManufacturerDataFactory(IBluetoothLEManufacturerDataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerDataFactory] {
			#[cfg(feature="windows.storage")] fn Create(&mut self, companyId: u16, data: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEManufacturerData) -> ::w::HRESULT
		}}
		impl IBluetoothLEManufacturerDataFactory {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create(&mut self, companyId: u16, data: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<ComPtr<BluetoothLEManufacturerData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, companyId, data as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEManufacturerData, 2435693080, 26979, 17715, 176, 97, 70, 148, 218, 251, 52, 229);
		RT_INTERFACE!{interface IBluetoothLEManufacturerData(IBluetoothLEManufacturerDataVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerData] {
			fn get_CompanyId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn put_CompanyId(&mut self, value: u16) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_Data(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IBluetoothLEManufacturerData {
			#[inline] pub unsafe fn get_company_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CompanyId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_company_id(&mut self, value: u16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CompanyId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_data(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Data)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePatternFactory, 3269610867, 64860, 20163, 190, 42, 156, 166, 250, 17, 183, 189);
		RT_INTERFACE!{static interface IBluetoothLEAdvertisementBytePatternFactory(IBluetoothLEAdvertisementBytePatternFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePatternFactory] {
			#[cfg(feature="windows.storage")] fn Create(&mut self, dataType: u8, offset: i16, data: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEAdvertisementBytePattern) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementBytePatternFactory {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create(&mut self, dataType: u8, offset: i16, data: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<ComPtr<BluetoothLEAdvertisementBytePattern>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, dataType, offset, data as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePattern, 4227520498, 47557, 18952, 188, 81, 80, 47, 142, 246, 138, 121);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementBytePattern(IBluetoothLEAdvertisementBytePatternVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePattern] {
			fn get_DataType(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_DataType(&mut self, value: u8) -> ::w::HRESULT,
			fn get_Offset(&mut self, out: *mut i16) -> ::w::HRESULT,
			fn put_Offset(&mut self, value: i16) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_Data(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementBytePattern {
			#[inline] pub unsafe fn get_data_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_type(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataType)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_offset(&mut self) -> RtResult<i16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Offset)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_offset(&mut self, value: i16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Offset)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_data(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Data)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementDataTypesStatics, 1001801519, 1542, 17227, 167, 110, 116, 21, 159, 6, 132, 211);
		RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataTypesStatics(IBluetoothLEAdvertisementDataTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataTypesStatics] {
			fn get_Flags(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_IncompleteService16BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_CompleteService16BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_IncompleteService32BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_CompleteService32BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_IncompleteService128BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_CompleteService128BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ShortenedLocalName(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_CompleteLocalName(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_TxPowerLevel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SlaveConnectionIntervalRange(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceSolicitation16BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceSolicitation32BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceSolicitation128BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceData16BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceData32BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ServiceData128BitUuids(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_PublicTargetAddress(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_RandomTargetAddress(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Appearance(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_AdvertisingInterval(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ManufacturerSpecificData(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementDataTypesStatics {
			#[inline] pub unsafe fn get_flags(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Flags)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_incomplete_service16_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IncompleteService16BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_complete_service16_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CompleteService16BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_incomplete_service32_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IncompleteService32BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_complete_service32_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CompleteService32BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_incomplete_service128_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IncompleteService128BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_complete_service128_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CompleteService128BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_shortened_local_name(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ShortenedLocalName)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_complete_local_name(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CompleteLocalName)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tx_power_level(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TxPowerLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_slave_connection_interval_range(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SlaveConnectionIntervalRange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_solicitation16_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceSolicitation16BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_solicitation32_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceSolicitation32BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_solicitation128_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceSolicitation128BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_data16_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceData16BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_data32_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceData32BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_data128_bit_uuids(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceData128BitUuids)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_public_target_address(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PublicTargetAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_random_target_address(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RandomTargetAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_appearance(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Appearance)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertising_interval(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AdvertisingInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_manufacturer_specific_data(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ManufacturerSpecificData)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IBluetoothLEAdvertisementDataTypesStatics [CLSID_BluetoothLEAdvertisementDataTypes]}
		DEFINE_CLSID!(CLSID_BluetoothLEAdvertisementDataTypes = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,84,121,112,101,115,0]);
		RT_ENUM! { enum BluetoothLEAdvertisementPublisherStatus: i32 {
			Created (BluetoothLEAdvertisementPublisherStatus_Created) = 0, Waiting (BluetoothLEAdvertisementPublisherStatus_Waiting) = 1, Started (BluetoothLEAdvertisementPublisherStatus_Started) = 2, Stopping (BluetoothLEAdvertisementPublisherStatus_Stopping) = 3, Stopped (BluetoothLEAdvertisementPublisherStatus_Stopped) = 4, Aborted (BluetoothLEAdvertisementPublisherStatus_Aborted) = 5,
		}}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs, 163757471, 11775, 19235, 134, 238, 13, 20, 251, 148, 174, 174);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherStatusChangedEventArgs(IBluetoothLEAdvertisementPublisherStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs] {
			fn get_Status(&mut self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> ::w::HRESULT,
			fn get_Error(&mut self, out: *mut super::BluetoothError) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementPublisherStatusChangedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<BluetoothLEAdvertisementPublisherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<super::BluetoothError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementPublisherStatusChangedEventArgs: IBluetoothLEAdvertisementPublisherStatusChangedEventArgs}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherFactory, 1549731422, 47203, 18817, 161, 175, 28, 84, 77, 139, 12, 13);
		RT_INTERFACE!{static interface IBluetoothLEAdvertisementPublisherFactory(IBluetoothLEAdvertisementPublisherFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherFactory] {
			fn Create(&mut self, advertisement: *mut BluetoothLEAdvertisement, out: *mut *mut BluetoothLEAdvertisementPublisher) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementPublisherFactory {
			#[inline] pub unsafe fn create(&mut self, advertisement: &BluetoothLEAdvertisement) -> RtResult<ComPtr<BluetoothLEAdvertisementPublisher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, advertisement as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementPublisher: IBluetoothLEAdvertisementPublisher [IBluetoothLEAdvertisementPublisherFactory] [CLSID_BluetoothLEAdvertisementPublisher]}
		DEFINE_CLSID!(CLSID_BluetoothLEAdvertisementPublisher = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,0]);
		DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisher, 3454542073, 55802, 17366, 162, 100, 221, 216, 183, 218, 139, 120);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisher(IBluetoothLEAdvertisementPublisherVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisher] {
			fn get_Status(&mut self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> ::w::HRESULT,
			fn get_Advertisement(&mut self, out: *mut *mut BluetoothLEAdvertisement) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT,
			fn add_StatusChanged(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementPublisher {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<BluetoothLEAdvertisementPublisherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement(&mut self) -> RtResult<ComPtr<BluetoothLEAdvertisement>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Advertisement)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_changed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Bluetooth.Advertisement
pub mod background { // Windows.Devices.Bluetooth.Background
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_CLASS!{class RfcommInboundConnectionInformation: IRfcommInboundConnectionInformation}
		RT_CLASS!{class RfcommOutboundConnectionInformation: IRfcommOutboundConnectionInformation}
		DEFINE_IID!(IID_IRfcommInboundConnectionInformation, 1832809896, 21545, 16473, 146, 227, 30, 139, 101, 82, 135, 7);
		RT_INTERFACE!{interface IRfcommInboundConnectionInformation(IRfcommInboundConnectionInformationVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommInboundConnectionInformation] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_SdpRecord(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_SdpRecord(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_LocalServiceId(&mut self, out: *mut *mut super::rfcomm::RfcommServiceId) -> ::w::HRESULT,
			fn put_LocalServiceId(&mut self, value: *mut super::rfcomm::RfcommServiceId) -> ::w::HRESULT,
			fn get_ServiceCapabilities(&mut self, out: *mut super::BluetoothServiceCapabilities) -> ::w::HRESULT,
			fn put_ServiceCapabilities(&mut self, value: super::BluetoothServiceCapabilities) -> ::w::HRESULT
		}}
		impl IRfcommInboundConnectionInformation {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_sdp_record(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SdpRecord)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_sdp_record(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SdpRecord)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_local_service_id(&mut self) -> RtResult<ComPtr<super::rfcomm::RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LocalServiceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_local_service_id(&mut self, value: &super::rfcomm::RfcommServiceId) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_LocalServiceId)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_capabilities(&mut self) -> RtResult<super::BluetoothServiceCapabilities> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceCapabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_service_capabilities(&mut self, value: super::BluetoothServiceCapabilities) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ServiceCapabilities)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommOutboundConnectionInformation, 2962301563, 62516, 19632, 153, 177, 74, 184, 206, 218, 237, 215);
		RT_INTERFACE!{interface IRfcommOutboundConnectionInformation(IRfcommOutboundConnectionInformationVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommOutboundConnectionInformation] {
			fn get_RemoteServiceId(&mut self, out: *mut *mut super::rfcomm::RfcommServiceId) -> ::w::HRESULT,
			fn put_RemoteServiceId(&mut self, value: *mut super::rfcomm::RfcommServiceId) -> ::w::HRESULT
		}}
		impl IRfcommOutboundConnectionInformation {
			#[inline] pub unsafe fn get_remote_service_id(&mut self) -> RtResult<ComPtr<super::rfcomm::RfcommServiceId>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RemoteServiceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_remote_service_id(&mut self, value: &super::rfcomm::RfcommServiceId) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RemoteServiceId)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IRfcommConnectionTriggerDetails, 4179784525, 11836, 20220, 171, 89, 252, 92, 249, 111, 151, 227);
		RT_INTERFACE!{interface IRfcommConnectionTriggerDetails(IRfcommConnectionTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommConnectionTriggerDetails] {
			#[cfg(not(feature="windows.networking"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_Socket(&mut self, out: *mut *mut ::rt::gen::windows::networking::sockets::StreamSocket) -> ::w::HRESULT,
			fn get_Incoming(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_RemoteDevice(&mut self, out: *mut *mut super::BluetoothDevice) -> ::w::HRESULT
		}}
		impl IRfcommConnectionTriggerDetails {
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_socket(&mut self) -> RtResult<ComPtr<::rt::gen::windows::networking::sockets::StreamSocket>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Socket)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_incoming(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Incoming)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_remote_device(&mut self) -> RtResult<ComPtr<super::BluetoothDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RemoteDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class RfcommConnectionTriggerDetails: IRfcommConnectionTriggerDetails}
		DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerDetails, 2610969368, 4076, 17258, 147, 177, 244, 108, 105, 117, 50, 162);
		RT_INTERFACE!{interface IGattCharacteristicNotificationTriggerDetails(IGattCharacteristicNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerDetails] {
			fn get_Characteristic(&mut self, out: *mut *mut super::genericattributeprofile::GattCharacteristic) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Value(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IGattCharacteristicNotificationTriggerDetails {
			#[inline] pub unsafe fn get_characteristic(&mut self) -> RtResult<ComPtr<super::genericattributeprofile::GattCharacteristic>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Characteristic)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_value(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GattCharacteristicNotificationTriggerDetails: IGattCharacteristicNotificationTriggerDetails}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherTriggerDetails, 2816170711, 8791, 20073, 151, 132, 254, 230, 69, 193, 220, 224);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherTriggerDetails(IBluetoothLEAdvertisementWatcherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherTriggerDetails] {
			fn get_Error(&mut self, out: *mut super::BluetoothError) -> ::w::HRESULT,
			fn get_Advertisements(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs>) -> ::w::HRESULT,
			fn get_SignalStrengthFilter(&mut self, out: *mut *mut super::BluetoothSignalStrengthFilter) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementWatcherTriggerDetails {
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<super::BluetoothError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisements(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Advertisements)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_signal_strength_filter(&mut self) -> RtResult<ComPtr<super::BluetoothSignalStrengthFilter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SignalStrengthFilter)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementWatcherTriggerDetails: IBluetoothLEAdvertisementWatcherTriggerDetails}
		DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherTriggerDetails, 1628359302, 13440, 16841, 169, 24, 125, 218, 223, 32, 126, 0);
		RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherTriggerDetails(IBluetoothLEAdvertisementPublisherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherTriggerDetails] {
			fn get_Status(&mut self, out: *mut super::advertisement::BluetoothLEAdvertisementPublisherStatus) -> ::w::HRESULT,
			fn get_Error(&mut self, out: *mut super::BluetoothError) -> ::w::HRESULT
		}}
		impl IBluetoothLEAdvertisementPublisherTriggerDetails {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::advertisement::BluetoothLEAdvertisementPublisherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<super::BluetoothError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BluetoothLEAdvertisementPublisherTriggerDetails: IBluetoothLEAdvertisementPublisherTriggerDetails}
} // Windows.Devices.Bluetooth.Background
} // Windows.Devices.Bluetooth
pub mod enumeration { // Windows.Devices.Enumeration
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IDeviceConnectionChangeTriggerDetails, 3092745228, 48065, 18507, 191, 250, 123, 49, 220, 194, 0, 178);
		RT_INTERFACE!{interface IDeviceConnectionChangeTriggerDetails(IDeviceConnectionChangeTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceConnectionChangeTriggerDetails] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IDeviceConnectionChangeTriggerDetails {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceConnectionChangeTriggerDetails: IDeviceConnectionChangeTriggerDetails}
		RT_ENUM! { enum DevicePickerDisplayStatusOptions: u32 {
			None (DevicePickerDisplayStatusOptions_None) = 0, ShowProgress (DevicePickerDisplayStatusOptions_ShowProgress) = 1, ShowDisconnectButton (DevicePickerDisplayStatusOptions_ShowDisconnectButton) = 2, ShowRetryButton (DevicePickerDisplayStatusOptions_ShowRetryButton) = 4,
		}}
		DEFINE_IID!(IID_IDevicePickerAppearance, 3868857030, 58919, 20184, 155, 108, 70, 10, 244, 69, 229, 109);
		RT_INTERFACE!{interface IDevicePickerAppearance(IDevicePickerAppearanceVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePickerAppearance] {
			fn get_Title(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Title(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_ForegroundColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_ForegroundColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_BackgroundColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_BackgroundColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_AccentColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_AccentColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_SelectedForegroundColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_SelectedForegroundColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_SelectedBackgroundColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_SelectedBackgroundColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn get_SelectedAccentColor(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(feature="windows.ui")] fn put_SelectedAccentColor(&mut self, value: super::super::ui::Color) -> ::w::HRESULT
		}}
		impl IDevicePickerAppearance {
			#[inline] pub unsafe fn get_title(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Title)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_title(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Title)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_foreground_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ForegroundColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_foreground_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ForegroundColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_background_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BackgroundColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_background_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BackgroundColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_accent_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AccentColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_accent_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AccentColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_selected_foreground_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelectedForegroundColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_selected_foreground_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SelectedForegroundColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_selected_background_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelectedBackgroundColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_selected_background_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SelectedBackgroundColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_selected_accent_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelectedAccentColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_selected_accent_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SelectedAccentColor)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DevicePickerAppearance: IDevicePickerAppearance}
		DEFINE_IID!(IID_IDeviceSelectedEventArgs, 647944926, 7471, 18752, 132, 2, 65, 86, 184, 29, 60, 119);
		RT_INTERFACE!{interface IDeviceSelectedEventArgs(IDeviceSelectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceSelectedEventArgs] {
			fn get_SelectedDevice(&mut self, out: *mut *mut DeviceInformation) -> ::w::HRESULT
		}}
		impl IDeviceSelectedEventArgs {
			#[inline] pub unsafe fn get_selected_device(&mut self) -> RtResult<ComPtr<DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SelectedDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceSelectedEventArgs: IDeviceSelectedEventArgs}
		DEFINE_IID!(IID_IDeviceDisconnectButtonClickedEventArgs, 2386867565, 63746, 18944, 181, 54, 243, 121, 146, 230, 162, 167);
		RT_INTERFACE!{interface IDeviceDisconnectButtonClickedEventArgs(IDeviceDisconnectButtonClickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceDisconnectButtonClickedEventArgs] {
			fn get_Device(&mut self, out: *mut *mut DeviceInformation) -> ::w::HRESULT
		}}
		impl IDeviceDisconnectButtonClickedEventArgs {
			#[inline] pub unsafe fn get_device(&mut self) -> RtResult<ComPtr<DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Device)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceDisconnectButtonClickedEventArgs: IDeviceDisconnectButtonClickedEventArgs}
		DEFINE_IID!(IID_IDevicePickerFilter, 2447086242, 22475, 18673, 155, 89, 165, 155, 122, 31, 2, 162);
		RT_INTERFACE!{interface IDevicePickerFilter(IDevicePickerFilterVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePickerFilter] {
			fn get_SupportedDeviceClasses(&mut self, out: *mut *mut super::super::foundation::collections::IVector<DeviceClass>) -> ::w::HRESULT,
			fn get_SupportedDeviceSelectors(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT
		}}
		impl IDevicePickerFilter {
			#[inline] pub unsafe fn get_supported_device_classes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<DeviceClass>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedDeviceClasses)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_device_selectors(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedDeviceSelectors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DevicePickerFilter: IDevicePickerFilter}
		DEFINE_IID!(IID_IDevicePicker, 2224650914, 842, 17472, 136, 19, 125, 11, 212, 121, 191, 90);
		RT_INTERFACE!{interface IDevicePicker(IDevicePickerVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePicker] {
			fn get_Filter(&mut self, out: *mut *mut DevicePickerFilter) -> ::w::HRESULT,
			fn get_Appearance(&mut self, out: *mut *mut DevicePickerAppearance) -> ::w::HRESULT,
			fn get_RequestedProperties(&mut self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			fn add_DeviceSelected(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DeviceSelected(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_DisconnectButtonClicked(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DisconnectButtonClicked(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_DevicePickerDismissed(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DevicePicker, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DevicePickerDismissed(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn Show(&mut self, selection: super::super::foundation::Rect) -> ::w::HRESULT,
			#[cfg(not(feature="windows.ui"))] fn __Dummy10(&mut self) -> (),
			#[cfg(feature="windows.ui")] fn ShowWithPlacement(&mut self, selection: super::super::foundation::Rect, placement: super::super::ui::popups::Placement) -> ::w::HRESULT,
			fn PickSingleDeviceAsync(&mut self, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformation>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.ui"))] fn __Dummy12(&mut self) -> (),
			#[cfg(feature="windows.ui")] fn PickSingleDeviceAsyncWithPlacement(&mut self, selection: super::super::foundation::Rect, placement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformation>) -> ::w::HRESULT,
			fn Hide(&mut self) -> ::w::HRESULT,
			fn SetDisplayStatus(&mut self, device: *mut DeviceInformation, status: ::w::HSTRING, options: DevicePickerDisplayStatusOptions) -> ::w::HRESULT
		}}
		impl IDevicePicker {
			#[inline] pub unsafe fn get_filter(&mut self) -> RtResult<ComPtr<DevicePickerFilter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Filter)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_appearance(&mut self) -> RtResult<ComPtr<DevicePickerAppearance>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Appearance)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_requested_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RequestedProperties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_device_selected(&mut self, handler: &super::super::foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DeviceSelected)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_device_selected(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DeviceSelected)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_disconnect_button_clicked(&mut self, handler: &super::super::foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DisconnectButtonClicked)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_disconnect_button_clicked(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DisconnectButtonClicked)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_device_picker_dismissed(&mut self, handler: &super::super::foundation::TypedEventHandler<DevicePicker, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DevicePickerDismissed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_device_picker_dismissed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DevicePickerDismissed)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn show(&mut self, selection: super::super::foundation::Rect) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Show)(self, selection);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn show_with_placement(&mut self, selection: super::super::foundation::Rect, placement: super::super::ui::popups::Placement) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ShowWithPlacement)(self, selection, placement);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pick_single_device_async(&mut self, selection: super::super::foundation::Rect) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PickSingleDeviceAsync)(self, selection, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn pick_single_device_async_with_placement(&mut self, selection: super::super::foundation::Rect, placement: super::super::ui::popups::Placement) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PickSingleDeviceAsyncWithPlacement)(self, selection, placement, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn hide(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Hide)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_display_status(&mut self, device: &DeviceInformation, status: &HStringArg, options: DevicePickerDisplayStatusOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetDisplayStatus)(self, device as *const _ as *mut _, status.get(), options);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DevicePicker: IDevicePicker}
		RT_ENUM! { enum DeviceClass: i32 {
			All (DeviceClass_All) = 0, AudioCapture (DeviceClass_AudioCapture) = 1, AudioRender (DeviceClass_AudioRender) = 2, PortableStorageDevice (DeviceClass_PortableStorageDevice) = 3, VideoCapture (DeviceClass_VideoCapture) = 4, ImageScanner (DeviceClass_ImageScanner) = 5, Location (DeviceClass_Location) = 6,
		}}
		RT_ENUM! { enum DeviceWatcherStatus: i32 {
			Created (DeviceWatcherStatus_Created) = 0, Started (DeviceWatcherStatus_Started) = 1, EnumerationCompleted (DeviceWatcherStatus_EnumerationCompleted) = 2, Stopping (DeviceWatcherStatus_Stopping) = 3, Stopped (DeviceWatcherStatus_Stopped) = 4, Aborted (DeviceWatcherStatus_Aborted) = 5,
		}}
		#[cfg(feature="windows.storage")] RT_CLASS!{class DeviceThumbnail: super::super::storage::streams::IRandomAccessStreamWithContentType}
		#[cfg(not(feature="windows.storage"))] RT_CLASS!{class DeviceThumbnail: IInspectable}
		RT_ENUM! { enum Panel: i32 {
			Unknown (Panel_Unknown) = 0, Front (Panel_Front) = 1, Back (Panel_Back) = 2, Top (Panel_Top) = 3, Bottom (Panel_Bottom) = 4, Left (Panel_Left) = 5, Right (Panel_Right) = 6,
		}}
		DEFINE_IID!(IID_IEnclosureLocation, 1110706727, 22544, 17820, 170, 187, 198, 94, 31, 129, 62, 207);
		RT_INTERFACE!{interface IEnclosureLocation(IEnclosureLocationVtbl): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation] {
			fn get_InDock(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_InLid(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Panel(&mut self, out: *mut Panel) -> ::w::HRESULT
		}}
		impl IEnclosureLocation {
			#[inline] pub unsafe fn get_in_dock(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InDock)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_in_lid(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InLid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_panel(&mut self) -> RtResult<Panel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Panel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IEnclosureLocation2, 679844187, 57469, 18525, 138, 158, 189, 242, 154, 239, 79, 102);
		RT_INTERFACE!{interface IEnclosureLocation2(IEnclosureLocation2Vtbl): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation2] {
			fn get_RotationAngleInDegreesClockwise(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IEnclosureLocation2 {
			#[inline] pub unsafe fn get_rotation_angle_in_degrees_clockwise(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RotationAngleInDegreesClockwise)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class EnclosureLocation: IEnclosureLocation}
		RT_ENUM! { enum DeviceInformationKind: i32 {
			Unknown (DeviceInformationKind_Unknown) = 0, DeviceInterface (DeviceInformationKind_DeviceInterface) = 1, DeviceContainer (DeviceInformationKind_DeviceContainer) = 2, Device (DeviceInformationKind_Device) = 3, DeviceInterfaceClass (DeviceInformationKind_DeviceInterfaceClass) = 4, AssociationEndpoint (DeviceInformationKind_AssociationEndpoint) = 5, AssociationEndpointContainer (DeviceInformationKind_AssociationEndpointContainer) = 6, AssociationEndpointService (DeviceInformationKind_AssociationEndpointService) = 7,
		}}
		DEFINE_IID!(IID_IDeviceInformationUpdate, 2402374405, 55666, 17591, 163, 126, 158, 130, 44, 120, 33, 59);
		RT_INTERFACE!{interface IDeviceInformationUpdate(IDeviceInformationUpdateVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT
		}}
		impl IDeviceInformationUpdate {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformationUpdate2, 1570575500, 43123, 18526, 186, 166, 170, 98, 7, 136, 227, 204);
		RT_INTERFACE!{interface IDeviceInformationUpdate2(IDeviceInformationUpdate2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate2] {
			fn get_Kind(&mut self, out: *mut DeviceInformationKind) -> ::w::HRESULT
		}}
		impl IDeviceInformationUpdate2 {
			#[inline] pub unsafe fn get_kind(&mut self) -> RtResult<DeviceInformationKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Kind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceInformationUpdate: IDeviceInformationUpdate}
		RT_CLASS!{class DeviceInformationCollection: super::super::foundation::collections::IVectorView<DeviceInformation>}
		DEFINE_IID!(IID_IDeviceWatcher, 3387603325, 36715, 20374, 169, 244, 171, 200, 20, 226, 34, 113);
		RT_INTERFACE!{interface IDeviceWatcher(IDeviceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher] {
			fn add_Added(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformation>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Added(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Updated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Removed(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_EnumerationCompleted(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_EnumerationCompleted(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut DeviceWatcherStatus) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IDeviceWatcher {
			#[inline] pub unsafe fn add_added(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformation>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Added)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Added)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Updated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Updated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Removed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Removed)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_enumeration_completed(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_EnumerationCompleted)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_enumeration_completed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_EnumerationCompleted)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<DeviceWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceWatcher: IDeviceWatcher}
		RT_CLASS!{class DeviceInformation: IDeviceInformation}
		RT_ACTIVATABLE!{IDeviceInformationStatics [CLSID_DeviceInformation]}
		RT_ACTIVATABLE!{IDeviceInformationStatics2 [CLSID_DeviceInformation]}
		DEFINE_CLSID!(CLSID_DeviceInformation = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,0]);
		RT_ENUM! { enum DeviceWatcherEventKind: i32 {
			Add (DeviceWatcherEventKind_Add) = 0, Update (DeviceWatcherEventKind_Update) = 1, Remove (DeviceWatcherEventKind_Remove) = 2,
		}}
		DEFINE_IID!(IID_IDeviceWatcher2, 4278732142, 60692, 18921, 154, 105, 129, 23, 197, 74, 233, 113);
		RT_INTERFACE!{interface IDeviceWatcher2(IDeviceWatcher2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher2] {
			#[cfg(feature="windows.applicationmodel")] fn GetBackgroundTrigger(&mut self, requestedEventKinds: *mut super::super::foundation::collections::IIterable<DeviceWatcherEventKind>, out: *mut *mut super::super::applicationmodel::background::DeviceWatcherTrigger) -> ::w::HRESULT
		}}
		impl IDeviceWatcher2 {
			#[cfg(feature="windows.applicationmodel")] #[inline] pub unsafe fn get_background_trigger(&mut self, requestedEventKinds: &super::super::foundation::collections::IIterable<DeviceWatcherEventKind>) -> RtResult<ComPtr<super::super::applicationmodel::background::DeviceWatcherTrigger>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBackgroundTrigger)(self, requestedEventKinds as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformationStatics, 3246329870, 14918, 19064, 128, 19, 118, 157, 201, 185, 115, 144);
		RT_INTERFACE!{static interface IDeviceInformationStatics(IDeviceInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics] {
			fn CreateFromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformation>) -> ::w::HRESULT,
			fn CreateFromIdAsyncAdditionalProperties(&mut self, deviceId: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformation>) -> ::w::HRESULT,
			fn FindAllAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformationCollection>) -> ::w::HRESULT,
			fn FindAllAsyncDeviceClass(&mut self, deviceClass: DeviceClass, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformationCollection>) -> ::w::HRESULT,
			fn FindAllAsyncAqsFilter(&mut self, aqsFilter: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformationCollection>) -> ::w::HRESULT,
			fn FindAllAsyncAqsFilterAndAdditionalProperties(&mut self, aqsFilter: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformationCollection>) -> ::w::HRESULT,
			fn CreateWatcher(&mut self, out: *mut *mut DeviceWatcher) -> ::w::HRESULT,
			fn CreateWatcherDeviceClass(&mut self, deviceClass: DeviceClass, out: *mut *mut DeviceWatcher) -> ::w::HRESULT,
			fn CreateWatcherAqsFilter(&mut self, aqsFilter: ::w::HSTRING, out: *mut *mut DeviceWatcher) -> ::w::HRESULT,
			fn CreateWatcherAqsFilterAndAdditionalProperties(&mut self, aqsFilter: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut DeviceWatcher) -> ::w::HRESULT
		}}
		impl IDeviceInformationStatics {
			#[inline] pub unsafe fn create_from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_id_async_additional_properties(&mut self, deviceId: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromIdAsyncAdditionalProperties)(self, deviceId.get(), additionalProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformationCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async_device_class(&mut self, deviceClass: DeviceClass) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformationCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsyncDeviceClass)(self, deviceClass, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async_aqs_filter(&mut self, aqsFilter: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformationCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsyncAqsFilter)(self, aqsFilter.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async_aqs_filter_and_additional_properties(&mut self, aqsFilter: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformationCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsyncAqsFilterAndAdditionalProperties)(self, aqsFilter.get(), additionalProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher(&mut self) -> RtResult<ComPtr<DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcher)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher_device_class(&mut self, deviceClass: DeviceClass) -> RtResult<ComPtr<DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcherDeviceClass)(self, deviceClass, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher_aqs_filter(&mut self, aqsFilter: &HStringArg) -> RtResult<ComPtr<DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcherAqsFilter)(self, aqsFilter.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher_aqs_filter_and_additional_properties(&mut self, aqsFilter: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcherAqsFilterAndAdditionalProperties)(self, aqsFilter.get(), additionalProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformationStatics2, 1228623668, 43087, 17917, 145, 103, 21, 209, 203, 27, 209, 249);
		RT_INTERFACE!{static interface IDeviceInformationStatics2(IDeviceInformationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics2] {
			fn GetAqsFilterFromDeviceClass(&mut self, deviceClass: DeviceClass, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn CreateFromIdAsyncWithKindAndAdditionalProperties(&mut self, deviceId: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformation>) -> ::w::HRESULT,
			fn FindAllAsyncWithKindAqsFilterAndAdditionalProperties(&mut self, aqsFilter: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceInformationCollection>) -> ::w::HRESULT,
			fn CreateWatcherWithKindAqsFilterAndAdditionalProperties(&mut self, aqsFilter: ::w::HSTRING, additionalProperties: *mut super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut DeviceWatcher) -> ::w::HRESULT
		}}
		impl IDeviceInformationStatics2 {
			#[inline] pub unsafe fn get_aqs_filter_from_device_class(&mut self, deviceClass: DeviceClass) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAqsFilterFromDeviceClass)(self, deviceClass, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_id_async_with_kind_and_additional_properties(&mut self, deviceId: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromIdAsyncWithKindAndAdditionalProperties)(self, deviceId.get(), additionalProperties as *const _ as *mut _, kind, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async_with_kind_aqs_filter_and_additional_properties(&mut self, aqsFilter: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceInformationCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsyncWithKindAqsFilterAndAdditionalProperties)(self, aqsFilter.get(), additionalProperties as *const _ as *mut _, kind, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher_with_kind_aqs_filter_and_additional_properties(&mut self, aqsFilter: &HStringArg, additionalProperties: &super::super::foundation::collections::IIterable<HString>, kind: DeviceInformationKind) -> RtResult<ComPtr<DeviceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcherWithKindAqsFilterAndAdditionalProperties)(self, aqsFilter.get(), additionalProperties as *const _ as *mut _, kind, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformation, 2879454101, 17304, 18589, 142, 68, 230, 19, 9, 39, 1, 31);
		RT_INTERFACE!{interface IDeviceInformation(IDeviceInformationVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformation] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDefault(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_EnclosureLocation(&mut self, out: *mut *mut EnclosureLocation) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn Update(&mut self, updateInfo: *mut DeviceInformationUpdate) -> ::w::HRESULT,
			fn GetThumbnailAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceThumbnail>) -> ::w::HRESULT,
			fn GetGlyphThumbnailAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceThumbnail>) -> ::w::HRESULT
		}}
		impl IDeviceInformation {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_default(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_enclosure_location(&mut self) -> RtResult<ComPtr<EnclosureLocation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EnclosureLocation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update(&mut self, updateInfo: &DeviceInformationUpdate) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Update)(self, updateInfo as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_thumbnail_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceThumbnail>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetThumbnailAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_glyph_thumbnail_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceThumbnail>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGlyphThumbnailAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum DevicePairingKinds: u32 {
			None (DevicePairingKinds_None) = 0, ConfirmOnly (DevicePairingKinds_ConfirmOnly) = 1, DisplayPin (DevicePairingKinds_DisplayPin) = 2, ProvidePin (DevicePairingKinds_ProvidePin) = 4, ConfirmPinMatch (DevicePairingKinds_ConfirmPinMatch) = 8,
		}}
		RT_ENUM! { enum DevicePairingResultStatus: i32 {
			Paired (DevicePairingResultStatus_Paired) = 0, NotReadyToPair (DevicePairingResultStatus_NotReadyToPair) = 1, NotPaired (DevicePairingResultStatus_NotPaired) = 2, AlreadyPaired (DevicePairingResultStatus_AlreadyPaired) = 3, ConnectionRejected (DevicePairingResultStatus_ConnectionRejected) = 4, TooManyConnections (DevicePairingResultStatus_TooManyConnections) = 5, HardwareFailure (DevicePairingResultStatus_HardwareFailure) = 6, AuthenticationTimeout (DevicePairingResultStatus_AuthenticationTimeout) = 7, AuthenticationNotAllowed (DevicePairingResultStatus_AuthenticationNotAllowed) = 8, AuthenticationFailure (DevicePairingResultStatus_AuthenticationFailure) = 9, NoSupportedProfiles (DevicePairingResultStatus_NoSupportedProfiles) = 10, ProtectionLevelCouldNotBeMet (DevicePairingResultStatus_ProtectionLevelCouldNotBeMet) = 11, AccessDenied (DevicePairingResultStatus_AccessDenied) = 12, InvalidCeremonyData (DevicePairingResultStatus_InvalidCeremonyData) = 13, PairingCanceled (DevicePairingResultStatus_PairingCanceled) = 14, OperationAlreadyInProgress (DevicePairingResultStatus_OperationAlreadyInProgress) = 15, RequiredHandlerNotRegistered (DevicePairingResultStatus_RequiredHandlerNotRegistered) = 16, RejectedByHandler (DevicePairingResultStatus_RejectedByHandler) = 17, RemoteDeviceHasAssociation (DevicePairingResultStatus_RemoteDeviceHasAssociation) = 18, Failed (DevicePairingResultStatus_Failed) = 19,
		}}
		RT_ENUM! { enum DeviceUnpairingResultStatus: i32 {
			Unpaired (DeviceUnpairingResultStatus_Unpaired) = 0, AlreadyUnpaired (DeviceUnpairingResultStatus_AlreadyUnpaired) = 1, OperationAlreadyInProgress (DeviceUnpairingResultStatus_OperationAlreadyInProgress) = 2, AccessDenied (DeviceUnpairingResultStatus_AccessDenied) = 3, Failed (DeviceUnpairingResultStatus_Failed) = 4,
		}}
		RT_ENUM! { enum DevicePairingProtectionLevel: i32 {
			Default (DevicePairingProtectionLevel_Default) = 0, None (DevicePairingProtectionLevel_None) = 1, Encryption (DevicePairingProtectionLevel_Encryption) = 2, EncryptionAndAuthentication (DevicePairingProtectionLevel_EncryptionAndAuthentication) = 3,
		}}
		DEFINE_IID!(IID_IDevicePairingResult, 120259263, 56725, 16421, 155, 55, 222, 81, 173, 186, 55, 183);
		RT_INTERFACE!{interface IDevicePairingResult(IDevicePairingResultVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingResult] {
			fn get_Status(&mut self, out: *mut DevicePairingResultStatus) -> ::w::HRESULT,
			fn get_ProtectionLevelUsed(&mut self, out: *mut DevicePairingProtectionLevel) -> ::w::HRESULT
		}}
		impl IDevicePairingResult {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<DevicePairingResultStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protection_level_used(&mut self) -> RtResult<DevicePairingProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtectionLevelUsed)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DevicePairingResult: IDevicePairingResult}
		DEFINE_IID!(IID_IDeviceUnpairingResult, 1727285971, 31193, 17483, 146, 207, 169, 46, 247, 37, 113, 199);
		RT_INTERFACE!{interface IDeviceUnpairingResult(IDeviceUnpairingResultVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceUnpairingResult] {
			fn get_Status(&mut self, out: *mut DeviceUnpairingResultStatus) -> ::w::HRESULT
		}}
		impl IDeviceUnpairingResult {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<DeviceUnpairingResultStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceUnpairingResult: IDeviceUnpairingResult}
		DEFINE_IID!(IID_IDevicePairingSettings, 1210888828, 33723, 16910, 190, 81, 102, 2, 178, 34, 222, 84);
		RT_INTERFACE!{interface IDevicePairingSettings(IDevicePairingSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingSettings] {
			
		}}
		DEFINE_IID!(IID_IDevicePairingRequestedEventArgs, 4145544278, 56939, 18559, 131, 118, 1, 128, 172, 166, 153, 99);
		RT_INTERFACE!{interface IDevicePairingRequestedEventArgs(IDevicePairingRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingRequestedEventArgs] {
			fn get_DeviceInformation(&mut self, out: *mut *mut DeviceInformation) -> ::w::HRESULT,
			fn get_PairingKind(&mut self, out: *mut DevicePairingKinds) -> ::w::HRESULT,
			fn get_Pin(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn Accept(&mut self) -> ::w::HRESULT,
			fn AcceptWithPin(&mut self, pin: ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut super::super::foundation::Deferral) -> ::w::HRESULT
		}}
		impl IDevicePairingRequestedEventArgs {
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pairing_kind(&mut self) -> RtResult<DevicePairingKinds> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PairingKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pin(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pin)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn accept(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Accept)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn accept_with_pin(&mut self, pin: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AcceptWithPin)(self, pin.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<super::super::foundation::Deferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DevicePairingRequestedEventArgs: IDevicePairingRequestedEventArgs}
		DEFINE_IID!(IID_IDeviceInformationCustomPairing, 2232650754, 20198, 18708, 131, 112, 16, 122, 57, 20, 76, 14);
		RT_INTERFACE!{interface IDeviceInformationCustomPairing(IDeviceInformationCustomPairingVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationCustomPairing] {
			fn PairAsync(&mut self, pairingKindsSupported: DevicePairingKinds, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT,
			fn PairWithProtectionLevelAsync(&mut self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT,
			fn PairWithProtectionLevelAndSettingsAsync(&mut self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: *mut IDevicePairingSettings, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT,
			fn add_PairingRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PairingRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IDeviceInformationCustomPairing {
			#[inline] pub unsafe fn pair_async(&mut self, pairingKindsSupported: DevicePairingKinds) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairAsync)(self, pairingKindsSupported, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pair_with_protection_level_async(&mut self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairWithProtectionLevelAsync)(self, pairingKindsSupported, minProtectionLevel, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pair_with_protection_level_and_settings_async(&mut self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &IDevicePairingSettings) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self, pairingKindsSupported, minProtectionLevel, devicePairingSettings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_pairing_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PairingRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_pairing_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PairingRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceInformationCustomPairing: IDeviceInformationCustomPairing}
		DEFINE_IID!(IID_IDeviceInformationPairing, 742877685, 63108, 16597, 132, 105, 232, 219, 170, 183, 4, 133);
		RT_INTERFACE!{interface IDeviceInformationPairing(IDeviceInformationPairingVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing] {
			fn get_IsPaired(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_CanPair(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn PairAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT,
			fn PairWithProtectionLevelAsync(&mut self, minProtectionLevel: DevicePairingProtectionLevel, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT
		}}
		impl IDeviceInformationPairing {
			#[inline] pub unsafe fn get_is_paired(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaired)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_can_pair(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanPair)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pair_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pair_with_protection_level_async(&mut self, minProtectionLevel: DevicePairingProtectionLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairWithProtectionLevelAsync)(self, minProtectionLevel, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformationPairing2, 4135981821, 2798, 17192, 133, 204, 28, 116, 43, 177, 121, 13);
		RT_INTERFACE!{interface IDeviceInformationPairing2(IDeviceInformationPairing2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing2] {
			fn get_ProtectionLevel(&mut self, out: *mut DevicePairingProtectionLevel) -> ::w::HRESULT,
			fn get_Custom(&mut self, out: *mut *mut DeviceInformationCustomPairing) -> ::w::HRESULT,
			fn PairWithProtectionLevelAndSettingsAsync(&mut self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: *mut IDevicePairingSettings, out: *mut *mut super::super::foundation::IAsyncOperation<DevicePairingResult>) -> ::w::HRESULT,
			fn UnpairAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceUnpairingResult>) -> ::w::HRESULT
		}}
		impl IDeviceInformationPairing2 {
			#[inline] pub unsafe fn get_protection_level(&mut self) -> RtResult<DevicePairingProtectionLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtectionLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_custom(&mut self) -> RtResult<ComPtr<DeviceInformationCustomPairing>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Custom)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn pair_with_protection_level_and_settings_async(&mut self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &IDevicePairingSettings) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DevicePairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self, minProtectionLevel, devicePairingSettings as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unpair_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<DeviceUnpairingResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UnpairAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceInformationPairingStatics, 3910517768, 14036, 18849, 191, 19, 81, 65, 115, 121, 155, 107);
		RT_INTERFACE!{static interface IDeviceInformationPairingStatics(IDeviceInformationPairingStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairingStatics] {
			fn TryRegisterForAllInboundPairingRequests(&mut self, pairingKindsSupported: DevicePairingKinds, out: *mut bool) -> ::w::HRESULT
		}}
		impl IDeviceInformationPairingStatics {
			#[inline] pub unsafe fn try_register_for_all_inbound_pairing_requests(&mut self, pairingKindsSupported: DevicePairingKinds) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryRegisterForAllInboundPairingRequests)(self, pairingKindsSupported, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceInformationPairing: IDeviceInformationPairing}
		RT_ACTIVATABLE!{IDeviceInformationPairingStatics [CLSID_DeviceInformationPairing]}
		DEFINE_CLSID!(CLSID_DeviceInformationPairing = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,80,97,105,114,105,110,103,0]);
		DEFINE_IID!(IID_IDeviceInformation2, 4048987704, 31127, 18649, 161, 12, 38, 157, 70, 83, 63, 72);
		RT_INTERFACE!{interface IDeviceInformation2(IDeviceInformation2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformation2] {
			fn get_Kind(&mut self, out: *mut DeviceInformationKind) -> ::w::HRESULT,
			fn get_Pairing(&mut self, out: *mut *mut DeviceInformationPairing) -> ::w::HRESULT
		}}
		impl IDeviceInformation2 {
			#[inline] pub unsafe fn get_kind(&mut self) -> RtResult<DeviceInformationKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Kind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pairing(&mut self) -> RtResult<ComPtr<DeviceInformationPairing>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pairing)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum DeviceAccessStatus: i32 {
			Unspecified (DeviceAccessStatus_Unspecified) = 0, Allowed (DeviceAccessStatus_Allowed) = 1, DeniedByUser (DeviceAccessStatus_DeniedByUser) = 2, DeniedBySystem (DeviceAccessStatus_DeniedBySystem) = 3,
		}}
		DEFINE_IID!(IID_IDeviceAccessChangedEventArgs, 3738831820, 20381, 20312, 157, 186, 169, 188, 128, 4, 8, 213);
		RT_INTERFACE!{interface IDeviceAccessChangedEventArgs(IDeviceAccessChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs] {
			fn get_Status(&mut self, out: *mut DeviceAccessStatus) -> ::w::HRESULT
		}}
		impl IDeviceAccessChangedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<DeviceAccessStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceAccessChangedEventArgs2, 2186424930, 37707, 19248, 161, 120, 173, 195, 159, 47, 43, 227);
		RT_INTERFACE!{interface IDeviceAccessChangedEventArgs2(IDeviceAccessChangedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs2] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IDeviceAccessChangedEventArgs2 {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceAccessChangedEventArgs: IDeviceAccessChangedEventArgs}
		DEFINE_IID!(IID_IDeviceAccessInformation, 195730035, 28133, 18709, 141, 221, 154, 5, 84, 166, 245, 69);
		RT_INTERFACE!{interface IDeviceAccessInformation(IDeviceAccessInformationVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformation] {
			fn add_AccessChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AccessChanged(&mut self, cookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_CurrentStatus(&mut self, out: *mut DeviceAccessStatus) -> ::w::HRESULT
		}}
		impl IDeviceAccessInformation {
			#[inline] pub unsafe fn add_access_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AccessChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_access_changed(&mut self, cookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AccessChanged)(self, cookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_current_status(&mut self) -> RtResult<DeviceAccessStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CurrentStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceAccessInformation: IDeviceAccessInformation}
		RT_ACTIVATABLE!{IDeviceAccessInformationStatics [CLSID_DeviceAccessInformation]}
		DEFINE_CLSID!(CLSID_DeviceAccessInformation = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,65,99,99,101,115,115,73,110,102,111,114,109,97,116,105,111,110,0]);
		DEFINE_IID!(IID_IDeviceAccessInformationStatics, 1464587219, 24368, 17869, 138, 148, 114, 79, 229, 151, 48, 132);
		RT_INTERFACE!{static interface IDeviceAccessInformationStatics(IDeviceAccessInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformationStatics] {
			fn CreateFromId(&mut self, deviceId: ::w::HSTRING, out: *mut *mut DeviceAccessInformation) -> ::w::HRESULT,
			fn CreateFromDeviceClassId(&mut self, deviceClassId: ::Guid, out: *mut *mut DeviceAccessInformation) -> ::w::HRESULT,
			fn CreateFromDeviceClass(&mut self, deviceClass: DeviceClass, out: *mut *mut DeviceAccessInformation) -> ::w::HRESULT
		}}
		impl IDeviceAccessInformationStatics {
			#[inline] pub unsafe fn create_from_id(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<DeviceAccessInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromId)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_device_class_id(&mut self, deviceClassId: ::Guid) -> RtResult<ComPtr<DeviceAccessInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromDeviceClassId)(self, deviceClassId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_device_class(&mut self, deviceClass: DeviceClass) -> RtResult<ComPtr<DeviceAccessInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromDeviceClass)(self, deviceClass, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeviceWatcherEvent, 1957338123, 7613, 18429, 182, 53, 60, 197, 86, 208, 255, 139);
		RT_INTERFACE!{interface IDeviceWatcherEvent(IDeviceWatcherEventVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherEvent] {
			fn get_Kind(&mut self, out: *mut DeviceWatcherEventKind) -> ::w::HRESULT,
			fn get_DeviceInformation(&mut self, out: *mut *mut DeviceInformation) -> ::w::HRESULT,
			fn get_DeviceInformationUpdate(&mut self, out: *mut *mut DeviceInformationUpdate) -> ::w::HRESULT
		}}
		impl IDeviceWatcherEvent {
			#[inline] pub unsafe fn get_kind(&mut self) -> RtResult<DeviceWatcherEventKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Kind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_information_update(&mut self) -> RtResult<ComPtr<DeviceInformationUpdate>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformationUpdate)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceWatcherEvent: IDeviceWatcherEvent}
		DEFINE_IID!(IID_IDeviceWatcherTriggerDetails, 947945753, 19639, 20055, 165, 109, 119, 109, 7, 203, 254, 249);
		RT_INTERFACE!{interface IDeviceWatcherTriggerDetails(IDeviceWatcherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherTriggerDetails] {
			fn get_DeviceWatcherEvents(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<DeviceWatcherEvent>) -> ::w::HRESULT
		}}
		impl IDeviceWatcherTriggerDetails {
			#[inline] pub unsafe fn get_device_watcher_events(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<DeviceWatcherEvent>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceWatcherEvents)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class DeviceWatcherTriggerDetails: IDeviceWatcherTriggerDetails}
pub mod pnp { // Windows.Devices.Enumeration.Pnp
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum PnpObjectType: i32 {
			Unknown (PnpObjectType_Unknown) = 0, DeviceInterface (PnpObjectType_DeviceInterface) = 1, DeviceContainer (PnpObjectType_DeviceContainer) = 2, Device (PnpObjectType_Device) = 3, DeviceInterfaceClass (PnpObjectType_DeviceInterfaceClass) = 4, AssociationEndpoint (PnpObjectType_AssociationEndpoint) = 5, AssociationEndpointContainer (PnpObjectType_AssociationEndpointContainer) = 6, AssociationEndpointService (PnpObjectType_AssociationEndpointService) = 7,
		}}
		DEFINE_IID!(IID_IPnpObjectUpdate, 1868163090, 30, 18500, 188, 198, 67, 40, 134, 133, 106, 23);
		RT_INTERFACE!{interface IPnpObjectUpdate(IPnpObjectUpdateVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectUpdate] {
			fn get_Type(&mut self, out: *mut PnpObjectType) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT
		}}
		impl IPnpObjectUpdate {
			#[inline] pub unsafe fn get_type(&mut self) -> RtResult<PnpObjectType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Type)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PnpObjectUpdate: IPnpObjectUpdate}
		RT_CLASS!{class PnpObjectCollection: ::rt::gen::windows::foundation::collections::IVectorView<PnpObject>}
		DEFINE_IID!(IID_IPnpObjectWatcher, 2211011752, 18290, 19066, 172, 168, 228, 140, 66, 168, 156, 68);
		RT_INTERFACE!{interface IPnpObjectWatcher(IPnpObjectWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectWatcher] {
			fn add_Added(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObject>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Added(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Updated(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Updated(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Removed(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Removed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_EnumerationCompleted(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_EnumerationCompleted(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut super::DeviceWatcherStatus) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IPnpObjectWatcher {
			#[inline] pub unsafe fn add_added(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObject>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Added)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_added(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Added)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_updated(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Updated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_updated(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Updated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_removed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Removed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_removed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Removed)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_enumeration_completed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_EnumerationCompleted)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_enumeration_completed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_EnumerationCompleted)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::DeviceWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PnpObjectWatcher: IPnpObjectWatcher}
		RT_CLASS!{class PnpObject: IPnpObject}
		RT_ACTIVATABLE!{IPnpObjectStatics [CLSID_PnpObject]}
		DEFINE_CLSID!(CLSID_PnpObject = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,80,110,112,46,80,110,112,79,98,106,101,99,116,0]);
		DEFINE_IID!(IID_IPnpObjectStatics, 3015911997, 53608, 18016, 187, 243, 167, 51, 177, 75, 110, 1);
		RT_INTERFACE!{static interface IPnpObjectStatics(IPnpObjectStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectStatics] {
			fn CreateFromIdAsync(&mut self, type_: PnpObjectType, id: ::w::HSTRING, requestedProperties: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<PnpObject>) -> ::w::HRESULT,
			fn FindAllAsync(&mut self, type_: PnpObjectType, requestedProperties: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<PnpObjectCollection>) -> ::w::HRESULT,
			fn FindAllAsyncAqsFilter(&mut self, type_: PnpObjectType, requestedProperties: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, aqsFilter: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<PnpObjectCollection>) -> ::w::HRESULT,
			fn CreateWatcher(&mut self, type_: PnpObjectType, requestedProperties: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut PnpObjectWatcher) -> ::w::HRESULT,
			fn CreateWatcherAqsFilter(&mut self, type_: PnpObjectType, requestedProperties: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, aqsFilter: ::w::HSTRING, out: *mut *mut PnpObjectWatcher) -> ::w::HRESULT
		}}
		impl IPnpObjectStatics {
			#[inline] pub unsafe fn create_from_id_async(&mut self, type_: PnpObjectType, id: &HStringArg, requestedProperties: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PnpObject>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromIdAsync)(self, type_, id.get(), requestedProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async(&mut self, type_: PnpObjectType, requestedProperties: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PnpObjectCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsync)(self, type_, requestedProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async_aqs_filter(&mut self, type_: PnpObjectType, requestedProperties: &::rt::gen::windows::foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PnpObjectCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsyncAqsFilter)(self, type_, requestedProperties as *const _ as *mut _, aqsFilter.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher(&mut self, type_: PnpObjectType, requestedProperties: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<PnpObjectWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcher)(self, type_, requestedProperties as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_watcher_aqs_filter(&mut self, type_: PnpObjectType, requestedProperties: &::rt::gen::windows::foundation::collections::IIterable<HString>, aqsFilter: &HStringArg) -> RtResult<ComPtr<PnpObjectWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcherAqsFilter)(self, type_, requestedProperties as *const _ as *mut _, aqsFilter.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPnpObject, 2512806488, 29499, 19087, 147, 163, 219, 7, 138, 200, 112, 193);
		RT_INTERFACE!{interface IPnpObject(IPnpObjectVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObject] {
			fn get_Type(&mut self, out: *mut PnpObjectType) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn Update(&mut self, updateInfo: *mut PnpObjectUpdate) -> ::w::HRESULT
		}}
		impl IPnpObject {
			#[inline] pub unsafe fn get_type(&mut self) -> RtResult<PnpObjectType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Type)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update(&mut self, updateInfo: &PnpObjectUpdate) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Update)(self, updateInfo as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Enumeration.Pnp
} // Windows.Devices.Enumeration
pub mod geolocation { // Windows.Devices.Geolocation
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum PositionAccuracy: i32 {
			Default (PositionAccuracy_Default) = 0, High (PositionAccuracy_High) = 1,
		}}
		RT_ENUM! { enum PositionStatus: i32 {
			Ready (PositionStatus_Ready) = 0, Initializing (PositionStatus_Initializing) = 1, NoData (PositionStatus_NoData) = 2, Disabled (PositionStatus_Disabled) = 3, NotInitialized (PositionStatus_NotInitialized) = 4, NotAvailable (PositionStatus_NotAvailable) = 5,
		}}
		RT_ENUM! { enum PositionSource: i32 {
			Cellular (PositionSource_Cellular) = 0, Satellite (PositionSource_Satellite) = 1, WiFi (PositionSource_WiFi) = 2, IPAddress (PositionSource_IPAddress) = 3, Unknown (PositionSource_Unknown) = 4, Default (PositionSource_Default) = 5, Obfuscated (PositionSource_Obfuscated) = 6,
		}}
		RT_ENUM! { enum GeoshapeType: i32 {
			Geopoint (GeoshapeType_Geopoint) = 0, Geocircle (GeoshapeType_Geocircle) = 1, Geopath (GeoshapeType_Geopath) = 2, GeoboundingBox (GeoshapeType_GeoboundingBox) = 3,
		}}
		RT_ENUM! { enum AltitudeReferenceSystem: i32 {
			Unspecified (AltitudeReferenceSystem_Unspecified) = 0, Terrain (AltitudeReferenceSystem_Terrain) = 1, Ellipsoid (AltitudeReferenceSystem_Ellipsoid) = 2, Geoid (AltitudeReferenceSystem_Geoid) = 3, Surface (AltitudeReferenceSystem_Surface) = 4,
		}}
		RT_STRUCT! { struct BasicGeoposition {
			Latitude: f64, Longitude: f64, Altitude: f64,
		}}
		RT_ENUM! { enum GeolocationAccessStatus: i32 {
			Unspecified (GeolocationAccessStatus_Unspecified) = 0, Allowed (GeolocationAccessStatus_Allowed) = 1, Denied (GeolocationAccessStatus_Denied) = 2,
		}}
		DEFINE_IID!(IID_IGeoshape, 3382485679, 50985, 17345, 143, 171, 214, 222, 201, 20, 223, 126);
		RT_INTERFACE!{interface IGeoshape(IGeoshapeVtbl): IInspectable(IInspectableVtbl) [IID_IGeoshape] {
			fn get_GeoshapeType(&mut self, out: *mut GeoshapeType) -> ::w::HRESULT,
			fn get_SpatialReferenceId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_AltitudeReferenceSystem(&mut self, out: *mut AltitudeReferenceSystem) -> ::w::HRESULT
		}}
		impl IGeoshape {
			#[inline] pub unsafe fn get_geoshape_type(&mut self) -> RtResult<GeoshapeType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GeoshapeType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_spatial_reference_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SpatialReferenceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_altitude_reference_system(&mut self) -> RtResult<AltitudeReferenceSystem> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AltitudeReferenceSystem)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeopoint, 1811546347, 58734, 18875, 156, 175, 203, 170, 120, 168, 188, 239);
		RT_INTERFACE!{interface IGeopoint(IGeopointVtbl): IInspectable(IInspectableVtbl) [IID_IGeopoint] {
			fn get_Position(&mut self, out: *mut BasicGeoposition) -> ::w::HRESULT
		}}
		impl IGeopoint {
			#[inline] pub unsafe fn get_position(&mut self) -> RtResult<BasicGeoposition> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Position)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeopointFactory, 3681258803, 30397, 20016, 138, 247, 168, 68, 220, 55, 183, 160);
		RT_INTERFACE!{static interface IGeopointFactory(IGeopointFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeopointFactory] {
			fn Create(&mut self, position: BasicGeoposition, out: *mut *mut Geopoint) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceSystem(&mut self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geopoint) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&mut self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geopoint) -> ::w::HRESULT
		}}
		impl IGeopointFactory {
			#[inline] pub unsafe fn create(&mut self, position: BasicGeoposition) -> RtResult<ComPtr<Geopoint>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, position, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_system(&mut self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> RtResult<ComPtr<Geopoint>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceSystem)(self, position, altitudeReferenceSystem, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_system_and_spatial_reference_id(&mut self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> RtResult<ComPtr<Geopoint>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self, position, altitudeReferenceSystem, spatialReferenceId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geopoint: IGeopoint [IGeopointFactory] [CLSID_Geopoint]}
		DEFINE_CLSID!(CLSID_Geopoint = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,111,105,110,116,0]);
		DEFINE_IID!(IID_IGeopath, 3846166457, 11684, 18196, 166, 82, 222, 133, 147, 40, 152, 152);
		RT_INTERFACE!{interface IGeopath(IGeopathVtbl): IInspectable(IInspectableVtbl) [IID_IGeopath] {
			fn get_Positions(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<BasicGeoposition>) -> ::w::HRESULT
		}}
		impl IGeopath {
			#[inline] pub unsafe fn get_positions(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<BasicGeoposition>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Positions)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeopathFactory, 666806728, 51175, 17241, 155, 155, 252, 163, 224, 94, 245, 147);
		RT_INTERFACE!{static interface IGeopathFactory(IGeopathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeopathFactory] {
			fn Create(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, out: *mut *mut Geopath) -> ::w::HRESULT,
			fn CreateWithAltitudeReference(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geopath) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceAndSpatialReference(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geopath) -> ::w::HRESULT
		}}
		impl IGeopathFactory {
			#[inline] pub unsafe fn create(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>) -> RtResult<ComPtr<Geopath>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, positions as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem) -> RtResult<ComPtr<Geopath>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReference)(self, positions as *const _ as *mut _, altitudeReferenceSystem, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_and_spatial_reference(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> RtResult<ComPtr<Geopath>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self, positions as *const _ as *mut _, altitudeReferenceSystem, spatialReferenceId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geopath: IGeopath [IGeopathFactory] [CLSID_Geopath]}
		DEFINE_CLSID!(CLSID_Geopath = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,97,116,104,0]);
		DEFINE_IID!(IID_IGeoboundingBox, 144099339, 10063, 17370, 154, 6, 203, 252, 218, 235, 78, 194);
		RT_INTERFACE!{interface IGeoboundingBox(IGeoboundingBoxVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBox] {
			fn get_NorthwestCorner(&mut self, out: *mut BasicGeoposition) -> ::w::HRESULT,
			fn get_SoutheastCorner(&mut self, out: *mut BasicGeoposition) -> ::w::HRESULT,
			fn get_Center(&mut self, out: *mut BasicGeoposition) -> ::w::HRESULT,
			fn get_MinAltitude(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_MaxAltitude(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IGeoboundingBox {
			#[inline] pub unsafe fn get_northwest_corner(&mut self) -> RtResult<BasicGeoposition> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NorthwestCorner)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_southeast_corner(&mut self) -> RtResult<BasicGeoposition> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SoutheastCorner)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_center(&mut self) -> RtResult<BasicGeoposition> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Center)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_altitude(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinAltitude)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_altitude(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxAltitude)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeoboundingBoxFactory, 1308337545, 1041, 19132, 179, 181, 91, 188, 203, 87, 217, 140);
		RT_INTERFACE!{static interface IGeoboundingBoxFactory(IGeoboundingBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxFactory] {
			fn Create(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, out: *mut *mut GeoboundingBox) -> ::w::HRESULT,
			fn CreateWithAltitudeReference(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut GeoboundingBox) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceAndSpatialReference(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut GeoboundingBox) -> ::w::HRESULT
		}}
		impl IGeoboundingBoxFactory {
			#[inline] pub unsafe fn create(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, northwestCorner, southeastCorner, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReference)(self, northwestCorner, southeastCorner, altitudeReferenceSystem, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_and_spatial_reference(&mut self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self, northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GeoboundingBox: IGeoboundingBox [IGeoboundingBoxFactory] [CLSID_GeoboundingBox]}
		RT_ACTIVATABLE!{IGeoboundingBoxStatics [CLSID_GeoboundingBox]}
		DEFINE_CLSID!(CLSID_GeoboundingBox = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,98,111,117,110,100,105,110,103,66,111,120,0]);
		DEFINE_IID!(IID_IGeoboundingBoxStatics, 1740113672, 58906, 19664, 132, 27, 147, 35, 55, 146, 181, 202);
		RT_INTERFACE!{static interface IGeoboundingBoxStatics(IGeoboundingBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxStatics] {
			fn TryCompute(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, out: *mut *mut GeoboundingBox) -> ::w::HRESULT,
			fn TryComputeWithAltitudeReference(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, out: *mut *mut GeoboundingBox) -> ::w::HRESULT,
			fn TryComputeWithAltitudeReferenceAndSpatialReference(&mut self, positions: *mut super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut GeoboundingBox) -> ::w::HRESULT
		}}
		impl IGeoboundingBoxStatics {
			#[inline] pub unsafe fn try_compute(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryCompute)(self, positions as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_compute_with_altitude_reference(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryComputeWithAltitudeReference)(self, positions as *const _ as *mut _, altitudeRefSystem, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_compute_with_altitude_reference_and_spatial_reference(&mut self, positions: &super::super::foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> RtResult<ComPtr<GeoboundingBox>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryComputeWithAltitudeReferenceAndSpatialReference)(self, positions as *const _ as *mut _, altitudeRefSystem, spatialReferenceId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocoordinateSatelliteData, 3274339545, 9736, 18252, 145, 44, 6, 221, 73, 15, 74, 247);
		RT_INTERFACE!{interface IGeocoordinateSatelliteData(IGeocoordinateSatelliteDataVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateSatelliteData] {
			fn get_PositionDilutionOfPrecision(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_HorizontalDilutionOfPrecision(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_VerticalDilutionOfPrecision(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT
		}}
		impl IGeocoordinateSatelliteData {
			#[inline] pub unsafe fn get_position_dilution_of_precision(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PositionDilutionOfPrecision)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_horizontal_dilution_of_precision(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HorizontalDilutionOfPrecision)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_vertical_dilution_of_precision(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VerticalDilutionOfPrecision)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GeocoordinateSatelliteData: IGeocoordinateSatelliteData}
		DEFINE_IID!(IID_IVenueData, 1727238535, 24803, 19247, 181, 39, 79, 83, 241, 195, 198, 119);
		RT_INTERFACE!{interface IVenueData(IVenueDataVtbl): IInspectable(IInspectableVtbl) [IID_IVenueData] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Level(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IVenueData {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_level(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Level)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class VenueData: IVenueData}
		DEFINE_IID!(IID_IGeocoordinate, 3995181994, 38762, 19568, 128, 61, 8, 62, 165, 91, 203, 196);
		RT_INTERFACE!{interface IGeocoordinate(IGeocoordinateVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinate] {
			fn get_Latitude(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_Longitude(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_Altitude(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_Accuracy(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_AltitudeAccuracy(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_Heading(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_Speed(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT,
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT
		}}
		impl IGeocoordinate {
			#[inline] pub unsafe fn get_latitude(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Latitude)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_longitude(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Longitude)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_altitude(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Altitude)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_accuracy(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Accuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_altitude_accuracy(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AltitudeAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heading(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Heading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_speed(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Speed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocoordinateWithPositionData, 2514891966, 56278, 16556, 184, 242, 166, 92, 3, 64, 217, 166);
		RT_INTERFACE!{interface IGeocoordinateWithPositionData(IGeocoordinateWithPositionDataVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionData] {
			fn get_PositionSource(&mut self, out: *mut PositionSource) -> ::w::HRESULT,
			fn get_SatelliteData(&mut self, out: *mut *mut GeocoordinateSatelliteData) -> ::w::HRESULT
		}}
		impl IGeocoordinateWithPositionData {
			#[inline] pub unsafe fn get_position_source(&mut self) -> RtResult<PositionSource> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PositionSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_satellite_data(&mut self) -> RtResult<ComPtr<GeocoordinateSatelliteData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SatelliteData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocoordinateWithPoint, 4276749605, 53804, 19782, 181, 39, 11, 150, 6, 111, 199, 219);
		RT_INTERFACE!{interface IGeocoordinateWithPoint(IGeocoordinateWithPointVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPoint] {
			fn get_Point(&mut self, out: *mut *mut Geopoint) -> ::w::HRESULT
		}}
		impl IGeocoordinateWithPoint {
			#[inline] pub unsafe fn get_point(&mut self) -> RtResult<ComPtr<Geopoint>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Point)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocoordinateWithPositionSourceTimestamp, 2235825154, 51697, 17936, 175, 224, 139, 195, 166, 168, 112, 54);
		RT_INTERFACE!{interface IGeocoordinateWithPositionSourceTimestamp(IGeocoordinateWithPositionSourceTimestampVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionSourceTimestamp] {
			fn get_PositionSourceTimestamp(&mut self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> ::w::HRESULT
		}}
		impl IGeocoordinateWithPositionSourceTimestamp {
			#[inline] pub unsafe fn get_position_source_timestamp(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PositionSourceTimestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeoposition, 3247244372, 32065, 20471, 169, 87, 157, 255, 180, 239, 127, 91);
		RT_INTERFACE!{interface IGeoposition(IGeopositionVtbl): IInspectable(IInspectableVtbl) [IID_IGeoposition] {
			fn get_Coordinate(&mut self, out: *mut *mut Geocoordinate) -> ::w::HRESULT,
			fn get_CivicAddress(&mut self, out: *mut *mut CivicAddress) -> ::w::HRESULT
		}}
		impl IGeoposition {
			#[inline] pub unsafe fn get_coordinate(&mut self) -> RtResult<ComPtr<Geocoordinate>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Coordinate)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_civic_address(&mut self) -> RtResult<ComPtr<CivicAddress>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CivicAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeoposition2, 2137192087, 34417, 19213, 134, 248, 71, 74, 132, 150, 24, 124);
		RT_INTERFACE!{interface IGeoposition2(IGeoposition2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeoposition2] {
			fn get_VenueData(&mut self, out: *mut *mut VenueData) -> ::w::HRESULT
		}}
		impl IGeoposition2 {
			#[inline] pub unsafe fn get_venue_data(&mut self) -> RtResult<ComPtr<VenueData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VenueData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geocoordinate: IGeocoordinate}
		RT_CLASS!{class CivicAddress: ICivicAddress}
		DEFINE_IID!(IID_ICivicAddress, 2824239642, 25844, 19784, 188, 234, 246, 176, 8, 236, 163, 76);
		RT_INTERFACE!{interface ICivicAddress(ICivicAddressVtbl): IInspectable(IInspectableVtbl) [IID_ICivicAddress] {
			fn get_Country(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_State(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_City(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_PostalCode(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT
		}}
		impl ICivicAddress {
			#[inline] pub unsafe fn get_country(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Country)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_state(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_State)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_city(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_City)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_postal_code(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PostalCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geoposition: IGeoposition}
		DEFINE_IID!(IID_IPositionChangedEventArgs, 931503333, 40222, 18117, 191, 59, 106, 216, 202, 193, 160, 147);
		RT_INTERFACE!{interface IPositionChangedEventArgs(IPositionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPositionChangedEventArgs] {
			fn get_Position(&mut self, out: *mut *mut Geoposition) -> ::w::HRESULT
		}}
		impl IPositionChangedEventArgs {
			#[inline] pub unsafe fn get_position(&mut self) -> RtResult<ComPtr<Geoposition>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Position)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PositionChangedEventArgs: IPositionChangedEventArgs}
		DEFINE_IID!(IID_IStatusChangedEventArgs, 877908698, 35987, 16657, 162, 5, 154, 236, 252, 155, 229, 192);
		RT_INTERFACE!{interface IStatusChangedEventArgs(IStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IStatusChangedEventArgs] {
			fn get_Status(&mut self, out: *mut PositionStatus) -> ::w::HRESULT
		}}
		impl IStatusChangedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<PositionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class StatusChangedEventArgs: IStatusChangedEventArgs}
		DEFINE_IID!(IID_IGeolocator, 2848178018, 17700, 18825, 138, 169, 222, 1, 157, 46, 85, 31);
		RT_INTERFACE!{interface IGeolocator(IGeolocatorVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocator] {
			fn get_DesiredAccuracy(&mut self, out: *mut PositionAccuracy) -> ::w::HRESULT,
			fn put_DesiredAccuracy(&mut self, value: PositionAccuracy) -> ::w::HRESULT,
			fn get_MovementThreshold(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn put_MovementThreshold(&mut self, value: f64) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_LocationStatus(&mut self, out: *mut PositionStatus) -> ::w::HRESULT,
			fn GetGeopositionAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<Geoposition>) -> ::w::HRESULT,
			fn GetGeopositionAsyncWithAgeAndTimeout(&mut self, maximumAge: super::super::foundation::TimeSpan, timeout: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<Geoposition>) -> ::w::HRESULT,
			fn add_PositionChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PositionChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_StatusChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IGeolocator {
			#[inline] pub unsafe fn get_desired_accuracy(&mut self) -> RtResult<PositionAccuracy> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DesiredAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_desired_accuracy(&mut self, value: PositionAccuracy) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DesiredAccuracy)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_movement_threshold(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MovementThreshold)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_movement_threshold(&mut self, value: f64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_MovementThreshold)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_location_status(&mut self) -> RtResult<PositionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LocationStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoposition_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Geoposition>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGeopositionAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoposition_async_with_age_and_timeout(&mut self, maximumAge: super::super::foundation::TimeSpan, timeout: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Geoposition>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGeopositionAsyncWithAgeAndTimeout)(self, maximumAge, timeout, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_position_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PositionChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_position_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PositionChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geolocator: IGeolocator}
		RT_ACTIVATABLE!{IGeolocatorStatics [CLSID_Geolocator]}
		RT_ACTIVATABLE!{IGeolocatorStatics2 [CLSID_Geolocator]}
		DEFINE_CLSID!(CLSID_Geolocator = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,108,111,99,97,116,111,114,0]);
		DEFINE_IID!(IID_IGeolocatorWithScalarAccuracy, 2532692929, 47119, 17930, 153, 77, 169, 108, 71, 165, 26, 164);
		RT_INTERFACE!{interface IGeolocatorWithScalarAccuracy(IGeolocatorWithScalarAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorWithScalarAccuracy] {
			fn get_DesiredAccuracyInMeters(&mut self, out: *mut *mut super::super::foundation::IReference<u32>) -> ::w::HRESULT,
			fn put_DesiredAccuracyInMeters(&mut self, value: *mut super::super::foundation::IReference<u32>) -> ::w::HRESULT
		}}
		impl IGeolocatorWithScalarAccuracy {
			#[inline] pub unsafe fn get_desired_accuracy_in_meters(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DesiredAccuracyInMeters)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_desired_accuracy_in_meters(&mut self, value: &super::super::foundation::IReference<u32>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DesiredAccuracyInMeters)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeolocator2, 3518246509, 34961, 17332, 173, 54, 39, 198, 254, 154, 151, 177);
		RT_INTERFACE!{interface IGeolocator2(IGeolocator2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeolocator2] {
			fn AllowFallbackToConsentlessPositions(&mut self) -> ::w::HRESULT
		}}
		impl IGeolocator2 {
			#[inline] pub unsafe fn allow_fallback_to_consentless_positions(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AllowFallbackToConsentlessPositions)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeolocatorStatics, 2593027441, 11765, 17809, 159, 135, 235, 95, 216, 148, 233, 183);
		RT_INTERFACE!{static interface IGeolocatorStatics(IGeolocatorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics] {
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<GeolocationAccessStatus>) -> ::w::HRESULT,
			fn GetGeopositionHistoryAsync(&mut self, startTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Geoposition>>) -> ::w::HRESULT,
			fn GetGeopositionHistoryWithDurationAsync(&mut self, startTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Geoposition>>) -> ::w::HRESULT
		}}
		impl IGeolocatorStatics {
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<GeolocationAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoposition_history_async(&mut self, startTime: super::super::foundation::DateTime) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Geoposition>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGeopositionHistoryAsync)(self, startTime, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoposition_history_with_duration_async(&mut self, startTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Geoposition>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGeopositionHistoryWithDurationAsync)(self, startTime, duration, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeolocatorStatics2, 2570064290, 64028, 17969, 167, 29, 13, 190, 177, 37, 13, 156);
		RT_INTERFACE!{static interface IGeolocatorStatics2(IGeolocatorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics2] {
			fn get_IsDefaultGeopositionRecommended(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_DefaultGeoposition(&mut self, value: *mut super::super::foundation::IReference<BasicGeoposition>) -> ::w::HRESULT,
			fn get_DefaultGeoposition(&mut self, out: *mut *mut super::super::foundation::IReference<BasicGeoposition>) -> ::w::HRESULT
		}}
		impl IGeolocatorStatics2 {
			#[inline] pub unsafe fn get_is_default_geoposition_recommended(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDefaultGeopositionRecommended)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_default_geoposition(&mut self, value: &super::super::foundation::IReference<BasicGeoposition>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DefaultGeoposition)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_geoposition(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<BasicGeoposition>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultGeoposition)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocircle, 971266115, 43001, 20067, 146, 167, 186, 12, 40, 209, 36, 177);
		RT_INTERFACE!{interface IGeocircle(IGeocircleVtbl): IInspectable(IInspectableVtbl) [IID_IGeocircle] {
			fn get_Center(&mut self, out: *mut BasicGeoposition) -> ::w::HRESULT,
			fn get_Radius(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IGeocircle {
			#[inline] pub unsafe fn get_center(&mut self) -> RtResult<BasicGeoposition> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Center)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_radius(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Radius)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeocircleFactory, 2950058783, 29361, 20349, 135, 204, 78, 212, 201, 132, 156, 5);
		RT_INTERFACE!{static interface IGeocircleFactory(IGeocircleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeocircleFactory] {
			fn Create(&mut self, position: BasicGeoposition, radius: f64, out: *mut *mut Geocircle) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceSystem(&mut self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geocircle) -> ::w::HRESULT,
			fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&mut self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geocircle) -> ::w::HRESULT
		}}
		impl IGeocircleFactory {
			#[inline] pub unsafe fn create(&mut self, position: BasicGeoposition, radius: f64) -> RtResult<ComPtr<Geocircle>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, position, radius, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_system(&mut self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem) -> RtResult<ComPtr<Geocircle>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceSystem)(self, position, radius, altitudeReferenceSystem, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_altitude_reference_system_and_spatial_reference_id(&mut self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> RtResult<ComPtr<Geocircle>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self, position, radius, altitudeReferenceSystem, spatialReferenceId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geocircle: IGeocircle [IGeocircleFactory] [CLSID_Geocircle]}
		DEFINE_CLSID!(CLSID_Geocircle = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,99,105,114,99,108,101,0]);
pub mod geofencing { // Windows.Devices.Geolocation.Geofencing
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum MonitoredGeofenceStates: u32 {
			None (MonitoredGeofenceStates_None) = 0, Entered (MonitoredGeofenceStates_Entered) = 1, Exited (MonitoredGeofenceStates_Exited) = 2, Removed (MonitoredGeofenceStates_Removed) = 4,
		}}
		RT_ENUM! { enum GeofenceState: u32 {
			None (GeofenceState_None) = 0, Entered (GeofenceState_Entered) = 1, Exited (GeofenceState_Exited) = 2, Removed (GeofenceState_Removed) = 4,
		}}
		RT_ENUM! { enum GeofenceMonitorStatus: i32 {
			Ready (GeofenceMonitorStatus_Ready) = 0, Initializing (GeofenceMonitorStatus_Initializing) = 1, NoData (GeofenceMonitorStatus_NoData) = 2, Disabled (GeofenceMonitorStatus_Disabled) = 3, NotInitialized (GeofenceMonitorStatus_NotInitialized) = 4, NotAvailable (GeofenceMonitorStatus_NotAvailable) = 5,
		}}
		RT_ENUM! { enum GeofenceRemovalReason: i32 {
			Used (GeofenceRemovalReason_Used) = 0, Expired (GeofenceRemovalReason_Expired) = 1,
		}}
		DEFINE_IID!(IID_IGeofenceFactory, 2216649291, 12895, 19344, 188, 167, 43, 128, 34, 169, 55, 150);
		RT_INTERFACE!{static interface IGeofenceFactory(IGeofenceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceFactory] {
			fn Create(&mut self, id: ::w::HSTRING, geoshape: *mut super::IGeoshape, out: *mut *mut Geofence) -> ::w::HRESULT,
			fn CreateWithMonitorStates(&mut self, id: ::w::HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, out: *mut *mut Geofence) -> ::w::HRESULT,
			fn CreateWithMonitorStatesAndDwellTime(&mut self, id: ::w::HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: ::rt::gen::windows::foundation::TimeSpan, out: *mut *mut Geofence) -> ::w::HRESULT,
			fn CreateWithMonitorStatesDwellTimeStartTimeAndDuration(&mut self, id: ::w::HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: ::rt::gen::windows::foundation::TimeSpan, startTime: ::rt::gen::windows::foundation::DateTime, duration: ::rt::gen::windows::foundation::TimeSpan, out: *mut *mut Geofence) -> ::w::HRESULT
		}}
		impl IGeofenceFactory {
			#[inline] pub unsafe fn create(&mut self, id: &HStringArg, geoshape: &super::IGeoshape) -> RtResult<ComPtr<Geofence>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, id.get(), geoshape as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_monitor_states(&mut self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool) -> RtResult<ComPtr<Geofence>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithMonitorStates)(self, id.get(), geoshape as *const _ as *mut _, monitoredStates, singleUse, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_monitor_states_and_dwell_time(&mut self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: ::rt::gen::windows::foundation::TimeSpan) -> RtResult<ComPtr<Geofence>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithMonitorStatesAndDwellTime)(self, id.get(), geoshape as *const _ as *mut _, monitoredStates, singleUse, dwellTime, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_monitor_states_dwell_time_start_time_and_duration(&mut self, id: &HStringArg, geoshape: &super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: ::rt::gen::windows::foundation::TimeSpan, startTime: ::rt::gen::windows::foundation::DateTime, duration: ::rt::gen::windows::foundation::TimeSpan) -> RtResult<ComPtr<Geofence>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithMonitorStatesDwellTimeStartTimeAndDuration)(self, id.get(), geoshape as *const _ as *mut _, monitoredStates, singleUse, dwellTime, startTime, duration, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Geofence: IGeofence [IGeofenceFactory] [CLSID_Geofence]}
		DEFINE_CLSID!(CLSID_Geofence = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,0]);
		DEFINE_IID!(IID_IGeofence, 2617837603, 60856, 18400, 130, 69, 91, 246, 29, 50, 31, 45);
		RT_INTERFACE!{interface IGeofence(IGeofenceVtbl): IInspectable(IInspectableVtbl) [IID_IGeofence] {
			fn get_StartTime(&mut self, out: *mut ::rt::gen::windows::foundation::DateTime) -> ::w::HRESULT,
			fn get_Duration(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_DwellTime(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MonitoredStates(&mut self, out: *mut MonitoredGeofenceStates) -> ::w::HRESULT,
			fn get_Geoshape(&mut self, out: *mut *mut super::IGeoshape) -> ::w::HRESULT,
			fn get_SingleUse(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IGeofence {
			#[inline] pub unsafe fn get_start_time(&mut self) -> RtResult<::rt::gen::windows::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StartTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_duration(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Duration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_dwell_time(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DwellTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_monitored_states(&mut self) -> RtResult<MonitoredGeofenceStates> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MonitoredStates)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoshape(&mut self) -> RtResult<ComPtr<super::IGeoshape>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Geoshape)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_single_use(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SingleUse)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeofenceStateChangeReport, 2586065944, 9316, 19593, 190, 5, 179, 255, 255, 91, 171, 197);
		RT_INTERFACE!{interface IGeofenceStateChangeReport(IGeofenceStateChangeReportVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceStateChangeReport] {
			fn get_NewState(&mut self, out: *mut GeofenceState) -> ::w::HRESULT,
			fn get_Geofence(&mut self, out: *mut *mut Geofence) -> ::w::HRESULT,
			fn get_Geoposition(&mut self, out: *mut *mut super::Geoposition) -> ::w::HRESULT,
			fn get_RemovalReason(&mut self, out: *mut GeofenceRemovalReason) -> ::w::HRESULT
		}}
		impl IGeofenceStateChangeReport {
			#[inline] pub unsafe fn get_new_state(&mut self) -> RtResult<GeofenceState> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NewState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geofence(&mut self) -> RtResult<ComPtr<Geofence>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Geofence)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geoposition(&mut self) -> RtResult<ComPtr<super::Geoposition>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Geoposition)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_removal_reason(&mut self) -> RtResult<GeofenceRemovalReason> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RemovalReason)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGeofenceMonitorStatics, 768815055, 32373, 18585, 172, 227, 43, 208, 166, 92, 206, 6);
		RT_INTERFACE!{static interface IGeofenceMonitorStatics(IGeofenceMonitorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitorStatics] {
			fn get_Current(&mut self, out: *mut *mut GeofenceMonitor) -> ::w::HRESULT
		}}
		impl IGeofenceMonitorStatics {
			#[inline] pub unsafe fn get_current(&mut self) -> RtResult<ComPtr<GeofenceMonitor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Current)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GeofenceMonitor: IGeofenceMonitor}
		RT_ACTIVATABLE!{IGeofenceMonitorStatics [CLSID_GeofenceMonitor]}
		DEFINE_CLSID!(CLSID_GeofenceMonitor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,77,111,110,105,116,111,114,0]);
		DEFINE_IID!(IID_IGeofenceMonitor, 1276075896, 7199, 17953, 187, 189, 131, 59, 146, 36, 114, 38);
		RT_INTERFACE!{interface IGeofenceMonitor(IGeofenceMonitorVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitor] {
			fn get_Status(&mut self, out: *mut GeofenceMonitorStatus) -> ::w::HRESULT,
			fn get_Geofences(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<Geofence>) -> ::w::HRESULT,
			fn get_LastKnownGeoposition(&mut self, out: *mut *mut super::Geoposition) -> ::w::HRESULT,
			fn add_GeofenceStateChanged(&mut self, eventHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<GeofenceMonitor, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_GeofenceStateChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn ReadReports(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<GeofenceStateChangeReport>) -> ::w::HRESULT,
			fn add_StatusChanged(&mut self, eventHandler: *mut ::rt::gen::windows::foundation::TypedEventHandler<GeofenceMonitor, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IGeofenceMonitor {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<GeofenceMonitorStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_geofences(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<Geofence>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Geofences)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_last_known_geoposition(&mut self) -> RtResult<ComPtr<super::Geoposition>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LastKnownGeoposition)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_geofence_state_changed(&mut self, eventHandler: &::rt::gen::windows::foundation::TypedEventHandler<GeofenceMonitor, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_GeofenceStateChanged)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_geofence_state_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_GeofenceStateChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn read_reports(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<GeofenceStateChangeReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadReports)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_changed(&mut self, eventHandler: &::rt::gen::windows::foundation::TypedEventHandler<GeofenceMonitor, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusChanged)(self, eventHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GeofenceStateChangeReport: IGeofenceStateChangeReport}
} // Windows.Devices.Geolocation.Geofencing
} // Windows.Devices.Geolocation
pub mod humaninterfacedevice { // Windows.Devices.HumanInterfaceDevice
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum HidReportType: i32 {
			Input (HidReportType_Input) = 0, Output (HidReportType_Output) = 1, Feature (HidReportType_Feature) = 2,
		}}
		RT_ENUM! { enum HidCollectionType: i32 {
			Physical (HidCollectionType_Physical) = 0, Application (HidCollectionType_Application) = 1, Logical (HidCollectionType_Logical) = 2, Report (HidCollectionType_Report) = 3, NamedArray (HidCollectionType_NamedArray) = 4, UsageSwitch (HidCollectionType_UsageSwitch) = 5, UsageModifier (HidCollectionType_UsageModifier) = 6, Other (HidCollectionType_Other) = 7,
		}}
		DEFINE_IID!(IID_IHidDeviceStatics, 2656666084, 38998, 16780, 159, 115, 119, 222, 12, 216, 87, 84);
		RT_INTERFACE!{static interface IHidDeviceStatics(IHidDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHidDeviceStatics] {
			fn GetDeviceSelector(&mut self, usagePage: u16, usageId: u16, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorVidPid(&mut self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, accessMode: super::super::storage::FileAccessMode, out: *mut *mut super::super::foundation::IAsyncOperation<HidDevice>) -> ::w::HRESULT
		}}
		impl IHidDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self, usagePage: u16, usageId: u16) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_vid_pid(&mut self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorVidPid)(self, usagePage, usageId, vendorId, productId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg, accessMode: super::super::storage::FileAccessMode) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HidDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), accessMode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class HidDevice: IHidDevice}
		RT_ACTIVATABLE!{IHidDeviceStatics [CLSID_HidDevice]}
		DEFINE_CLSID!(CLSID_HidDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,117,109,97,110,73,110,116,101,114,102,97,99,101,68,101,118,105,99,101,46,72,105,100,68,101,118,105,99,101,0]);
		RT_CLASS!{class HidInputReport: IHidInputReport}
		RT_CLASS!{class HidFeatureReport: IHidFeatureReport}
		RT_CLASS!{class HidOutputReport: IHidOutputReport}
		RT_CLASS!{class HidBooleanControlDescription: IHidBooleanControlDescription}
		RT_CLASS!{class HidNumericControlDescription: IHidNumericControlDescription}
		RT_CLASS!{class HidInputReportReceivedEventArgs: IHidInputReportReceivedEventArgs}
		DEFINE_IID!(IID_IHidBooleanControlDescription, 1637279043, 10712, 18986, 134, 131, 132, 158, 32, 123, 190, 49);
		RT_INTERFACE!{interface IHidBooleanControlDescription(IHidBooleanControlDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ReportId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ReportType(&mut self, out: *mut HidReportType) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ParentCollections(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HidCollection>) -> ::w::HRESULT
		}}
		impl IHidBooleanControlDescription {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_type(&mut self) -> RtResult<HidReportType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_parent_collections(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ParentCollections)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class HidCollection: IHidCollection}
		DEFINE_IID!(IID_IHidBooleanControlDescription2, 3371094762, 35447, 19510, 170, 0, 95, 240, 68, 157, 62, 115);
		RT_INTERFACE!{interface IHidBooleanControlDescription2(IHidBooleanControlDescription2Vtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription2] {
			fn get_IsAbsolute(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IHidBooleanControlDescription2 {
			#[inline] pub unsafe fn get_is_absolute(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsAbsolute)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidNumericControlDescription, 1670209158, 7575, 19573, 146, 127, 95, 245, 139, 160, 94, 50);
		RT_INTERFACE!{interface IHidNumericControlDescription(IHidNumericControlDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IHidNumericControlDescription] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ReportId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ReportType(&mut self, out: *mut HidReportType) -> ::w::HRESULT,
			fn get_ReportSize(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ReportCount(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_LogicalMinimum(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_LogicalMaximum(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_PhysicalMinimum(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_PhysicalMaximum(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_UnitExponent(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Unit(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsAbsolute(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_HasNull(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_ParentCollections(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HidCollection>) -> ::w::HRESULT
		}}
		impl IHidNumericControlDescription {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_type(&mut self) -> RtResult<HidReportType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_count(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportCount)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_logical_minimum(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LogicalMinimum)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_logical_maximum(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LogicalMaximum)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_physical_minimum(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PhysicalMinimum)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_physical_maximum(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PhysicalMaximum)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_unit_exponent(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UnitExponent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_unit(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Unit)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_absolute(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsAbsolute)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_has_null(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HasNull)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_parent_collections(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidCollection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ParentCollections)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidCollection, 1904866723, 13041, 18147, 190, 253, 68, 210, 102, 59, 126, 106);
		RT_INTERFACE!{interface IHidCollection(IHidCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IHidCollection] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Type(&mut self, out: *mut HidCollectionType) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IHidCollection {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_type(&mut self) -> RtResult<HidCollectionType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Type)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidInputReport, 3277655632, 63463, 20109, 178, 62, 202, 187, 229, 107, 144, 233);
		RT_INTERFACE!{interface IHidInputReport(IHidInputReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidInputReport] {
			fn get_Id(&mut self, out: *mut u16) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_ActivatedBooleanControls(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HidBooleanControl>) -> ::w::HRESULT,
			fn get_TransitionedBooleanControls(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HidBooleanControl>) -> ::w::HRESULT,
			fn GetBooleanControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetBooleanControlByDescription(&mut self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetNumericControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> ::w::HRESULT,
			fn GetNumericControlByDescription(&mut self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> ::w::HRESULT
		}}
		impl IHidInputReport {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_activated_boolean_controls(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidBooleanControl>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ActivatedBooleanControls)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_transitioned_boolean_controls(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidBooleanControl>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TransitionedBooleanControls)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control_by_description(&mut self, controlDescription: &HidBooleanControlDescription) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control_by_description(&mut self, controlDescription: &HidNumericControlDescription) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class HidBooleanControl: IHidBooleanControl}
		RT_CLASS!{class HidNumericControl: IHidNumericControl}
		DEFINE_IID!(IID_IHidOutputReport, 1657480516, 51350, 17507, 147, 193, 223, 157, 176, 83, 196, 80);
		RT_INTERFACE!{interface IHidOutputReport(IHidOutputReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidOutputReport] {
			fn get_Id(&mut self, out: *mut u16) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_Data(&mut self, value: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn GetBooleanControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetBooleanControlByDescription(&mut self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetNumericControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> ::w::HRESULT,
			fn GetNumericControlByDescription(&mut self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> ::w::HRESULT
		}}
		impl IHidOutputReport {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_data(&mut self, value: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Data)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control_by_description(&mut self, controlDescription: &HidBooleanControlDescription) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control_by_description(&mut self, controlDescription: &HidNumericControlDescription) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidFeatureReport, 2216532857, 23269, 18147, 130, 239, 31, 236, 92, 137, 66, 244);
		RT_INTERFACE!{interface IHidFeatureReport(IHidFeatureReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidFeatureReport] {
			fn get_Id(&mut self, out: *mut u16) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_Data(&mut self, value: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn GetBooleanControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetBooleanControlByDescription(&mut self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> ::w::HRESULT,
			fn GetNumericControl(&mut self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> ::w::HRESULT,
			fn GetNumericControlByDescription(&mut self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> ::w::HRESULT
		}}
		impl IHidFeatureReport {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_data(&mut self, value: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Data)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control_by_description(&mut self, controlDescription: &HidBooleanControlDescription) -> RtResult<ComPtr<HidBooleanControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control(&mut self, usagePage: u16, usageId: u16) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControl)(self, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control_by_description(&mut self, controlDescription: &HidNumericControlDescription) -> RtResult<ComPtr<HidNumericControl>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControlByDescription)(self, controlDescription as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidInputReportReceivedEventArgs, 1884931531, 22962, 19906, 152, 92, 10, 220, 97, 54, 250, 45);
		RT_INTERFACE!{interface IHidInputReportReceivedEventArgs(IHidInputReportReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHidInputReportReceivedEventArgs] {
			fn get_Report(&mut self, out: *mut *mut HidInputReport) -> ::w::HRESULT
		}}
		impl IHidInputReportReceivedEventArgs {
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<HidInputReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidBooleanControl, 1380840586, 13973, 16524, 187, 162, 226, 235, 90, 191, 188, 32);
		RT_INTERFACE!{interface IHidBooleanControl(IHidBooleanControlVtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControl] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_IsActive(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsActive(&mut self, value: bool) -> ::w::HRESULT,
			fn get_ControlDescription(&mut self, out: *mut *mut HidBooleanControlDescription) -> ::w::HRESULT
		}}
		impl IHidBooleanControl {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_active(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsActive)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_active(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsActive)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_control_description(&mut self) -> RtResult<ComPtr<HidBooleanControlDescription>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ControlDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidNumericControl, 3817476773, 13735, 19317, 137, 200, 251, 31, 40, 177, 8, 35);
		RT_INTERFACE!{interface IHidNumericControl(IHidNumericControlVtbl): IInspectable(IInspectableVtbl) [IID_IHidNumericControl] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsGrouped(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Value(&mut self, out: *mut i64) -> ::w::HRESULT,
			fn put_Value(&mut self, value: i64) -> ::w::HRESULT,
			fn get_ScaledValue(&mut self, out: *mut i64) -> ::w::HRESULT,
			fn put_ScaledValue(&mut self, value: i64) -> ::w::HRESULT,
			fn get_ControlDescription(&mut self, out: *mut *mut HidNumericControlDescription) -> ::w::HRESULT
		}}
		impl IHidNumericControl {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_grouped(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsGrouped)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<i64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_value(&mut self, value: i64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Value)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scaled_value(&mut self) -> RtResult<i64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScaledValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_scaled_value(&mut self, value: i64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ScaledValue)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_control_description(&mut self) -> RtResult<ComPtr<HidNumericControlDescription>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ControlDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IHidDevice, 1602884839, 8704, 17198, 149, 218, 208, 155, 135, 213, 116, 168);
		RT_INTERFACE!{interface IHidDevice(IHidDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IHidDevice] {
			fn get_VendorId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_ProductId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_Version(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsagePage(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsageId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn GetInputReportAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<HidInputReport>) -> ::w::HRESULT,
			fn GetInputReportByIdAsync(&mut self, reportId: u16, out: *mut *mut super::super::foundation::IAsyncOperation<HidInputReport>) -> ::w::HRESULT,
			fn GetFeatureReportAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<HidFeatureReport>) -> ::w::HRESULT,
			fn GetFeatureReportByIdAsync(&mut self, reportId: u16, out: *mut *mut super::super::foundation::IAsyncOperation<HidFeatureReport>) -> ::w::HRESULT,
			fn CreateOutputReport(&mut self, out: *mut *mut HidOutputReport) -> ::w::HRESULT,
			fn CreateOutputReportById(&mut self, reportId: u16, out: *mut *mut HidOutputReport) -> ::w::HRESULT,
			fn CreateFeatureReport(&mut self, out: *mut *mut HidFeatureReport) -> ::w::HRESULT,
			fn CreateFeatureReportById(&mut self, reportId: u16, out: *mut *mut HidFeatureReport) -> ::w::HRESULT,
			fn SendOutputReportAsync(&mut self, outputReport: *mut HidOutputReport, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> ::w::HRESULT,
			fn SendFeatureReportAsync(&mut self, featureReport: *mut HidFeatureReport, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> ::w::HRESULT,
			fn GetBooleanControlDescriptions(&mut self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut *mut super::super::foundation::collections::IVectorView<HidBooleanControlDescription>) -> ::w::HRESULT,
			fn GetNumericControlDescriptions(&mut self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut *mut super::super::foundation::collections::IVectorView<HidNumericControlDescription>) -> ::w::HRESULT,
			fn add_InputReportReceived(&mut self, reportHandler: *mut super::super::foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_InputReportReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IHidDevice {
			#[inline] pub unsafe fn get_vendor_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_VendorId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_product_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProductId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_version(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Version)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_page(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsagePage)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usage_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsageId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_input_report_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HidInputReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInputReportAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_input_report_by_id_async(&mut self, reportId: u16) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HidInputReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInputReportByIdAsync)(self, reportId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_feature_report_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HidFeatureReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFeatureReportAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_feature_report_by_id_async(&mut self, reportId: u16) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HidFeatureReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFeatureReportByIdAsync)(self, reportId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_output_report(&mut self) -> RtResult<ComPtr<HidOutputReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateOutputReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_output_report_by_id(&mut self, reportId: u16) -> RtResult<ComPtr<HidOutputReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateOutputReportById)(self, reportId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_feature_report(&mut self) -> RtResult<ComPtr<HidFeatureReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFeatureReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_feature_report_by_id(&mut self, reportId: u16) -> RtResult<ComPtr<HidFeatureReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFeatureReportById)(self, reportId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn send_output_report_async(&mut self, outputReport: &HidOutputReport) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendOutputReportAsync)(self, outputReport as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn send_feature_report_async(&mut self, featureReport: &HidFeatureReport) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendFeatureReportAsync)(self, featureReport as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_control_descriptions(&mut self, reportType: HidReportType, usagePage: u16, usageId: u16) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidBooleanControlDescription>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanControlDescriptions)(self, reportType, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_numeric_control_descriptions(&mut self, reportType: HidReportType, usagePage: u16, usageId: u16) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HidNumericControlDescription>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNumericControlDescriptions)(self, reportType, usagePage, usageId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_input_report_received(&mut self, reportHandler: &super::super::foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_InputReportReceived)(self, reportHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_input_report_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_InputReportReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.HumanInterfaceDevice
pub mod input { // Windows.Devices.Input
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum PointerDeviceType: i32 {
			Touch (PointerDeviceType_Touch) = 0, Pen (PointerDeviceType_Pen) = 1, Mouse (PointerDeviceType_Mouse) = 2,
		}}
		RT_STRUCT! { struct PointerDeviceUsage {
			UsagePage: u32, Usage: u32, MinLogical: i32, MaxLogical: i32, MinPhysical: i32, MaxPhysical: i32, Unit: u32, PhysicalMultiplier: f32,
		}}
		RT_STRUCT! { struct MouseDelta {
			X: i32, Y: i32,
		}}
		DEFINE_IID!(IID_IMouseCapabilities, 3164987427, 32217, 19307, 154, 146, 85, 212, 60, 179, 143, 115);
		RT_INTERFACE!{interface IMouseCapabilities(IMouseCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IMouseCapabilities] {
			fn get_MousePresent(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_VerticalWheelPresent(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_HorizontalWheelPresent(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_SwapButtons(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_NumberOfButtons(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IMouseCapabilities {
			#[inline] pub unsafe fn get_mouse_present(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MousePresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_vertical_wheel_present(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_VerticalWheelPresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_horizontal_wheel_present(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HorizontalWheelPresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_swap_buttons(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SwapButtons)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_number_of_buttons(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NumberOfButtons)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKeyboardCapabilities, 977247062, 26520, 19388, 131, 62, 15, 52, 177, 124, 101, 255);
		RT_INTERFACE!{interface IKeyboardCapabilities(IKeyboardCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IKeyboardCapabilities] {
			fn get_KeyboardPresent(&mut self, out: *mut i32) -> ::w::HRESULT
		}}
		impl IKeyboardCapabilities {
			#[inline] pub unsafe fn get_keyboard_present(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_KeyboardPresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ITouchCapabilities, 551376377, 5105, 18120, 146, 133, 44, 5, 250, 62, 218, 111);
		RT_INTERFACE!{interface ITouchCapabilities(ITouchCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ITouchCapabilities] {
			fn get_TouchPresent(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Contacts(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl ITouchCapabilities {
			#[inline] pub unsafe fn get_touch_present(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TouchPresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_contacts(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Contacts)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPointerDeviceStatics, 3635976865, 53702, 16750, 189, 141, 87, 144, 145, 77, 197, 99);
		RT_INTERFACE!{static interface IPointerDeviceStatics(IPointerDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDeviceStatics] {
			fn GetPointerDevice(&mut self, pointerId: u32, out: *mut *mut PointerDevice) -> ::w::HRESULT,
			fn GetPointerDevices(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PointerDevice>) -> ::w::HRESULT
		}}
		impl IPointerDeviceStatics {
			#[inline] pub unsafe fn get_pointer_device(&mut self, pointerId: u32) -> RtResult<ComPtr<PointerDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetPointerDevice)(self, pointerId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pointer_devices(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PointerDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetPointerDevices)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PointerDevice: IPointerDevice}
		RT_ACTIVATABLE!{IPointerDeviceStatics [CLSID_PointerDevice]}
		DEFINE_CLSID!(CLSID_PointerDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,80,111,105,110,116,101,114,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IPointerDevice, 2479471356, 60363, 18046, 130, 198, 39, 111, 234, 227, 107, 90);
		RT_INTERFACE!{interface IPointerDevice(IPointerDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDevice] {
			fn get_PointerDeviceType(&mut self, out: *mut PointerDeviceType) -> ::w::HRESULT,
			fn get_IsIntegrated(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_MaxContacts(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_PhysicalDeviceRect(&mut self, out: *mut super::super::foundation::Rect) -> ::w::HRESULT,
			fn get_ScreenRect(&mut self, out: *mut super::super::foundation::Rect) -> ::w::HRESULT,
			fn get_SupportedUsages(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PointerDeviceUsage>) -> ::w::HRESULT
		}}
		impl IPointerDevice {
			#[inline] pub unsafe fn get_pointer_device_type(&mut self) -> RtResult<PointerDeviceType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PointerDeviceType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_integrated(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsIntegrated)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_contacts(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxContacts)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_physical_device_rect(&mut self) -> RtResult<super::super::foundation::Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PhysicalDeviceRect)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_screen_rect(&mut self) -> RtResult<super::super::foundation::Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScreenRect)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_usages(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PointerDeviceUsage>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedUsages)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPointerDevice2, 4171682464, 50308, 18591, 174, 62, 48, 210, 238, 31, 253, 62);
		RT_INTERFACE!{interface IPointerDevice2(IPointerDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IPointerDevice2] {
			fn get_MaxPointersWithZDistance(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IPointerDevice2 {
			#[inline] pub unsafe fn get_max_pointers_with_zdistance(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPointersWithZDistance)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMouseEventArgs, 4129663581, 9044, 19655, 146, 48, 150, 148, 28, 150, 159, 222);
		RT_INTERFACE!{interface IMouseEventArgs(IMouseEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMouseEventArgs] {
			fn get_MouseDelta(&mut self, out: *mut MouseDelta) -> ::w::HRESULT
		}}
		impl IMouseEventArgs {
			#[inline] pub unsafe fn get_mouse_delta(&mut self) -> RtResult<MouseDelta> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MouseDelta)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMouseDevice, 2297295960, 62152, 18932, 190, 31, 194, 86, 179, 136, 188, 17);
		RT_INTERFACE!{interface IMouseDevice(IMouseDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IMouseDevice] {
			fn add_MouseMoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<MouseDevice, MouseEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MouseMoved(&mut self, cookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IMouseDevice {
			#[inline] pub unsafe fn add_mouse_moved(&mut self, handler: &super::super::foundation::TypedEventHandler<MouseDevice, MouseEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MouseMoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_mouse_moved(&mut self, cookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MouseMoved)(self, cookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MouseDevice: IMouseDevice}
		RT_ACTIVATABLE!{IMouseDeviceStatics [CLSID_MouseDevice]}
		DEFINE_CLSID!(CLSID_MouseDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,77,111,117,115,101,68,101,118,105,99,101,0]);
		RT_CLASS!{class MouseEventArgs: IMouseEventArgs}
		DEFINE_IID!(IID_IMouseDeviceStatics, 1212846149, 28016, 18907, 142, 104, 70, 255, 189, 23, 211, 141);
		RT_INTERFACE!{static interface IMouseDeviceStatics(IMouseDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMouseDeviceStatics] {
			fn GetForCurrentView(&mut self, out: *mut *mut MouseDevice) -> ::w::HRESULT
		}}
		impl IMouseDeviceStatics {
			#[inline] pub unsafe fn get_for_current_view(&mut self) -> RtResult<ComPtr<MouseDevice>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetForCurrentView)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MouseCapabilities: IMouseCapabilities}
		RT_CLASS!{class KeyboardCapabilities: IKeyboardCapabilities}
		RT_CLASS!{class TouchCapabilities: ITouchCapabilities}
} // Windows.Devices.Input
pub mod lights { // Windows.Devices.Lights
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_ILampStatics, 2820817260, 34949, 16414, 184, 33, 142, 139, 56, 168, 232, 236);
		RT_INTERFACE!{static interface ILampStatics(ILampStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILampStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Lamp>) -> ::w::HRESULT,
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<Lamp>) -> ::w::HRESULT
		}}
		impl ILampStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Lamp>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Lamp>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Lamp: ILamp}
		RT_ACTIVATABLE!{ILampStatics [CLSID_Lamp]}
		DEFINE_CLSID!(CLSID_Lamp = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,76,97,109,112,0]);
		RT_CLASS!{class LampAvailabilityChangedEventArgs: ILampAvailabilityChangedEventArgs}
		DEFINE_IID!(IID_ILampAvailabilityChangedEventArgs, 1332624877, 1954, 18845, 146, 96, 103, 227, 4, 83, 43, 164);
		RT_INTERFACE!{interface ILampAvailabilityChangedEventArgs(ILampAvailabilityChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILampAvailabilityChangedEventArgs] {
			fn get_IsAvailable(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl ILampAvailabilityChangedEventArgs {
			#[inline] pub unsafe fn get_is_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsAvailable)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILamp, 75324314, 59973, 19243, 177, 162, 20, 223, 240, 11, 222, 123);
		RT_INTERFACE!{interface ILamp(ILampVtbl): IInspectable(IInspectableVtbl) [IID_ILamp] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_BrightnessLevel(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn put_BrightnessLevel(&mut self, value: f32) -> ::w::HRESULT,
			fn get_IsColorSettable(&mut self, out: *mut bool) -> ::w::HRESULT,
			#[cfg(not(feature="windows.ui"))] fn __Dummy6(&mut self) -> (),
			#[cfg(feature="windows.ui")] fn get_Color(&mut self, out: *mut super::super::ui::Color) -> ::w::HRESULT,
			#[cfg(not(feature="windows.ui"))] fn __Dummy7(&mut self) -> (),
			#[cfg(feature="windows.ui")] fn put_Color(&mut self, value: super::super::ui::Color) -> ::w::HRESULT,
			fn add_AvailabilityChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AvailabilityChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ILamp {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_brightness_level(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BrightnessLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_brightness_level(&mut self, value: f32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BrightnessLevel)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_color_settable(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsColorSettable)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn get_color(&mut self) -> RtResult<super::super::ui::Color> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Color)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.ui")] #[inline] pub unsafe fn set_color(&mut self, value: super::super::ui::Color) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Color)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_availability_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AvailabilityChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_availability_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AvailabilityChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Lights
pub mod midi { // Windows.Devices.Midi
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum MidiMessageType: i32 {
			None (MidiMessageType_None) = 0, NoteOff (MidiMessageType_NoteOff) = 128, NoteOn (MidiMessageType_NoteOn) = 144, PolyphonicKeyPressure (MidiMessageType_PolyphonicKeyPressure) = 160, ControlChange (MidiMessageType_ControlChange) = 176, ProgramChange (MidiMessageType_ProgramChange) = 192, ChannelPressure (MidiMessageType_ChannelPressure) = 208, PitchBendChange (MidiMessageType_PitchBendChange) = 224, SystemExclusive (MidiMessageType_SystemExclusive) = 240, MidiTimeCode (MidiMessageType_MidiTimeCode) = 241, SongPositionPointer (MidiMessageType_SongPositionPointer) = 242, SongSelect (MidiMessageType_SongSelect) = 243, TuneRequest (MidiMessageType_TuneRequest) = 246, EndSystemExclusive (MidiMessageType_EndSystemExclusive) = 247, TimingClock (MidiMessageType_TimingClock) = 248, Start (MidiMessageType_Start) = 250, Continue (MidiMessageType_Continue) = 251, Stop (MidiMessageType_Stop) = 252, ActiveSensing (MidiMessageType_ActiveSensing) = 254, SystemReset (MidiMessageType_SystemReset) = 255,
		}}
		DEFINE_IID!(IID_IMidiMessage, 2037807429, 4244, 17027, 155, 224, 40, 159, 192, 238, 131, 52);
		RT_INTERFACE!{interface IMidiMessage(IMidiMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiMessage] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_RawData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_Type(&mut self, out: *mut MidiMessageType) -> ::w::HRESULT
		}}
		impl IMidiMessage {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_raw_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RawData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_type(&mut self) -> RtResult<MidiMessageType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Type)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiNoteOffMessage, 385714932, 6542, 19855, 166, 84, 211, 5, 162, 147, 84, 143);
		RT_INTERFACE!{interface IMidiNoteOffMessage(IMidiNoteOffMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Note(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Velocity(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiNoteOffMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_note(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Note)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_velocity(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Velocity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiNoteOnMessage, 3760343797, 24961, 18141, 175, 162, 65, 0, 4, 192, 87, 170);
		RT_INTERFACE!{interface IMidiNoteOnMessage(IMidiNoteOnMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Note(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Velocity(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiNoteOnMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_note(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Note)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_velocity(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Velocity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessage, 527644670, 44264, 18592, 134, 142, 124, 219, 242, 15, 4, 214);
		RT_INTERFACE!{interface IMidiPolyphonicKeyPressureMessage(IMidiPolyphonicKeyPressureMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Note(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Pressure(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiPolyphonicKeyPressureMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_note(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Note)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pressure(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Pressure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiControlChangeMessage, 3085000579, 30733, 16479, 183, 129, 62, 21, 152, 201, 127, 64);
		RT_INTERFACE!{interface IMidiControlChangeMessage(IMidiControlChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Controller(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ControlValue(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiControlChangeMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_controller(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Controller)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_control_value(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ControlValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiProgramChangeMessage, 2629516408, 31294, 17191, 170, 152, 32, 184, 228, 72, 90, 248);
		RT_INTERFACE!{interface IMidiProgramChangeMessage(IMidiProgramChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Program(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiProgramChangeMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_program(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Program)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiChannelPressureMessage, 3189745760, 25268, 19794, 163, 126, 146, 229, 77, 53, 185, 9);
		RT_INTERFACE!{interface IMidiChannelPressureMessage(IMidiChannelPressureMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Pressure(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiChannelPressureMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pressure(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Pressure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiPitchBendChangeMessage, 702500017, 11935, 20399, 140, 43, 156, 184, 42, 144, 121, 202);
		RT_INTERFACE!{interface IMidiPitchBendChangeMessage(IMidiPitchBendChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessage] {
			fn get_Channel(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Bend(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IMidiPitchBendChangeMessage {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bend(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Bend)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiTimeCodeMessage, 200738941, 64099, 18972, 141, 235, 192, 232, 119, 150, 166, 215);
		RT_INTERFACE!{interface IMidiTimeCodeMessage(IMidiTimeCodeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessage] {
			fn get_FrameType(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Values(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiTimeCodeMessage {
			#[inline] pub unsafe fn get_frame_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_FrameType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_values(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Values)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiSongPositionPointerMessage, 1285885014, 60510, 19172, 161, 21, 136, 220, 87, 204, 43, 121);
		RT_INTERFACE!{interface IMidiSongPositionPointerMessage(IMidiSongPositionPointerMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessage] {
			fn get_Beats(&mut self, out: *mut u16) -> ::w::HRESULT
		}}
		impl IMidiSongPositionPointerMessage {
			#[inline] pub unsafe fn get_beats(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Beats)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiSongSelectMessage, 1240527487, 28035, 18241, 165, 191, 70, 41, 246, 190, 151, 79);
		RT_INTERFACE!{interface IMidiSongSelectMessage(IMidiSongSelectMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessage] {
			fn get_Song(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IMidiSongSelectMessage {
			#[inline] pub unsafe fn get_song(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Song)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiNoteOffMessageFactory, 2796699872, 42825, 16991, 138, 244, 164, 217, 121, 204, 21, 181);
		RT_INTERFACE!{static interface IMidiNoteOffMessageFactory(IMidiNoteOffMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessageFactory] {
			fn CreateMidiNoteOffMessage(&mut self, channel: u8, note: u8, velocity: u8, out: *mut *mut MidiNoteOffMessage) -> ::w::HRESULT
		}}
		impl IMidiNoteOffMessageFactory {
			#[inline] pub unsafe fn create_midi_note_off_message(&mut self, channel: u8, note: u8, velocity: u8) -> RtResult<ComPtr<MidiNoteOffMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiNoteOffMessage)(self, channel, note, velocity, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiNoteOffMessage: IMidiNoteOffMessage [IMidiNoteOffMessageFactory] [CLSID_MidiNoteOffMessage]}
		DEFINE_CLSID!(CLSID_MidiNoteOffMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,102,102,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiNoteOnMessageFactory, 2604826784, 22977, 16910, 181, 23, 21, 161, 10, 169, 96, 107);
		RT_INTERFACE!{static interface IMidiNoteOnMessageFactory(IMidiNoteOnMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessageFactory] {
			fn CreateMidiNoteOnMessage(&mut self, channel: u8, note: u8, velocity: u8, out: *mut *mut MidiNoteOnMessage) -> ::w::HRESULT
		}}
		impl IMidiNoteOnMessageFactory {
			#[inline] pub unsafe fn create_midi_note_on_message(&mut self, channel: u8, note: u8, velocity: u8) -> RtResult<ComPtr<MidiNoteOnMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiNoteOnMessage)(self, channel, note, velocity, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiNoteOnMessage: IMidiNoteOnMessage [IMidiNoteOnMessageFactory] [CLSID_MidiNoteOnMessage]}
		DEFINE_CLSID!(CLSID_MidiNoteOnMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,110,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessageFactory, 3918481470, 50355, 19922, 145, 124, 227, 73, 129, 90, 27, 59);
		RT_INTERFACE!{static interface IMidiPolyphonicKeyPressureMessageFactory(IMidiPolyphonicKeyPressureMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessageFactory] {
			fn CreateMidiPolyphonicKeyPressureMessage(&mut self, channel: u8, note: u8, pressure: u8, out: *mut *mut MidiPolyphonicKeyPressureMessage) -> ::w::HRESULT
		}}
		impl IMidiPolyphonicKeyPressureMessageFactory {
			#[inline] pub unsafe fn create_midi_polyphonic_key_pressure_message(&mut self, channel: u8, note: u8, pressure: u8) -> RtResult<ComPtr<MidiPolyphonicKeyPressureMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiPolyphonicKeyPressureMessage)(self, channel, note, pressure, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiPolyphonicKeyPressureMessage: IMidiPolyphonicKeyPressureMessage [IMidiPolyphonicKeyPressureMessageFactory] [CLSID_MidiPolyphonicKeyPressureMessage]}
		DEFINE_CLSID!(CLSID_MidiPolyphonicKeyPressureMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,111,108,121,112,104,111,110,105,99,75,101,121,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiControlChangeMessageFactory, 716260129, 38252, 18093, 151, 82, 248, 127, 85, 5, 47, 227);
		RT_INTERFACE!{static interface IMidiControlChangeMessageFactory(IMidiControlChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessageFactory] {
			fn CreateMidiControlChangeMessage(&mut self, channel: u8, controller: u8, controlValue: u8, out: *mut *mut MidiControlChangeMessage) -> ::w::HRESULT
		}}
		impl IMidiControlChangeMessageFactory {
			#[inline] pub unsafe fn create_midi_control_change_message(&mut self, channel: u8, controller: u8, controlValue: u8) -> RtResult<ComPtr<MidiControlChangeMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiControlChangeMessage)(self, channel, controller, controlValue, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiControlChangeMessage: IMidiControlChangeMessage [IMidiControlChangeMessageFactory] [CLSID_MidiControlChangeMessage]}
		DEFINE_CLSID!(CLSID_MidiControlChangeMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,111,110,116,114,111,108,67,104,97,110,103,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiProgramChangeMessageFactory, 3601875847, 21067, 16644, 156, 153, 101, 114, 191, 210, 226, 97);
		RT_INTERFACE!{static interface IMidiProgramChangeMessageFactory(IMidiProgramChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessageFactory] {
			fn CreateMidiProgramChangeMessage(&mut self, channel: u8, program: u8, out: *mut *mut MidiProgramChangeMessage) -> ::w::HRESULT
		}}
		impl IMidiProgramChangeMessageFactory {
			#[inline] pub unsafe fn create_midi_program_change_message(&mut self, channel: u8, program: u8) -> RtResult<ComPtr<MidiProgramChangeMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiProgramChangeMessage)(self, channel, program, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiProgramChangeMessage: IMidiProgramChangeMessage [IMidiProgramChangeMessageFactory] [CLSID_MidiProgramChangeMessage]}
		DEFINE_CLSID!(CLSID_MidiProgramChangeMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,114,111,103,114,97,109,67,104,97,110,103,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiChannelPressureMessageFactory, 1645800751, 8836, 16682, 148, 207, 16, 251, 4, 132, 44, 108);
		RT_INTERFACE!{static interface IMidiChannelPressureMessageFactory(IMidiChannelPressureMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessageFactory] {
			fn CreateMidiChannelPressureMessage(&mut self, channel: u8, pressure: u8, out: *mut *mut MidiChannelPressureMessage) -> ::w::HRESULT
		}}
		impl IMidiChannelPressureMessageFactory {
			#[inline] pub unsafe fn create_midi_channel_pressure_message(&mut self, channel: u8, pressure: u8) -> RtResult<ComPtr<MidiChannelPressureMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiChannelPressureMessage)(self, channel, pressure, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiChannelPressureMessage: IMidiChannelPressureMessage [IMidiChannelPressureMessageFactory] [CLSID_MidiChannelPressureMessage]}
		DEFINE_CLSID!(CLSID_MidiChannelPressureMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,104,97,110,110,101,108,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiPitchBendChangeMessageFactory, 4126072661, 53192, 18726, 179, 14, 163, 98, 35, 147, 48, 108);
		RT_INTERFACE!{static interface IMidiPitchBendChangeMessageFactory(IMidiPitchBendChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessageFactory] {
			fn CreateMidiPitchBendChangeMessage(&mut self, channel: u8, bend: u16, out: *mut *mut MidiPitchBendChangeMessage) -> ::w::HRESULT
		}}
		impl IMidiPitchBendChangeMessageFactory {
			#[inline] pub unsafe fn create_midi_pitch_bend_change_message(&mut self, channel: u8, bend: u16) -> RtResult<ComPtr<MidiPitchBendChangeMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiPitchBendChangeMessage)(self, channel, bend, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiPitchBendChangeMessage: IMidiPitchBendChangeMessage [IMidiPitchBendChangeMessageFactory] [CLSID_MidiPitchBendChangeMessage]}
		DEFINE_CLSID!(CLSID_MidiPitchBendChangeMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,105,116,99,104,66,101,110,100,67,104,97,110,103,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiSystemExclusiveMessageFactory, 138273314, 15220, 17184, 155, 66, 12, 168, 84, 95, 138, 36);
		RT_INTERFACE!{static interface IMidiSystemExclusiveMessageFactory(IMidiSystemExclusiveMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSystemExclusiveMessageFactory] {
			#[cfg(feature="windows.storage")] fn CreateMidiSystemExclusiveMessage(&mut self, rawData: *mut super::super::storage::streams::IBuffer, out: *mut *mut MidiSystemExclusiveMessage) -> ::w::HRESULT
		}}
		impl IMidiSystemExclusiveMessageFactory {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create_midi_system_exclusive_message(&mut self, rawData: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<MidiSystemExclusiveMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiSystemExclusiveMessage)(self, rawData as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiSystemExclusiveMessage: IMidiMessage [IMidiSystemExclusiveMessageFactory] [CLSID_MidiSystemExclusiveMessage]}
		DEFINE_CLSID!(CLSID_MidiSystemExclusiveMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,115,116,101,109,69,120,99,108,117,115,105,118,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiTimeCodeMessageFactory, 3945830853, 30492, 16606, 185, 97, 23, 90, 116, 137, 168, 94);
		RT_INTERFACE!{static interface IMidiTimeCodeMessageFactory(IMidiTimeCodeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessageFactory] {
			fn CreateMidiTimeCodeMessage(&mut self, frameType: u8, values: u8, out: *mut *mut MidiTimeCodeMessage) -> ::w::HRESULT
		}}
		impl IMidiTimeCodeMessageFactory {
			#[inline] pub unsafe fn create_midi_time_code_message(&mut self, frameType: u8, values: u8) -> RtResult<ComPtr<MidiTimeCodeMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiTimeCodeMessage)(self, frameType, values, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiTimeCodeMessage: IMidiTimeCodeMessage [IMidiTimeCodeMessageFactory] [CLSID_MidiTimeCodeMessage]}
		DEFINE_CLSID!(CLSID_MidiTimeCodeMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,105,109,101,67,111,100,101,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiSongPositionPointerMessageFactory, 2617305494, 61707, 20458, 179, 149, 245, 214, 207, 128, 246, 78);
		RT_INTERFACE!{static interface IMidiSongPositionPointerMessageFactory(IMidiSongPositionPointerMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessageFactory] {
			fn CreateMidiSongPositionPointerMessage(&mut self, beats: u16, out: *mut *mut MidiSongPositionPointerMessage) -> ::w::HRESULT
		}}
		impl IMidiSongPositionPointerMessageFactory {
			#[inline] pub unsafe fn create_midi_song_position_pointer_message(&mut self, beats: u16) -> RtResult<ComPtr<MidiSongPositionPointerMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiSongPositionPointerMessage)(self, beats, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiSongPositionPointerMessage: IMidiSongPositionPointerMessage [IMidiSongPositionPointerMessageFactory] [CLSID_MidiSongPositionPointerMessage]}
		DEFINE_CLSID!(CLSID_MidiSongPositionPointerMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,80,111,115,105,116,105,111,110,80,111,105,110,116,101,114,77,101,115,115,97,103,101,0]);
		DEFINE_IID!(IID_IMidiSongSelectMessageFactory, 2223536356, 34632, 16681, 166, 108, 160, 84, 147, 247, 93, 170);
		RT_INTERFACE!{static interface IMidiSongSelectMessageFactory(IMidiSongSelectMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessageFactory] {
			fn CreateMidiSongSelectMessage(&mut self, song: u8, out: *mut *mut MidiSongSelectMessage) -> ::w::HRESULT
		}}
		impl IMidiSongSelectMessageFactory {
			#[inline] pub unsafe fn create_midi_song_select_message(&mut self, song: u8) -> RtResult<ComPtr<MidiSongSelectMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateMidiSongSelectMessage)(self, song, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiSongSelectMessage: IMidiSongSelectMessage [IMidiSongSelectMessageFactory] [CLSID_MidiSongSelectMessage]}
		DEFINE_CLSID!(CLSID_MidiSongSelectMessage = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,83,101,108,101,99,116,77,101,115,115,97,103,101,0]);
		RT_CLASS!{class MidiTuneRequestMessage: IMidiMessage}
		RT_CLASS!{class MidiTimingClockMessage: IMidiMessage}
		RT_CLASS!{class MidiStartMessage: IMidiMessage}
		RT_CLASS!{class MidiContinueMessage: IMidiMessage}
		RT_CLASS!{class MidiStopMessage: IMidiMessage}
		RT_CLASS!{class MidiActiveSensingMessage: IMidiMessage}
		RT_CLASS!{class MidiSystemResetMessage: IMidiMessage}
		DEFINE_IID!(IID_IMidiMessageReceivedEventArgs, 1985375830, 62248, 19281, 144, 125, 179, 168, 206, 150, 191, 128);
		RT_INTERFACE!{interface IMidiMessageReceivedEventArgs(IMidiMessageReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiMessageReceivedEventArgs] {
			fn get_Message(&mut self, out: *mut *mut IMidiMessage) -> ::w::HRESULT
		}}
		impl IMidiMessageReceivedEventArgs {
			#[inline] pub unsafe fn get_message(&mut self) -> RtResult<ComPtr<IMidiMessage>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Message)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiMessageReceivedEventArgs: IMidiMessageReceivedEventArgs}
		DEFINE_IID!(IID_IMidiInPortStatics, 1153710556, 26623, 19054, 139, 172, 253, 182, 97, 12, 242, 150);
		RT_INTERFACE!{static interface IMidiInPortStatics(IMidiInPortStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiInPortStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<MidiInPort>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMidiInPortStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<MidiInPort>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiInPort: IMidiInPort}
		RT_ACTIVATABLE!{IMidiInPortStatics [CLSID_MidiInPort]}
		DEFINE_CLSID!(CLSID_MidiInPort = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,73,110,80,111,114,116,0]);
		DEFINE_IID!(IID_IMidiOutPortStatics, 106742761, 3976, 17547, 155, 100, 169, 88, 38, 198, 91, 143);
		RT_INTERFACE!{static interface IMidiOutPortStatics(IMidiOutPortStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiOutPortStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<IMidiOutPort>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMidiOutPortStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<IMidiOutPort>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiOutPort: IMidiOutPort}
		RT_ACTIVATABLE!{IMidiOutPortStatics [CLSID_MidiOutPort]}
		DEFINE_CLSID!(CLSID_MidiOutPort = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,79,117,116,80,111,114,116,0]);
		DEFINE_IID!(IID_IMidiSynthesizerStatics, 1109715624, 26153, 19819, 170, 143, 212, 82, 26, 90, 49, 206);
		RT_INTERFACE!{static interface IMidiSynthesizerStatics(IMidiSynthesizerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizerStatics] {
			fn CreateAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<MidiSynthesizer>) -> ::w::HRESULT,
			fn CreateFromAudioDeviceAsync(&mut self, audioDevice: *mut super::enumeration::DeviceInformation, out: *mut *mut super::super::foundation::IAsyncOperation<MidiSynthesizer>) -> ::w::HRESULT,
			fn IsSynthesizer(&mut self, midiDevice: *mut super::enumeration::DeviceInformation, out: *mut bool) -> ::w::HRESULT
		}}
		impl IMidiSynthesizerStatics {
			#[inline] pub unsafe fn create_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<MidiSynthesizer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_audio_device_async(&mut self, audioDevice: &super::enumeration::DeviceInformation) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<MidiSynthesizer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromAudioDeviceAsync)(self, audioDevice as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_synthesizer(&mut self, midiDevice: &super::enumeration::DeviceInformation) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsSynthesizer)(self, midiDevice as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MidiSynthesizer: IMidiSynthesizer}
		RT_ACTIVATABLE!{IMidiSynthesizerStatics [CLSID_MidiSynthesizer]}
		DEFINE_CLSID!(CLSID_MidiSynthesizer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,110,116,104,101,115,105,122,101,114,0]);
		DEFINE_IID!(IID_IMidiOutPort, 2468179359, 22434, 19002, 173, 184, 70, 64, 136, 111, 102, 147);
		RT_INTERFACE!{interface IMidiOutPort(IMidiOutPortVtbl): IInspectable(IInspectableVtbl) [IID_IMidiOutPort] {
			fn SendMessage(&mut self, midiMessage: *mut IMidiMessage) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn SendBuffer(&mut self, midiData: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMidiOutPort {
			#[inline] pub unsafe fn send_message(&mut self, midiMessage: &IMidiMessage) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SendMessage)(self, midiMessage as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn send_buffer(&mut self, midiData: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SendBuffer)(self, midiData as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiInPort, 3586251227, 38682, 20143, 162, 61, 234, 25, 254, 96, 127, 249);
		RT_INTERFACE!{interface IMidiInPort(IMidiInPortVtbl): IInspectable(IInspectableVtbl) [IID_IMidiInPort] {
			fn add_MessageReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MessageReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMidiInPort {
			#[inline] pub unsafe fn add_message_received(&mut self, handler: &super::super::foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MessageReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_message_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MessageReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMidiSynthesizer, 4040824158, 56208, 16479, 184, 174, 33, 210, 225, 127, 46, 69);
		RT_INTERFACE!{interface IMidiSynthesizer(IMidiSynthesizerVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizer] {
			fn get_AudioDevice(&mut self, out: *mut *mut super::enumeration::DeviceInformation) -> ::w::HRESULT,
			fn get_Volume(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn put_Volume(&mut self, value: f64) -> ::w::HRESULT
		}}
		impl IMidiSynthesizer {
			#[inline] pub unsafe fn get_audio_device(&mut self) -> RtResult<ComPtr<super::enumeration::DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AudioDevice)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_volume(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Volume)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_volume(&mut self, value: f64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Volume)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.Midi
pub mod perception { // Windows.Devices.Perception
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum PerceptionFrameSourceAccessStatus: i32 {
			Unspecified (PerceptionFrameSourceAccessStatus_Unspecified) = 0, Allowed (PerceptionFrameSourceAccessStatus_Allowed) = 1, DeniedByUser (PerceptionFrameSourceAccessStatus_DeniedByUser) = 2, DeniedBySystem (PerceptionFrameSourceAccessStatus_DeniedBySystem) = 3,
		}}
		RT_ENUM! { enum PerceptionFrameSourcePropertyChangeStatus: i32 {
			Unknown (PerceptionFrameSourcePropertyChangeStatus_Unknown) = 0, Accepted (PerceptionFrameSourcePropertyChangeStatus_Accepted) = 1, LostControl (PerceptionFrameSourcePropertyChangeStatus_LostControl) = 2, PropertyNotSupported (PerceptionFrameSourcePropertyChangeStatus_PropertyNotSupported) = 3, PropertyReadOnly (PerceptionFrameSourcePropertyChangeStatus_PropertyReadOnly) = 4, ValueOutOfRange (PerceptionFrameSourcePropertyChangeStatus_ValueOutOfRange) = 5,
		}}
		DEFINE_IID!(IID_IPerceptionColorFrameSourceWatcher, 2528973714, 58983, 16580, 137, 249, 20, 98, 222, 166, 169, 204);
		RT_INTERFACE!{interface IPerceptionColorFrameSourceWatcher(IPerceptionColorFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceWatcher] {
			fn add_SourceAdded(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceAdded(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SourceRemoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceRemoved(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_EnumerationCompleted(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_EnumerationCompleted(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut super::enumeration::DeviceWatcherStatus) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSourceWatcher {
			#[inline] pub unsafe fn add_source_added(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_source_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceRemoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceRemoved)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_enumeration_completed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_EnumerationCompleted)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_enumeration_completed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_EnumerationCompleted)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::enumeration::DeviceWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionColorFrameSourceWatcher: IPerceptionColorFrameSourceWatcher}
		RT_CLASS!{class PerceptionColorFrameSourceAddedEventArgs: IPerceptionColorFrameSourceAddedEventArgs}
		RT_CLASS!{class PerceptionColorFrameSourceRemovedEventArgs: IPerceptionColorFrameSourceRemovedEventArgs}
		DEFINE_IID!(IID_IPerceptionDepthFrameSourceWatcher, 2014222033, 36098, 19755, 173, 164, 91, 166, 36, 160, 235, 16);
		RT_INTERFACE!{interface IPerceptionDepthFrameSourceWatcher(IPerceptionDepthFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceWatcher] {
			fn add_SourceAdded(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceAdded(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SourceRemoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceRemoved(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_EnumerationCompleted(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_EnumerationCompleted(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut super::enumeration::DeviceWatcherStatus) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSourceWatcher {
			#[inline] pub unsafe fn add_source_added(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_source_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceRemoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceRemoved)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_enumeration_completed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_EnumerationCompleted)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_enumeration_completed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_EnumerationCompleted)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::enumeration::DeviceWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionDepthFrameSourceWatcher: IPerceptionDepthFrameSourceWatcher}
		RT_CLASS!{class PerceptionDepthFrameSourceAddedEventArgs: IPerceptionDepthFrameSourceAddedEventArgs}
		RT_CLASS!{class PerceptionDepthFrameSourceRemovedEventArgs: IPerceptionDepthFrameSourceRemovedEventArgs}
		DEFINE_IID!(IID_IPerceptionInfraredFrameSourceWatcher, 943521689, 55052, 17485, 168, 176, 114, 12, 46, 102, 254, 59);
		RT_INTERFACE!{interface IPerceptionInfraredFrameSourceWatcher(IPerceptionInfraredFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceWatcher] {
			fn add_SourceAdded(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceAdded(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_SourceRemoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SourceRemoved(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Stopped(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_EnumerationCompleted(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_EnumerationCompleted(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut super::enumeration::DeviceWatcherStatus) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSourceWatcher {
			#[inline] pub unsafe fn add_source_added(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_source_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SourceRemoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_source_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SourceRemoved)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_stopped(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Stopped)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_stopped(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Stopped)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_enumeration_completed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_EnumerationCompleted)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_enumeration_completed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_EnumerationCompleted)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::enumeration::DeviceWatcherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionInfraredFrameSourceWatcher: IPerceptionInfraredFrameSourceWatcher}
		RT_CLASS!{class PerceptionInfraredFrameSourceAddedEventArgs: IPerceptionInfraredFrameSourceAddedEventArgs}
		RT_CLASS!{class PerceptionInfraredFrameSourceRemovedEventArgs: IPerceptionInfraredFrameSourceRemovedEventArgs}
		DEFINE_IID!(IID_IPerceptionColorFrameSourceAddedEventArgs, 3513513190, 55844, 17452, 187, 213, 85, 84, 155, 91, 148, 243);
		RT_INTERFACE!{interface IPerceptionColorFrameSourceAddedEventArgs(IPerceptionColorFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceAddedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionColorFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSourceAddedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionColorFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionColorFrameSource: IPerceptionColorFrameSource}
		RT_ACTIVATABLE!{IPerceptionColorFrameSourceStatics [CLSID_PerceptionColorFrameSource]}
		DEFINE_CLSID!(CLSID_PerceptionColorFrameSource = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,0]);
		DEFINE_IID!(IID_IPerceptionColorFrameSourceRemovedEventArgs, 3531078249, 60236, 17135, 186, 79, 40, 143, 97, 92, 147, 193);
		RT_INTERFACE!{interface IPerceptionColorFrameSourceRemovedEventArgs(IPerceptionColorFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceRemovedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionColorFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSourceRemovedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionColorFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrameSourceAddedEventArgs, 2477031784, 35832, 17874, 162, 248, 74, 192, 147, 28, 199, 166);
		RT_INTERFACE!{interface IPerceptionDepthFrameSourceAddedEventArgs(IPerceptionDepthFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceAddedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionDepthFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSourceAddedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionDepthFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionDepthFrameSource: IPerceptionDepthFrameSource}
		RT_ACTIVATABLE!{IPerceptionDepthFrameSourceStatics [CLSID_PerceptionDepthFrameSource]}
		DEFINE_CLSID!(CLSID_PerceptionDepthFrameSource = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,0]);
		DEFINE_IID!(IID_IPerceptionDepthFrameSourceRemovedEventArgs, 2696989773, 59756, 19841, 134, 221, 56, 185, 94, 73, 198, 223);
		RT_INTERFACE!{interface IPerceptionDepthFrameSourceRemovedEventArgs(IPerceptionDepthFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceRemovedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionDepthFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSourceRemovedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionDepthFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrameSourceAddedEventArgs, 1832075552, 38350, 18016, 144, 122, 217, 128, 53, 170, 43, 124);
		RT_INTERFACE!{interface IPerceptionInfraredFrameSourceAddedEventArgs(IPerceptionInfraredFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceAddedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionInfraredFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSourceAddedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionInfraredFrameSource: IPerceptionInfraredFrameSource}
		RT_ACTIVATABLE!{IPerceptionInfraredFrameSourceStatics [CLSID_PerceptionInfraredFrameSource]}
		DEFINE_CLSID!(CLSID_PerceptionInfraredFrameSource = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,0]);
		DEFINE_IID!(IID_IPerceptionInfraredFrameSourceRemovedEventArgs, 3927605361, 31344, 19041, 175, 148, 7, 48, 56, 83, 246, 149);
		RT_INTERFACE!{interface IPerceptionInfraredFrameSourceRemovedEventArgs(IPerceptionInfraredFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceRemovedEventArgs] {
			fn get_FrameSource(&mut self, out: *mut *mut PerceptionInfraredFrameSource) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSourceRemovedEventArgs {
			#[inline] pub unsafe fn get_frame_source(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
		RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics(IKnownPerceptionFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_PhysicalDeviceIds(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_FrameKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceModelVersion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_EnclosureLocation(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionFrameSourcePropertiesStatics {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_physical_device_ids(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PhysicalDeviceIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_frame_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_model_version(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceModelVersion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_enclosure_location(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EnclosureLocation)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics2, 2848483441, 1500, 19021, 138, 92, 164, 236, 242, 107, 188, 70);
		RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics2(IKnownPerceptionFrameSourcePropertiesStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics2] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionFrameSourcePropertiesStatics2 {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionVideoFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
		RT_INTERFACE!{static interface IKnownPerceptionVideoFrameSourcePropertiesStatics(IKnownPerceptionVideoFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoFrameSourcePropertiesStatics] {
			fn get_VideoProfile(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SupportedVideoProfiles(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AvailableVideoProfiles(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsMirrored(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_CameraIntrinsics(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionVideoFrameSourcePropertiesStatics {
			#[inline] pub unsafe fn get_video_profile(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoProfile)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_video_profiles(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available_video_profiles(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AvailableVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_mirrored(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_IsMirrored)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_camera_intrinsics(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CameraIntrinsics)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
		RT_INTERFACE!{static interface IKnownPerceptionInfraredFrameSourcePropertiesStatics(IKnownPerceptionInfraredFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics] {
			fn get_Exposure(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AutoExposureEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ExposureCompensation(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ActiveIlluminationEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AmbientSubtractionEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_StructureLightPatternEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_InterleavedIlluminationEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionInfraredFrameSourcePropertiesStatics {
			#[inline] pub unsafe fn get_exposure(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Exposure)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_exposure_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AutoExposureEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_exposure_compensation(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ExposureCompensation)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active_illumination_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ActiveIlluminationEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ambient_subtraction_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AmbientSubtractionEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_structure_light_pattern_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_StructureLightPatternEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interleaved_illumination_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterleavedIlluminationEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionDepthFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 74);
		RT_INTERFACE!{static interface IKnownPerceptionDepthFrameSourcePropertiesStatics(IKnownPerceptionDepthFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionDepthFrameSourcePropertiesStatics] {
			fn get_MinDepth(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MaxDepth(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionDepthFrameSourcePropertiesStatics {
			#[inline] pub unsafe fn get_min_depth(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MinDepth)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_depth(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MaxDepth)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionColorFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 75);
		RT_INTERFACE!{static interface IKnownPerceptionColorFrameSourcePropertiesStatics(IKnownPerceptionColorFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionColorFrameSourcePropertiesStatics] {
			fn get_Exposure(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_AutoExposureEnabled(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ExposureCompensation(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionColorFrameSourcePropertiesStatics {
			#[inline] pub unsafe fn get_exposure(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Exposure)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_exposure_enabled(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AutoExposureEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_exposure_compensation(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ExposureCompensation)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownPerceptionVideoProfilePropertiesStatics, 2399724263, 23158, 17379, 161, 58, 218, 61, 145, 169, 239, 152);
		RT_INTERFACE!{static interface IKnownPerceptionVideoProfilePropertiesStatics(IKnownPerceptionVideoProfilePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoProfilePropertiesStatics] {
			fn get_BitmapPixelFormat(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_BitmapAlphaMode(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Width(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Height(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_FrameDuration(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionVideoProfilePropertiesStatics {
			#[inline] pub unsafe fn get_bitmap_pixel_format(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BitmapPixelFormat)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bitmap_alpha_mode(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BitmapAlphaMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_width(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Width)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_height(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Height)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_frame_duration(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameDuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKnownCameraIntrinsicsPropertiesStatics, 146815352, 17274, 19863, 166, 99, 253, 49, 149, 96, 2, 73);
		RT_INTERFACE!{static interface IKnownCameraIntrinsicsPropertiesStatics(IKnownCameraIntrinsicsPropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownCameraIntrinsicsPropertiesStatics] {
			fn get_FocalLength(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_PrincipalPoint(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_RadialDistortion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_TangentialDistortion(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownCameraIntrinsicsPropertiesStatics {
			#[inline] pub unsafe fn get_focal_length(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FocalLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_principal_point(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PrincipalPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_radial_distortion(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RadialDistortion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tangential_distortion(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TangentialDistortion)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFrameSourcePropertyChangeResult, 506673418, 15504, 19746, 184, 152, 244, 43, 186, 100, 24, 255);
		RT_INTERFACE!{interface IPerceptionFrameSourcePropertyChangeResult(IPerceptionFrameSourcePropertyChangeResultVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertyChangeResult] {
			fn get_Status(&mut self, out: *mut PerceptionFrameSourcePropertyChangeStatus) -> ::w::HRESULT,
			fn get_NewValue(&mut self, out: *mut *mut IInspectable) -> ::w::HRESULT
		}}
		impl IPerceptionFrameSourcePropertyChangeResult {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<PerceptionFrameSourcePropertyChangeStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_new_value(&mut self) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_NewValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionControlSession: IPerceptionControlSession}
		RT_CLASS!{class PerceptionFrameSourcePropertyChangeResult: IPerceptionFrameSourcePropertyChangeResult}
		DEFINE_IID!(IID_IPerceptionFrameSourcePropertiesChangedEventArgs, 1818812520, 48369, 20172, 184, 145, 118, 37, 209, 36, 75, 107);
		RT_INTERFACE!{interface IPerceptionFrameSourcePropertiesChangedEventArgs(IPerceptionFrameSourcePropertiesChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertiesChangedEventArgs] {
			fn get_CollectionChange(&mut self, out: *mut super::super::foundation::collections::CollectionChange) -> ::w::HRESULT,
			fn get_Key(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPerceptionFrameSourcePropertiesChangedEventArgs {
			#[inline] pub unsafe fn get_collection_change(&mut self) -> RtResult<super::super::foundation::collections::CollectionChange> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CollectionChange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_key(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Key)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
		RT_INTERFACE!{static interface IPerceptionInfraredFrameSourceStatics(IPerceptionInfraredFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceStatics] {
			fn CreateWatcher(&mut self, out: *mut *mut PerceptionInfraredFrameSourceWatcher) -> ::w::HRESULT,
			fn FindAllAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionInfraredFrameSource>>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, id: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionInfraredFrameSource>) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSourceStatics {
			#[inline] pub unsafe fn create_watcher(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrameSourceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcher)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionInfraredFrameSource>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, id: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionInfraredFrameSource>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, id.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
		RT_INTERFACE!{static interface IPerceptionDepthFrameSourceStatics(IPerceptionDepthFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceStatics] {
			fn CreateWatcher(&mut self, out: *mut *mut PerceptionDepthFrameSourceWatcher) -> ::w::HRESULT,
			fn FindAllAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionDepthFrameSource>>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, id: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthFrameSource>) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSourceStatics {
			#[inline] pub unsafe fn create_watcher(&mut self) -> RtResult<ComPtr<PerceptionDepthFrameSourceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcher)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionDepthFrameSource>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, id: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthFrameSource>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, id.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionColorFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
		RT_INTERFACE!{static interface IPerceptionColorFrameSourceStatics(IPerceptionColorFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceStatics] {
			fn CreateWatcher(&mut self, out: *mut *mut PerceptionColorFrameSourceWatcher) -> ::w::HRESULT,
			fn FindAllAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionColorFrameSource>>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, id: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionColorFrameSource>) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSourceStatics {
			#[inline] pub unsafe fn create_watcher(&mut self) -> RtResult<ComPtr<PerceptionColorFrameSourceWatcher>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWatcher)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PerceptionColorFrameSource>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, id: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionColorFrameSource>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, id.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionColorFrameSource, 3698178684, 2904, 18061, 156, 161, 109, 176, 76, 192, 71, 124);
		RT_INTERFACE!{interface IPerceptionColorFrameSource(IPerceptionColorFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource] {
			fn add_AvailableChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AvailableChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ActiveChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ActiveChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_PropertiesChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PropertiesChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_VideoProfileChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_VideoProfileChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_CameraIntrinsicsChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CameraIntrinsicsChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Available(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Active(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsControlled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn get_SupportedVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_AvailableVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_VideoProfile(&mut self, out: *mut *mut PerceptionVideoProfile) -> ::w::HRESULT,
			#[cfg(not(feature="windows.media"))] fn __Dummy20(&mut self) -> (),
			#[cfg(feature="windows.media")] fn get_CameraIntrinsics(&mut self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> ::w::HRESULT,
			fn AcquireControlSession(&mut self, out: *mut *mut PerceptionControlSession) -> ::w::HRESULT,
			fn CanControlIndependentlyFrom(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsCorrelatedWith(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn TryGetTransformTo(&mut self, targetId: ::w::HSTRING, result: *mut super::super::foundation::numerics::Matrix4x4, out: *mut bool) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&mut self, correlatedDepthFrameSource: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCoordinateMapperAsync(&mut self, targetSourceId: ::w::HSTRING, correlatedDepthFrameSource: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> ::w::HRESULT,
			fn TrySetVideoProfileAsync(&mut self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> ::w::HRESULT,
			fn OpenReader(&mut self, out: *mut *mut PerceptionColorFrameReader) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSource {
			#[inline] pub unsafe fn add_available_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AvailableChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_available_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AvailableChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_active_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ActiveChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_active_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ActiveChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_properties_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PropertiesChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_properties_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PropertiesChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_video_profile_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_VideoProfileChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_video_profile_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_VideoProfileChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_camera_intrinsics_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CameraIntrinsicsChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_camera_intrinsics_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CameraIntrinsicsChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Available)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Active)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_controlled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsControlled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AvailableVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_video_profile(&mut self) -> RtResult<ComPtr<PerceptionVideoProfile>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoProfile)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_camera_intrinsics(&mut self) -> RtResult<ComPtr<super::super::media::devices::core::CameraIntrinsics>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CameraIntrinsics)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn acquire_control_session(&mut self) -> RtResult<ComPtr<PerceptionControlSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AcquireControlSession)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn can_control_independently_from(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).CanControlIndependentlyFrom)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_correlated_with(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsCorrelatedWith)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_transform_to(&mut self, targetId: &HStringArg) -> RtResult<(super::super::foundation::numerics::Matrix4x4, bool)> {
				let mut result = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryGetTransformTo)(self, targetId.get(), &mut result, &mut out);
				if hr == ::w::S_OK { Ok((result, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_camera_intrinsics_async(&mut self, correlatedDepthFrameSource: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self, correlatedDepthFrameSource as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_coordinate_mapper_async(&mut self, targetSourceId: &HStringArg, correlatedDepthFrameSource: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self, targetSourceId.get(), correlatedDepthFrameSource as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_set_video_profile_async(&mut self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TrySetVideoProfileAsync)(self, controlSession as *const _ as *mut _, profile as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_reader(&mut self) -> RtResult<ComPtr<PerceptionColorFrameReader>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenReader)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionFrameSourcePropertiesChangedEventArgs: IPerceptionFrameSourcePropertiesChangedEventArgs}
		RT_CLASS!{class PerceptionVideoProfile: IPerceptionVideoProfile}
		RT_CLASS!{class PerceptionDepthCorrelatedCameraIntrinsics: IPerceptionDepthCorrelatedCameraIntrinsics}
		RT_CLASS!{class PerceptionDepthCorrelatedCoordinateMapper: IPerceptionDepthCorrelatedCoordinateMapper}
		RT_CLASS!{class PerceptionColorFrameReader: IPerceptionColorFrameReader}
		DEFINE_IID!(IID_IPerceptionColorFrameSource2, 4169140453, 22065, 17901, 173, 152, 140, 106, 160, 76, 251, 145);
		RT_INTERFACE!{interface IPerceptionColorFrameSource2(IPerceptionColorFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource2] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameSource2 {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrameSource, 2043950038, 18427, 19953, 191, 201, 240, 29, 64, 189, 153, 66);
		RT_INTERFACE!{interface IPerceptionDepthFrameSource(IPerceptionDepthFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource] {
			fn add_AvailableChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AvailableChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ActiveChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ActiveChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_PropertiesChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PropertiesChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_VideoProfileChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_VideoProfileChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_CameraIntrinsicsChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CameraIntrinsicsChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Available(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Active(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsControlled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn get_SupportedVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_AvailableVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_VideoProfile(&mut self, out: *mut *mut PerceptionVideoProfile) -> ::w::HRESULT,
			#[cfg(not(feature="windows.media"))] fn __Dummy20(&mut self) -> (),
			#[cfg(feature="windows.media")] fn get_CameraIntrinsics(&mut self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> ::w::HRESULT,
			fn AcquireControlSession(&mut self, out: *mut *mut PerceptionControlSession) -> ::w::HRESULT,
			fn CanControlIndependentlyFrom(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsCorrelatedWith(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn TryGetTransformTo(&mut self, targetId: ::w::HSTRING, result: *mut super::super::foundation::numerics::Matrix4x4, out: *mut bool) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&mut self, target: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCoordinateMapperAsync(&mut self, targetId: ::w::HSTRING, depthFrameSourceToMapWith: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> ::w::HRESULT,
			fn TrySetVideoProfileAsync(&mut self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> ::w::HRESULT,
			fn OpenReader(&mut self, out: *mut *mut PerceptionDepthFrameReader) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSource {
			#[inline] pub unsafe fn add_available_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AvailableChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_available_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AvailableChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_active_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ActiveChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_active_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ActiveChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_properties_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PropertiesChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_properties_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PropertiesChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_video_profile_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_VideoProfileChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_video_profile_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_VideoProfileChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_camera_intrinsics_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CameraIntrinsicsChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_camera_intrinsics_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CameraIntrinsicsChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Available)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Active)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_controlled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsControlled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AvailableVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_video_profile(&mut self) -> RtResult<ComPtr<PerceptionVideoProfile>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoProfile)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_camera_intrinsics(&mut self) -> RtResult<ComPtr<super::super::media::devices::core::CameraIntrinsics>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CameraIntrinsics)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn acquire_control_session(&mut self) -> RtResult<ComPtr<PerceptionControlSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AcquireControlSession)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn can_control_independently_from(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).CanControlIndependentlyFrom)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_correlated_with(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsCorrelatedWith)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_transform_to(&mut self, targetId: &HStringArg) -> RtResult<(super::super::foundation::numerics::Matrix4x4, bool)> {
				let mut result = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryGetTransformTo)(self, targetId.get(), &mut result, &mut out);
				if hr == ::w::S_OK { Ok((result, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_camera_intrinsics_async(&mut self, target: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self, target as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_coordinate_mapper_async(&mut self, targetId: &HStringArg, depthFrameSourceToMapWith: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self, targetId.get(), depthFrameSourceToMapWith as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_set_video_profile_async(&mut self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TrySetVideoProfileAsync)(self, controlSession as *const _ as *mut _, profile as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_reader(&mut self) -> RtResult<ComPtr<PerceptionDepthFrameReader>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenReader)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionDepthFrameReader: IPerceptionDepthFrameReader}
		DEFINE_IID!(IID_IPerceptionDepthFrameSource2, 3822206254, 28204, 20077, 145, 217, 112, 76, 216, 223, 247, 157);
		RT_INTERFACE!{interface IPerceptionDepthFrameSource2(IPerceptionDepthFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource2] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameSource2 {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrameSource, 1437632322, 6152, 18766, 158, 48, 157, 42, 123, 232, 247, 0);
		RT_INTERFACE!{interface IPerceptionInfraredFrameSource(IPerceptionInfraredFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource] {
			fn add_AvailableChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AvailableChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ActiveChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ActiveChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_PropertiesChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PropertiesChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_VideoProfileChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_VideoProfileChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_CameraIntrinsicsChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CameraIntrinsicsChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Available(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Active(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsControlled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT,
			fn get_SupportedVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_AvailableVideoProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PerceptionVideoProfile>) -> ::w::HRESULT,
			fn get_VideoProfile(&mut self, out: *mut *mut PerceptionVideoProfile) -> ::w::HRESULT,
			#[cfg(not(feature="windows.media"))] fn __Dummy20(&mut self) -> (),
			#[cfg(feature="windows.media")] fn get_CameraIntrinsics(&mut self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> ::w::HRESULT,
			fn AcquireControlSession(&mut self, out: *mut *mut PerceptionControlSession) -> ::w::HRESULT,
			fn CanControlIndependentlyFrom(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsCorrelatedWith(&mut self, targetId: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn TryGetTransformTo(&mut self, targetId: ::w::HSTRING, result: *mut super::super::foundation::numerics::Matrix4x4, out: *mut bool) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&mut self, target: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> ::w::HRESULT,
			fn TryGetDepthCorrelatedCoordinateMapperAsync(&mut self, targetId: ::w::HSTRING, depthFrameSourceToMapWith: *mut PerceptionDepthFrameSource, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> ::w::HRESULT,
			fn TrySetVideoProfileAsync(&mut self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> ::w::HRESULT,
			fn OpenReader(&mut self, out: *mut *mut PerceptionInfraredFrameReader) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSource {
			#[inline] pub unsafe fn add_available_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AvailableChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_available_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AvailableChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_active_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ActiveChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_active_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ActiveChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_properties_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PropertiesChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_properties_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PropertiesChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_video_profile_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_VideoProfileChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_video_profile_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_VideoProfileChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_camera_intrinsics_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CameraIntrinsicsChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_camera_intrinsics_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CameraIntrinsicsChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Available)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Active)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_controlled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsControlled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available_video_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PerceptionVideoProfile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AvailableVideoProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_video_profile(&mut self) -> RtResult<ComPtr<PerceptionVideoProfile>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoProfile)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_camera_intrinsics(&mut self) -> RtResult<ComPtr<super::super::media::devices::core::CameraIntrinsics>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CameraIntrinsics)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn acquire_control_session(&mut self) -> RtResult<ComPtr<PerceptionControlSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AcquireControlSession)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn can_control_independently_from(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).CanControlIndependentlyFrom)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_correlated_with(&mut self, targetId: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsCorrelatedWith)(self, targetId.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_transform_to(&mut self, targetId: &HStringArg) -> RtResult<(super::super::foundation::numerics::Matrix4x4, bool)> {
				let mut result = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryGetTransformTo)(self, targetId.get(), &mut result, &mut out);
				if hr == ::w::S_OK { Ok((result, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_camera_intrinsics_async(&mut self, target: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self, target as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_get_depth_correlated_coordinate_mapper_async(&mut self, targetId: &HStringArg, depthFrameSourceToMapWith: &PerceptionDepthFrameSource) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self, targetId.get(), depthFrameSourceToMapWith as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_set_video_profile_async(&mut self, controlSession: &PerceptionControlSession, profile: &PerceptionVideoProfile) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TrySetVideoProfileAsync)(self, controlSession as *const _ as *mut _, profile as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_reader(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrameReader>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenReader)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionInfraredFrameReader: IPerceptionInfraredFrameReader}
		DEFINE_IID!(IID_IPerceptionInfraredFrameSource2, 3704936344, 19211, 17152, 141, 133, 65, 8, 23, 250, 160, 50);
		RT_INTERFACE!{interface IPerceptionInfraredFrameSource2(IPerceptionInfraredFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource2] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameSource2 {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionVideoProfile, 1970683555, 282, 18190, 130, 37, 111, 5, 173, 226, 86, 72);
		RT_INTERFACE!{interface IPerceptionVideoProfile(IPerceptionVideoProfileVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoProfile] {
			#[cfg(not(feature="windows.graphics"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_BitmapPixelFormat(&mut self, out: *mut super::super::graphics::imaging::BitmapPixelFormat) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_BitmapAlphaMode(&mut self, out: *mut super::super::graphics::imaging::BitmapAlphaMode) -> ::w::HRESULT,
			fn get_Width(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Height(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_FrameDuration(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn IsEqual(&mut self, other: *mut PerceptionVideoProfile, out: *mut bool) -> ::w::HRESULT
		}}
		impl IPerceptionVideoProfile {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_bitmap_pixel_format(&mut self) -> RtResult<super::super::graphics::imaging::BitmapPixelFormat> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BitmapPixelFormat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_bitmap_alpha_mode(&mut self) -> RtResult<super::super::graphics::imaging::BitmapAlphaMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BitmapAlphaMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_width(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Width)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_height(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Height)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_frame_duration(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_FrameDuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_equal(&mut self, other: &PerceptionVideoProfile) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEqual)(self, other as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionColorFrameArrivedEventArgs: IPerceptionColorFrameArrivedEventArgs}
		RT_CLASS!{class PerceptionColorFrame: IPerceptionColorFrame}
		RT_CLASS!{class PerceptionDepthFrameArrivedEventArgs: IPerceptionDepthFrameArrivedEventArgs}
		RT_CLASS!{class PerceptionDepthFrame: IPerceptionDepthFrame}
		RT_CLASS!{class PerceptionInfraredFrameArrivedEventArgs: IPerceptionInfraredFrameArrivedEventArgs}
		RT_CLASS!{class PerceptionInfraredFrame: IPerceptionInfraredFrame}
		DEFINE_IID!(IID_IPerceptionColorFrameArrivedEventArgs, 2410480341, 34551, 19853, 185, 102, 90, 55, 97, 186, 159, 89);
		RT_INTERFACE!{interface IPerceptionColorFrameArrivedEventArgs(IPerceptionColorFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameArrivedEventArgs] {
			fn get_RelativeTime(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn TryOpenFrame(&mut self, out: *mut *mut PerceptionColorFrame) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameArrivedEventArgs {
			#[inline] pub unsafe fn get_relative_time(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RelativeTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_open_frame(&mut self) -> RtResult<ComPtr<PerceptionColorFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryOpenFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrameArrivedEventArgs, 1144858034, 45698, 17975, 145, 115, 172, 151, 132, 53, 201, 133);
		RT_INTERFACE!{interface IPerceptionDepthFrameArrivedEventArgs(IPerceptionDepthFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameArrivedEventArgs] {
			fn get_RelativeTime(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn TryOpenFrame(&mut self, out: *mut *mut PerceptionDepthFrame) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameArrivedEventArgs {
			#[inline] pub unsafe fn get_relative_time(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RelativeTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_open_frame(&mut self) -> RtResult<ComPtr<PerceptionDepthFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryOpenFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrameArrivedEventArgs, 2675440327, 46269, 18519, 157, 80, 190, 142, 240, 117, 218, 239);
		RT_INTERFACE!{interface IPerceptionInfraredFrameArrivedEventArgs(IPerceptionInfraredFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameArrivedEventArgs] {
			fn get_RelativeTime(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn TryOpenFrame(&mut self, out: *mut *mut PerceptionInfraredFrame) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameArrivedEventArgs {
			#[inline] pub unsafe fn get_relative_time(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RelativeTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_open_frame(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryOpenFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthCorrelatedCameraIntrinsics, 1699269121, 34526, 23521, 101, 130, 128, 127, 207, 76, 149, 207);
		RT_INTERFACE!{interface IPerceptionDepthCorrelatedCameraIntrinsics(IPerceptionDepthCorrelatedCameraIntrinsicsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCameraIntrinsics] {
			fn UnprojectPixelAtCorrelatedDepth(&mut self, pixelCoordinate: super::super::foundation::Point, depthFrame: *mut PerceptionDepthFrame, out: *mut super::super::foundation::numerics::Vector3) -> ::w::HRESULT,
			fn UnprojectPixelsAtCorrelatedDepth(&mut self, sourceCoordinatesSize: u32, sourceCoordinates: *mut super::super::foundation::Point, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3) -> ::w::HRESULT,
			fn UnprojectRegionPixelsAtCorrelatedDepthAsync(&mut self, region: super::super::foundation::Rect, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn UnprojectAllPixelsAtCorrelatedDepthAsync(&mut self, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT
		}}
		impl IPerceptionDepthCorrelatedCameraIntrinsics {
			#[inline] pub unsafe fn unproject_pixel_at_correlated_depth(&mut self, pixelCoordinate: super::super::foundation::Point, depthFrame: &PerceptionDepthFrame) -> RtResult<super::super::foundation::numerics::Vector3> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).UnprojectPixelAtCorrelatedDepth)(self, pixelCoordinate, depthFrame as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unproject_pixels_at_correlated_depth(&mut self, sourceCoordinates: &[super::super::foundation::Point], depthFrame: &PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UnprojectPixelsAtCorrelatedDepth)(self, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, depthFrame as *const _ as *mut _, resultsSize, results);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unproject_region_pixels_at_correlated_depth_async(&mut self, region: super::super::foundation::Rect, depthFrame: &PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UnprojectRegionPixelsAtCorrelatedDepthAsync)(self, region, depthFrame as *const _ as *mut _, resultsSize, results, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unproject_all_pixels_at_correlated_depth_async(&mut self, depthFrame: &PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::numerics::Vector3) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UnprojectAllPixelsAtCorrelatedDepthAsync)(self, depthFrame as *const _ as *mut _, resultsSize, results, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthCorrelatedCoordinateMapper, 1531813149, 46582, 18076, 184, 194, 185, 122, 69, 230, 134, 59);
		RT_INTERFACE!{interface IPerceptionDepthCorrelatedCoordinateMapper(IPerceptionDepthCorrelatedCoordinateMapperVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCoordinateMapper] {
			fn MapPixelToTarget(&mut self, sourcePixelCoordinate: super::super::foundation::Point, depthFrame: *mut PerceptionDepthFrame, out: *mut super::super::foundation::Point) -> ::w::HRESULT,
			fn MapPixelsToTarget(&mut self, sourceCoordinatesSize: u32, sourceCoordinates: *mut super::super::foundation::Point, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::Point) -> ::w::HRESULT,
			fn MapRegionOfPixelsToTargetAsync(&mut self, region: super::super::foundation::Rect, depthFrame: *mut PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut super::super::foundation::Point, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn MapAllPixelsToTargetAsync(&mut self, depthFrame: *mut PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut super::super::foundation::Point, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT
		}}
		impl IPerceptionDepthCorrelatedCoordinateMapper {
			#[inline] pub unsafe fn map_pixel_to_target(&mut self, sourcePixelCoordinate: super::super::foundation::Point, depthFrame: &PerceptionDepthFrame) -> RtResult<super::super::foundation::Point> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).MapPixelToTarget)(self, sourcePixelCoordinate, depthFrame as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn map_pixels_to_target(&mut self, sourceCoordinates: &[super::super::foundation::Point], depthFrame: &PerceptionDepthFrame, resultsSize: u32, results: *mut super::super::foundation::Point) -> RtResult<()> {
				let hr = ((*self.lpVtbl).MapPixelsToTarget)(self, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, depthFrame as *const _ as *mut _, resultsSize, results);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn map_region_of_pixels_to_target_async(&mut self, region: super::super::foundation::Rect, depthFrame: &PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut super::super::foundation::Point) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).MapRegionOfPixelsToTargetAsync)(self, region, depthFrame as *const _ as *mut _, targetCoordinatesSize, targetCoordinates, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn map_all_pixels_to_target_async(&mut self, depthFrame: &PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut super::super::foundation::Point) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).MapAllPixelsToTargetAsync)(self, depthFrame as *const _ as *mut _, targetCoordinatesSize, targetCoordinates, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IKnownPerceptionFrameSourcePropertiesStatics [CLSID_KnownPerceptionFrameSourceProperties]}
		RT_ACTIVATABLE!{IKnownPerceptionFrameSourcePropertiesStatics2 [CLSID_KnownPerceptionFrameSourceProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionFrameSourceProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownPerceptionVideoFrameSourcePropertiesStatics [CLSID_KnownPerceptionVideoFrameSourceProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionVideoFrameSourceProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownPerceptionInfraredFrameSourcePropertiesStatics [CLSID_KnownPerceptionInfraredFrameSourceProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionInfraredFrameSourceProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownPerceptionDepthFrameSourcePropertiesStatics [CLSID_KnownPerceptionDepthFrameSourceProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionDepthFrameSourceProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownPerceptionColorFrameSourcePropertiesStatics [CLSID_KnownPerceptionColorFrameSourceProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionColorFrameSourceProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownPerceptionVideoProfilePropertiesStatics [CLSID_KnownPerceptionVideoProfileProperties]}
		DEFINE_CLSID!(CLSID_KnownPerceptionVideoProfileProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,80,114,111,102,105,108,101,80,114,111,112,101,114,116,105,101,115,0]);
		RT_ACTIVATABLE!{IKnownCameraIntrinsicsPropertiesStatics [CLSID_KnownCameraIntrinsicsProperties]}
		DEFINE_CLSID!(CLSID_KnownCameraIntrinsicsProperties = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,67,97,109,101,114,97,73,110,116,114,105,110,115,105,99,115,80,114,111,112,101,114,116,105,101,115,0]);
		DEFINE_IID!(IID_IPerceptionControlSession, 2576975443, 23101, 16767, 146, 57, 241, 136, 158, 84, 139, 72);
		RT_INTERFACE!{interface IPerceptionControlSession(IPerceptionControlSessionVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlSession] {
			fn add_ControlLost(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionControlSession, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ControlLost(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn TrySetPropertyAsync(&mut self, name: ::w::HSTRING, value: *mut IInspectable, out: *mut *mut super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> ::w::HRESULT
		}}
		impl IPerceptionControlSession {
			#[inline] pub unsafe fn add_control_lost(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionControlSession, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ControlLost)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_control_lost(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ControlLost)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_set_property_async(&mut self, name: &HStringArg, value: &IInspectable) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TrySetPropertyAsync)(self, name.get(), value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionColorFrameReader, 1985017198, 47605, 17947, 131, 173, 242, 34, 175, 42, 170, 220);
		RT_INTERFACE!{interface IPerceptionColorFrameReader(IPerceptionColorFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameReader] {
			fn add_FrameArrived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_FrameArrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Source(&mut self, out: *mut *mut PerceptionColorFrameSource) -> ::w::HRESULT,
			fn get_IsPaused(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsPaused(&mut self, value: bool) -> ::w::HRESULT,
			fn TryReadLatestFrame(&mut self, out: *mut *mut PerceptionColorFrame) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrameReader {
			#[inline] pub unsafe fn add_frame_arrived(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_FrameArrived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_frame_arrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_FrameArrived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_source(&mut self) -> RtResult<ComPtr<PerceptionColorFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Source)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paused(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaused)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_paused(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsPaused)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_read_latest_frame(&mut self) -> RtResult<ComPtr<PerceptionColorFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryReadLatestFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrameReader, 2980298911, 10651, 17938, 164, 247, 39, 15, 37, 160, 150, 236);
		RT_INTERFACE!{interface IPerceptionDepthFrameReader(IPerceptionDepthFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameReader] {
			fn add_FrameArrived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_FrameArrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Source(&mut self, out: *mut *mut PerceptionDepthFrameSource) -> ::w::HRESULT,
			fn get_IsPaused(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsPaused(&mut self, value: bool) -> ::w::HRESULT,
			fn TryReadLatestFrame(&mut self, out: *mut *mut PerceptionDepthFrame) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrameReader {
			#[inline] pub unsafe fn add_frame_arrived(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_FrameArrived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_frame_arrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_FrameArrived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_source(&mut self) -> RtResult<ComPtr<PerceptionDepthFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Source)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paused(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaused)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_paused(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsPaused)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_read_latest_frame(&mut self) -> RtResult<ComPtr<PerceptionDepthFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryReadLatestFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrameReader, 2036387352, 54171, 20424, 160, 74, 146, 151, 52, 198, 117, 108);
		RT_INTERFACE!{interface IPerceptionInfraredFrameReader(IPerceptionInfraredFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameReader] {
			fn add_FrameArrived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_FrameArrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_Source(&mut self, out: *mut *mut PerceptionInfraredFrameSource) -> ::w::HRESULT,
			fn get_IsPaused(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsPaused(&mut self, value: bool) -> ::w::HRESULT,
			fn TryReadLatestFrame(&mut self, out: *mut *mut PerceptionInfraredFrame) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrameReader {
			#[inline] pub unsafe fn add_frame_arrived(&mut self, handler: &super::super::foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_FrameArrived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_frame_arrived(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_FrameArrived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_source(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrameSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Source)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paused(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaused)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_paused(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsPaused)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn try_read_latest_frame(&mut self) -> RtResult<ComPtr<PerceptionInfraredFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TryReadLatestFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionColorFrame, 4267840841, 11455, 20372, 152, 97, 248, 23, 234, 49, 119, 71);
		RT_INTERFACE!{interface IPerceptionColorFrame(IPerceptionColorFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrame] {
			#[cfg(feature="windows.media")] fn get_VideoFrame(&mut self, out: *mut *mut super::super::media::VideoFrame) -> ::w::HRESULT
		}}
		impl IPerceptionColorFrame {
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_video_frame(&mut self) -> RtResult<ComPtr<super::super::media::VideoFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionDepthFrame, 2742780412, 39174, 20477, 145, 97, 0, 36, 179, 96, 182, 87);
		RT_INTERFACE!{interface IPerceptionDepthFrame(IPerceptionDepthFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrame] {
			#[cfg(feature="windows.media")] fn get_VideoFrame(&mut self, out: *mut *mut super::super::media::VideoFrame) -> ::w::HRESULT
		}}
		impl IPerceptionDepthFrame {
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_video_frame(&mut self) -> RtResult<ComPtr<super::super::media::VideoFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionInfraredFrame, 2961728118, 33950, 19578, 138, 230, 181, 96, 100, 83, 33, 83);
		RT_INTERFACE!{interface IPerceptionInfraredFrame(IPerceptionInfraredFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrame] {
			#[cfg(feature="windows.media")] fn get_VideoFrame(&mut self, out: *mut *mut super::super::media::VideoFrame) -> ::w::HRESULT
		}}
		impl IPerceptionInfraredFrame {
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn get_video_frame(&mut self) -> RtResult<ComPtr<super::super::media::VideoFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
pub mod provider { // Windows.Devices.Perception.Provider
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IKnownPerceptionFrameKindStatics, 988172758, 38505, 16646, 159, 174, 72, 53, 193, 185, 97, 4);
		RT_INTERFACE!{static interface IKnownPerceptionFrameKindStatics(IKnownPerceptionFrameKindStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameKindStatics] {
			fn get_Color(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Depth(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Infrared(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IKnownPerceptionFrameKindStatics {
			#[inline] pub unsafe fn get_color(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Color)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_depth(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Depth)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_infrared(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Infrared)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFrameProviderManagerServiceStatics, 2927855334, 51929, 17241, 143, 150, 142, 174, 81, 129, 5, 38);
		RT_INTERFACE!{static interface IPerceptionFrameProviderManagerServiceStatics(IPerceptionFrameProviderManagerServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManagerServiceStatics] {
			fn RegisterFrameProviderInfo(&mut self, manager: *mut IPerceptionFrameProviderManager, frameProviderInfo: *mut PerceptionFrameProviderInfo) -> ::w::HRESULT,
			fn UnregisterFrameProviderInfo(&mut self, manager: *mut IPerceptionFrameProviderManager, frameProviderInfo: *mut PerceptionFrameProviderInfo) -> ::w::HRESULT,
			fn RegisterFaceAuthenticationGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, faceAuthenticationGroup: *mut PerceptionFaceAuthenticationGroup) -> ::w::HRESULT,
			fn UnregisterFaceAuthenticationGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, faceAuthenticationGroup: *mut PerceptionFaceAuthenticationGroup) -> ::w::HRESULT,
			fn RegisterControlGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, controlGroup: *mut PerceptionControlGroup) -> ::w::HRESULT,
			fn UnregisterControlGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, controlGroup: *mut PerceptionControlGroup) -> ::w::HRESULT,
			fn RegisterCorrelationGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, correlationGroup: *mut PerceptionCorrelationGroup) -> ::w::HRESULT,
			fn UnregisterCorrelationGroup(&mut self, manager: *mut IPerceptionFrameProviderManager, correlationGroup: *mut PerceptionCorrelationGroup) -> ::w::HRESULT,
			fn UpdateAvailabilityForProvider(&mut self, provider: *mut IPerceptionFrameProvider, available: bool) -> ::w::HRESULT,
			fn PublishFrameForProvider(&mut self, provider: *mut IPerceptionFrameProvider, frame: *mut PerceptionFrame) -> ::w::HRESULT
		}}
		impl IPerceptionFrameProviderManagerServiceStatics {
			#[inline] pub unsafe fn register_frame_provider_info(&mut self, manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RegisterFrameProviderInfo)(self, manager as *const _ as *mut _, frameProviderInfo as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unregister_frame_provider_info(&mut self, manager: &IPerceptionFrameProviderManager, frameProviderInfo: &PerceptionFrameProviderInfo) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UnregisterFrameProviderInfo)(self, manager as *const _ as *mut _, frameProviderInfo as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn register_face_authentication_group(&mut self, manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RegisterFaceAuthenticationGroup)(self, manager as *const _ as *mut _, faceAuthenticationGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unregister_face_authentication_group(&mut self, manager: &IPerceptionFrameProviderManager, faceAuthenticationGroup: &PerceptionFaceAuthenticationGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UnregisterFaceAuthenticationGroup)(self, manager as *const _ as *mut _, faceAuthenticationGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn register_control_group(&mut self, manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RegisterControlGroup)(self, manager as *const _ as *mut _, controlGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unregister_control_group(&mut self, manager: &IPerceptionFrameProviderManager, controlGroup: &PerceptionControlGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UnregisterControlGroup)(self, manager as *const _ as *mut _, controlGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn register_correlation_group(&mut self, manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RegisterCorrelationGroup)(self, manager as *const _ as *mut _, correlationGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn unregister_correlation_group(&mut self, manager: &IPerceptionFrameProviderManager, correlationGroup: &PerceptionCorrelationGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UnregisterCorrelationGroup)(self, manager as *const _ as *mut _, correlationGroup as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_availability_for_provider(&mut self, provider: &IPerceptionFrameProvider, available: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).UpdateAvailabilityForProvider)(self, provider as *const _ as *mut _, available);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn publish_frame_for_provider(&mut self, provider: &IPerceptionFrameProvider, frame: &PerceptionFrame) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PublishFrameForProvider)(self, provider as *const _ as *mut _, frame as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionFrameProviderInfo: IPerceptionFrameProviderInfo}
		RT_CLASS!{class PerceptionPropertyChangeRequest: IPerceptionPropertyChangeRequest}
		RT_CLASS!{class PerceptionFaceAuthenticationGroup: IPerceptionFaceAuthenticationGroup [IPerceptionFaceAuthenticationGroupFactory] [CLSID_PerceptionFaceAuthenticationGroup]}
		DEFINE_CLSID!(CLSID_PerceptionFaceAuthenticationGroup = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,97,99,101,65,117,116,104,101,110,116,105,99,97,116,105,111,110,71,114,111,117,112,0]);
		RT_CLASS!{class PerceptionControlGroup: IPerceptionControlGroup [IPerceptionControlGroupFactory] [CLSID_PerceptionControlGroup]}
		DEFINE_CLSID!(CLSID_PerceptionControlGroup = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,110,116,114,111,108,71,114,111,117,112,0]);
		RT_CLASS!{class PerceptionCorrelationGroup: IPerceptionCorrelationGroup [IPerceptionCorrelationGroupFactory] [CLSID_PerceptionCorrelationGroup]}
		DEFINE_CLSID!(CLSID_PerceptionCorrelationGroup = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,71,114,111,117,112,0]);
		RT_CLASS!{class PerceptionFrame: IPerceptionFrame}
		DEFINE_IID!(IID_IPerceptionFrameProviderInfo, 3433650664, 31102, 20099, 155, 135, 3, 106, 116, 20, 47, 196);
		RT_INTERFACE!{interface IPerceptionFrameProviderInfo(IPerceptionFrameProviderInfoVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderInfo] {
			fn get_Id(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Id(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_DisplayName(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_DeviceKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_DeviceKind(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_FrameKind(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_FrameKind(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			fn get_Hidden(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_Hidden(&mut self, value: bool) -> ::w::HRESULT
		}}
		impl IPerceptionFrameProviderInfo {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_id(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Id)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_display_name(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DisplayName)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_device_kind(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DeviceKind)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_frame_kind(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_frame_kind(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_FrameKind)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hidden(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Hidden)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_hidden(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Hidden)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionControlGroupFactory, 790295264, 47857, 17723, 190, 212, 205, 157, 70, 25, 21, 76);
		RT_INTERFACE!{static interface IPerceptionControlGroupFactory(IPerceptionControlGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroupFactory] {
			fn Create(&mut self, ids: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut PerceptionControlGroup) -> ::w::HRESULT
		}}
		impl IPerceptionControlGroupFactory {
			#[inline] pub unsafe fn create(&mut self, ids: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<PerceptionControlGroup>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, ids as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionControlGroup, 388778114, 12249, 19534, 186, 52, 253, 242, 10, 115, 221, 229);
		RT_INTERFACE!{interface IPerceptionControlGroup(IPerceptionControlGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroup] {
			fn get_FrameProviderIds(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> ::w::HRESULT
		}}
		impl IPerceptionControlGroup {
			#[inline] pub unsafe fn get_frame_provider_ids(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameProviderIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_PerceptionStartFaceAuthenticationHandler, 1954639146, 8336, 18032, 140, 72, 239, 57, 231, 255, 124, 38);
		RT_DELEGATE!{delegate PerceptionStartFaceAuthenticationHandler(PerceptionStartFaceAuthenticationHandlerVtbl, PerceptionStartFaceAuthenticationHandlerImpl) [IID_PerceptionStartFaceAuthenticationHandler] {
			fn Invoke(&mut self, sender: *mut PerceptionFaceAuthenticationGroup, out: *mut bool) -> ::w::HRESULT
		}}
		impl PerceptionStartFaceAuthenticationHandler {
			#[inline] pub unsafe fn invoke(&mut self, sender: &PerceptionFaceAuthenticationGroup) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_PerceptionStopFaceAuthenticationHandler, 947840682, 35277, 18462, 170, 222, 221, 146, 247, 11, 42, 215);
		RT_DELEGATE!{delegate PerceptionStopFaceAuthenticationHandler(PerceptionStopFaceAuthenticationHandlerVtbl, PerceptionStopFaceAuthenticationHandlerImpl) [IID_PerceptionStopFaceAuthenticationHandler] {
			fn Invoke(&mut self, sender: *mut PerceptionFaceAuthenticationGroup) -> ::w::HRESULT
		}}
		impl PerceptionStopFaceAuthenticationHandler {
			#[inline] pub unsafe fn invoke(&mut self, sender: &PerceptionFaceAuthenticationGroup) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroupFactory, 3867805140, 46604, 16628, 188, 185, 242, 77, 70, 70, 115, 32);
		RT_INTERFACE!{static interface IPerceptionFaceAuthenticationGroupFactory(IPerceptionFaceAuthenticationGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroupFactory] {
			fn Create(&mut self, ids: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, startHandler: *mut PerceptionStartFaceAuthenticationHandler, stopHandler: *mut PerceptionStopFaceAuthenticationHandler, out: *mut *mut PerceptionFaceAuthenticationGroup) -> ::w::HRESULT
		}}
		impl IPerceptionFaceAuthenticationGroupFactory {
			#[inline] pub unsafe fn create(&mut self, ids: &::rt::gen::windows::foundation::collections::IIterable<HString>, startHandler: &PerceptionStartFaceAuthenticationHandler, stopHandler: &PerceptionStopFaceAuthenticationHandler) -> RtResult<ComPtr<PerceptionFaceAuthenticationGroup>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, ids as *const _ as *mut _, startHandler as *const _ as *mut _, stopHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroup, 3892418580, 19089, 16816, 131, 166, 136, 26, 23, 117, 53, 62);
		RT_INTERFACE!{interface IPerceptionFaceAuthenticationGroup(IPerceptionFaceAuthenticationGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroup] {
			fn get_FrameProviderIds(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> ::w::HRESULT
		}}
		impl IPerceptionFaceAuthenticationGroup {
			#[inline] pub unsafe fn get_frame_provider_ids(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameProviderIds)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionCorrelationFactory, 3567698981, 10372, 19087, 129, 52, 40, 53, 215, 40, 108, 191);
		RT_INTERFACE!{static interface IPerceptionCorrelationFactory(IPerceptionCorrelationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationFactory] {
			fn Create(&mut self, targetId: ::w::HSTRING, position: ::rt::gen::windows::foundation::numerics::Vector3, orientation: ::rt::gen::windows::foundation::numerics::Quaternion, out: *mut *mut PerceptionCorrelation) -> ::w::HRESULT
		}}
		impl IPerceptionCorrelationFactory {
			#[inline] pub unsafe fn create(&mut self, targetId: &HStringArg, position: ::rt::gen::windows::foundation::numerics::Vector3, orientation: ::rt::gen::windows::foundation::numerics::Quaternion) -> RtResult<ComPtr<PerceptionCorrelation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, targetId.get(), position, orientation, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionCorrelation: IPerceptionCorrelation [IPerceptionCorrelationFactory] [CLSID_PerceptionCorrelation]}
		DEFINE_CLSID!(CLSID_PerceptionCorrelation = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,0]);
		DEFINE_IID!(IID_IPerceptionCorrelation, 3021150850, 57333, 16455, 138, 25, 59, 77, 128, 95, 113, 118);
		RT_INTERFACE!{interface IPerceptionCorrelation(IPerceptionCorrelationVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelation] {
			fn get_TargetId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Position(&mut self, out: *mut ::rt::gen::windows::foundation::numerics::Vector3) -> ::w::HRESULT,
			fn get_Orientation(&mut self, out: *mut ::rt::gen::windows::foundation::numerics::Quaternion) -> ::w::HRESULT
		}}
		impl IPerceptionCorrelation {
			#[inline] pub unsafe fn get_target_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_TargetId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_position(&mut self) -> RtResult<::rt::gen::windows::foundation::numerics::Vector3> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Position)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_orientation(&mut self) -> RtResult<::rt::gen::windows::foundation::numerics::Quaternion> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Orientation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionCorrelationGroupFactory, 2113806472, 25567, 18669, 131, 177, 74, 184, 41, 19, 41, 149);
		RT_INTERFACE!{static interface IPerceptionCorrelationGroupFactory(IPerceptionCorrelationGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroupFactory] {
			fn Create(&mut self, relativeLocations: *mut ::rt::gen::windows::foundation::collections::IIterable<PerceptionCorrelation>, out: *mut *mut PerceptionCorrelationGroup) -> ::w::HRESULT
		}}
		impl IPerceptionCorrelationGroupFactory {
			#[inline] pub unsafe fn create(&mut self, relativeLocations: &::rt::gen::windows::foundation::collections::IIterable<PerceptionCorrelation>) -> RtResult<ComPtr<PerceptionCorrelationGroup>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, relativeLocations as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionCorrelationGroup, 1965689094, 13991, 18363, 155, 121, 86, 204, 107, 116, 103, 112);
		RT_INTERFACE!{interface IPerceptionCorrelationGroup(IPerceptionCorrelationGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroup] {
			fn get_RelativeLocations(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<PerceptionCorrelation>) -> ::w::HRESULT
		}}
		impl IPerceptionCorrelationGroup {
			#[inline] pub unsafe fn get_relative_locations(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<PerceptionCorrelation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RelativeLocations)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFrame, 2097051685, 21691, 19869, 190, 197, 142, 246, 97, 81, 210, 172);
		RT_INTERFACE!{interface IPerceptionFrame(IPerceptionFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrame] {
			fn get_RelativeTime(&mut self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_RelativeTime(&mut self, value: ::rt::gen::windows::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::ValueSet) -> ::w::HRESULT,
			fn get_FrameData(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IMemoryBuffer) -> ::w::HRESULT
		}}
		impl IPerceptionFrame {
			#[inline] pub unsafe fn get_relative_time(&mut self) -> RtResult<::rt::gen::windows::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RelativeTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_relative_time(&mut self, value: ::rt::gen::windows::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RelativeTime)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::ValueSet>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_frame_data(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IMemoryBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionVideoFrameAllocatorFactory, 442020065, 59674, 18462, 184, 118, 168, 158, 43, 188, 107, 51);
		RT_INTERFACE!{static interface IPerceptionVideoFrameAllocatorFactory(IPerceptionVideoFrameAllocatorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocatorFactory] {
			#[cfg(feature="windows.graphics")] fn Create(&mut self, maxOutstandingFrameCountForWrite: u32, format: ::rt::gen::windows::graphics::imaging::BitmapPixelFormat, resolution: ::rt::gen::windows::foundation::Size, alpha: ::rt::gen::windows::graphics::imaging::BitmapAlphaMode, out: *mut *mut PerceptionVideoFrameAllocator) -> ::w::HRESULT
		}}
		impl IPerceptionVideoFrameAllocatorFactory {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn create(&mut self, maxOutstandingFrameCountForWrite: u32, format: ::rt::gen::windows::graphics::imaging::BitmapPixelFormat, resolution: ::rt::gen::windows::foundation::Size, alpha: ::rt::gen::windows::graphics::imaging::BitmapAlphaMode) -> RtResult<ComPtr<PerceptionVideoFrameAllocator>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, maxOutstandingFrameCountForWrite, format, resolution, alpha, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PerceptionVideoFrameAllocator: IPerceptionVideoFrameAllocator [IPerceptionVideoFrameAllocatorFactory] [CLSID_PerceptionVideoFrameAllocator]}
		DEFINE_CLSID!(CLSID_PerceptionVideoFrameAllocator = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,65,108,108,111,99,97,116,111,114,0]);
		DEFINE_IID!(IID_IPerceptionPropertyChangeRequest, 1012591441, 13579, 19960, 148, 20, 89, 224, 152, 21, 81, 11);
		RT_INTERFACE!{interface IPerceptionPropertyChangeRequest(IPerceptionPropertyChangeRequestVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionPropertyChangeRequest] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Value(&mut self, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut super::PerceptionFrameSourcePropertyChangeStatus) -> ::w::HRESULT,
			fn put_Status(&mut self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> ::w::HRESULT
		}}
		impl IPerceptionPropertyChangeRequest {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<super::PerceptionFrameSourcePropertyChangeStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_status(&mut self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Status)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::Deferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IPerceptionFrameProviderManagerServiceStatics [CLSID_PerceptionFrameProviderManagerService]}
		DEFINE_CLSID!(CLSID_PerceptionFrameProviderManagerService = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,80,114,111,118,105,100,101,114,77,97,110,97,103,101,114,83,101,114,118,105,99,101,0]);
		RT_ACTIVATABLE!{IKnownPerceptionFrameKindStatics [CLSID_KnownPerceptionFrameKind]}
		DEFINE_CLSID!(CLSID_KnownPerceptionFrameKind = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,75,105,110,100,0]);
		DEFINE_IID!(IID_IPerceptionFrameProviderManager, 2841234951, 60115, 13279, 142, 193, 185, 36, 171, 224, 25, 196);
		RT_INTERFACE!{interface IPerceptionFrameProviderManager(IPerceptionFrameProviderManagerVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManager] {
			fn GetFrameProvider(&mut self, frameProviderInfo: *mut PerceptionFrameProviderInfo, out: *mut *mut IPerceptionFrameProvider) -> ::w::HRESULT
		}}
		impl IPerceptionFrameProviderManager {
			#[inline] pub unsafe fn get_frame_provider(&mut self, frameProviderInfo: &PerceptionFrameProviderInfo) -> RtResult<ComPtr<IPerceptionFrameProvider>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFrameProvider)(self, frameProviderInfo as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionFrameProvider, 2035251897, 45949, 15155, 161, 13, 48, 98, 100, 25, 206, 101);
		RT_INTERFACE!{interface IPerceptionFrameProvider(IPerceptionFrameProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProvider] {
			fn get_FrameProviderInfo(&mut self, out: *mut *mut PerceptionFrameProviderInfo) -> ::w::HRESULT,
			fn get_Available(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IPropertySet) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT,
			fn SetProperty(&mut self, value: *mut PerceptionPropertyChangeRequest) -> ::w::HRESULT
		}}
		impl IPerceptionFrameProvider {
			#[inline] pub unsafe fn get_frame_provider_info(&mut self) -> RtResult<ComPtr<PerceptionFrameProviderInfo>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FrameProviderInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Available)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IPropertySet>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_property(&mut self, value: &PerceptionPropertyChangeRequest) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetProperty)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPerceptionVideoFrameAllocator, 1278781402, 64984, 20180, 160, 57, 42, 111, 155, 35, 80, 56);
		RT_INTERFACE!{interface IPerceptionVideoFrameAllocator(IPerceptionVideoFrameAllocatorVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocator] {
			fn AllocateFrame(&mut self, out: *mut *mut PerceptionFrame) -> ::w::HRESULT,
			#[cfg(feature="windows.media")] fn CopyFromVideoFrame(&mut self, frame: *mut ::rt::gen::windows::media::VideoFrame, out: *mut *mut PerceptionFrame) -> ::w::HRESULT
		}}
		impl IPerceptionVideoFrameAllocator {
			#[inline] pub unsafe fn allocate_frame(&mut self) -> RtResult<ComPtr<PerceptionFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AllocateFrame)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.media")] #[inline] pub unsafe fn copy_from_video_frame(&mut self, frame: &::rt::gen::windows::media::VideoFrame) -> RtResult<ComPtr<PerceptionFrame>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CopyFromVideoFrame)(self, frame as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Perception.Provider
} // Windows.Devices.Perception
pub mod pointofservice { // Windows.Devices.PointOfService
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum UnifiedPosErrorSeverity: i32 {
			UnknownErrorSeverity (UnifiedPosErrorSeverity_UnknownErrorSeverity) = 0, Warning (UnifiedPosErrorSeverity_Warning) = 1, Recoverable (UnifiedPosErrorSeverity_Recoverable) = 2, Unrecoverable (UnifiedPosErrorSeverity_Unrecoverable) = 3, AssistanceRequired (UnifiedPosErrorSeverity_AssistanceRequired) = 4, Fatal (UnifiedPosErrorSeverity_Fatal) = 5,
		}}
		RT_ENUM! { enum UnifiedPosPowerReportingType: i32 {
			UnknownPowerReportingType (UnifiedPosPowerReportingType_UnknownPowerReportingType) = 0, Standard (UnifiedPosPowerReportingType_Standard) = 1, Advanced (UnifiedPosPowerReportingType_Advanced) = 2,
		}}
		RT_ENUM! { enum UnifiedPosHealthCheckLevel: i32 {
			UnknownHealthCheckLevel (UnifiedPosHealthCheckLevel_UnknownHealthCheckLevel) = 0, POSInternal (UnifiedPosHealthCheckLevel_POSInternal) = 1, External (UnifiedPosHealthCheckLevel_External) = 2, Interactive (UnifiedPosHealthCheckLevel_Interactive) = 3,
		}}
		RT_ENUM! { enum UnifiedPosErrorReason: i32 {
			UnknownErrorReason (UnifiedPosErrorReason_UnknownErrorReason) = 0, NoService (UnifiedPosErrorReason_NoService) = 1, Disabled (UnifiedPosErrorReason_Disabled) = 2, Illegal (UnifiedPosErrorReason_Illegal) = 3, NoHardware (UnifiedPosErrorReason_NoHardware) = 4, Closed (UnifiedPosErrorReason_Closed) = 5, Offline (UnifiedPosErrorReason_Offline) = 6, Failure (UnifiedPosErrorReason_Failure) = 7, Timeout (UnifiedPosErrorReason_Timeout) = 8, Busy (UnifiedPosErrorReason_Busy) = 9, Extended (UnifiedPosErrorReason_Extended) = 10,
		}}
		RT_ENUM! { enum MagneticStripeReaderAuthenticationLevel: i32 {
			NotSupported (MagneticStripeReaderAuthenticationLevel_NotSupported) = 0, Optional (MagneticStripeReaderAuthenticationLevel_Optional) = 1, Required (MagneticStripeReaderAuthenticationLevel_Required) = 2,
		}}
		RT_ENUM! { enum PosPrinterMapMode: i32 {
			Dots (PosPrinterMapMode_Dots) = 0, Twips (PosPrinterMapMode_Twips) = 1, English (PosPrinterMapMode_English) = 2, Metric (PosPrinterMapMode_Metric) = 3,
		}}
		RT_ENUM! { enum PosPrinterCartridgeSensors: u32 {
			None (PosPrinterCartridgeSensors_None) = 0, Removed (PosPrinterCartridgeSensors_Removed) = 1, Empty (PosPrinterCartridgeSensors_Empty) = 2, HeadCleaning (PosPrinterCartridgeSensors_HeadCleaning) = 4, NearEnd (PosPrinterCartridgeSensors_NearEnd) = 8,
		}}
		RT_ENUM! { enum PosPrinterColorCapabilities: u32 {
			None (PosPrinterColorCapabilities_None) = 0, Primary (PosPrinterColorCapabilities_Primary) = 1, Custom1 (PosPrinterColorCapabilities_Custom1) = 2, Custom2 (PosPrinterColorCapabilities_Custom2) = 4, Custom3 (PosPrinterColorCapabilities_Custom3) = 8, Custom4 (PosPrinterColorCapabilities_Custom4) = 16, Custom5 (PosPrinterColorCapabilities_Custom5) = 32, Custom6 (PosPrinterColorCapabilities_Custom6) = 64, Cyan (PosPrinterColorCapabilities_Cyan) = 128, Magenta (PosPrinterColorCapabilities_Magenta) = 256, Yellow (PosPrinterColorCapabilities_Yellow) = 512, Full (PosPrinterColorCapabilities_Full) = 1024,
		}}
		RT_ENUM! { enum PosPrinterColorCartridge: i32 {
			Unknown (PosPrinterColorCartridge_Unknown) = 0, Primary (PosPrinterColorCartridge_Primary) = 1, Custom1 (PosPrinterColorCartridge_Custom1) = 2, Custom2 (PosPrinterColorCartridge_Custom2) = 3, Custom3 (PosPrinterColorCartridge_Custom3) = 4, Custom4 (PosPrinterColorCartridge_Custom4) = 5, Custom5 (PosPrinterColorCartridge_Custom5) = 6, Custom6 (PosPrinterColorCartridge_Custom6) = 7, Cyan (PosPrinterColorCartridge_Cyan) = 8, Magenta (PosPrinterColorCartridge_Magenta) = 9, Yellow (PosPrinterColorCartridge_Yellow) = 10,
		}}
		RT_ENUM! { enum PosPrinterMarkFeedCapabilities: u32 {
			None (PosPrinterMarkFeedCapabilities_None) = 0, ToTakeUp (PosPrinterMarkFeedCapabilities_ToTakeUp) = 1, ToCutter (PosPrinterMarkFeedCapabilities_ToCutter) = 2, ToCurrentTopOfForm (PosPrinterMarkFeedCapabilities_ToCurrentTopOfForm) = 4, ToNextTopOfForm (PosPrinterMarkFeedCapabilities_ToNextTopOfForm) = 8,
		}}
		RT_ENUM! { enum PosPrinterRuledLineCapabilities: u32 {
			None (PosPrinterRuledLineCapabilities_None) = 0, Horizontal (PosPrinterRuledLineCapabilities_Horizontal) = 1, Vertical (PosPrinterRuledLineCapabilities_Vertical) = 2,
		}}
		RT_ENUM! { enum PosPrinterPrintSide: i32 {
			Unknown (PosPrinterPrintSide_Unknown) = 0, Side1 (PosPrinterPrintSide_Side1) = 1, Side2 (PosPrinterPrintSide_Side2) = 2,
		}}
		RT_ENUM! { enum PosPrinterLineDirection: i32 {
			Horizontal (PosPrinterLineDirection_Horizontal) = 0, Vertical (PosPrinterLineDirection_Vertical) = 1,
		}}
		RT_ENUM! { enum PosPrinterLineStyle: i32 {
			SingleSolid (PosPrinterLineStyle_SingleSolid) = 0, DoubleSolid (PosPrinterLineStyle_DoubleSolid) = 1, Broken (PosPrinterLineStyle_Broken) = 2, Chain (PosPrinterLineStyle_Chain) = 3,
		}}
		RT_ENUM! { enum PosPrinterMarkFeedKind: i32 {
			ToTakeUp (PosPrinterMarkFeedKind_ToTakeUp) = 0, ToCutter (PosPrinterMarkFeedKind_ToCutter) = 1, ToCurrentTopOfForm (PosPrinterMarkFeedKind_ToCurrentTopOfForm) = 2, ToNextTopOfForm (PosPrinterMarkFeedKind_ToNextTopOfForm) = 3,
		}}
		RT_ENUM! { enum PosPrinterAlignment: i32 {
			Left (PosPrinterAlignment_Left) = 0, Center (PosPrinterAlignment_Center) = 1, Right (PosPrinterAlignment_Right) = 2,
		}}
		RT_ENUM! { enum PosPrinterBarcodeTextPosition: i32 {
			None (PosPrinterBarcodeTextPosition_None) = 0, Above (PosPrinterBarcodeTextPosition_Above) = 1, Below (PosPrinterBarcodeTextPosition_Below) = 2,
		}}
		RT_ENUM! { enum PosPrinterRotation: i32 {
			Normal (PosPrinterRotation_Normal) = 0, Right90 (PosPrinterRotation_Right90) = 1, Left90 (PosPrinterRotation_Left90) = 2, Rotate180 (PosPrinterRotation_Rotate180) = 3,
		}}
		RT_ENUM! { enum PosPrinterStatusKind: i32 {
			Online (PosPrinterStatusKind_Online) = 0, Off (PosPrinterStatusKind_Off) = 1, Offline (PosPrinterStatusKind_Offline) = 2, OffOrOffline (PosPrinterStatusKind_OffOrOffline) = 3, Extended (PosPrinterStatusKind_Extended) = 4,
		}}
		RT_ENUM! { enum CashDrawerStatusKind: i32 {
			Online (CashDrawerStatusKind_Online) = 0, Off (CashDrawerStatusKind_Off) = 1, Offline (CashDrawerStatusKind_Offline) = 2, OffOrOffline (CashDrawerStatusKind_OffOrOffline) = 3, Extended (CashDrawerStatusKind_Extended) = 4,
		}}
		RT_ENUM! { enum BarcodeScannerStatus: i32 {
			Online (BarcodeScannerStatus_Online) = 0, Off (BarcodeScannerStatus_Off) = 1, Offline (BarcodeScannerStatus_Offline) = 2, OffOrOffline (BarcodeScannerStatus_OffOrOffline) = 3, Extended (BarcodeScannerStatus_Extended) = 4,
		}}
		DEFINE_IID!(IID_IUnifiedPosErrorData, 731483194, 21852, 18569, 142, 216, 197, 153, 187, 58, 113, 42);
		RT_INTERFACE!{interface IUnifiedPosErrorData(IUnifiedPosErrorDataVtbl): IInspectable(IInspectableVtbl) [IID_IUnifiedPosErrorData] {
			fn get_Message(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Severity(&mut self, out: *mut UnifiedPosErrorSeverity) -> ::w::HRESULT,
			fn get_Reason(&mut self, out: *mut UnifiedPosErrorReason) -> ::w::HRESULT,
			fn get_ExtendedReason(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IUnifiedPosErrorData {
			#[inline] pub unsafe fn get_message(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Message)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_severity(&mut self) -> RtResult<UnifiedPosErrorSeverity> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Severity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_reason(&mut self) -> RtResult<UnifiedPosErrorReason> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Reason)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_reason(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedReason)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UnifiedPosErrorData: IUnifiedPosErrorData}
		DEFINE_IID!(IID_IBarcodeScannerStatusUpdatedEventArgs, 895321478, 40003, 17963, 169, 26, 129, 109, 201, 127, 69, 44);
		RT_INTERFACE!{interface IBarcodeScannerStatusUpdatedEventArgs(IBarcodeScannerStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatusUpdatedEventArgs] {
			fn get_Status(&mut self, out: *mut BarcodeScannerStatus) -> ::w::HRESULT,
			fn get_ExtendedStatus(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IBarcodeScannerStatusUpdatedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<BarcodeScannerStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_status(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScannerStatusUpdatedEventArgs: IBarcodeScannerStatusUpdatedEventArgs}
		DEFINE_IID!(IID_IBarcodeSymbologiesStatics, 3397732795, 1746, 17396, 164, 75, 198, 32, 103, 159, 216, 208);
		RT_INTERFACE!{static interface IBarcodeSymbologiesStatics(IBarcodeSymbologiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologiesStatics] {
			fn get_Unknown(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean8(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean8Add2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean8Add5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Eanv(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EanvAdd2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EanvAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean13(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean13Add2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean13Add5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Isbn(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsbnAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ismn(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsmnAdd2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsmnAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Issn(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IssnAdd2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IssnAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean99(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean99Add2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ean99Add5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Upca(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UpcaAdd2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UpcaAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Upce(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UpceAdd2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UpceAdd5(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UpcCoupon(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfStd(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfDis(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfInt(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfInd(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfMat(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TfIata(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Gs1DatabarType1(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Gs1DatabarType2(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Gs1DatabarType3(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code39(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code39Ex(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Trioptic39(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code32(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Pzn(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code93(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code93Ex(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code128(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Gs1128(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Gs1128Coupon(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UccEan128(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Sisac(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Isbt(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Codabar(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code11(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Msi(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Plessey(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Telepen(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code16k(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_CodablockA(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_CodablockF(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Codablock128(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Code49(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Aztec(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DataCode(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DataMatrix(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_HanXin(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Maxicode(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MicroPdf417(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MicroQr(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Pdf417(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Qr(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MsTag(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ccab(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ccc(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Tlc39(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_AusPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_CanPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ChinaPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DutchKix(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_InfoMail(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ItalianPost25(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ItalianPost39(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_JapanPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_KoreanPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_SwedenPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UkPost(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsIntelligent(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsIntelligentPkg(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsPlanet(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_UsPostNet(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Us4StateFics(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_OcrA(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_OcrB(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Micr(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ExtendedBase(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn GetName(&mut self, scanDataType: u32, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBarcodeSymbologiesStatics {
			#[inline] pub unsafe fn get_unknown(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Unknown)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean8(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean8_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean8Add2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean8_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean8Add5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_eanv(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Eanv)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_eanv_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EanvAdd2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_eanv_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EanvAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean13(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean13)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean13_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean13Add2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean13_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean13Add5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_isbn(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Isbn)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_isbn_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsbnAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ismn(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ismn)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ismn_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsmnAdd2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ismn_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsmnAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_issn(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Issn)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_issn_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IssnAdd2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_issn_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IssnAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean99(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean99)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean99_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean99Add2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ean99_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ean99Add5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upca(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Upca)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upca_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpcaAdd2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upca_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpcaAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upce(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Upce)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upce_add2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpceAdd2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upce_add5(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpceAdd5)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_upc_coupon(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UpcCoupon)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_std(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfStd)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_dis(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfDis)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_int(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfInt)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_ind(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfInd)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_mat(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfMat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tf_iata(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TfIata)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gs1_databar_type1(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gs1DatabarType1)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gs1_databar_type2(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gs1DatabarType2)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gs1_databar_type3(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gs1DatabarType3)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code39(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code39)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code39_ex(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code39Ex)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_trioptic39(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Trioptic39)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code32(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pzn(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Pzn)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code93(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code93)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code93_ex(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code93Ex)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code128(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gs1128(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gs1128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gs1128_coupon(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Gs1128Coupon)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ucc_ean128(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UccEan128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sisac(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Sisac)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_isbt(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Isbt)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_codabar(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Codabar)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code11(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code11)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_msi(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Msi)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_plessey(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Plessey)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_telepen(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Telepen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code16k(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code16k)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_codablock_a(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CodablockA)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_codablock_f(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CodablockF)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_codablock128(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Codablock128)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_code49(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Code49)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_aztec(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Aztec)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_code(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_matrix(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataMatrix)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_han_xin(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HanXin)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_maxicode(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Maxicode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_micro_pdf417(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MicroPdf417)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_micro_qr(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MicroQr)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pdf417(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Pdf417)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_qr(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Qr)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ms_tag(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MsTag)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ccab(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ccab)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ccc(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ccc)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tlc39(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Tlc39)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_aus_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AusPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_can_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_china_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChinaPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_dutch_kix(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DutchKix)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_info_mail(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InfoMail)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_italian_post25(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ItalianPost25)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_italian_post39(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ItalianPost39)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_japan_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_JapanPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_korean_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_KoreanPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sweden_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SwedenPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uk_post(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UkPost)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_us_intelligent(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsIntelligent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_us_intelligent_pkg(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsIntelligentPkg)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_us_planet(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsPlanet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_us_post_net(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsPostNet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_us4_state_fics(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Us4StateFics)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ocr_a(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OcrA)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ocr_b(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OcrB)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_micr(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Micr)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_base(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedBase)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self, scanDataType: u32) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetName)(self, scanDataType, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IBarcodeSymbologiesStatics [CLSID_BarcodeSymbologies]}
		DEFINE_CLSID!(CLSID_BarcodeSymbologies = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,121,109,98,111,108,111,103,105,101,115,0]);
		DEFINE_IID!(IID_IBarcodeScannerDataReceivedEventArgs, 1110747106, 60823, 18045, 173, 43, 1, 228, 67, 19, 169, 41);
		RT_INTERFACE!{interface IBarcodeScannerDataReceivedEventArgs(IBarcodeScannerDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDataReceivedEventArgs] {
			fn get_Report(&mut self, out: *mut *mut BarcodeScannerReport) -> ::w::HRESULT
		}}
		impl IBarcodeScannerDataReceivedEventArgs {
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<BarcodeScannerReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScannerReport: IBarcodeScannerReport}
		RT_CLASS!{class BarcodeScannerDataReceivedEventArgs: IBarcodeScannerDataReceivedEventArgs}
		DEFINE_IID!(IID_IBarcodeScannerReport, 1558501552, 42121, 19350, 134, 196, 240, 191, 138, 55, 117, 61);
		RT_INTERFACE!{interface IBarcodeScannerReport(IBarcodeScannerReportVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerReport] {
			fn get_ScanDataType(&mut self, out: *mut u32) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_ScanData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_ScanDataLabel(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IBarcodeScannerReport {
			#[inline] pub unsafe fn get_scan_data_type(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanDataType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_scan_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ScanData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_scan_data_label(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ScanDataLabel)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBarcodeScannerErrorOccurredEventArgs, 751984687, 53050, 16386, 167, 90, 197, 236, 70, 143, 10, 32);
		RT_INTERFACE!{interface IBarcodeScannerErrorOccurredEventArgs(IBarcodeScannerErrorOccurredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerErrorOccurredEventArgs] {
			fn get_PartialInputData(&mut self, out: *mut *mut BarcodeScannerReport) -> ::w::HRESULT,
			fn get_IsRetriable(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_ErrorData(&mut self, out: *mut *mut UnifiedPosErrorData) -> ::w::HRESULT
		}}
		impl IBarcodeScannerErrorOccurredEventArgs {
			#[inline] pub unsafe fn get_partial_input_data(&mut self) -> RtResult<ComPtr<BarcodeScannerReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PartialInputData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_retriable(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsRetriable)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_data(&mut self) -> RtResult<ComPtr<UnifiedPosErrorData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ErrorData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScannerErrorOccurredEventArgs: IBarcodeScannerErrorOccurredEventArgs}
		DEFINE_IID!(IID_IBarcodeScannerImagePreviewReceivedEventArgs, 4088913541, 28299, 17230, 159, 88, 6, 239, 38, 188, 75, 175);
		RT_INTERFACE!{interface IBarcodeScannerImagePreviewReceivedEventArgs(IBarcodeScannerImagePreviewReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerImagePreviewReceivedEventArgs] {
			#[cfg(feature="windows.storage")] fn get_Preview(&mut self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamWithContentType) -> ::w::HRESULT
		}}
		impl IBarcodeScannerImagePreviewReceivedEventArgs {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_preview(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IRandomAccessStreamWithContentType>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Preview)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScannerImagePreviewReceivedEventArgs: IBarcodeScannerImagePreviewReceivedEventArgs}
		DEFINE_IID!(IID_IBarcodeScannerCapabilities, 3322319332, 62152, 17440, 163, 7, 177, 46, 246, 98, 40, 87);
		RT_INTERFACE!{interface IBarcodeScannerCapabilities(IBarcodeScannerCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities] {
			fn get_PowerReportingType(&mut self, out: *mut UnifiedPosPowerReportingType) -> ::w::HRESULT,
			fn get_IsStatisticsReportingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatisticsUpdatingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsImagePreviewSupported(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IBarcodeScannerCapabilities {
			#[inline] pub unsafe fn get_power_reporting_type(&mut self) -> RtResult<UnifiedPosPowerReportingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerReportingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_reporting_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsReportingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_updating_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsUpdatingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_image_preview_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsImagePreviewSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBarcodeScannerCapabilities1, 2388308969, 3628, 18223, 161, 204, 238, 128, 84, 182, 166, 132);
		RT_INTERFACE!{interface IBarcodeScannerCapabilities1(IBarcodeScannerCapabilities1Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities1] {
			fn get_IsSoftwareTriggerSupported(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IBarcodeScannerCapabilities1 {
			#[inline] pub unsafe fn get_is_software_trigger_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsSoftwareTriggerSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScannerCapabilities: IBarcodeScannerCapabilities}
		DEFINE_IID!(IID_IBarcodeScannerStatics, 1561419631, 55881, 16872, 140, 140, 240, 203, 98, 169, 196, 252);
		RT_INTERFACE!{static interface IBarcodeScannerStatics(IBarcodeScannerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<BarcodeScanner>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<BarcodeScanner>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBarcodeScannerStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BarcodeScanner>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<BarcodeScanner>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarcodeScanner: IBarcodeScanner}
		RT_ACTIVATABLE!{IBarcodeScannerStatics [CLSID_BarcodeScanner]}
		DEFINE_CLSID!(CLSID_BarcodeScanner = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,99,97,110,110,101,114,0]);
		DEFINE_IID!(IID_IBarcodeScanner, 3198369286, 45668, 20227, 169, 193, 69, 178, 15, 1, 19, 79);
		RT_INTERFACE!{interface IBarcodeScanner(IBarcodeScannerVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Capabilities(&mut self, out: *mut *mut BarcodeScannerCapabilities) -> ::w::HRESULT,
			fn ClaimScannerAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ClaimedBarcodeScanner>) -> ::w::HRESULT,
			fn CheckHealthAsync(&mut self, level: UnifiedPosHealthCheckLevel, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn GetSupportedSymbologiesAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<u32>>) -> ::w::HRESULT,
			fn IsSymbologySupportedAsync(&mut self, barcodeSymbology: u32, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy6(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn RetrieveStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			fn GetSupportedProfiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> ::w::HRESULT,
			fn IsProfileSupported(&mut self, profile: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn add_StatusUpdated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusUpdated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBarcodeScanner {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_capabilities(&mut self) -> RtResult<ComPtr<BarcodeScannerCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Capabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn claim_scanner_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ClaimedBarcodeScanner>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClaimScannerAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn check_health_async(&mut self, level: UnifiedPosHealthCheckLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CheckHealthAsync)(self, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_symbologies_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<u32>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSupportedSymbologiesAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_symbology_supported_async(&mut self, barcodeSymbology: u32) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).IsSymbologySupportedAsync)(self, barcodeSymbology, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn retrieve_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RetrieveStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_profiles(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSupportedProfiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_profile_supported(&mut self, profile: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsProfileSupported)(self, profile.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusUpdated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusUpdated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedBarcodeScanner: IClaimedBarcodeScanner}
		DEFINE_IID!(IID_IBarcodeScanner2, 2300662119, 36078, 17261, 137, 171, 141, 251, 67, 187, 66, 134);
		RT_INTERFACE!{interface IBarcodeScanner2(IBarcodeScanner2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner2] {
			fn get_VideoDeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IBarcodeScanner2 {
			#[inline] pub unsafe fn get_video_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VideoDeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum MagneticStripeReaderStatus: i32 {
			Unauthenticated (MagneticStripeReaderStatus_Unauthenticated) = 0, Authenticated (MagneticStripeReaderStatus_Authenticated) = 1, Extended (MagneticStripeReaderStatus_Extended) = 2,
		}}
		RT_ENUM! { enum MagneticStripeReaderAuthenticationProtocol: i32 {
			None (MagneticStripeReaderAuthenticationProtocol_None) = 0, ChallengeResponse (MagneticStripeReaderAuthenticationProtocol_ChallengeResponse) = 1,
		}}
		RT_ENUM! { enum MagneticStripeReaderTrackIds: i32 {
			None (MagneticStripeReaderTrackIds_None) = 0, Track1 (MagneticStripeReaderTrackIds_Track1) = 1, Track2 (MagneticStripeReaderTrackIds_Track2) = 2, Track3 (MagneticStripeReaderTrackIds_Track3) = 4, Track4 (MagneticStripeReaderTrackIds_Track4) = 8,
		}}
		RT_ENUM! { enum MagneticStripeReaderErrorReportingType: i32 {
			CardLevel (MagneticStripeReaderErrorReportingType_CardLevel) = 0, TrackLevel (MagneticStripeReaderErrorReportingType_TrackLevel) = 1,
		}}
		RT_ENUM! { enum MagneticStripeReaderTrackErrorType: i32 {
			None (MagneticStripeReaderTrackErrorType_None) = 0, StartSentinelError (MagneticStripeReaderTrackErrorType_StartSentinelError) = 1, EndSentinelError (MagneticStripeReaderTrackErrorType_EndSentinelError) = 2, ParityError (MagneticStripeReaderTrackErrorType_ParityError) = 3, LrcError (MagneticStripeReaderTrackErrorType_LrcError) = 4, Unknown (MagneticStripeReaderTrackErrorType_Unknown) = -1,
		}}
		DEFINE_IID!(IID_IMagneticStripeReaderEncryptionAlgorithmsStatics, 1404400464, 50139, 18260, 156, 0, 65, 57, 35, 116, 161, 9);
		RT_INTERFACE!{static interface IMagneticStripeReaderEncryptionAlgorithmsStatics(IMagneticStripeReaderEncryptionAlgorithmsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderEncryptionAlgorithmsStatics] {
			fn get_None(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_TripleDesDukpt(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ExtendedBase(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderEncryptionAlgorithmsStatics {
			#[inline] pub unsafe fn get_none(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_None)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_triple_des_dukpt(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TripleDesDukpt)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_base(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedBase)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IMagneticStripeReaderEncryptionAlgorithmsStatics [CLSID_MagneticStripeReaderEncryptionAlgorithms]}
		DEFINE_CLSID!(CLSID_MagneticStripeReaderEncryptionAlgorithms = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,69,110,99,114,121,112,116,105,111,110,65,108,103,111,114,105,116,104,109,115,0]);
		DEFINE_IID!(IID_IMagneticStripeReaderCardTypesStatics, 1385114717, 10630, 18255, 132, 84, 124, 205, 5, 146, 141, 95);
		RT_INTERFACE!{static interface IMagneticStripeReaderCardTypesStatics(IMagneticStripeReaderCardTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCardTypesStatics] {
			fn get_Unknown(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Bank(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Aamva(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ExtendedBase(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderCardTypesStatics {
			#[inline] pub unsafe fn get_unknown(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Unknown)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bank(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Bank)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_aamva(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Aamva)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_base(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedBase)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IMagneticStripeReaderCardTypesStatics [CLSID_MagneticStripeReaderCardTypes]}
		DEFINE_CLSID!(CLSID_MagneticStripeReaderCardTypes = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,67,97,114,100,84,121,112,101,115,0]);
		DEFINE_IID!(IID_IMagneticStripeReaderTrackData, 273479281, 19101, 17518, 171, 197, 32, 64, 35, 7, 186, 54);
		RT_INTERFACE!{interface IMagneticStripeReaderTrackData(IMagneticStripeReaderTrackDataVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderTrackData] {
			#[cfg(feature="windows.storage")] fn get_Data(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_DiscretionaryData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_EncryptedData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderTrackData {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Data)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_discretionary_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DiscretionaryData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_encrypted_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EncryptedData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagneticStripeReaderReport, 1784373319, 39344, 16776, 190, 241, 237, 223, 121, 247, 143, 230);
		RT_INTERFACE!{interface IMagneticStripeReaderReport(IMagneticStripeReaderReportVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderReport] {
			fn get_CardType(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Track1(&mut self, out: *mut *mut MagneticStripeReaderTrackData) -> ::w::HRESULT,
			fn get_Track2(&mut self, out: *mut *mut MagneticStripeReaderTrackData) -> ::w::HRESULT,
			fn get_Track3(&mut self, out: *mut *mut MagneticStripeReaderTrackData) -> ::w::HRESULT,
			fn get_Track4(&mut self, out: *mut *mut MagneticStripeReaderTrackData) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<HString, HString>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_CardAuthenticationData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_CardAuthenticationDataLength(&mut self, out: *mut u32) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_AdditionalSecurityInformation(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderReport {
			#[inline] pub unsafe fn get_card_type(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CardType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track1(&mut self) -> RtResult<ComPtr<MagneticStripeReaderTrackData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Track1)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track2(&mut self) -> RtResult<ComPtr<MagneticStripeReaderTrackData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Track2)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track3(&mut self) -> RtResult<ComPtr<MagneticStripeReaderTrackData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Track3)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track4(&mut self) -> RtResult<ComPtr<MagneticStripeReaderTrackData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Track4)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<HString, HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_card_authentication_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CardAuthenticationData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_card_authentication_data_length(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CardAuthenticationDataLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_additional_security_information(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AdditionalSecurityInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagneticStripeReaderTrackData: IMagneticStripeReaderTrackData}
		DEFINE_IID!(IID_IMagneticStripeReaderBankCardDataReceivedEventArgs, 781551651, 41754, 18275, 136, 44, 35, 114, 94, 57, 176, 142);
		RT_INTERFACE!{interface IMagneticStripeReaderBankCardDataReceivedEventArgs(IMagneticStripeReaderBankCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderBankCardDataReceivedEventArgs] {
			fn get_Report(&mut self, out: *mut *mut MagneticStripeReaderReport) -> ::w::HRESULT,
			fn get_AccountNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ExpirationDate(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ServiceCode(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Title(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_FirstName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MiddleInitial(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Surname(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Suffix(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderBankCardDataReceivedEventArgs {
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<MagneticStripeReaderReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_account_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AccountNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_expiration_date(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ExpirationDate)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_code(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_title(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Title)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_first_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FirstName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_middle_initial(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MiddleInitial)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_surname(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Surname)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_suffix(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Suffix)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagneticStripeReaderReport: IMagneticStripeReaderReport}
		DEFINE_IID!(IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs, 172735825, 49942, 18704, 135, 243, 122, 98, 186, 134, 45, 49);
		RT_INTERFACE!{interface IMagneticStripeReaderAamvaCardDataReceivedEventArgs(IMagneticStripeReaderAamvaCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs] {
			fn get_Report(&mut self, out: *mut *mut MagneticStripeReaderReport) -> ::w::HRESULT,
			fn get_LicenseNumber(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ExpirationDate(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Restrictions(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Class(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Endorsements(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_BirthDate(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_FirstName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Surname(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Suffix(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Gender(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_HairColor(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_EyeColor(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Height(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Weight(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Address(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_City(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_State(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_PostalCode(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderAamvaCardDataReceivedEventArgs {
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<MagneticStripeReaderReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_license_number(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LicenseNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_expiration_date(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ExpirationDate)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_restrictions(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Restrictions)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_class(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Class)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endorsements(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Endorsements)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_birth_date(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BirthDate)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_first_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FirstName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_surname(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Surname)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_suffix(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Suffix)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_gender(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Gender)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_hair_color(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HairColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_eye_color(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EyeColor)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_height(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Height)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_weight(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Weight)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_address(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Address)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_city(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_City)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_state(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_State)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_postal_code(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PostalCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, 2936689940, 22988, 19040, 153, 232, 153, 165, 61, 172, 229, 170);
		RT_INTERFACE!{interface IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs] {
			fn get_Report(&mut self, out: *mut *mut MagneticStripeReaderReport) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs {
			#[inline] pub unsafe fn get_report(&mut self) -> RtResult<ComPtr<MagneticStripeReaderReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Report)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagneticStripeReaderErrorOccurredEventArgs, 535689565, 11396, 16813, 183, 120, 242, 53, 106, 120, 154, 177);
		RT_INTERFACE!{interface IMagneticStripeReaderErrorOccurredEventArgs(IMagneticStripeReaderErrorOccurredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderErrorOccurredEventArgs] {
			fn get_Track1Status(&mut self, out: *mut MagneticStripeReaderTrackErrorType) -> ::w::HRESULT,
			fn get_Track2Status(&mut self, out: *mut MagneticStripeReaderTrackErrorType) -> ::w::HRESULT,
			fn get_Track3Status(&mut self, out: *mut MagneticStripeReaderTrackErrorType) -> ::w::HRESULT,
			fn get_Track4Status(&mut self, out: *mut MagneticStripeReaderTrackErrorType) -> ::w::HRESULT,
			fn get_ErrorData(&mut self, out: *mut *mut UnifiedPosErrorData) -> ::w::HRESULT,
			fn get_PartialInputData(&mut self, out: *mut *mut MagneticStripeReaderReport) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderErrorOccurredEventArgs {
			#[inline] pub unsafe fn get_track1_status(&mut self) -> RtResult<MagneticStripeReaderTrackErrorType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Track1Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track2_status(&mut self) -> RtResult<MagneticStripeReaderTrackErrorType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Track2Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track3_status(&mut self) -> RtResult<MagneticStripeReaderTrackErrorType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Track3Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_track4_status(&mut self) -> RtResult<MagneticStripeReaderTrackErrorType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Track4Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_data(&mut self) -> RtResult<ComPtr<UnifiedPosErrorData>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ErrorData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_partial_input_data(&mut self) -> RtResult<ComPtr<MagneticStripeReaderReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PartialInputData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagneticStripeReaderStatusUpdatedEventArgs, 164391856, 12898, 16413, 158, 138, 232, 13, 99, 88, 144, 107);
		RT_INTERFACE!{interface IMagneticStripeReaderStatusUpdatedEventArgs(IMagneticStripeReaderStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatusUpdatedEventArgs] {
			fn get_Status(&mut self, out: *mut MagneticStripeReaderStatus) -> ::w::HRESULT,
			fn get_ExtendedStatus(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderStatusUpdatedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<MagneticStripeReaderStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_status(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagneticStripeReaderBankCardDataReceivedEventArgs: IMagneticStripeReaderBankCardDataReceivedEventArgs}
		RT_CLASS!{class MagneticStripeReaderAamvaCardDataReceivedEventArgs: IMagneticStripeReaderAamvaCardDataReceivedEventArgs}
		RT_CLASS!{class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs}
		RT_CLASS!{class MagneticStripeReaderErrorOccurredEventArgs: IMagneticStripeReaderErrorOccurredEventArgs}
		RT_CLASS!{class MagneticStripeReaderStatusUpdatedEventArgs: IMagneticStripeReaderStatusUpdatedEventArgs}
		DEFINE_IID!(IID_IMagneticStripeReaderCapabilities, 1898479772, 50240, 17570, 164, 103, 70, 145, 117, 208, 40, 150);
		RT_INTERFACE!{interface IMagneticStripeReaderCapabilities(IMagneticStripeReaderCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCapabilities] {
			fn get_CardAuthentication(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SupportedEncryptionAlgorithms(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_AuthenticationLevel(&mut self, out: *mut MagneticStripeReaderAuthenticationLevel) -> ::w::HRESULT,
			fn get_IsIsoSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsJisOneSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsJisTwoSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_PowerReportingType(&mut self, out: *mut UnifiedPosPowerReportingType) -> ::w::HRESULT,
			fn get_IsStatisticsReportingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatisticsUpdatingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsTrackDataMaskingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsTransmitSentinelsSupported(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderCapabilities {
			#[inline] pub unsafe fn get_card_authentication(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CardAuthentication)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_encryption_algorithms(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SupportedEncryptionAlgorithms)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_authentication_level(&mut self) -> RtResult<MagneticStripeReaderAuthenticationLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AuthenticationLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_iso_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsIsoSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_jis_one_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsJisOneSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_jis_two_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsJisTwoSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_power_reporting_type(&mut self) -> RtResult<UnifiedPosPowerReportingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerReportingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_reporting_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsReportingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_updating_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsUpdatingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_track_data_masking_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsTrackDataMaskingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_transmit_sentinels_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsTransmitSentinelsSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagneticStripeReaderCapabilities: IMagneticStripeReaderCapabilities}
		RT_CLASS!{class ClaimedMagneticStripeReader: IClaimedMagneticStripeReader}
		DEFINE_IID!(IID_IMagneticStripeReaderStatics, 3294604106, 61399, 18272, 165, 206, 21, 176, 228, 126, 148, 235);
		RT_INTERFACE!{static interface IMagneticStripeReaderStatics(IMagneticStripeReaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<MagneticStripeReader>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<MagneticStripeReader>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMagneticStripeReaderStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<MagneticStripeReader>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<MagneticStripeReader>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagneticStripeReader: IMagneticStripeReader}
		RT_ACTIVATABLE!{IMagneticStripeReaderStatics [CLSID_MagneticStripeReader]}
		DEFINE_CLSID!(CLSID_MagneticStripeReader = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,0]);
		DEFINE_IID!(IID_IMagneticStripeReader, 445820949, 18371, 18058, 147, 51, 12, 101, 23, 87, 72, 131);
		RT_INTERFACE!{interface IMagneticStripeReader(IMagneticStripeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReader] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Capabilities(&mut self, out: *mut *mut MagneticStripeReaderCapabilities) -> ::w::HRESULT,
			fn get_SupportedCardTypes(&mut self, outSize: *mut u32, out: *mut *mut u32) -> ::w::HRESULT,
			fn get_DeviceAuthenticationProtocol(&mut self, out: *mut MagneticStripeReaderAuthenticationProtocol) -> ::w::HRESULT,
			fn CheckHealthAsync(&mut self, level: UnifiedPosHealthCheckLevel, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn ClaimReaderAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ClaimedMagneticStripeReader>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy6(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn RetrieveStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			fn GetErrorReportingType(&mut self, out: *mut MagneticStripeReaderErrorReportingType) -> ::w::HRESULT,
			fn add_StatusUpdated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusUpdated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IMagneticStripeReader {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_capabilities(&mut self) -> RtResult<ComPtr<MagneticStripeReaderCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Capabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_card_types(&mut self) -> RtResult<ComArray<u32>> {
				let mut outSize = 0; let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedCardTypes)(self, &mut outSize, &mut out);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(outSize, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_authentication_protocol(&mut self) -> RtResult<MagneticStripeReaderAuthenticationProtocol> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DeviceAuthenticationProtocol)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn check_health_async(&mut self, level: UnifiedPosHealthCheckLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CheckHealthAsync)(self, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn claim_reader_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ClaimedMagneticStripeReader>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClaimReaderAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn retrieve_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RetrieveStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_reporting_type(&mut self) -> RtResult<MagneticStripeReaderErrorReportingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetErrorReportingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusUpdated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusUpdated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPosPrinterCharacterSetIdsStatics, 1550884607, 28826, 20455, 178, 21, 6, 167, 72, 163, 139, 57);
		RT_INTERFACE!{static interface IPosPrinterCharacterSetIdsStatics(IPosPrinterCharacterSetIdsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterCharacterSetIdsStatics] {
			fn get_Utf16LE(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ascii(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Ansi(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IPosPrinterCharacterSetIdsStatics {
			#[inline] pub unsafe fn get_utf16_le(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Utf16LE)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ascii(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ascii)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ansi(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Ansi)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IPosPrinterCharacterSetIdsStatics [CLSID_PosPrinterCharacterSetIds]}
		DEFINE_CLSID!(CLSID_PosPrinterCharacterSetIds = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,67,104,97,114,97,99,116,101,114,83,101,116,73,100,115,0]);
		DEFINE_IID!(IID_ICommonPosPrintStationCapabilities, 3730526922, 57390, 16617, 158, 94, 27, 72, 142, 106, 172, 252);
		RT_INTERFACE!{interface ICommonPosPrintStationCapabilities(ICommonPosPrintStationCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICommonPosPrintStationCapabilities] {
			fn get_IsPrinterPresent(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDualColorSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_ColorCartridgeCapabilities(&mut self, out: *mut PosPrinterColorCapabilities) -> ::w::HRESULT,
			fn get_CartridgeSensors(&mut self, out: *mut PosPrinterCartridgeSensors) -> ::w::HRESULT,
			fn get_IsBoldSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsItalicSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsUnderlineSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDoubleHighPrintSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDoubleWidePrintSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDoubleHighDoubleWidePrintSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsPaperEmptySensorSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsPaperNearEndSensorSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_SupportedCharactersPerLine(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<u32>) -> ::w::HRESULT
		}}
		impl ICommonPosPrintStationCapabilities {
			#[inline] pub unsafe fn get_is_printer_present(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPrinterPresent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_dual_color_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDualColorSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_color_cartridge_capabilities(&mut self) -> RtResult<PosPrinterColorCapabilities> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ColorCartridgeCapabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cartridge_sensors(&mut self) -> RtResult<PosPrinterCartridgeSensors> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CartridgeSensors)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_bold_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsBoldSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_italic_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsItalicSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_underline_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsUnderlineSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_double_high_print_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDoubleHighPrintSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_double_wide_print_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDoubleWidePrintSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_double_high_double_wide_print_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDoubleHighDoubleWidePrintSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paper_empty_sensor_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaperEmptySensorSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paper_near_end_sensor_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaperNearEndSensorSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_characters_per_line(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedCharactersPerLine)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICommonReceiptSlipCapabilities, 153643915, 39027, 19717, 191, 190, 71, 39, 166, 3, 143, 105);
		RT_INTERFACE!{interface ICommonReceiptSlipCapabilities(ICommonReceiptSlipCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICommonReceiptSlipCapabilities] {
			fn get_IsBarcodeSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsBitmapSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsLeft90RotationSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsRight90RotationSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Is180RotationSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsPrintAreaSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_RuledLineCapabilities(&mut self, out: *mut PosPrinterRuledLineCapabilities) -> ::w::HRESULT,
			fn get_SupportedBarcodeRotations(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PosPrinterRotation>) -> ::w::HRESULT,
			fn get_SupportedBitmapRotations(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<PosPrinterRotation>) -> ::w::HRESULT
		}}
		impl ICommonReceiptSlipCapabilities {
			#[inline] pub unsafe fn get_is_barcode_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsBarcodeSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_bitmap_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsBitmapSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_left90_rotation_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsLeft90RotationSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_right90_rotation_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsRight90RotationSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is180_rotation_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Is180RotationSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_print_area_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPrintAreaSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ruled_line_capabilities(&mut self) -> RtResult<PosPrinterRuledLineCapabilities> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RuledLineCapabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_barcode_rotations(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PosPrinterRotation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedBarcodeRotations)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_bitmap_rotations(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PosPrinterRotation>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedBitmapRotations)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IReceiptPrinterCapabilities, 3102782863, 20904, 17404, 155, 213, 141, 226, 114, 166, 65, 91);
		RT_INTERFACE!{interface IReceiptPrinterCapabilities(IReceiptPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptPrinterCapabilities] {
			fn get_CanCutPaper(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStampSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_MarkFeedCapabilities(&mut self, out: *mut PosPrinterMarkFeedCapabilities) -> ::w::HRESULT
		}}
		impl IReceiptPrinterCapabilities {
			#[inline] pub unsafe fn get_can_cut_paper(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanCutPaper)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_stamp_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStampSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_mark_feed_capabilities(&mut self) -> RtResult<PosPrinterMarkFeedCapabilities> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MarkFeedCapabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ReceiptPrinterCapabilities: IReceiptPrinterCapabilities}
		DEFINE_IID!(IID_ISlipPrinterCapabilities, 2578539417, 18572, 16727, 138, 194, 159, 87, 247, 8, 211, 219);
		RT_INTERFACE!{interface ISlipPrinterCapabilities(ISlipPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ISlipPrinterCapabilities] {
			fn get_IsFullLengthSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsBothSidesPrintingSupported(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl ISlipPrinterCapabilities {
			#[inline] pub unsafe fn get_is_full_length_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsFullLengthSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_both_sides_printing_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsBothSidesPrintingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SlipPrinterCapabilities: ISlipPrinterCapabilities}
		DEFINE_IID!(IID_IJournalPrinterCapabilities, 995937347, 57415, 17507, 187, 88, 23, 181, 186, 29, 128, 86);
		RT_INTERFACE!{interface IJournalPrinterCapabilities(IJournalPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IJournalPrinterCapabilities] {
			
		}}
		RT_CLASS!{class JournalPrinterCapabilities: IJournalPrinterCapabilities}
		DEFINE_IID!(IID_IPosPrinterCapabilities, 3454621473, 17280, 18821, 173, 197, 57, 219, 48, 205, 147, 188);
		RT_INTERFACE!{interface IPosPrinterCapabilities(IPosPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterCapabilities] {
			fn get_PowerReportingType(&mut self, out: *mut UnifiedPosPowerReportingType) -> ::w::HRESULT,
			fn get_IsStatisticsReportingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatisticsUpdatingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_DefaultCharacterSet(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_HasCoverSensor(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_CanMapCharacterSet(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsTransactionSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Receipt(&mut self, out: *mut *mut ReceiptPrinterCapabilities) -> ::w::HRESULT,
			fn get_Slip(&mut self, out: *mut *mut SlipPrinterCapabilities) -> ::w::HRESULT,
			fn get_Journal(&mut self, out: *mut *mut JournalPrinterCapabilities) -> ::w::HRESULT
		}}
		impl IPosPrinterCapabilities {
			#[inline] pub unsafe fn get_power_reporting_type(&mut self) -> RtResult<UnifiedPosPowerReportingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerReportingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_reporting_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsReportingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_updating_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsUpdatingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_character_set(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultCharacterSet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_has_cover_sensor(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HasCoverSensor)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_can_map_character_set(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanMapCharacterSet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_transaction_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsTransactionSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_receipt(&mut self) -> RtResult<ComPtr<ReceiptPrinterCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Receipt)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_slip(&mut self) -> RtResult<ComPtr<SlipPrinterCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Slip)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_journal(&mut self) -> RtResult<ComPtr<JournalPrinterCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Journal)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PosPrinterCapabilities: IPosPrinterCapabilities}
		DEFINE_IID!(IID_IPosPrinterStatus, 3522217776, 55872, 17192, 191, 118, 81, 86, 250, 51, 183, 71);
		RT_INTERFACE!{interface IPosPrinterStatus(IPosPrinterStatusVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatus] {
			fn get_StatusKind(&mut self, out: *mut PosPrinterStatusKind) -> ::w::HRESULT,
			fn get_ExtendedStatus(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IPosPrinterStatus {
			#[inline] pub unsafe fn get_status_kind(&mut self) -> RtResult<PosPrinterStatusKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StatusKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_status(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PosPrinterStatus: IPosPrinterStatus}
		DEFINE_IID!(IID_IPosPrinterStatusUpdatedEventArgs, 786139103, 5030, 17037, 186, 129, 176, 231, 195, 229, 163, 205);
		RT_INTERFACE!{interface IPosPrinterStatusUpdatedEventArgs(IPosPrinterStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatusUpdatedEventArgs] {
			fn get_Status(&mut self, out: *mut *mut PosPrinterStatus) -> ::w::HRESULT
		}}
		impl IPosPrinterStatusUpdatedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<ComPtr<PosPrinterStatus>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PosPrinterStatusUpdatedEventArgs: IPosPrinterStatusUpdatedEventArgs}
		DEFINE_IID!(IID_IPosPrinterReleaseDeviceRequestedEventArgs, 734765913, 7407, 16562, 158, 203, 249, 39, 248, 86, 174, 60);
		RT_INTERFACE!{interface IPosPrinterReleaseDeviceRequestedEventArgs(IPosPrinterReleaseDeviceRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterReleaseDeviceRequestedEventArgs] {
			
		}}
		RT_CLASS!{class PosPrinterReleaseDeviceRequestedEventArgs: IPosPrinterReleaseDeviceRequestedEventArgs}
		DEFINE_IID!(IID_IPosPrinterStatics, 2363544810, 4911, 19679, 166, 74, 45, 13, 124, 150, 168, 91);
		RT_INTERFACE!{static interface IPosPrinterStatics(IPosPrinterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<PosPrinter>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PosPrinter>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IPosPrinterStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PosPrinter>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<PosPrinter>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PosPrinter: IPosPrinter}
		RT_ACTIVATABLE!{IPosPrinterStatics [CLSID_PosPrinter]}
		DEFINE_CLSID!(CLSID_PosPrinter = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,0]);
		DEFINE_IID!(IID_IPosPrinter, 704889102, 39449, 18945, 153, 79, 18, 223, 173, 106, 220, 191);
		RT_INTERFACE!{interface IPosPrinter(IPosPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinter] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Capabilities(&mut self, out: *mut *mut PosPrinterCapabilities) -> ::w::HRESULT,
			fn get_SupportedCharacterSets(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<u32>) -> ::w::HRESULT,
			fn get_SupportedTypeFaces(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut *mut PosPrinterStatus) -> ::w::HRESULT,
			fn ClaimPrinterAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ClaimedPosPrinter>) -> ::w::HRESULT,
			fn CheckHealthAsync(&mut self, level: UnifiedPosHealthCheckLevel, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn GetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn add_StatusUpdated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusUpdated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IPosPrinter {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_capabilities(&mut self) -> RtResult<ComPtr<PosPrinterCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Capabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_character_sets(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedCharacterSets)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_type_faces(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedTypeFaces)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<ComPtr<PosPrinterStatus>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn claim_printer_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ClaimedPosPrinter>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClaimPrinterAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn check_health_async(&mut self, level: UnifiedPosHealthCheckLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CheckHealthAsync)(self, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusUpdated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusUpdated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedPosPrinter: IClaimedPosPrinter}
		DEFINE_IID!(IID_IPosPrinterJob, 2593390684, 1557, 17809, 165, 143, 48, 248, 126, 223, 226, 228);
		RT_INTERFACE!{interface IPosPrinterJob(IPosPrinterJobVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterJob] {
			fn Print(&mut self, data: ::w::HSTRING) -> ::w::HRESULT,
			fn PrintLine(&mut self, data: ::w::HSTRING) -> ::w::HRESULT,
			fn PrintNewline(&mut self) -> ::w::HRESULT,
			fn ExecuteAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT
		}}
		impl IPosPrinterJob {
			#[inline] pub unsafe fn print(&mut self, data: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Print)(self, data.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn print_line(&mut self, data: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintLine)(self, data.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn print_newline(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintNewline)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn execute_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ExecuteAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IReceiptOrSlipJob, 1394710974, 51395, 19906, 137, 233, 92, 74, 55, 179, 77, 220);
		RT_INTERFACE!{interface IReceiptOrSlipJob(IReceiptOrSlipJobVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptOrSlipJob] {
			fn SetBarcodeRotation(&mut self, value: PosPrinterRotation) -> ::w::HRESULT,
			fn SetPrintRotation(&mut self, value: PosPrinterRotation, includeBitmaps: bool) -> ::w::HRESULT,
			fn SetPrintArea(&mut self, value: super::super::foundation::Rect) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn SetBitmap(&mut self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn SetBitmapCustomWidthStandardAlign(&mut self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn SetCustomAlignedBitmap(&mut self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn SetBitmapCustomWidthCustomAlign(&mut self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> ::w::HRESULT,
			fn PrintSavedBitmap(&mut self, bitmapNumber: u32) -> ::w::HRESULT,
			fn DrawRuledLine(&mut self, positionList: ::w::HSTRING, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> ::w::HRESULT,
			fn PrintBarcode(&mut self, data: ::w::HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> ::w::HRESULT,
			fn PrintBarcodeCustomAlign(&mut self, data: ::w::HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn PrintBitmap(&mut self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn PrintBitmapCustomWidthStandardAlign(&mut self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn PrintCustomAlignedBitmap(&mut self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn PrintBitmapCustomWidthCustomAlign(&mut self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> ::w::HRESULT
		}}
		impl IReceiptOrSlipJob {
			#[inline] pub unsafe fn set_barcode_rotation(&mut self, value: PosPrinterRotation) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetBarcodeRotation)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_print_rotation(&mut self, value: PosPrinterRotation, includeBitmaps: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetPrintRotation)(self, value, includeBitmaps);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_print_area(&mut self, value: super::super::foundation::Rect) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetPrintArea)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_bitmap(&mut self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetBitmap)(self, bitmapNumber, bitmap as *const _ as *mut _, alignment);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_bitmap_custom_width_standard_align(&mut self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetBitmapCustomWidthStandardAlign)(self, bitmapNumber, bitmap as *const _ as *mut _, alignment, width);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_custom_aligned_bitmap(&mut self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetCustomAlignedBitmap)(self, bitmapNumber, bitmap as *const _ as *mut _, alignmentDistance);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_bitmap_custom_width_custom_align(&mut self, bitmapNumber: u32, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetBitmapCustomWidthCustomAlign)(self, bitmapNumber, bitmap as *const _ as *mut _, alignmentDistance, width);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn print_saved_bitmap(&mut self, bitmapNumber: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintSavedBitmap)(self, bitmapNumber);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn draw_ruled_line(&mut self, positionList: &HStringArg, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).DrawRuledLine)(self, positionList.get(), lineDirection, lineWidth, lineStyle, lineColor);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn print_barcode(&mut self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintBarcode)(self, data.get(), symbology, height, width, textPosition, alignment);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn print_barcode_custom_align(&mut self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintBarcodeCustomAlign)(self, data.get(), symbology, height, width, textPosition, alignmentDistance);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn print_bitmap(&mut self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintBitmap)(self, bitmap as *const _ as *mut _, alignment);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn print_bitmap_custom_width_standard_align(&mut self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintBitmapCustomWidthStandardAlign)(self, bitmap as *const _ as *mut _, alignment, width);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn print_custom_aligned_bitmap(&mut self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintCustomAlignedBitmap)(self, bitmap as *const _ as *mut _, alignmentDistance);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn print_bitmap_custom_width_custom_align(&mut self, bitmap: &super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).PrintBitmapCustomWidthCustomAlign)(self, bitmap as *const _ as *mut _, alignmentDistance, width);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IReceiptPrintJob, 2861958766, 44205, 19321, 157, 15, 192, 207, 192, 141, 199, 123);
		RT_INTERFACE!{interface IReceiptPrintJob(IReceiptPrintJobVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptPrintJob] {
			fn MarkFeed(&mut self, kind: PosPrinterMarkFeedKind) -> ::w::HRESULT,
			fn CutPaper(&mut self, percentage: f64) -> ::w::HRESULT,
			fn CutPaperDefault(&mut self) -> ::w::HRESULT
		}}
		impl IReceiptPrintJob {
			#[inline] pub unsafe fn mark_feed(&mut self, kind: PosPrinterMarkFeedKind) -> RtResult<()> {
				let hr = ((*self.lpVtbl).MarkFeed)(self, kind);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn cut_paper(&mut self, percentage: f64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).CutPaper)(self, percentage);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn cut_paper_default(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).CutPaperDefault)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ReceiptPrintJob: IReceiptPrintJob}
		RT_CLASS!{class SlipPrintJob: IReceiptOrSlipJob}
		RT_CLASS!{class JournalPrintJob: IPosPrinterJob}
		DEFINE_IID!(IID_ICommonClaimedPosPrinterStation, 3085657768, 65162, 19707, 139, 66, 227, 91, 40, 12, 178, 124);
		RT_INTERFACE!{interface ICommonClaimedPosPrinterStation(ICommonClaimedPosPrinterStationVtbl): IInspectable(IInspectableVtbl) [IID_ICommonClaimedPosPrinterStation] {
			fn put_CharactersPerLine(&mut self, value: u32) -> ::w::HRESULT,
			fn get_CharactersPerLine(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_LineHeight(&mut self, value: u32) -> ::w::HRESULT,
			fn get_LineHeight(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_LineSpacing(&mut self, value: u32) -> ::w::HRESULT,
			fn get_LineSpacing(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_LineWidth(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_IsLetterQuality(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsLetterQuality(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsPaperNearEnd(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_ColorCartridge(&mut self, value: PosPrinterColorCartridge) -> ::w::HRESULT,
			fn get_ColorCartridge(&mut self, out: *mut PosPrinterColorCartridge) -> ::w::HRESULT,
			fn get_IsCoverOpen(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsCartridgeRemoved(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsCartridgeEmpty(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsHeadCleaning(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsPaperEmpty(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsReadyToPrint(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn ValidateData(&mut self, data: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT
		}}
		impl ICommonClaimedPosPrinterStation {
			#[inline] pub unsafe fn set_characters_per_line(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CharactersPerLine)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_characters_per_line(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharactersPerLine)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_line_height(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_LineHeight)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_line_height(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LineHeight)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_line_spacing(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_LineSpacing)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_line_spacing(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LineSpacing)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_line_width(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LineWidth)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_letter_quality(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsLetterQuality)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_letter_quality(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsLetterQuality)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paper_near_end(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaperNearEnd)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_color_cartridge(&mut self, value: PosPrinterColorCartridge) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ColorCartridge)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_color_cartridge(&mut self) -> RtResult<PosPrinterColorCartridge> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ColorCartridge)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_cover_open(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsCoverOpen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_cartridge_removed(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsCartridgeRemoved)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_cartridge_empty(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsCartridgeEmpty)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_head_cleaning(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsHeadCleaning)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_paper_empty(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsPaperEmpty)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_ready_to_print(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsReadyToPrint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn validate_data(&mut self, data: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).ValidateData)(self, data.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IClaimedReceiptPrinter, 2597485172, 56673, 20194, 152, 55, 91, 93, 114, 213, 56, 185);
		RT_INTERFACE!{interface IClaimedReceiptPrinter(IClaimedReceiptPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedReceiptPrinter] {
			fn get_SidewaysMaxLines(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_SidewaysMaxChars(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_LinesToPaperCut(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_PageSize(&mut self, out: *mut super::super::foundation::Size) -> ::w::HRESULT,
			fn get_PrintArea(&mut self, out: *mut super::super::foundation::Rect) -> ::w::HRESULT,
			fn CreateJob(&mut self, out: *mut *mut ReceiptPrintJob) -> ::w::HRESULT
		}}
		impl IClaimedReceiptPrinter {
			#[inline] pub unsafe fn get_sideways_max_lines(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SidewaysMaxLines)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sideways_max_chars(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SidewaysMaxChars)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_lines_to_paper_cut(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LinesToPaperCut)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_page_size(&mut self) -> RtResult<super::super::foundation::Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PageSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_print_area(&mut self) -> RtResult<super::super::foundation::Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PrintArea)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_job(&mut self) -> RtResult<ComPtr<ReceiptPrintJob>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateJob)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedReceiptPrinter: IClaimedReceiptPrinter}
		DEFINE_IID!(IID_IClaimedSlipPrinter, 3177050098, 44944, 20106, 183, 123, 227, 174, 156, 166, 58, 127);
		RT_INTERFACE!{interface IClaimedSlipPrinter(IClaimedSlipPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedSlipPrinter] {
			fn get_SidewaysMaxLines(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_SidewaysMaxChars(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MaxLines(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_LinesNearEndToEnd(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_PrintSide(&mut self, out: *mut PosPrinterPrintSide) -> ::w::HRESULT,
			fn get_PageSize(&mut self, out: *mut super::super::foundation::Size) -> ::w::HRESULT,
			fn get_PrintArea(&mut self, out: *mut super::super::foundation::Rect) -> ::w::HRESULT,
			fn OpenJaws(&mut self) -> ::w::HRESULT,
			fn CloseJaws(&mut self) -> ::w::HRESULT,
			fn InsertSlipAsync(&mut self, timeout: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn RemoveSlipAsync(&mut self, timeout: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn ChangePrintSide(&mut self, printSide: PosPrinterPrintSide) -> ::w::HRESULT,
			fn CreateJob(&mut self, out: *mut *mut SlipPrintJob) -> ::w::HRESULT
		}}
		impl IClaimedSlipPrinter {
			#[inline] pub unsafe fn get_sideways_max_lines(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SidewaysMaxLines)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sideways_max_chars(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SidewaysMaxChars)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_lines(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxLines)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_lines_near_end_to_end(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LinesNearEndToEnd)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_print_side(&mut self) -> RtResult<PosPrinterPrintSide> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PrintSide)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_page_size(&mut self) -> RtResult<super::super::foundation::Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PageSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_print_area(&mut self) -> RtResult<super::super::foundation::Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PrintArea)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_jaws(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).OpenJaws)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn close_jaws(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).CloseJaws)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn insert_slip_async(&mut self, timeout: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).InsertSlipAsync)(self, timeout, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_slip_async(&mut self, timeout: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RemoveSlipAsync)(self, timeout, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn change_print_side(&mut self, printSide: PosPrinterPrintSide) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ChangePrintSide)(self, printSide);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_job(&mut self) -> RtResult<ComPtr<SlipPrintJob>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateJob)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedSlipPrinter: IClaimedSlipPrinter}
		DEFINE_IID!(IID_IClaimedJournalPrinter, 1743390256, 20861, 18559, 159, 223, 210, 224, 160, 162, 100, 165);
		RT_INTERFACE!{interface IClaimedJournalPrinter(IClaimedJournalPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedJournalPrinter] {
			fn CreateJob(&mut self, out: *mut *mut JournalPrintJob) -> ::w::HRESULT
		}}
		impl IClaimedJournalPrinter {
			#[inline] pub unsafe fn create_job(&mut self) -> RtResult<ComPtr<JournalPrintJob>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateJob)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedJournalPrinter: IClaimedJournalPrinter}
		DEFINE_IID!(IID_ICashDrawerStatusUpdatedEventArgs, 816507274, 3440, 17820, 149, 83, 135, 225, 36, 197, 36, 136);
		RT_INTERFACE!{interface ICashDrawerStatusUpdatedEventArgs(ICashDrawerStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatusUpdatedEventArgs] {
			fn get_Status(&mut self, out: *mut *mut CashDrawerStatus) -> ::w::HRESULT
		}}
		impl ICashDrawerStatusUpdatedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<ComPtr<CashDrawerStatus>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CashDrawerStatus: ICashDrawerStatus}
		RT_CLASS!{class CashDrawerStatusUpdatedEventArgs: ICashDrawerStatusUpdatedEventArgs}
		DEFINE_IID!(IID_ICashDrawerStatus, 1807579327, 56481, 19974, 153, 235, 90, 246, 165, 174, 193, 8);
		RT_INTERFACE!{interface ICashDrawerStatus(ICashDrawerStatusVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatus] {
			fn get_StatusKind(&mut self, out: *mut CashDrawerStatusKind) -> ::w::HRESULT,
			fn get_ExtendedStatus(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl ICashDrawerStatus {
			#[inline] pub unsafe fn get_status_kind(&mut self) -> RtResult<CashDrawerStatusKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StatusKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extended_status(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ExtendedStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICashDrawerCapabilities, 197582347, 59623, 19231, 177, 209, 62, 80, 26, 208, 130, 71);
		RT_INTERFACE!{interface ICashDrawerCapabilities(ICashDrawerCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerCapabilities] {
			fn get_PowerReportingType(&mut self, out: *mut UnifiedPosPowerReportingType) -> ::w::HRESULT,
			fn get_IsStatisticsReportingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatisticsUpdatingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatusReportingSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsStatusMultiDrawerDetectSupported(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDrawerOpenSensorAvailable(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl ICashDrawerCapabilities {
			#[inline] pub unsafe fn get_power_reporting_type(&mut self) -> RtResult<UnifiedPosPowerReportingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerReportingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_reporting_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsReportingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_statistics_updating_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatisticsUpdatingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_status_reporting_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatusReportingSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_status_multi_drawer_detect_supported(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsStatusMultiDrawerDetectSupported)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_drawer_open_sensor_available(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDrawerOpenSensorAvailable)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CashDrawerCapabilities: ICashDrawerCapabilities}
		DEFINE_IID!(IID_ICashDrawerEventSourceEventArgs, 1774926785, 5247, 16924, 156, 35, 9, 1, 35, 187, 120, 108);
		RT_INTERFACE!{interface ICashDrawerEventSourceEventArgs(ICashDrawerEventSourceEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSourceEventArgs] {
			fn get_CashDrawer(&mut self, out: *mut *mut CashDrawer) -> ::w::HRESULT
		}}
		impl ICashDrawerEventSourceEventArgs {
			#[inline] pub unsafe fn get_cash_drawer(&mut self) -> RtResult<ComPtr<CashDrawer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CashDrawer)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CashDrawer: ICashDrawer}
		RT_ACTIVATABLE!{ICashDrawerStatics [CLSID_CashDrawer]}
		DEFINE_CLSID!(CLSID_CashDrawer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,67,97,115,104,68,114,97,119,101,114,0]);
		RT_CLASS!{class CashDrawerClosedEventArgs: ICashDrawerEventSourceEventArgs}
		RT_CLASS!{class CashDrawerOpenedEventArgs: ICashDrawerEventSourceEventArgs}
		DEFINE_IID!(IID_ICashDrawerEventSource, 3758548076, 62201, 17455, 141, 214, 6, 193, 10, 66, 39, 186);
		RT_INTERFACE!{interface ICashDrawerEventSource(ICashDrawerEventSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSource] {
			fn add_DrawerClosed(&mut self, handler: *mut super::super::foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DrawerClosed(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_DrawerOpened(&mut self, handler: *mut super::super::foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DrawerOpened(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ICashDrawerEventSource {
			#[inline] pub unsafe fn add_drawer_closed(&mut self, handler: &super::super::foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DrawerClosed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_drawer_closed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DrawerClosed)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_drawer_opened(&mut self, handler: &super::super::foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DrawerOpened)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_drawer_opened(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DrawerOpened)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CashDrawerEventSource: ICashDrawerEventSource}
		DEFINE_IID!(IID_ICashDrawerStatics, 3751843162, 54327, 20479, 181, 71, 221, 169, 105, 164, 248, 131);
		RT_INTERFACE!{static interface ICashDrawerStatics(ICashDrawerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<CashDrawer>) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<CashDrawer>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl ICashDrawerStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<CashDrawer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<CashDrawer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICashDrawer, 2676553160, 56916, 19182, 168, 144, 146, 11, 203, 254, 48, 252);
		RT_INTERFACE!{interface ICashDrawer(ICashDrawerVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawer] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Capabilities(&mut self, out: *mut *mut CashDrawerCapabilities) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut *mut CashDrawerStatus) -> ::w::HRESULT,
			fn get_IsDrawerOpen(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_DrawerEventSource(&mut self, out: *mut *mut CashDrawerEventSource) -> ::w::HRESULT,
			fn ClaimDrawerAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ClaimedCashDrawer>) -> ::w::HRESULT,
			fn CheckHealthAsync(&mut self, level: UnifiedPosHealthCheckLevel, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn GetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn add_StatusUpdated(&mut self, handler: *mut super::super::foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusUpdated(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ICashDrawer {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_capabilities(&mut self) -> RtResult<ComPtr<CashDrawerCapabilities>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Capabilities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<ComPtr<CashDrawerStatus>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_drawer_open(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDrawerOpen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_drawer_event_source(&mut self) -> RtResult<ComPtr<CashDrawerEventSource>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DrawerEventSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn claim_drawer_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ClaimedCashDrawer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClaimDrawerAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn check_health_async(&mut self, level: UnifiedPosHealthCheckLevel) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CheckHealthAsync)(self, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_updated(&mut self, handler: &super::super::foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusUpdated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_updated(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusUpdated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ClaimedCashDrawer: IClaimedCashDrawer}
		DEFINE_IID!(IID_ICashDrawerCloseAlarm, 1811451079, 28515, 17166, 171, 59, 149, 215, 95, 251, 232, 127);
		RT_INTERFACE!{interface ICashDrawerCloseAlarm(ICashDrawerCloseAlarmVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerCloseAlarm] {
			fn put_AlarmTimeout(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_AlarmTimeout(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_BeepFrequency(&mut self, value: u32) -> ::w::HRESULT,
			fn get_BeepFrequency(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_BeepDuration(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_BeepDuration(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_BeepDelay(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_BeepDelay(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn add_AlarmTimeoutExpired(&mut self, handler: *mut super::super::foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AlarmTimeoutExpired(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn StartAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT
		}}
		impl ICashDrawerCloseAlarm {
			#[inline] pub unsafe fn set_alarm_timeout(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AlarmTimeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alarm_timeout(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlarmTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_beep_frequency(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BeepFrequency)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_beep_frequency(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BeepFrequency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_beep_duration(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BeepDuration)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_beep_duration(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BeepDuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_beep_delay(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BeepDelay)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_beep_delay(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BeepDelay)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_alarm_timeout_expired(&mut self, handler: &super::super::foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AlarmTimeoutExpired)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_alarm_timeout_expired(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AlarmTimeoutExpired)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CashDrawerCloseAlarm: ICashDrawerCloseAlarm}
		DEFINE_IID!(IID_IClaimedBarcodeScanner, 1248048284, 36772, 17202, 187, 38, 148, 93, 17, 216, 30, 15);
		RT_INTERFACE!{interface IClaimedBarcodeScanner(IClaimedBarcodeScannerVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDisabledOnDataReceived(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsDisabledOnDataReceived(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDecodeDataEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsDecodeDataEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn EnableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn DisableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn RetainDevice(&mut self) -> ::w::HRESULT,
			fn SetActiveSymbologiesAsync(&mut self, symbologies: *mut super::super::foundation::collections::IIterable<u32>, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn ResetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn UpdateStatisticsAsync(&mut self, statistics: *mut super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn SetActiveProfileAsync(&mut self, profile: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn add_DataReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DataReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_TriggerPressed(&mut self, handler: *mut super::super::foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_TriggerPressed(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_TriggerReleased(&mut self, handler: *mut super::super::foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_TriggerReleased(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ReleaseDeviceRequested(&mut self, handler: *mut super::super::foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReleaseDeviceRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ImagePreviewReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ImagePreviewReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ErrorOccurred(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ErrorOccurred(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IClaimedBarcodeScanner {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_disabled_on_data_received(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDisabledOnDataReceived)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_disabled_on_data_received(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDisabledOnDataReceived)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_decode_data_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDecodeDataEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_decode_data_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDecodeDataEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn enable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).EnableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DisableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn retain_device(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RetainDevice)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_active_symbologies_async(&mut self, symbologies: &super::super::foundation::collections::IIterable<u32>) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SetActiveSymbologiesAsync)(self, symbologies as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn reset_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ResetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_statistics_async(&mut self, statistics: &super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UpdateStatisticsAsync)(self, statistics as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_active_profile_async(&mut self, profile: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SetActiveProfileAsync)(self, profile.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_data_received(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DataReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_data_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DataReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_trigger_pressed(&mut self, handler: &super::super::foundation::EventHandler<ClaimedBarcodeScanner>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_TriggerPressed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_trigger_pressed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_TriggerPressed)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_trigger_released(&mut self, handler: &super::super::foundation::EventHandler<ClaimedBarcodeScanner>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_TriggerReleased)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_trigger_released(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_TriggerReleased)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_release_device_requested(&mut self, handler: &super::super::foundation::EventHandler<ClaimedBarcodeScanner>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReleaseDeviceRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_release_device_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReleaseDeviceRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_image_preview_received(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ImagePreviewReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_image_preview_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ImagePreviewReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_error_occurred(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ErrorOccurred)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_error_occurred(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ErrorOccurred)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IClaimedBarcodeScanner1, 4128943372, 34129, 17076, 153, 140, 151, 12, 32, 33, 10, 34);
		RT_INTERFACE!{interface IClaimedBarcodeScanner1(IClaimedBarcodeScanner1Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner1] {
			fn StartSoftwareTriggerAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn StopSoftwareTriggerAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT
		}}
		impl IClaimedBarcodeScanner1 {
			#[inline] pub unsafe fn start_software_trigger_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartSoftwareTriggerAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop_software_trigger_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StopSoftwareTriggerAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IClaimedMagneticStripeReader, 1197254899, 37911, 18620, 185, 215, 65, 99, 167, 132, 76, 2);
		RT_INTERFACE!{interface IClaimedMagneticStripeReader(IClaimedMagneticStripeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReader] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDisabledOnDataReceived(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsDisabledOnDataReceived(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDecodeDataEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsDecodeDataEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDeviceAuthenticated(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_DataEncryptionAlgorithm(&mut self, value: u32) -> ::w::HRESULT,
			fn get_DataEncryptionAlgorithm(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_TracksToRead(&mut self, value: MagneticStripeReaderTrackIds) -> ::w::HRESULT,
			fn get_TracksToRead(&mut self, out: *mut MagneticStripeReaderTrackIds) -> ::w::HRESULT,
			fn put_IsTransmitSentinelsEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsTransmitSentinelsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn EnableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn DisableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn RetainDevice(&mut self) -> ::w::HRESULT,
			fn SetErrorReportingType(&mut self, value: MagneticStripeReaderErrorReportingType) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy17(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn RetrieveDeviceAuthenticationDataAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			fn AuthenticateDeviceAsync(&mut self, responseTokenSize: u32, responseToken: *mut u8, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn DeAuthenticateDeviceAsync(&mut self, responseTokenSize: u32, responseToken: *mut u8, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn UpdateKeyAsync(&mut self, key: ::w::HSTRING, keyName: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn ResetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn UpdateStatisticsAsync(&mut self, statistics: *mut super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn add_BankCardDataReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_BankCardDataReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_AamvaCardDataReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AamvaCardDataReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_VendorSpecificDataReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_VendorSpecificDataReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ReleaseDeviceRequested(&mut self, handler: *mut super::super::foundation::EventHandler<ClaimedMagneticStripeReader>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReleaseDeviceRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_ErrorOccurred(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ErrorOccurred(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IClaimedMagneticStripeReader {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_disabled_on_data_received(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDisabledOnDataReceived)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_disabled_on_data_received(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDisabledOnDataReceived)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_decode_data_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDecodeDataEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_decode_data_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDecodeDataEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_device_authenticated(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDeviceAuthenticated)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_encryption_algorithm(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataEncryptionAlgorithm)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_encryption_algorithm(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataEncryptionAlgorithm)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_tracks_to_read(&mut self, value: MagneticStripeReaderTrackIds) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_TracksToRead)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tracks_to_read(&mut self) -> RtResult<MagneticStripeReaderTrackIds> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TracksToRead)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_transmit_sentinels_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsTransmitSentinelsEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_transmit_sentinels_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsTransmitSentinelsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn enable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).EnableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DisableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn retain_device(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RetainDevice)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_error_reporting_type(&mut self, value: MagneticStripeReaderErrorReportingType) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetErrorReportingType)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn retrieve_device_authentication_data_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RetrieveDeviceAuthenticationDataAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn authenticate_device_async(&mut self, responseToken: &[u8]) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AuthenticateDeviceAsync)(self, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn de_authenticate_device_async(&mut self, responseToken: &[u8]) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DeAuthenticateDeviceAsync)(self, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_key_async(&mut self, key: &HStringArg, keyName: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UpdateKeyAsync)(self, key.get(), keyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn reset_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ResetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_statistics_async(&mut self, statistics: &super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UpdateStatisticsAsync)(self, statistics as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_bank_card_data_received(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_BankCardDataReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_bank_card_data_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_BankCardDataReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_aamva_card_data_received(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AamvaCardDataReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_aamva_card_data_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AamvaCardDataReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_vendor_specific_data_received(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_VendorSpecificDataReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_vendor_specific_data_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_VendorSpecificDataReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_release_device_requested(&mut self, handler: &super::super::foundation::EventHandler<ClaimedMagneticStripeReader>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReleaseDeviceRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_release_device_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReleaseDeviceRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_error_occurred(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ErrorOccurred)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_error_occurred(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ErrorOccurred)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IClaimedPosPrinter, 1835322892, 57406, 19220, 163, 142, 194, 140, 52, 184, 99, 83);
		RT_INTERFACE!{interface IClaimedPosPrinter(IClaimedPosPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinter] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_CharacterSet(&mut self, value: u32) -> ::w::HRESULT,
			fn get_CharacterSet(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_IsCoverOpen(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsCharacterSetMappingEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsCharacterSetMappingEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_MapMode(&mut self, value: PosPrinterMapMode) -> ::w::HRESULT,
			fn get_MapMode(&mut self, out: *mut PosPrinterMapMode) -> ::w::HRESULT,
			fn get_Receipt(&mut self, out: *mut *mut ClaimedReceiptPrinter) -> ::w::HRESULT,
			fn get_Slip(&mut self, out: *mut *mut ClaimedSlipPrinter) -> ::w::HRESULT,
			fn get_Journal(&mut self, out: *mut *mut ClaimedJournalPrinter) -> ::w::HRESULT,
			fn EnableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn DisableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn RetainDeviceAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn ResetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn UpdateStatisticsAsync(&mut self, statistics: *mut super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn add_ReleaseDeviceRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReleaseDeviceRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IClaimedPosPrinter {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_character_set(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CharacterSet)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_character_set(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CharacterSet)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_cover_open(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsCoverOpen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_character_set_mapping_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsCharacterSetMappingEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_character_set_mapping_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsCharacterSetMappingEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_map_mode(&mut self, value: PosPrinterMapMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_MapMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_map_mode(&mut self) -> RtResult<PosPrinterMapMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MapMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_receipt(&mut self) -> RtResult<ComPtr<ClaimedReceiptPrinter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Receipt)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_slip(&mut self) -> RtResult<ComPtr<ClaimedSlipPrinter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Slip)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_journal(&mut self) -> RtResult<ComPtr<ClaimedJournalPrinter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Journal)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn enable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).EnableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DisableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn retain_device_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RetainDeviceAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn reset_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ResetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_statistics_async(&mut self, statistics: &super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UpdateStatisticsAsync)(self, statistics as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_release_device_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReleaseDeviceRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_release_device_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReleaseDeviceRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IClaimedCashDrawer, 3393165743, 43960, 17089, 138, 132, 92, 102, 81, 47, 90, 117);
		RT_INTERFACE!{interface IClaimedCashDrawer(IClaimedCashDrawerVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawer] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_IsDrawerOpen(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_CloseAlarm(&mut self, out: *mut *mut CashDrawerCloseAlarm) -> ::w::HRESULT,
			fn OpenDrawerAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn EnableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn DisableAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn RetainDeviceAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn ResetStatisticsAsync(&mut self, statisticsCategories: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn UpdateStatisticsAsync(&mut self, statistics: *mut super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn add_ReleaseDeviceRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReleaseDeviceRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IClaimedCashDrawer {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_drawer_open(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDrawerOpen)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_close_alarm(&mut self) -> RtResult<ComPtr<CashDrawerCloseAlarm>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CloseAlarm)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn open_drawer_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).OpenDrawerAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn enable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).EnableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disable_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).DisableAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn retain_device_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RetainDeviceAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn reset_statistics_async(&mut self, statisticsCategories: &super::super::foundation::collections::IIterable<HString>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ResetStatisticsAsync)(self, statisticsCategories as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn update_statistics_async(&mut self, statistics: &super::super::foundation::collections::IIterable<super::super::foundation::collections::IKeyValuePair<HString, HString>>) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UpdateStatisticsAsync)(self, statistics as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_release_device_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReleaseDeviceRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_release_device_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReleaseDeviceRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.PointOfService
pub mod radios { // Windows.Devices.Radios
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum RadioState: i32 {
			Unknown (RadioState_Unknown) = 0, On (RadioState_On) = 1, Off (RadioState_Off) = 2, Disabled (RadioState_Disabled) = 3,
		}}
		RT_ENUM! { enum RadioKind: i32 {
			Other (RadioKind_Other) = 0, WiFi (RadioKind_WiFi) = 1, MobileBroadband (RadioKind_MobileBroadband) = 2, Bluetooth (RadioKind_Bluetooth) = 3, FM (RadioKind_FM) = 4,
		}}
		RT_ENUM! { enum RadioAccessStatus: i32 {
			Unspecified (RadioAccessStatus_Unspecified) = 0, Allowed (RadioAccessStatus_Allowed) = 1, DeniedByUser (RadioAccessStatus_DeniedByUser) = 2, DeniedBySystem (RadioAccessStatus_DeniedBySystem) = 3,
		}}
		DEFINE_IID!(IID_IRadioStatics, 1605804334, 26571, 18094, 170, 233, 101, 145, 159, 134, 239, 244);
		RT_INTERFACE!{static interface IRadioStatics(IRadioStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadioStatics] {
			fn GetRadiosAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Radio>>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Radio>) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<RadioAccessStatus>) -> ::w::HRESULT
		}}
		impl IRadioStatics {
			#[inline] pub unsafe fn get_radios_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Radio>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRadiosAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Radio>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<RadioAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Radio: IRadio}
		RT_ACTIVATABLE!{IRadioStatics [CLSID_Radio]}
		DEFINE_CLSID!(CLSID_Radio = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,82,97,100,105,111,115,46,82,97,100,105,111,0]);
		DEFINE_IID!(IID_IRadio, 622926047, 45886, 16746, 135, 95, 28, 243, 138, 226, 216, 62);
		RT_INTERFACE!{interface IRadio(IRadioVtbl): IInspectable(IInspectableVtbl) [IID_IRadio] {
			fn SetStateAsync(&mut self, value: RadioState, out: *mut *mut super::super::foundation::IAsyncOperation<RadioAccessStatus>) -> ::w::HRESULT,
			fn add_StateChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Radio, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StateChanged(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn get_State(&mut self, out: *mut RadioState) -> ::w::HRESULT,
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Kind(&mut self, out: *mut RadioKind) -> ::w::HRESULT
		}}
		impl IRadio {
			#[inline] pub unsafe fn set_state_async(&mut self, value: RadioState) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<RadioAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SetStateAsync)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_state_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Radio, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StateChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_state_changed(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StateChanged)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_state(&mut self) -> RtResult<RadioState> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_State)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_kind(&mut self) -> RtResult<RadioKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Kind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
} // Windows.Devices.Radios
pub mod sensors { // Windows.Devices.Sensors
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum MagnetometerAccuracy: i32 {
			Unknown (MagnetometerAccuracy_Unknown) = 0, Unreliable (MagnetometerAccuracy_Unreliable) = 1, Approximate (MagnetometerAccuracy_Approximate) = 2, High (MagnetometerAccuracy_High) = 3,
		}}
		RT_ENUM! { enum ActivityType: i32 {
			Unknown (ActivityType_Unknown) = 0, Idle (ActivityType_Idle) = 1, Stationary (ActivityType_Stationary) = 2, Fidgeting (ActivityType_Fidgeting) = 3, Walking (ActivityType_Walking) = 4, Running (ActivityType_Running) = 5, InVehicle (ActivityType_InVehicle) = 6, Biking (ActivityType_Biking) = 7,
		}}
		RT_ENUM! { enum ActivitySensorReadingConfidence: i32 {
			High (ActivitySensorReadingConfidence_High) = 0, Low (ActivitySensorReadingConfidence_Low) = 1,
		}}
		RT_ENUM! { enum SensorReadingType: i32 {
			Absolute (SensorReadingType_Absolute) = 0, Relative (SensorReadingType_Relative) = 1,
		}}
		RT_ENUM! { enum AccelerometerReadingType: i32 {
			Standard (AccelerometerReadingType_Standard) = 0, Linear (AccelerometerReadingType_Linear) = 1, Gravity (AccelerometerReadingType_Gravity) = 2,
		}}
		RT_ENUM! { enum SensorOptimizationGoal: i32 {
			Precision (SensorOptimizationGoal_Precision) = 0, PowerEfficiency (SensorOptimizationGoal_PowerEfficiency) = 1,
		}}
		RT_ENUM! { enum SensorType: i32 {
			Accelerometer (SensorType_Accelerometer) = 0, ActivitySensor (SensorType_ActivitySensor) = 1, Barometer (SensorType_Barometer) = 2, Compass (SensorType_Compass) = 3, CustomSensor (SensorType_CustomSensor) = 4, Gyroscope (SensorType_Gyroscope) = 5, ProximitySensor (SensorType_ProximitySensor) = 6, Inclinometer (SensorType_Inclinometer) = 7, LightSensor (SensorType_LightSensor) = 8, OrientationSensor (SensorType_OrientationSensor) = 9, Pedometer (SensorType_Pedometer) = 10, RelativeInclinometer (SensorType_RelativeInclinometer) = 11, RelativeOrientationSensor (SensorType_RelativeOrientationSensor) = 12, SimpleOrientationSensor (SensorType_SimpleOrientationSensor) = 13,
		}}
		DEFINE_IID!(IID_ISensorDataThreshold, 1423633505, 65099, 19975, 178, 96, 58, 76, 223, 190, 57, 110);
		RT_INTERFACE!{interface ISensorDataThreshold(ISensorDataThresholdVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThreshold] {
			
		}}
		DEFINE_IID!(IID_ISensorDataThresholdTriggerDetails, 2433151415, 59533, 18609, 188, 144, 97, 156, 123, 52, 147, 145);
		RT_INTERFACE!{interface ISensorDataThresholdTriggerDetails(ISensorDataThresholdTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThresholdTriggerDetails] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SensorType(&mut self, out: *mut SensorType) -> ::w::HRESULT
		}}
		impl ISensorDataThresholdTriggerDetails {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_sensor_type(&mut self) -> RtResult<SensorType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SensorType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SensorDataThresholdTriggerDetails: ISensorDataThresholdTriggerDetails}
		DEFINE_IID!(IID_IAccelerometerDeviceId, 2125227177, 38869, 17517, 171, 90, 145, 125, 249, 185, 106, 44);
		RT_INTERFACE!{interface IAccelerometerDeviceId(IAccelerometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IAccelerometerDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometerStatics, 2783087476, 23175, 18989, 190, 204, 15, 144, 110, 160, 97, 221);
		RT_INTERFACE!{static interface IAccelerometerStatics(IAccelerometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics] {
			fn GetDefault(&mut self, out: *mut *mut Accelerometer) -> ::w::HRESULT
		}}
		impl IAccelerometerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Accelerometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Accelerometer: IAccelerometer}
		RT_ACTIVATABLE!{IAccelerometerStatics [CLSID_Accelerometer]}
		RT_ACTIVATABLE!{IAccelerometerStatics2 [CLSID_Accelerometer]}
		DEFINE_CLSID!(CLSID_Accelerometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,99,101,108,101,114,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IAccelerometerStatics2, 3301213231, 55403, 18053, 178, 215, 51, 150, 247, 152, 213, 123);
		RT_INTERFACE!{static interface IAccelerometerStatics2(IAccelerometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics2] {
			fn GetDefaultWithAccelerometerReadingType(&mut self, readingType: AccelerometerReadingType, out: *mut *mut Accelerometer) -> ::w::HRESULT
		}}
		impl IAccelerometerStatics2 {
			#[inline] pub unsafe fn get_default_with_accelerometer_reading_type(&mut self, readingType: AccelerometerReadingType) -> RtResult<ComPtr<Accelerometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultWithAccelerometerReadingType)(self, readingType, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometer, 3742909768, 10001, 19879, 128, 152, 75, 130, 32, 93, 60, 125);
		RT_INTERFACE!{interface IAccelerometer(IAccelerometerVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer] {
			fn GetCurrentReading(&mut self, out: *mut *mut AccelerometerReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_Shaken(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Shaken(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAccelerometer {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<AccelerometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_shaken(&mut self, handler: &super::super::foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Shaken)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_shaken(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Shaken)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AccelerometerReading: IAccelerometerReading}
		RT_CLASS!{class AccelerometerReadingChangedEventArgs: IAccelerometerReadingChangedEventArgs}
		RT_CLASS!{class AccelerometerShakenEventArgs: IAccelerometerShakenEventArgs}
		DEFINE_IID!(IID_IAccelerometer2, 3908080366, 18788, 16410, 182, 2, 34, 13, 113, 83, 198, 10);
		RT_INTERFACE!{interface IAccelerometer2(IAccelerometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer2] {
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT
		}}
		impl IAccelerometer2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometer3, 2279604778, 60800, 18923, 191, 138, 164, 234, 49, 229, 205, 132);
		RT_INTERFACE!{interface IAccelerometer3(IAccelerometer3Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer3] {
			fn put_ReportLatency(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportLatency(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MaxBatchSize(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IAccelerometer3 {
			#[inline] pub unsafe fn set_report_latency(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportLatency)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_latency(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportLatency)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_batch_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxBatchSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometer4, 490159183, 17107, 17842, 129, 68, 171, 127, 182, 101, 235, 89);
		RT_INTERFACE!{interface IAccelerometer4(IAccelerometer4Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer4] {
			fn get_ReadingType(&mut self, out: *mut AccelerometerReadingType) -> ::w::HRESULT
		}}
		impl IAccelerometer4 {
			#[inline] pub unsafe fn get_reading_type(&mut self) -> RtResult<AccelerometerReadingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometerReading, 3120462539, 54097, 16559, 139, 182, 122, 169, 174, 100, 31, 183);
		RT_INTERFACE!{interface IAccelerometerReading(IAccelerometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_AccelerationX(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_AccelerationY(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_AccelerationZ(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IAccelerometerReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_acceleration_x(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AccelerationX)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_acceleration_y(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AccelerationY)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_acceleration_z(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AccelerationZ)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometerReadingChangedEventArgs, 9815643, 46764, 18266, 159, 68, 139, 50, 211, 90, 63, 37);
		RT_INTERFACE!{interface IAccelerometerReadingChangedEventArgs(IAccelerometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut AccelerometerReading) -> ::w::HRESULT
		}}
		impl IAccelerometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<AccelerometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAccelerometerShakenEventArgs, 2516517329, 18984, 20277, 152, 232, 129, 120, 170, 228, 8, 74);
		RT_INTERFACE!{interface IAccelerometerShakenEventArgs(IAccelerometerShakenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerShakenEventArgs] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT
		}}
		impl IAccelerometerShakenEventArgs {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerDeviceId, 32053634, 16895, 17414, 174, 131, 98, 33, 15, 241, 111, 227);
		RT_INTERFACE!{interface IInclinometerDeviceId(IInclinometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IInclinometerDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerStatics, 4063151441, 39984, 17722, 139, 73, 60, 62, 235, 51, 203, 97);
		RT_INTERFACE!{static interface IInclinometerStatics(IInclinometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics] {
			fn GetDefault(&mut self, out: *mut *mut Inclinometer) -> ::w::HRESULT
		}}
		impl IInclinometerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Inclinometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Inclinometer: IInclinometer}
		RT_ACTIVATABLE!{IInclinometerStatics2 [CLSID_Inclinometer]}
		RT_ACTIVATABLE!{IInclinometerStatics [CLSID_Inclinometer]}
		RT_ACTIVATABLE!{IInclinometerStatics3 [CLSID_Inclinometer]}
		DEFINE_CLSID!(CLSID_Inclinometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,73,110,99,108,105,110,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IInclinometerStatics2, 71276405, 27166, 18844, 134, 224, 99, 140, 26, 134, 75, 0);
		RT_INTERFACE!{static interface IInclinometerStatics2(IInclinometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics2] {
			fn GetDefaultForRelativeReadings(&mut self, out: *mut *mut Inclinometer) -> ::w::HRESULT
		}}
		impl IInclinometerStatics2 {
			#[inline] pub unsafe fn get_default_for_relative_readings(&mut self) -> RtResult<ComPtr<Inclinometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultForRelativeReadings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerStatics3, 3181003392, 47386, 18473, 147, 146, 171, 192, 182, 189, 242, 180);
		RT_INTERFACE!{static interface IInclinometerStatics3(IInclinometerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics3] {
			fn GetDefaultWithSensorReadingType(&mut self, sensorReadingtype: SensorReadingType, out: *mut *mut Inclinometer) -> ::w::HRESULT
		}}
		impl IInclinometerStatics3 {
			#[inline] pub unsafe fn get_default_with_sensor_reading_type(&mut self, sensorReadingtype: SensorReadingType) -> RtResult<ComPtr<Inclinometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultWithSensorReadingType)(self, sensorReadingtype, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometer, 642304623, 8838, 16495, 145, 97, 240, 196, 189, 128, 110, 191);
		RT_INTERFACE!{interface IInclinometer(IInclinometerVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometer] {
			fn GetCurrentReading(&mut self, out: *mut *mut InclinometerReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IInclinometer {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<InclinometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class InclinometerReading: IInclinometerReading}
		RT_CLASS!{class InclinometerReadingChangedEventArgs: IInclinometerReadingChangedEventArgs}
		DEFINE_IID!(IID_IInclinometer2, 43987859, 10418, 17912, 187, 22, 97, 232, 106, 127, 174, 110);
		RT_INTERFACE!{interface IInclinometer2(IInclinometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometer2] {
			#[cfg(not(feature="windows.graphics"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			fn get_ReadingType(&mut self, out: *mut SensorReadingType) -> ::w::HRESULT
		}}
		impl IInclinometer2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_reading_type(&mut self) -> RtResult<SensorReadingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerReading, 2672095317, 46838, 18815, 177, 39, 26, 119, 94, 80, 20, 88);
		RT_INTERFACE!{interface IInclinometerReading(IInclinometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_PitchDegrees(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_RollDegrees(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_YawDegrees(&mut self, out: *mut f32) -> ::w::HRESULT
		}}
		impl IInclinometerReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pitch_degrees(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PitchDegrees)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_roll_degrees(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RollDegrees)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_yaw_degrees(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_YawDegrees)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerReadingYawAccuracy, 3025397888, 8163, 18822, 162, 87, 230, 236, 226, 114, 57, 73);
		RT_INTERFACE!{interface IInclinometerReadingYawAccuracy(IInclinometerReadingYawAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingYawAccuracy] {
			fn get_YawAccuracy(&mut self, out: *mut MagnetometerAccuracy) -> ::w::HRESULT
		}}
		impl IInclinometerReadingYawAccuracy {
			#[inline] pub unsafe fn get_yaw_accuracy(&mut self) -> RtResult<MagnetometerAccuracy> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_YawAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IInclinometerReadingChangedEventArgs, 1256791489, 59371, 18744, 133, 17, 174, 13, 107, 68, 4, 56);
		RT_INTERFACE!{interface IInclinometerReadingChangedEventArgs(IInclinometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut InclinometerReading) -> ::w::HRESULT
		}}
		impl IInclinometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<InclinometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGyrometerDeviceId, 518383992, 35234, 17013, 158, 149, 113, 38, 244, 112, 135, 96);
		RT_INTERFACE!{interface IGyrometerDeviceId(IGyrometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IGyrometerDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGyrometerStatics, 2209802185, 58525, 19257, 134, 230, 205, 85, 75, 228, 197, 193);
		RT_INTERFACE!{static interface IGyrometerStatics(IGyrometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerStatics] {
			fn GetDefault(&mut self, out: *mut *mut Gyrometer) -> ::w::HRESULT
		}}
		impl IGyrometerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Gyrometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Gyrometer: IGyrometer}
		RT_ACTIVATABLE!{IGyrometerStatics [CLSID_Gyrometer]}
		DEFINE_CLSID!(CLSID_Gyrometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,71,121,114,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IGyrometer, 4256803268, 33969, 19618, 151, 99, 155, 88, 149, 6, 199, 12);
		RT_INTERFACE!{interface IGyrometer(IGyrometerVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometer] {
			fn GetCurrentReading(&mut self, out: *mut *mut GyrometerReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IGyrometer {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<GyrometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class GyrometerReading: IGyrometerReading}
		RT_CLASS!{class GyrometerReadingChangedEventArgs: IGyrometerReadingChangedEventArgs}
		DEFINE_IID!(IID_IGyrometer2, 1675568195, 36072, 16835, 172, 68, 134, 152, 129, 11, 85, 127);
		RT_INTERFACE!{interface IGyrometer2(IGyrometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IGyrometer2] {
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT
		}}
		impl IGyrometer2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGyrometerReading, 3017203292, 7908, 17775, 157, 231, 226, 73, 59, 92, 142, 3);
		RT_INTERFACE!{interface IGyrometerReading(IGyrometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_AngularVelocityX(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_AngularVelocityY(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_AngularVelocityZ(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IGyrometerReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_angular_velocity_x(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AngularVelocityX)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_angular_velocity_y(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AngularVelocityY)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_angular_velocity_z(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AngularVelocityZ)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IGyrometerReadingChangedEventArgs, 266279061, 28574, 17102, 141, 88, 56, 140, 10, 184, 53, 109);
		RT_INTERFACE!{interface IGyrometerReadingChangedEventArgs(IGyrometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut GyrometerReading) -> ::w::HRESULT
		}}
		impl IGyrometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<GyrometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICompassDeviceId, 3514944041, 45189, 19229, 135, 10, 79, 245, 123, 167, 79, 212);
		RT_INTERFACE!{interface ICompassDeviceId(ICompassDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ICompassDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl ICompassDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICompassStatics, 2596050911, 22252, 19493, 181, 77, 64, 166, 139, 181, 178, 105);
		RT_INTERFACE!{static interface ICompassStatics(ICompassStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompassStatics] {
			fn GetDefault(&mut self, out: *mut *mut Compass) -> ::w::HRESULT
		}}
		impl ICompassStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Compass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Compass: ICompass}
		RT_ACTIVATABLE!{ICompassStatics [CLSID_Compass]}
		DEFINE_CLSID!(CLSID_Compass = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,111,109,112,97,115,115,0]);
		DEFINE_IID!(IID_ICompass, 691010196, 6981, 16444, 186, 6, 177, 6, 219, 166, 154, 100);
		RT_INTERFACE!{interface ICompass(ICompassVtbl): IInspectable(IInspectableVtbl) [IID_ICompass] {
			fn GetCurrentReading(&mut self, out: *mut *mut CompassReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ICompass {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<CompassReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CompassReading: ICompassReading}
		RT_CLASS!{class CompassReadingChangedEventArgs: ICompassReadingChangedEventArgs}
		DEFINE_IID!(IID_ICompass2, 921857289, 51159, 17231, 180, 97, 151, 157, 223, 194, 50, 47);
		RT_INTERFACE!{interface ICompass2(ICompass2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompass2] {
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT
		}}
		impl ICompass2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICompassReading, 2190545192, 20797, 19913, 183, 129, 94, 237, 251, 240, 45, 12);
		RT_INTERFACE!{interface ICompassReading(ICompassReadingVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_HeadingMagneticNorth(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_HeadingTrueNorth(&mut self, out: *mut *mut super::super::foundation::IReference<f64>) -> ::w::HRESULT
		}}
		impl ICompassReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heading_magnetic_north(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeadingMagneticNorth)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_heading_true_north(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<f64>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HeadingTrueNorth)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICompassReadingHeadingAccuracy, 3881907534, 35089, 16631, 158, 22, 110, 204, 125, 174, 197, 222);
		RT_INTERFACE!{interface ICompassReadingHeadingAccuracy(ICompassReadingHeadingAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReadingHeadingAccuracy] {
			fn get_HeadingAccuracy(&mut self, out: *mut MagnetometerAccuracy) -> ::w::HRESULT
		}}
		impl ICompassReadingHeadingAccuracy {
			#[inline] pub unsafe fn get_heading_accuracy(&mut self) -> RtResult<MagnetometerAccuracy> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HeadingAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICompassReadingChangedEventArgs, 2400537008, 59580, 19582, 176, 9, 78, 65, 223, 19, 112, 114);
		RT_INTERFACE!{interface ICompassReadingChangedEventArgs(ICompassReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut CompassReading) -> ::w::HRESULT
		}}
		impl ICompassReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<CompassReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILightSensorDeviceId, 2146322936, 2811, 20305, 135, 240, 108, 38, 55, 92, 233, 79);
		RT_INTERFACE!{interface ILightSensorDeviceId(ILightSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl ILightSensorDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILightSensorStatics, 1172016260, 50088, 18206, 154, 83, 100, 87, 250, 216, 124, 14);
		RT_INTERFACE!{static interface ILightSensorStatics(ILightSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorStatics] {
			fn GetDefault(&mut self, out: *mut *mut LightSensor) -> ::w::HRESULT
		}}
		impl ILightSensorStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<LightSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LightSensor: ILightSensor}
		RT_ACTIVATABLE!{ILightSensorStatics [CLSID_LightSensor]}
		DEFINE_CLSID!(CLSID_LightSensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,76,105,103,104,116,83,101,110,115,111,114,0]);
		DEFINE_IID!(IID_ILightSensor, 4165732120, 3156, 18350, 146, 46, 120, 159, 87, 251, 3, 160);
		RT_INTERFACE!{interface ILightSensor(ILightSensorVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensor] {
			fn GetCurrentReading(&mut self, out: *mut *mut LightSensorReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ILightSensor {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<LightSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LightSensorReading: ILightSensorReading}
		RT_CLASS!{class LightSensorReadingChangedEventArgs: ILightSensorReadingChangedEventArgs}
		DEFINE_IID!(IID_ILightSensorReading, 4292829952, 8828, 19755, 179, 2, 252, 1, 66, 72, 92, 104);
		RT_INTERFACE!{interface ILightSensorReading(ILightSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_IlluminanceInLux(&mut self, out: *mut f32) -> ::w::HRESULT
		}}
		impl ILightSensorReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_illuminance_in_lux(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IlluminanceInLux)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILightSensorReadingChangedEventArgs, 2745365711, 9611, 16908, 184, 171, 142, 221, 96, 30, 207, 80);
		RT_INTERFACE!{interface ILightSensorReadingChangedEventArgs(ILightSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut LightSensorReading) -> ::w::HRESULT
		}}
		impl ILightSensorReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<LightSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISensorRotationMatrix, 171792999, 8948, 17298, 149, 56, 101, 208, 189, 6, 74, 166);
		RT_INTERFACE!{interface ISensorRotationMatrix(ISensorRotationMatrixVtbl): IInspectable(IInspectableVtbl) [IID_ISensorRotationMatrix] {
			fn get_M11(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M12(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M13(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M21(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M22(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M23(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M31(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M32(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_M33(&mut self, out: *mut f32) -> ::w::HRESULT
		}}
		impl ISensorRotationMatrix {
			#[inline] pub unsafe fn get_m11(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M11)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m12(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M12)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m13(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M13)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m21(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M21)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m22(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M22)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m23(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M23)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m31(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M31)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m32(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_m33(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_M33)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISensorQuaternion, 3385182247, 50972, 18151, 157, 163, 54, 161, 147, 178, 50, 188);
		RT_INTERFACE!{interface ISensorQuaternion(ISensorQuaternionVtbl): IInspectable(IInspectableVtbl) [IID_ISensorQuaternion] {
			fn get_W(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_X(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_Y(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_Z(&mut self, out: *mut f32) -> ::w::HRESULT
		}}
		impl ISensorQuaternion {
			#[inline] pub unsafe fn get_w(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_W)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_x(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_X)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_y(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Y)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_z(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Z)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SensorRotationMatrix: ISensorRotationMatrix}
		RT_CLASS!{class SensorQuaternion: ISensorQuaternion}
		DEFINE_IID!(IID_IOrientationSensorDeviceId, 1516877384, 19497, 18924, 178, 143, 234, 29, 17, 123, 102, 240);
		RT_INTERFACE!{interface IOrientationSensorDeviceId(IOrientationSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IOrientationSensorDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensorStatics, 284133138, 64332, 17034, 137, 139, 39, 101, 228, 9, 230, 105);
		RT_INTERFACE!{static interface IOrientationSensorStatics(IOrientationSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics] {
			fn GetDefault(&mut self, out: *mut *mut OrientationSensor) -> ::w::HRESULT
		}}
		impl IOrientationSensorStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<OrientationSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class OrientationSensor: IOrientationSensor}
		RT_ACTIVATABLE!{IOrientationSensorStatics [CLSID_OrientationSensor]}
		RT_ACTIVATABLE!{IOrientationSensorStatics3 [CLSID_OrientationSensor]}
		RT_ACTIVATABLE!{IOrientationSensorStatics2 [CLSID_OrientationSensor]}
		DEFINE_CLSID!(CLSID_OrientationSensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]);
		DEFINE_IID!(IID_IOrientationSensorStatics2, 1507462411, 54282, 19569, 146, 118, 138, 39, 42, 10, 102, 25);
		RT_INTERFACE!{static interface IOrientationSensorStatics2(IOrientationSensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics2] {
			fn GetDefaultForRelativeReadings(&mut self, out: *mut *mut OrientationSensor) -> ::w::HRESULT
		}}
		impl IOrientationSensorStatics2 {
			#[inline] pub unsafe fn get_default_for_relative_readings(&mut self) -> RtResult<ComPtr<OrientationSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultForRelativeReadings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensorStatics3, 3626821920, 10103, 16639, 159, 89, 214, 84, 176, 133, 241, 47);
		RT_INTERFACE!{static interface IOrientationSensorStatics3(IOrientationSensorStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics3] {
			fn GetDefaultWithSensorReadingType(&mut self, sensorReadingtype: SensorReadingType, out: *mut *mut OrientationSensor) -> ::w::HRESULT,
			fn GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(&mut self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal, out: *mut *mut OrientationSensor) -> ::w::HRESULT
		}}
		impl IOrientationSensorStatics3 {
			#[inline] pub unsafe fn get_default_with_sensor_reading_type(&mut self, sensorReadingtype: SensorReadingType) -> RtResult<ComPtr<OrientationSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultWithSensorReadingType)(self, sensorReadingtype, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_with_sensor_reading_type_and_sensor_optimization_goal(&mut self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> RtResult<ComPtr<OrientationSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal)(self, sensorReadingType, optimizationGoal, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensor, 1580549685, 53099, 19555, 171, 216, 16, 37, 43, 11, 246, 236);
		RT_INTERFACE!{interface IOrientationSensor(IOrientationSensorVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensor] {
			fn GetCurrentReading(&mut self, out: *mut *mut OrientationSensorReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IOrientationSensor {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<OrientationSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class OrientationSensorReading: IOrientationSensorReading}
		RT_CLASS!{class OrientationSensorReadingChangedEventArgs: IOrientationSensorReadingChangedEventArgs}
		DEFINE_IID!(IID_IOrientationSensor2, 227691769, 12063, 18889, 128, 66, 74, 24, 19, 214, 119, 96);
		RT_INTERFACE!{interface IOrientationSensor2(IOrientationSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensor2] {
			#[cfg(not(feature="windows.graphics"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			fn get_ReadingType(&mut self, out: *mut SensorReadingType) -> ::w::HRESULT
		}}
		impl IOrientationSensor2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_reading_type(&mut self) -> RtResult<SensorReadingType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensorReading, 1196870035, 26005, 18583, 188, 198, 213, 55, 238, 117, 117, 100);
		RT_INTERFACE!{interface IOrientationSensorReading(IOrientationSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_RotationMatrix(&mut self, out: *mut *mut SensorRotationMatrix) -> ::w::HRESULT,
			fn get_Quaternion(&mut self, out: *mut *mut SensorQuaternion) -> ::w::HRESULT
		}}
		impl IOrientationSensorReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rotation_matrix(&mut self) -> RtResult<ComPtr<SensorRotationMatrix>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RotationMatrix)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_quaternion(&mut self) -> RtResult<ComPtr<SensorQuaternion>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Quaternion)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensorReadingYawAccuracy, 3517749284, 16218, 18850, 188, 123, 17, 128, 188, 56, 205, 43);
		RT_INTERFACE!{interface IOrientationSensorReadingYawAccuracy(IOrientationSensorReadingYawAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingYawAccuracy] {
			fn get_YawAccuracy(&mut self, out: *mut MagnetometerAccuracy) -> ::w::HRESULT
		}}
		impl IOrientationSensorReadingYawAccuracy {
			#[inline] pub unsafe fn get_yaw_accuracy(&mut self) -> RtResult<MagnetometerAccuracy> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_YawAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IOrientationSensorReadingChangedEventArgs, 19665286, 50106, 18108, 174, 101, 122, 152, 153, 108, 191, 184);
		RT_INTERFACE!{interface IOrientationSensorReadingChangedEventArgs(IOrientationSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut OrientationSensorReading) -> ::w::HRESULT
		}}
		impl IOrientationSensorReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<OrientationSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum SimpleOrientation: i32 {
			NotRotated (SimpleOrientation_NotRotated) = 0, Rotated90DegreesCounterclockwise (SimpleOrientation_Rotated90DegreesCounterclockwise) = 1, Rotated180DegreesCounterclockwise (SimpleOrientation_Rotated180DegreesCounterclockwise) = 2, Rotated270DegreesCounterclockwise (SimpleOrientation_Rotated270DegreesCounterclockwise) = 3, Faceup (SimpleOrientation_Faceup) = 4, Facedown (SimpleOrientation_Facedown) = 5,
		}}
		DEFINE_IID!(IID_ISimpleOrientationSensorDeviceId, 4223666891, 15222, 16886, 128, 145, 48, 239, 230, 70, 211, 207);
		RT_INTERFACE!{interface ISimpleOrientationSensorDeviceId(ISimpleOrientationSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl ISimpleOrientationSensorDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISimpleOrientationSensorStatics, 1928136303, 28842, 16582, 155, 27, 52, 51, 247, 69, 155, 78);
		RT_INTERFACE!{static interface ISimpleOrientationSensorStatics(ISimpleOrientationSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorStatics] {
			fn GetDefault(&mut self, out: *mut *mut SimpleOrientationSensor) -> ::w::HRESULT
		}}
		impl ISimpleOrientationSensorStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<SimpleOrientationSensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SimpleOrientationSensor: ISimpleOrientationSensor}
		RT_ACTIVATABLE!{ISimpleOrientationSensorStatics [CLSID_SimpleOrientationSensor]}
		DEFINE_CLSID!(CLSID_SimpleOrientationSensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,83,105,109,112,108,101,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]);
		DEFINE_IID!(IID_ISimpleOrientationSensor, 1609906262, 8522, 19950, 163, 249, 97, 111, 26, 176, 111, 253);
		RT_INTERFACE!{interface ISimpleOrientationSensor(ISimpleOrientationSensorVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor] {
			fn GetCurrentOrientation(&mut self, out: *mut SimpleOrientation) -> ::w::HRESULT,
			fn add_OrientationChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_OrientationChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISimpleOrientationSensor {
			#[inline] pub unsafe fn get_current_orientation(&mut self) -> RtResult<SimpleOrientation> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetCurrentOrientation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_orientation_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_OrientationChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_orientation_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_OrientationChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SimpleOrientationSensorOrientationChangedEventArgs: ISimpleOrientationSensorOrientationChangedEventArgs}
		DEFINE_IID!(IID_ISimpleOrientationSensor2, 2725750680, 34928, 17726, 139, 214, 184, 245, 216, 215, 148, 27);
		RT_INTERFACE!{interface ISimpleOrientationSensor2(ISimpleOrientationSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor2] {
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT
		}}
		impl ISimpleOrientationSensor2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISimpleOrientationSensorOrientationChangedEventArgs, 3168126560, 9172, 19276, 162, 46, 186, 129, 173, 224, 198, 1);
		RT_INTERFACE!{interface ISimpleOrientationSensorOrientationChangedEventArgs(ISimpleOrientationSensorOrientationChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorOrientationChangedEventArgs] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_Orientation(&mut self, out: *mut SimpleOrientation) -> ::w::HRESULT
		}}
		impl ISimpleOrientationSensorOrientationChangedEventArgs {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_orientation(&mut self) -> RtResult<SimpleOrientation> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Orientation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagnetometerDeviceId, 1488230594, 32331, 16460, 159, 197, 93, 232, 180, 14, 186, 227);
		RT_INTERFACE!{interface IMagnetometerDeviceId(IMagnetometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerDeviceId] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IMagnetometerDeviceId {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagnetometerStatics, 2235327692, 1688, 19930, 166, 223, 156, 185, 204, 74, 180, 10);
		RT_INTERFACE!{static interface IMagnetometerStatics(IMagnetometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerStatics] {
			fn GetDefault(&mut self, out: *mut *mut Magnetometer) -> ::w::HRESULT
		}}
		impl IMagnetometerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Magnetometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Magnetometer: IMagnetometer}
		RT_ACTIVATABLE!{IMagnetometerStatics [CLSID_Magnetometer]}
		DEFINE_CLSID!(CLSID_Magnetometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,77,97,103,110,101,116,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IMagnetometer, 1213162094, 54217, 16657, 179, 246, 44, 241, 250, 164, 24, 213);
		RT_INTERFACE!{interface IMagnetometer(IMagnetometerVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometer] {
			fn GetCurrentReading(&mut self, out: *mut *mut MagnetometerReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IMagnetometer {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<MagnetometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MagnetometerReading: IMagnetometerReading}
		RT_CLASS!{class MagnetometerReadingChangedEventArgs: IMagnetometerReadingChangedEventArgs}
		DEFINE_IID!(IID_IMagnetometer2, 3026545797, 9974, 17483, 169, 226, 162, 63, 150, 108, 211, 104);
		RT_INTERFACE!{interface IMagnetometer2(IMagnetometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometer2] {
			#[cfg(feature="windows.graphics")] fn put_ReadingTransform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT,
			#[cfg(feature="windows.graphics")] fn get_ReadingTransform(&mut self, out: *mut super::super::graphics::display::DisplayOrientations) -> ::w::HRESULT
		}}
		impl IMagnetometer2 {
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_reading_transform(&mut self, value: super::super::graphics::display::DisplayOrientations) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadingTransform)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_reading_transform(&mut self) -> RtResult<super::super::graphics::display::DisplayOrientations> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadingTransform)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagnetometerReading, 204260365, 60413, 20060, 187, 17, 175, 194, 155, 60, 174, 97);
		RT_INTERFACE!{interface IMagnetometerReading(IMagnetometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_MagneticFieldX(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_MagneticFieldY(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_MagneticFieldZ(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn get_DirectionalAccuracy(&mut self, out: *mut MagnetometerAccuracy) -> ::w::HRESULT
		}}
		impl IMagnetometerReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_magnetic_field_x(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MagneticFieldX)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_magnetic_field_y(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MagneticFieldY)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_magnetic_field_z(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MagneticFieldZ)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_directional_accuracy(&mut self) -> RtResult<MagnetometerAccuracy> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DirectionalAccuracy)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMagnetometerReadingChangedEventArgs, 401270898, 11961, 20199, 138, 208, 49, 39, 83, 125, 148, 155);
		RT_INTERFACE!{interface IMagnetometerReadingChangedEventArgs(IMagnetometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut MagnetometerReading) -> ::w::HRESULT
		}}
		impl IMagnetometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<MagnetometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IActivitySensorStatics, 2803764893, 61067, 17873, 178, 91, 8, 204, 13, 249, 42, 182);
		RT_INTERFACE!{static interface IActivitySensorStatics(IActivitySensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorStatics] {
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ActivitySensor>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ActivitySensor>) -> ::w::HRESULT,
			fn GetSystemHistoryAsync(&mut self, fromTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ActivitySensorReading>>) -> ::w::HRESULT,
			fn GetSystemHistoryWithDurationAsync(&mut self, fromTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ActivitySensorReading>>) -> ::w::HRESULT
		}}
		impl IActivitySensorStatics {
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ActivitySensor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ActivitySensor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_system_history_async(&mut self, fromTime: super::super::foundation::DateTime) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ActivitySensorReading>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSystemHistoryAsync)(self, fromTime, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_system_history_with_duration_async(&mut self, fromTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ActivitySensorReading>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSystemHistoryWithDurationAsync)(self, fromTime, duration, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ActivitySensor: IActivitySensor}
		RT_ACTIVATABLE!{IActivitySensorStatics [CLSID_ActivitySensor]}
		DEFINE_CLSID!(CLSID_ActivitySensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,116,105,118,105,116,121,83,101,110,115,111,114,0]);
		RT_CLASS!{class ActivitySensorReading: IActivitySensorReading}
		DEFINE_IID!(IID_IActivitySensor, 3447350028, 64351, 18667, 176, 155, 162, 112, 141, 28, 97, 239);
		RT_INTERFACE!{interface IActivitySensor(IActivitySensorVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensor] {
			fn GetCurrentReadingAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<ActivitySensorReading>) -> ::w::HRESULT,
			fn get_SubscribedActivities(&mut self, out: *mut *mut super::super::foundation::collections::IVector<ActivityType>) -> ::w::HRESULT,
			fn get_PowerInMilliwatts(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SupportedActivities(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<ActivityType>) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IActivitySensor {
			#[inline] pub unsafe fn get_current_reading_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ActivitySensorReading>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReadingAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_subscribed_activities(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<ActivityType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SubscribedActivities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_power_in_milliwatts(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerInMilliwatts)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_activities(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<ActivityType>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedActivities)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ActivitySensorReadingChangedEventArgs: IActivitySensorReadingChangedEventArgs}
		DEFINE_IID!(IID_IActivitySensorReading, 2232572566, 5234, 16546, 178, 174, 225, 239, 41, 34, 108, 120);
		RT_INTERFACE!{interface IActivitySensorReading(IActivitySensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_Activity(&mut self, out: *mut ActivityType) -> ::w::HRESULT,
			fn get_Confidence(&mut self, out: *mut ActivitySensorReadingConfidence) -> ::w::HRESULT
		}}
		impl IActivitySensorReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_activity(&mut self) -> RtResult<ActivityType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Activity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_confidence(&mut self) -> RtResult<ActivitySensorReadingConfidence> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Confidence)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IActivitySensorReadingChangedEventArgs, 3728238359, 44726, 20167, 148, 106, 217, 204, 25, 185, 81, 236);
		RT_INTERFACE!{interface IActivitySensorReadingChangedEventArgs(IActivitySensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut ActivitySensorReading) -> ::w::HRESULT
		}}
		impl IActivitySensorReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<ActivitySensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IActivitySensorReadingChangeReport, 1329342741, 55611, 18365, 150, 10, 242, 15, 178, 243, 34, 185);
		RT_INTERFACE!{interface IActivitySensorReadingChangeReport(IActivitySensorReadingChangeReportVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangeReport] {
			fn get_Reading(&mut self, out: *mut *mut ActivitySensorReading) -> ::w::HRESULT
		}}
		impl IActivitySensorReadingChangeReport {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<ActivitySensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IActivitySensorTriggerDetails, 748578322, 47562, 18039, 178, 99, 36, 50, 151, 247, 157, 58);
		RT_INTERFACE!{interface IActivitySensorTriggerDetails(IActivitySensorTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorTriggerDetails] {
			fn ReadReports(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<ActivitySensorReadingChangeReport>) -> ::w::HRESULT
		}}
		impl IActivitySensorTriggerDetails {
			#[inline] pub unsafe fn read_reports(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<ActivitySensorReadingChangeReport>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ReadReports)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ActivitySensorReadingChangeReport: IActivitySensorReadingChangeReport}
		RT_CLASS!{class ActivitySensorTriggerDetails: IActivitySensorTriggerDetails}
		DEFINE_IID!(IID_IBarometerStatics, 678110986, 739, 20358, 132, 252, 253, 216, 146, 181, 148, 15);
		RT_INTERFACE!{static interface IBarometerStatics(IBarometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerStatics] {
			fn GetDefault(&mut self, out: *mut *mut Barometer) -> ::w::HRESULT
		}}
		impl IBarometerStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Barometer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Barometer: IBarometer}
		RT_ACTIVATABLE!{IBarometerStatics [CLSID_Barometer]}
		DEFINE_CLSID!(CLSID_Barometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,66,97,114,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IBarometer, 2470737320, 30911, 17711, 176, 23, 240, 32, 156, 230, 218, 180);
		RT_INTERFACE!{interface IBarometer(IBarometerVtbl): IInspectable(IInspectableVtbl) [IID_IBarometer] {
			fn GetCurrentReading(&mut self, out: *mut *mut BarometerReading) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IBarometer {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<BarometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class BarometerReading: IBarometerReading}
		RT_CLASS!{class BarometerReadingChangedEventArgs: IBarometerReadingChangedEventArgs}
		DEFINE_IID!(IID_IBarometerReading, 4122596070, 7670, 18970, 167, 173, 50, 29, 79, 93, 178, 71);
		RT_INTERFACE!{interface IBarometerReading(IBarometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_StationPressureInHectopascals(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IBarometerReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_station_pressure_in_hectopascals(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StationPressureInHectopascals)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IBarometerReadingChangedEventArgs, 1032098911, 891, 16463, 155, 187, 98, 50, 214, 149, 67, 195);
		RT_INTERFACE!{interface IBarometerReadingChangedEventArgs(IBarometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut BarometerReading) -> ::w::HRESULT
		}}
		impl IBarometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<BarometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum PedometerStepKind: i32 {
			Unknown (PedometerStepKind_Unknown) = 0, Walking (PedometerStepKind_Walking) = 1, Running (PedometerStepKind_Running) = 2,
		}}
		DEFINE_IID!(IID_IPedometerReading, 575003892, 43233, 17199, 137, 106, 190, 13, 217, 176, 45, 36);
		RT_INTERFACE!{interface IPedometerReading(IPedometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerReading] {
			fn get_StepKind(&mut self, out: *mut PedometerStepKind) -> ::w::HRESULT,
			fn get_CumulativeSteps(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_CumulativeStepsDuration(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT
		}}
		impl IPedometerReading {
			#[inline] pub unsafe fn get_step_kind(&mut self) -> RtResult<PedometerStepKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StepKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cumulative_steps(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CumulativeSteps)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_cumulative_steps_duration(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CumulativeStepsDuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPedometerReadingChangedEventArgs, 4166378622, 43964, 17494, 134, 168, 37, 207, 43, 51, 55, 66);
		RT_INTERFACE!{interface IPedometerReadingChangedEventArgs(IPedometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut PedometerReading) -> ::w::HRESULT
		}}
		impl IPedometerReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<PedometerReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PedometerReading: IPedometerReading}
		DEFINE_IID!(IID_IPedometerStatics, 2191002159, 16515, 19963, 180, 17, 147, 142, 160, 244, 185, 70);
		RT_INTERFACE!{static interface IPedometerStatics(IPedometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Pedometer>) -> ::w::HRESULT,
			fn GetDefaultAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<Pedometer>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetSystemHistoryAsync(&mut self, fromTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PedometerReading>>) -> ::w::HRESULT,
			fn GetSystemHistoryWithDurationAsync(&mut self, fromTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PedometerReading>>) -> ::w::HRESULT
		}}
		impl IPedometerStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Pedometer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<Pedometer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefaultAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_system_history_async(&mut self, fromTime: super::super::foundation::DateTime) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PedometerReading>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSystemHistoryAsync)(self, fromTime, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_system_history_with_duration_async(&mut self, fromTime: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PedometerReading>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSystemHistoryWithDurationAsync)(self, fromTime, duration, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Pedometer: IPedometer}
		RT_ACTIVATABLE!{IPedometerStatics2 [CLSID_Pedometer]}
		RT_ACTIVATABLE!{IPedometerStatics [CLSID_Pedometer]}
		DEFINE_CLSID!(CLSID_Pedometer = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IPedometerStatics2, 2046150331, 52750, 16691, 180, 126, 134, 39, 234, 114, 246, 119);
		RT_INTERFACE!{static interface IPedometerStatics2(IPedometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPedometerStatics2] {
			fn GetReadingsFromTriggerDetails(&mut self, triggerDetails: *mut SensorDataThresholdTriggerDetails, out: *mut *mut super::super::foundation::collections::IVectorView<PedometerReading>) -> ::w::HRESULT
		}}
		impl IPedometerStatics2 {
			#[inline] pub unsafe fn get_readings_from_trigger_details(&mut self, triggerDetails: &SensorDataThresholdTriggerDetails) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<PedometerReading>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetReadingsFromTriggerDetails)(self, triggerDetails as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPedometer2, 3852732127, 11137, 19165, 178, 255, 119, 171, 108, 152, 186, 25);
		RT_INTERFACE!{interface IPedometer2(IPedometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IPedometer2] {
			fn GetCurrentReadings(&mut self, out: *mut *mut super::super::foundation::collections::IMapView<PedometerStepKind, PedometerReading>) -> ::w::HRESULT
		}}
		impl IPedometer2 {
			#[inline] pub unsafe fn get_current_readings(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IMapView<PedometerStepKind, PedometerReading>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReadings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPedometer, 2585657661, 15768, 17912, 137, 32, 142, 78, 202, 202, 95, 151);
		RT_INTERFACE!{interface IPedometer(IPedometerVtbl): IInspectable(IInspectableVtbl) [IID_IPedometer] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_PowerInMilliwatts(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IPedometer {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_power_in_milliwatts(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PowerInMilliwatts)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PedometerReadingChangedEventArgs: IPedometerReadingChangedEventArgs}
		DEFINE_IID!(IID_IPedometerDataThresholdFactory, 3417149264, 31316, 18027, 144, 16, 119, 161, 98, 252, 165, 215);
		RT_INTERFACE!{static interface IPedometerDataThresholdFactory(IPedometerDataThresholdFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerDataThresholdFactory] {
			fn Create(&mut self, sensor: *mut Pedometer, stepGoal: i32, out: *mut *mut PedometerDataThreshold) -> ::w::HRESULT
		}}
		impl IPedometerDataThresholdFactory {
			#[inline] pub unsafe fn create(&mut self, sensor: &Pedometer, stepGoal: i32) -> RtResult<ComPtr<PedometerDataThreshold>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, sensor as *const _ as *mut _, stepGoal, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class PedometerDataThreshold: ISensorDataThreshold [IPedometerDataThresholdFactory] [CLSID_PedometerDataThreshold]}
		DEFINE_CLSID!(CLSID_PedometerDataThreshold = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]);
		DEFINE_IID!(IID_IProximitySensorStatics, 689464905, 25193, 20055, 165, 173, 130, 190, 128, 129, 51, 146);
		RT_INTERFACE!{static interface IProximitySensorStatics(IProximitySensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromId(&mut self, sensorId: ::w::HSTRING, out: *mut *mut ProximitySensor) -> ::w::HRESULT
		}}
		impl IProximitySensorStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id(&mut self, sensorId: &HStringArg) -> RtResult<ComPtr<ProximitySensor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromId)(self, sensorId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ProximitySensor: IProximitySensor}
		RT_ACTIVATABLE!{IProximitySensorStatics2 [CLSID_ProximitySensor]}
		RT_ACTIVATABLE!{IProximitySensorStatics [CLSID_ProximitySensor]}
		DEFINE_CLSID!(CLSID_ProximitySensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,0]);
		DEFINE_IID!(IID_IProximitySensor, 1421899448, 60667, 18756, 185, 40, 116, 252, 80, 77, 71, 238);
		RT_INTERFACE!{interface IProximitySensor(IProximitySensorVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensor] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MaxDistanceInMillimeters(&mut self, out: *mut *mut super::super::foundation::IReference<u32>) -> ::w::HRESULT,
			fn get_MinDistanceInMillimeters(&mut self, out: *mut *mut super::super::foundation::IReference<u32>) -> ::w::HRESULT,
			fn GetCurrentReading(&mut self, out: *mut *mut ProximitySensorReading) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn CreateDisplayOnOffController(&mut self, out: *mut *mut ProximitySensorDisplayOnOffController) -> ::w::HRESULT
		}}
		impl IProximitySensor {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_distance_in_millimeters(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MaxDistanceInMillimeters)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_distance_in_millimeters(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_MinDistanceInMillimeters)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<ProximitySensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_display_on_off_controller(&mut self) -> RtResult<ComPtr<ProximitySensorDisplayOnOffController>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateDisplayOnOffController)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ProximitySensorReading: IProximitySensorReading}
		RT_CLASS!{class ProximitySensorReadingChangedEventArgs: IProximitySensorReadingChangedEventArgs}
		RT_CLASS!{class ProximitySensorDisplayOnOffController: super::super::foundation::IClosable}
		DEFINE_IID!(IID_IProximitySensorReadingChangedEventArgs, 3485660006, 50152, 16637, 140, 195, 103, 226, 137, 0, 73, 56);
		RT_INTERFACE!{interface IProximitySensorReadingChangedEventArgs(IProximitySensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut ProximitySensorReading) -> ::w::HRESULT
		}}
		impl IProximitySensorReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<ProximitySensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IProximitySensorReading, 1898089817, 4909, 19807, 143, 249, 47, 13, 184, 117, 28, 237);
		RT_INTERFACE!{interface IProximitySensorReading(IProximitySensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_IsDetected(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_DistanceInMillimeters(&mut self, out: *mut *mut super::super::foundation::IReference<u32>) -> ::w::HRESULT
		}}
		impl IProximitySensorReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_detected(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDetected)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_distance_in_millimeters(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DistanceInMillimeters)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IProximitySensorDataThresholdFactory, 2421866785, 27943, 19155, 157, 181, 100, 103, 242, 165, 173, 157);
		RT_INTERFACE!{static interface IProximitySensorDataThresholdFactory(IProximitySensorDataThresholdFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorDataThresholdFactory] {
			fn Create(&mut self, sensor: *mut ProximitySensor, out: *mut *mut ProximitySensorDataThreshold) -> ::w::HRESULT
		}}
		impl IProximitySensorDataThresholdFactory {
			#[inline] pub unsafe fn create(&mut self, sensor: &ProximitySensor) -> RtResult<ComPtr<ProximitySensorDataThreshold>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, sensor as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ProximitySensorDataThreshold: ISensorDataThreshold [IProximitySensorDataThresholdFactory] [CLSID_ProximitySensorDataThreshold]}
		DEFINE_CLSID!(CLSID_ProximitySensorDataThreshold = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]);
		DEFINE_IID!(IID_IProximitySensorStatics2, 3421795246, 59850, 16943, 173, 103, 76, 61, 37, 223, 53, 12);
		RT_INTERFACE!{static interface IProximitySensorStatics2(IProximitySensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics2] {
			fn GetReadingsFromTriggerDetails(&mut self, triggerDetails: *mut SensorDataThresholdTriggerDetails, out: *mut *mut super::super::foundation::collections::IVectorView<ProximitySensorReading>) -> ::w::HRESULT
		}}
		impl IProximitySensorStatics2 {
			#[inline] pub unsafe fn get_readings_from_trigger_details(&mut self, triggerDetails: &SensorDataThresholdTriggerDetails) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<ProximitySensorReading>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetReadingsFromTriggerDetails)(self, triggerDetails as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAltimeterStatics, 2662651843, 58796, 18382, 142, 239, 211, 113, 129, 104, 192, 31);
		RT_INTERFACE!{static interface IAltimeterStatics(IAltimeterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterStatics] {
			fn GetDefault(&mut self, out: *mut *mut Altimeter) -> ::w::HRESULT
		}}
		impl IAltimeterStatics {
			#[inline] pub unsafe fn get_default(&mut self) -> RtResult<ComPtr<Altimeter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDefault)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Altimeter: IAltimeter}
		RT_ACTIVATABLE!{IAltimeterStatics [CLSID_Altimeter]}
		DEFINE_CLSID!(CLSID_Altimeter = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,108,116,105,109,101,116,101,114,0]);
		DEFINE_IID!(IID_IAltimeter, 1928353789, 36612, 18929, 180, 167, 244, 227, 99, 183, 1, 162);
		RT_INTERFACE!{interface IAltimeter(IAltimeterVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeter] {
			fn GetCurrentReading(&mut self, out: *mut *mut AltimeterReading) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAltimeter {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<AltimeterReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class AltimeterReading: IAltimeterReading}
		RT_CLASS!{class AltimeterReadingChangedEventArgs: IAltimeterReadingChangedEventArgs}
		DEFINE_IID!(IID_IAltimeterReading, 4226346867, 32606, 18632, 170, 26, 241, 243, 190, 252, 17, 68);
		RT_INTERFACE!{interface IAltimeterReading(IAltimeterReadingVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterReading] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_AltitudeChangeInMeters(&mut self, out: *mut f64) -> ::w::HRESULT
		}}
		impl IAltimeterReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_altitude_change_in_meters(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AltitudeChangeInMeters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAltimeterReadingChangedEventArgs, 1885982839, 17517, 18423, 153, 140, 235, 194, 59, 69, 228, 162);
		RT_INTERFACE!{interface IAltimeterReadingChangedEventArgs(IAltimeterReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut AltimeterReading) -> ::w::HRESULT
		}}
		impl IAltimeterReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<AltimeterReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
pub mod custom { // Windows.Devices.Sensors.Custom
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_ICustomSensorStatics, 2569032399, 62498, 19581, 131, 107, 231, 220, 116, 167, 18, 75);
		RT_INTERFACE!{static interface ICustomSensorStatics(ICustomSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorStatics] {
			fn GetDeviceSelector(&mut self, interfaceId: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, sensorId: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<CustomSensor>) -> ::w::HRESULT
		}}
		impl ICustomSensorStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self, interfaceId: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, interfaceId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, sensorId: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<CustomSensor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, sensorId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CustomSensor: ICustomSensor}
		RT_ACTIVATABLE!{ICustomSensorStatics [CLSID_CustomSensor]}
		DEFINE_CLSID!(CLSID_CustomSensor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,83,101,110,115,111,114,0]);
		DEFINE_IID!(IID_ICustomSensor, 2704734637, 16436, 19277, 153, 221, 83, 26, 172, 100, 156, 9);
		RT_INTERFACE!{interface ICustomSensor(ICustomSensorVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensor] {
			fn GetCurrentReading(&mut self, out: *mut *mut CustomSensorReading) -> ::w::HRESULT,
			fn get_MinimumReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_ReportInterval(&mut self, value: u32) -> ::w::HRESULT,
			fn get_ReportInterval(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn add_ReadingChanged(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ReadingChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ICustomSensor {
			#[inline] pub unsafe fn get_current_reading(&mut self) -> RtResult<ComPtr<CustomSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetCurrentReading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_minimum_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_report_interval(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReportInterval)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_report_interval(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReportInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_reading_changed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ReadingChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_reading_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ReadingChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class CustomSensorReading: ICustomSensorReading}
		RT_CLASS!{class CustomSensorReadingChangedEventArgs: ICustomSensorReadingChangedEventArgs}
		DEFINE_IID!(IID_ICustomSensorReading, 1677741901, 17514, 17254, 168, 122, 95, 150, 50, 104, 236, 83);
		RT_INTERFACE!{interface ICustomSensorReading(ICustomSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorReading] {
			fn get_Timestamp(&mut self, out: *mut ::rt::gen::windows::foundation::DateTime) -> ::w::HRESULT,
			fn get_Properties(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>) -> ::w::HRESULT
		}}
		impl ICustomSensorReading {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<::rt::gen::windows::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_properties(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, IInspectable>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Properties)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICustomSensorReadingChangedEventArgs, 1797267491, 53245, 19649, 143, 240, 226, 24, 35, 215, 111, 204);
		RT_INTERFACE!{interface ICustomSensorReadingChangedEventArgs(ICustomSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorReadingChangedEventArgs] {
			fn get_Reading(&mut self, out: *mut *mut CustomSensorReading) -> ::w::HRESULT
		}}
		impl ICustomSensorReadingChangedEventArgs {
			#[inline] pub unsafe fn get_reading(&mut self) -> RtResult<ComPtr<CustomSensorReading>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reading)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Sensors.Custom
} // Windows.Devices.Sensors
pub mod serialcommunication { // Windows.Devices.SerialCommunication
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum SerialParity: i32 {
			None (SerialParity_None) = 0, Odd (SerialParity_Odd) = 1, Even (SerialParity_Even) = 2, Mark (SerialParity_Mark) = 3, Space (SerialParity_Space) = 4,
		}}
		RT_ENUM! { enum SerialHandshake: i32 {
			None (SerialHandshake_None) = 0, RequestToSend (SerialHandshake_RequestToSend) = 1, XOnXOff (SerialHandshake_XOnXOff) = 2, RequestToSendXOnXOff (SerialHandshake_RequestToSendXOnXOff) = 3,
		}}
		RT_ENUM! { enum SerialStopBitCount: i32 {
			One (SerialStopBitCount_One) = 0, OnePointFive (SerialStopBitCount_OnePointFive) = 1, Two (SerialStopBitCount_Two) = 2,
		}}
		RT_ENUM! { enum SerialError: i32 {
			Frame (SerialError_Frame) = 0, BufferOverrun (SerialError_BufferOverrun) = 1, ReceiveFull (SerialError_ReceiveFull) = 2, ReceiveParity (SerialError_ReceiveParity) = 3, TransmitFull (SerialError_TransmitFull) = 4,
		}}
		RT_ENUM! { enum SerialPinChange: i32 {
			BreakSignal (SerialPinChange_BreakSignal) = 0, CarrierDetect (SerialPinChange_CarrierDetect) = 1, ClearToSend (SerialPinChange_ClearToSend) = 2, DataSetReady (SerialPinChange_DataSetReady) = 3, RingIndicator (SerialPinChange_RingIndicator) = 4,
		}}
		DEFINE_IID!(IID_ISerialDeviceStatics, 93080176, 2102, 18835, 174, 26, 182, 26, 227, 190, 5, 107);
		RT_INTERFACE!{static interface ISerialDeviceStatics(ISerialDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISerialDeviceStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromPortName(&mut self, portName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromUsbVidPid(&mut self, vendorId: u16, productId: u16, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<SerialDevice>) -> ::w::HRESULT
		}}
		impl ISerialDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_port_name(&mut self, portName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromPortName)(self, portName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_usb_vid_pid(&mut self, vendorId: u16, productId: u16) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromUsbVidPid)(self, vendorId, productId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SerialDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SerialDevice: ISerialDevice}
		RT_ACTIVATABLE!{ISerialDeviceStatics [CLSID_SerialDevice]}
		DEFINE_CLSID!(CLSID_SerialDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,114,105,97,108,67,111,109,109,117,110,105,99,97,116,105,111,110,46,83,101,114,105,97,108,68,101,118,105,99,101,0]);
		RT_CLASS!{class ErrorReceivedEventArgs: IErrorReceivedEventArgs}
		RT_CLASS!{class PinChangedEventArgs: IPinChangedEventArgs}
		DEFINE_IID!(IID_IErrorReceivedEventArgs, 4240883545, 4739, 19850, 191, 223, 86, 107, 51, 221, 178, 143);
		RT_INTERFACE!{interface IErrorReceivedEventArgs(IErrorReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IErrorReceivedEventArgs] {
			fn get_Error(&mut self, out: *mut SerialError) -> ::w::HRESULT
		}}
		impl IErrorReceivedEventArgs {
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<SerialError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPinChangedEventArgs, 2730433968, 64668, 17927, 147, 208, 250, 94, 131, 67, 238, 34);
		RT_INTERFACE!{interface IPinChangedEventArgs(IPinChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPinChangedEventArgs] {
			fn get_PinChange(&mut self, out: *mut SerialPinChange) -> ::w::HRESULT
		}}
		impl IPinChangedEventArgs {
			#[inline] pub unsafe fn get_pin_change(&mut self) -> RtResult<SerialPinChange> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PinChange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISerialDevice, 3783773382, 8720, 16719, 182, 90, 245, 85, 58, 3, 55, 42);
		RT_INTERFACE!{interface ISerialDevice(ISerialDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISerialDevice] {
			fn get_BaudRate(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_BaudRate(&mut self, value: u32) -> ::w::HRESULT,
			fn get_BreakSignalState(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_BreakSignalState(&mut self, value: bool) -> ::w::HRESULT,
			fn get_BytesReceived(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_CarrierDetectState(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_ClearToSendState(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_DataBits(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn put_DataBits(&mut self, value: u16) -> ::w::HRESULT,
			fn get_DataSetReadyState(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Handshake(&mut self, out: *mut SerialHandshake) -> ::w::HRESULT,
			fn put_Handshake(&mut self, value: SerialHandshake) -> ::w::HRESULT,
			fn get_IsDataTerminalReadyEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsDataTerminalReadyEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_IsRequestToSendEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsRequestToSendEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_Parity(&mut self, out: *mut SerialParity) -> ::w::HRESULT,
			fn put_Parity(&mut self, value: SerialParity) -> ::w::HRESULT,
			fn get_PortName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ReadTimeout(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_ReadTimeout(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_StopBits(&mut self, out: *mut SerialStopBitCount) -> ::w::HRESULT,
			fn put_StopBits(&mut self, value: SerialStopBitCount) -> ::w::HRESULT,
			fn get_UsbVendorId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_UsbProductId(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn get_WriteTimeout(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn put_WriteTimeout(&mut self, value: super::super::foundation::TimeSpan) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy27(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_InputStream(&mut self, out: *mut *mut super::super::storage::streams::IInputStream) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy28(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_OutputStream(&mut self, out: *mut *mut super::super::storage::streams::IOutputStream) -> ::w::HRESULT,
			fn add_ErrorReceived(&mut self, reportHandler: *mut super::super::foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ErrorReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_PinChanged(&mut self, reportHandler: *mut super::super::foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_PinChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISerialDevice {
			#[inline] pub unsafe fn get_baud_rate(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BaudRate)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_baud_rate(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BaudRate)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_break_signal_state(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BreakSignalState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_break_signal_state(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_BreakSignalState)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bytes_received(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BytesReceived)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_carrier_detect_state(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CarrierDetectState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_clear_to_send_state(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClearToSendState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_bits(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataBits)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_data_bits(&mut self, value: u16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DataBits)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_data_set_ready_state(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DataSetReadyState)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_handshake(&mut self) -> RtResult<SerialHandshake> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Handshake)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_handshake(&mut self, value: SerialHandshake) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Handshake)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_data_terminal_ready_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsDataTerminalReadyEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_data_terminal_ready_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsDataTerminalReadyEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_request_to_send_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsRequestToSendEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_request_to_send_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsRequestToSendEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_parity(&mut self) -> RtResult<SerialParity> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Parity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_parity(&mut self, value: SerialParity) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Parity)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_port_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PortName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_read_timeout(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_read_timeout(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadTimeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_stop_bits(&mut self) -> RtResult<SerialStopBitCount> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_StopBits)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_stop_bits(&mut self, value: SerialStopBitCount) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_StopBits)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usb_vendor_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsbVendorId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_usb_product_id(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UsbProductId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_write_timeout(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_WriteTimeout)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_write_timeout(&mut self, value: super::super::foundation::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_WriteTimeout)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_input_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IInputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_output_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IOutputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_error_received(&mut self, reportHandler: &super::super::foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ErrorReceived)(self, reportHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_error_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ErrorReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_pin_changed(&mut self, reportHandler: &super::super::foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_PinChanged)(self, reportHandler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_pin_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_PinChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.SerialCommunication
pub mod smartcards { // Windows.Devices.SmartCards
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum SmartCardReaderKind: i32 {
			Any (SmartCardReaderKind_Any) = 0, Generic (SmartCardReaderKind_Generic) = 1, Tpm (SmartCardReaderKind_Tpm) = 2, Nfc (SmartCardReaderKind_Nfc) = 3, Uicc (SmartCardReaderKind_Uicc) = 4, EmbeddedSE (SmartCardReaderKind_EmbeddedSE) = 5,
		}}
		RT_ENUM! { enum SmartCardReaderStatus: i32 {
			Disconnected (SmartCardReaderStatus_Disconnected) = 0, Ready (SmartCardReaderStatus_Ready) = 1, Exclusive (SmartCardReaderStatus_Exclusive) = 2,
		}}
		RT_ENUM! { enum SmartCardStatus: i32 {
			Disconnected (SmartCardStatus_Disconnected) = 0, Ready (SmartCardStatus_Ready) = 1, Shared (SmartCardStatus_Shared) = 2, Exclusive (SmartCardStatus_Exclusive) = 3, Unresponsive (SmartCardStatus_Unresponsive) = 4,
		}}
		RT_ENUM! { enum SmartCardPinCharacterPolicyOption: i32 {
			Allow (SmartCardPinCharacterPolicyOption_Allow) = 0, RequireAtLeastOne (SmartCardPinCharacterPolicyOption_RequireAtLeastOne) = 1, Disallow (SmartCardPinCharacterPolicyOption_Disallow) = 2,
		}}
		DEFINE_IID!(IID_ISmartCardReaderStatics, 272368865, 41418, 18674, 162, 129, 91, 111, 102, 154, 241, 7);
		RT_INTERFACE!{static interface ISmartCardReaderStatics(ISmartCardReaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardReaderStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorWithKind(&mut self, kind: SmartCardReaderKind, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardReader>) -> ::w::HRESULT
		}}
		impl ISmartCardReaderStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_with_kind(&mut self, kind: SmartCardReaderKind) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorWithKind)(self, kind, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardReader>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardReader: ISmartCardReader}
		RT_ACTIVATABLE!{ISmartCardReaderStatics [CLSID_SmartCardReader]}
		DEFINE_CLSID!(CLSID_SmartCardReader = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,82,101,97,100,101,114,0]);
		DEFINE_IID!(IID_ISmartCardReader, 276083936, 21698, 19952, 129, 122, 20, 193, 67, 120, 240, 108);
		RT_INTERFACE!{interface ISmartCardReader(ISmartCardReaderVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardReader] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Kind(&mut self, out: *mut SmartCardReaderKind) -> ::w::HRESULT,
			fn GetStatusAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardReaderStatus>) -> ::w::HRESULT,
			fn FindAllCardsAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<SmartCard>>) -> ::w::HRESULT,
			fn add_CardAdded(&mut self, handler: *mut super::super::foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CardAdded(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_CardRemoved(&mut self, handler: *mut super::super::foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_CardRemoved(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ISmartCardReader {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_kind(&mut self) -> RtResult<SmartCardReaderKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Kind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardReaderStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetStatusAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn find_all_cards_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<SmartCard>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllCardsAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_card_added(&mut self, handler: &super::super::foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CardAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_card_added(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CardAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_card_removed(&mut self, handler: &super::super::foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_CardRemoved)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_card_removed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_CardRemoved)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCard: ISmartCard}
		RT_CLASS!{class CardAddedEventArgs: ICardAddedEventArgs}
		RT_CLASS!{class CardRemovedEventArgs: ICardRemovedEventArgs}
		DEFINE_IID!(IID_ICardAddedEventArgs, 414969752, 61835, 19923, 177, 24, 223, 178, 200, 226, 60, 198);
		RT_INTERFACE!{interface ICardAddedEventArgs(ICardAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICardAddedEventArgs] {
			fn get_SmartCard(&mut self, out: *mut *mut SmartCard) -> ::w::HRESULT
		}}
		impl ICardAddedEventArgs {
			#[inline] pub unsafe fn get_smart_card(&mut self) -> RtResult<ComPtr<SmartCard>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SmartCard)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ICardRemovedEventArgs, 355670703, 8919, 18757, 175, 201, 3, 180, 111, 66, 166, 205);
		RT_INTERFACE!{interface ICardRemovedEventArgs(ICardRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICardRemovedEventArgs] {
			fn get_SmartCard(&mut self, out: *mut *mut SmartCard) -> ::w::HRESULT
		}}
		impl ICardRemovedEventArgs {
			#[inline] pub unsafe fn get_smart_card(&mut self) -> RtResult<ComPtr<SmartCard>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SmartCard)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCard, 460425329, 25652, 17396, 181, 90, 106, 41, 98, 56, 112, 170);
		RT_INTERFACE!{interface ISmartCard(ISmartCardVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCard] {
			fn get_Reader(&mut self, out: *mut *mut SmartCardReader) -> ::w::HRESULT,
			fn GetStatusAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardStatus>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn GetAnswerToResetAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT
		}}
		impl ISmartCard {
			#[inline] pub unsafe fn get_reader(&mut self) -> RtResult<ComPtr<SmartCardReader>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Reader)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetStatusAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_answer_to_reset_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAnswerToResetAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardProvisioningStatics, 327690312, 3347, 20080, 151, 53, 81, 218, 236, 165, 37, 79);
		RT_INTERFACE!{static interface ISmartCardProvisioningStatics(ISmartCardProvisioningStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics] {
			fn FromSmartCardAsync(&mut self, card: *mut SmartCard, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardProvisioning>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn RequestVirtualSmartCardCreationAsync(&mut self, friendlyName: ::w::HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardProvisioning>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn RequestVirtualSmartCardCreationAsyncWithCardId(&mut self, friendlyName: ::w::HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, cardId: ::Guid, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardProvisioning>) -> ::w::HRESULT,
			fn RequestVirtualSmartCardDeletionAsync(&mut self, card: *mut SmartCard, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT
		}}
		impl ISmartCardProvisioningStatics {
			#[inline] pub unsafe fn from_smart_card_async(&mut self, card: &SmartCard) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardProvisioning>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromSmartCardAsync)(self, card as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn request_virtual_smart_card_creation_async(&mut self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardProvisioning>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestVirtualSmartCardCreationAsync)(self, friendlyName.get(), administrativeKey as *const _ as *mut _, pinPolicy as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn request_virtual_smart_card_creation_async_with_card_id(&mut self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: ::Guid) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardProvisioning>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestVirtualSmartCardCreationAsyncWithCardId)(self, friendlyName.get(), administrativeKey as *const _ as *mut _, pinPolicy as *const _ as *mut _, cardId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_virtual_smart_card_deletion_async(&mut self, card: &SmartCard) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestVirtualSmartCardDeletionAsync)(self, card as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardProvisioning: ISmartCardProvisioning}
		RT_ACTIVATABLE!{ISmartCardProvisioningStatics2 [CLSID_SmartCardProvisioning]}
		RT_ACTIVATABLE!{ISmartCardProvisioningStatics [CLSID_SmartCardProvisioning]}
		DEFINE_CLSID!(CLSID_SmartCardProvisioning = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,80,114,111,118,105,115,105,111,110,105,110,103,0]);
		RT_CLASS!{class SmartCardPinPolicy: ISmartCardPinPolicy}
		DEFINE_IID!(IID_ISmartCardProvisioningStatics2, 877119144, 51616, 19414, 181, 13, 37, 31, 78, 141, 58, 98);
		RT_INTERFACE!{static interface ISmartCardProvisioningStatics2(ISmartCardProvisioningStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics2] {
			#[cfg(feature="windows.storage")] fn RequestAttestedVirtualSmartCardCreationAsync(&mut self, friendlyName: ::w::HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardProvisioning>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn RequestAttestedVirtualSmartCardCreationAsyncWithCardId(&mut self, friendlyName: ::w::HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, cardId: ::Guid, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardProvisioning>) -> ::w::HRESULT
		}}
		impl ISmartCardProvisioningStatics2 {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn request_attested_virtual_smart_card_creation_async(&mut self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardProvisioning>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAttestedVirtualSmartCardCreationAsync)(self, friendlyName.get(), administrativeKey as *const _ as *mut _, pinPolicy as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn request_attested_virtual_smart_card_creation_async_with_card_id(&mut self, friendlyName: &HStringArg, administrativeKey: &super::super::storage::streams::IBuffer, pinPolicy: &SmartCardPinPolicy, cardId: ::Guid) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardProvisioning>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAttestedVirtualSmartCardCreationAsyncWithCardId)(self, friendlyName.get(), administrativeKey as *const _ as *mut _, pinPolicy as *const _ as *mut _, cardId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardProvisioning, 435088829, 8107, 18300, 183, 18, 26, 44, 90, 241, 253, 110);
		RT_INTERFACE!{interface ISmartCardProvisioning(ISmartCardProvisioningVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning] {
			fn get_SmartCard(&mut self, out: *mut *mut SmartCard) -> ::w::HRESULT,
			fn GetIdAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<::Guid>) -> ::w::HRESULT,
			fn GetNameAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT,
			fn GetChallengeContextAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardChallengeContext>) -> ::w::HRESULT,
			fn RequestPinChangeAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			fn RequestPinResetAsync(&mut self, handler: *mut SmartCardPinResetHandler, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT
		}}
		impl ISmartCardProvisioning {
			#[inline] pub unsafe fn get_smart_card(&mut self) -> RtResult<ComPtr<SmartCard>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SmartCard)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<::Guid>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetIdAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_name_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetNameAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_challenge_context_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardChallengeContext>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetChallengeContextAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_pin_change_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestPinChangeAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_pin_reset_async(&mut self, handler: &SmartCardPinResetHandler) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestPinResetAsync)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardChallengeContext: ISmartCardChallengeContext}
		DEFINE_IID!(IID_SmartCardPinResetHandler, 328031808, 62396, 19036, 180, 29, 75, 78, 246, 132, 226, 55);
		RT_DELEGATE!{delegate SmartCardPinResetHandler(SmartCardPinResetHandlerVtbl, SmartCardPinResetHandlerImpl) [IID_SmartCardPinResetHandler] {
			fn Invoke(&mut self, sender: *mut SmartCardProvisioning, request: *mut SmartCardPinResetRequest) -> ::w::HRESULT
		}}
		impl SmartCardPinResetHandler {
			#[inline] pub unsafe fn invoke(&mut self, sender: &SmartCardProvisioning, request: &SmartCardPinResetRequest) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, request as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardPinResetRequest: ISmartCardPinResetRequest}
		DEFINE_IID!(IID_ISmartCardProvisioning2, 285026539, 16249, 19302, 155, 124, 17, 193, 73, 183, 208, 188);
		RT_INTERFACE!{interface ISmartCardProvisioning2(ISmartCardProvisioning2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning2] {
			fn GetAuthorityKeyContainerNameAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> ::w::HRESULT
		}}
		impl ISmartCardProvisioning2 {
			#[inline] pub unsafe fn get_authority_key_container_name_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetAuthorityKeyContainerNameAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardPinResetRequest, 318651469, 24505, 20110, 159, 246, 97, 244, 117, 18, 79, 239);
		RT_INTERFACE!{interface ISmartCardPinResetRequest(ISmartCardPinResetRequestVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetRequest] {
			#[cfg(feature="windows.storage")] fn get_Challenge(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_Deadline(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn GetDeferral(&mut self, out: *mut *mut SmartCardPinResetDeferral) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn SetResponse(&mut self, response: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl ISmartCardPinResetRequest {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_challenge(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Challenge)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deadline(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Deadline)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_deferral(&mut self) -> RtResult<ComPtr<SmartCardPinResetDeferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeferral)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_response(&mut self, response: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetResponse)(self, response as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardPinResetDeferral: ISmartCardPinResetDeferral}
		DEFINE_IID!(IID_ISmartCardPinResetDeferral, 415845036, 30725, 16388, 133, 228, 187, 239, 172, 143, 104, 132);
		RT_INTERFACE!{interface ISmartCardPinResetDeferral(ISmartCardPinResetDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetDeferral] {
			fn Complete(&mut self) -> ::w::HRESULT
		}}
		impl ISmartCardPinResetDeferral {
			#[inline] pub unsafe fn complete(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Complete)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardPinPolicy, 406643076, 19894, 18497, 172, 158, 42, 193, 243, 155, 115, 4);
		RT_INTERFACE!{interface ISmartCardPinPolicy(ISmartCardPinPolicyVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinPolicy] {
			fn get_MinLength(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_MinLength(&mut self, value: u32) -> ::w::HRESULT,
			fn get_MaxLength(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_MaxLength(&mut self, value: u32) -> ::w::HRESULT,
			fn get_UppercaseLetters(&mut self, out: *mut SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn put_UppercaseLetters(&mut self, value: SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn get_LowercaseLetters(&mut self, out: *mut SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn put_LowercaseLetters(&mut self, value: SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn get_Digits(&mut self, out: *mut SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn put_Digits(&mut self, value: SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn get_SpecialCharacters(&mut self, out: *mut SmartCardPinCharacterPolicyOption) -> ::w::HRESULT,
			fn put_SpecialCharacters(&mut self, value: SmartCardPinCharacterPolicyOption) -> ::w::HRESULT
		}}
		impl ISmartCardPinPolicy {
			#[inline] pub unsafe fn get_min_length(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_min_length(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_MinLength)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_length(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxLength)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_max_length(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_MaxLength)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uppercase_letters(&mut self) -> RtResult<SmartCardPinCharacterPolicyOption> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_UppercaseLetters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_uppercase_letters(&mut self, value: SmartCardPinCharacterPolicyOption) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_UppercaseLetters)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_lowercase_letters(&mut self) -> RtResult<SmartCardPinCharacterPolicyOption> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_LowercaseLetters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_lowercase_letters(&mut self, value: SmartCardPinCharacterPolicyOption) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_LowercaseLetters)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_digits(&mut self) -> RtResult<SmartCardPinCharacterPolicyOption> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Digits)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_digits(&mut self, value: SmartCardPinCharacterPolicyOption) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Digits)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_special_characters(&mut self) -> RtResult<SmartCardPinCharacterPolicyOption> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SpecialCharacters)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_special_characters(&mut self, value: SmartCardPinCharacterPolicyOption) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SpecialCharacters)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardConnect, 803178469, 653, 18718, 160, 88, 51, 130, 195, 152, 111, 64);
		RT_INTERFACE!{interface ISmartCardConnect(ISmartCardConnectVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardConnect] {
			fn ConnectAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<SmartCardConnection>) -> ::w::HRESULT
		}}
		impl ISmartCardConnect {
			#[inline] pub unsafe fn connect_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<SmartCardConnection>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class SmartCardConnection: ISmartCardConnection}
		DEFINE_IID!(IID_ISmartCardChallengeContext, 422204185, 51652, 18759, 129, 204, 68, 121, 74, 97, 239, 145);
		RT_INTERFACE!{interface ISmartCardChallengeContext(ISmartCardChallengeContextVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardChallengeContext] {
			#[cfg(feature="windows.storage")] fn get_Challenge(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn VerifyResponseAsync(&mut self, response: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ProvisionAsync(&mut self, response: *mut super::super::storage::streams::IBuffer, formatCard: bool, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ProvisionAsyncWithNewCardId(&mut self, response: *mut super::super::storage::streams::IBuffer, formatCard: bool, newCardId: ::Guid, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ChangeAdministrativeKeyAsync(&mut self, response: *mut super::super::storage::streams::IBuffer, newAdministrativeKey: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT
		}}
		impl ISmartCardChallengeContext {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_challenge(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Challenge)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn verify_response_async(&mut self, response: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).VerifyResponseAsync)(self, response as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn provision_async(&mut self, response: &super::super::storage::streams::IBuffer, formatCard: bool) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ProvisionAsync)(self, response as *const _ as *mut _, formatCard, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn provision_async_with_new_card_id(&mut self, response: &super::super::storage::streams::IBuffer, formatCard: bool, newCardId: ::Guid) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ProvisionAsyncWithNewCardId)(self, response as *const _ as *mut _, formatCard, newCardId, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn change_administrative_key_async(&mut self, response: &super::super::storage::streams::IBuffer, newAdministrativeKey: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ChangeAdministrativeKeyAsync)(self, response as *const _ as *mut _, newAdministrativeKey as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ISmartCardConnection, 2128320794, 43034, 18364, 166, 73, 21, 107, 230, 183, 242, 49);
		RT_INTERFACE!{interface ISmartCardConnection(ISmartCardConnectionVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardConnection] {
			#[cfg(feature="windows.storage")] fn TransmitAsync(&mut self, command: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT
		}}
		impl ISmartCardConnection {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn transmit_async(&mut self, command: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).TransmitAsync)(self, command as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.SmartCards
pub mod usb { // Windows.Devices.Usb
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum UsbTransferDirection: i32 {
			Out (UsbTransferDirection_Out) = 0, In (UsbTransferDirection_In) = 1,
		}}
		RT_ENUM! { enum UsbEndpointType: i32 {
			Control (UsbEndpointType_Control) = 0, Isochronous (UsbEndpointType_Isochronous) = 1, Bulk (UsbEndpointType_Bulk) = 2, Interrupt (UsbEndpointType_Interrupt) = 3,
		}}
		RT_ENUM! { enum UsbControlRecipient: i32 {
			Device (UsbControlRecipient_Device) = 0, SpecifiedInterface (UsbControlRecipient_SpecifiedInterface) = 1, Endpoint (UsbControlRecipient_Endpoint) = 2, Other (UsbControlRecipient_Other) = 3, DefaultInterface (UsbControlRecipient_DefaultInterface) = 4,
		}}
		RT_ENUM! { enum UsbControlTransferType: i32 {
			Standard (UsbControlTransferType_Standard) = 0, Class (UsbControlTransferType_Class) = 1, Vendor (UsbControlTransferType_Vendor) = 2,
		}}
		DEFINE_IID!(IID_IUsbControlRequestType, 2392090022, 55101, 18142, 148, 190, 170, 231, 240, 124, 15, 92);
		RT_INTERFACE!{interface IUsbControlRequestType(IUsbControlRequestTypeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbControlRequestType] {
			fn get_Direction(&mut self, out: *mut UsbTransferDirection) -> ::w::HRESULT,
			fn put_Direction(&mut self, value: UsbTransferDirection) -> ::w::HRESULT,
			fn get_ControlTransferType(&mut self, out: *mut UsbControlTransferType) -> ::w::HRESULT,
			fn put_ControlTransferType(&mut self, value: UsbControlTransferType) -> ::w::HRESULT,
			fn get_Recipient(&mut self, out: *mut UsbControlRecipient) -> ::w::HRESULT,
			fn put_Recipient(&mut self, value: UsbControlRecipient) -> ::w::HRESULT,
			fn get_AsByte(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_AsByte(&mut self, value: u8) -> ::w::HRESULT
		}}
		impl IUsbControlRequestType {
			#[inline] pub unsafe fn get_direction(&mut self) -> RtResult<UsbTransferDirection> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Direction)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_direction(&mut self, value: UsbTransferDirection) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Direction)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_control_transfer_type(&mut self) -> RtResult<UsbControlTransferType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ControlTransferType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_control_transfer_type(&mut self, value: UsbControlTransferType) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ControlTransferType)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_recipient(&mut self) -> RtResult<UsbControlRecipient> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Recipient)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_recipient(&mut self, value: UsbControlRecipient) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Recipient)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_as_byte(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AsByte)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_as_byte(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AsByte)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbControlRequestType: IUsbControlRequestType}
		DEFINE_IID!(IID_IUsbSetupPacketFactory, 3374677328, 6958, 19009, 162, 167, 51, 143, 12, 239, 60, 20);
		RT_INTERFACE!{static interface IUsbSetupPacketFactory(IUsbSetupPacketFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacketFactory] {
			#[cfg(feature="windows.storage")] fn CreateWithEightByteBuffer(&mut self, eightByteBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut UsbSetupPacket) -> ::w::HRESULT
		}}
		impl IUsbSetupPacketFactory {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create_with_eight_byte_buffer(&mut self, eightByteBuffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<UsbSetupPacket>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithEightByteBuffer)(self, eightByteBuffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbSetupPacket: IUsbSetupPacket [IUsbSetupPacketFactory] [CLSID_UsbSetupPacket]}
		DEFINE_CLSID!(CLSID_UsbSetupPacket = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,83,101,116,117,112,80,97,99,107,101,116,0]);
		DEFINE_IID!(IID_IUsbSetupPacket, 273391922, 51087, 19537, 182, 84, 228, 157, 2, 242, 203, 3);
		RT_INTERFACE!{interface IUsbSetupPacket(IUsbSetupPacketVtbl): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacket] {
			fn get_RequestType(&mut self, out: *mut *mut UsbControlRequestType) -> ::w::HRESULT,
			fn put_RequestType(&mut self, value: *mut UsbControlRequestType) -> ::w::HRESULT,
			fn get_Request(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_Request(&mut self, value: u8) -> ::w::HRESULT,
			fn get_Value(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_Value(&mut self, value: u32) -> ::w::HRESULT,
			fn get_Index(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_Index(&mut self, value: u32) -> ::w::HRESULT,
			fn get_Length(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_Length(&mut self, value: u32) -> ::w::HRESULT
		}}
		impl IUsbSetupPacket {
			#[inline] pub unsafe fn get_request_type(&mut self) -> RtResult<ComPtr<UsbControlRequestType>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RequestType)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_request_type(&mut self, value: &UsbControlRequestType) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RequestType)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_request(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Request)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_request(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Request)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_value(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Value)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_index(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Index)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_index(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Index)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_length(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Length)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_length(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Length)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbDeviceClass, 85541625, 33886, 18411, 177, 42, 56, 242, 246, 23, 175, 231);
		RT_INTERFACE!{interface IUsbDeviceClass(IUsbDeviceClassVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClass] {
			fn get_ClassCode(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_ClassCode(&mut self, value: u8) -> ::w::HRESULT,
			fn get_SubclassCode(&mut self, out: *mut *mut super::super::foundation::IReference<u8>) -> ::w::HRESULT,
			fn put_SubclassCode(&mut self, value: *mut super::super::foundation::IReference<u8>) -> ::w::HRESULT,
			fn get_ProtocolCode(&mut self, out: *mut *mut super::super::foundation::IReference<u8>) -> ::w::HRESULT,
			fn put_ProtocolCode(&mut self, value: *mut super::super::foundation::IReference<u8>) -> ::w::HRESULT
		}}
		impl IUsbDeviceClass {
			#[inline] pub unsafe fn get_class_code(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClassCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_class_code(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ClassCode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_subclass_code(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u8>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SubclassCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_subclass_code(&mut self, value: &super::super::foundation::IReference<u8>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SubclassCode)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_code(&mut self) -> RtResult<ComPtr<super::super::foundation::IReference<u8>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ProtocolCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_protocol_code(&mut self, value: &super::super::foundation::IReference<u8>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ProtocolCode)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbDeviceClass: IUsbDeviceClass}
		DEFINE_IID!(IID_IUsbDeviceClassesStatics, 2987066663, 50560, 17817, 161, 101, 152, 27, 79, 208, 50, 48);
		RT_INTERFACE!{static interface IUsbDeviceClassesStatics(IUsbDeviceClassesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClassesStatics] {
			fn get_CdcControl(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_Physical(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_PersonalHealthcare(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_ActiveSync(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_PalmSync(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_DeviceFirmwareUpdate(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_Irda(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_Measurement(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT,
			fn get_VendorSpecific(&mut self, out: *mut *mut UsbDeviceClass) -> ::w::HRESULT
		}}
		impl IUsbDeviceClassesStatics {
			#[inline] pub unsafe fn get_cdc_control(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_CdcControl)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_physical(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Physical)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_personal_healthcare(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PersonalHealthcare)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_active_sync(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ActiveSync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_palm_sync(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PalmSync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_firmware_update(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceFirmwareUpdate)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_irda(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Irda)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_measurement(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Measurement)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_vendor_specific(&mut self) -> RtResult<ComPtr<UsbDeviceClass>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_VendorSpecific)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbDeviceClasses, 1752143197, 39826, 19248, 151, 129, 194, 44, 85, 172, 53, 203);
		RT_INTERFACE!{interface IUsbDeviceClasses(IUsbDeviceClassesVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClasses] {
			
		}}
		RT_CLASS!{class UsbDeviceClasses: IUsbDeviceClasses}
		RT_ACTIVATABLE!{IUsbDeviceClassesStatics [CLSID_UsbDeviceClasses]}
		DEFINE_CLSID!(CLSID_UsbDeviceClasses = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,67,108,97,115,115,101,115,0]);
		DEFINE_IID!(IID_IUsbDeviceStatics, 107709858, 2487, 17478, 133, 2, 111, 230, 220, 170, 115, 9);
		RT_INTERFACE!{static interface IUsbDeviceStatics(IUsbDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceStatics] {
			fn GetDeviceSelector(&mut self, vendorId: u32, productId: u32, winUsbInterfaceClass: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorGuidOnly(&mut self, winUsbInterfaceClass: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorVidPidOnly(&mut self, vendorId: u32, productId: u32, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceClassSelector(&mut self, usbClass: *mut UsbDeviceClass, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UsbDevice>) -> ::w::HRESULT
		}}
		impl IUsbDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self, vendorId: u32, productId: u32, winUsbInterfaceClass: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, vendorId, productId, winUsbInterfaceClass, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_guid_only(&mut self, winUsbInterfaceClass: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorGuidOnly)(self, winUsbInterfaceClass, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_vid_pid_only(&mut self, vendorId: u32, productId: u32) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorVidPidOnly)(self, vendorId, productId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_class_selector(&mut self, usbClass: &UsbDeviceClass) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceClassSelector)(self, usbClass as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<UsbDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbDevice: IUsbDevice}
		RT_ACTIVATABLE!{IUsbDeviceStatics [CLSID_UsbDevice]}
		DEFINE_CLSID!(CLSID_UsbDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,0]);
		RT_CLASS!{class UsbInterface: IUsbInterface}
		RT_CLASS!{class UsbDeviceDescriptor: IUsbDeviceDescriptor}
		RT_CLASS!{class UsbConfiguration: IUsbConfiguration}
		DEFINE_IID!(IID_IUsbDeviceDescriptor, 524866038, 47767, 17186, 185, 44, 181, 177, 137, 33, 101, 136);
		RT_INTERFACE!{interface IUsbDeviceDescriptor(IUsbDeviceDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceDescriptor] {
			fn get_BcdUsb(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_MaxPacketSize0(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_VendorId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ProductId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_BcdDeviceRevision(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_NumberOfConfigurations(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IUsbDeviceDescriptor {
			#[inline] pub unsafe fn get_bcd_usb(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BcdUsb)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_packet_size0(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPacketSize0)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_vendor_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_VendorId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_product_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProductId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bcd_device_revision(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BcdDeviceRevision)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_number_of_configurations(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NumberOfConfigurations)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbConfigurationDescriptor, 4061621650, 46146, 16506, 130, 7, 125, 100, 108, 3, 133, 243);
		RT_INTERFACE!{interface IUsbConfigurationDescriptor(IUsbConfigurationDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptor] {
			fn get_ConfigurationValue(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_MaxPowerMilliamps(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_SelfPowered(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_RemoteWakeup(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IUsbConfigurationDescriptor {
			#[inline] pub unsafe fn get_configuration_value(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConfigurationValue)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_power_milliamps(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPowerMilliamps)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_self_powered(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelfPowered)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_remote_wakeup(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RemoteWakeup)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbConfigurationDescriptorStatics, 1112337811, 59200, 16545, 146, 189, 218, 18, 14, 160, 73, 20);
		RT_INTERFACE!{static interface IUsbConfigurationDescriptorStatics(IUsbConfigurationDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptorStatics] {
			fn TryParse(&mut self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbConfigurationDescriptor, out: *mut bool) -> ::w::HRESULT,
			fn Parse(&mut self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbConfigurationDescriptor) -> ::w::HRESULT
		}}
		impl IUsbConfigurationDescriptorStatics {
			#[inline] pub unsafe fn try_parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<(ComPtr<UsbConfigurationDescriptor>, bool)> {
				let mut parsed = ::std::ptr::null_mut(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryParse)(self, descriptor as *const _ as *mut _, &mut parsed, &mut out);
				if hr == ::w::S_OK { Ok((ComPtr::wrap(parsed), out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<ComPtr<UsbConfigurationDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Parse)(self, descriptor as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbDescriptor: IUsbDescriptor}
		RT_CLASS!{class UsbConfigurationDescriptor: IUsbConfigurationDescriptor}
		RT_ACTIVATABLE!{IUsbConfigurationDescriptorStatics [CLSID_UsbConfigurationDescriptor]}
		DEFINE_CLSID!(CLSID_UsbConfigurationDescriptor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,67,111,110,102,105,103,117,114,97,116,105,111,110,68,101,115,99,114,105,112,116,111,114,0]);
		DEFINE_IID!(IID_IUsbInterfaceDescriptor, 429289671, 47086, 20368, 140, 213, 148, 162, 226, 87, 89, 138);
		RT_INTERFACE!{interface IUsbInterfaceDescriptor(IUsbInterfaceDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptor] {
			fn get_ClassCode(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_SubclassCode(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_ProtocolCode(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_AlternateSettingNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_InterfaceNumber(&mut self, out: *mut u8) -> ::w::HRESULT
		}}
		impl IUsbInterfaceDescriptor {
			#[inline] pub unsafe fn get_class_code(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ClassCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_subclass_code(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SubclassCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol_code(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ProtocolCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_alternate_setting_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AlternateSettingNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interface_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InterfaceNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterfaceDescriptorStatics, 3813318645, 30678, 18614, 176, 190, 22, 198, 66, 35, 22, 254);
		RT_INTERFACE!{static interface IUsbInterfaceDescriptorStatics(IUsbInterfaceDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptorStatics] {
			fn TryParse(&mut self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbInterfaceDescriptor, out: *mut bool) -> ::w::HRESULT,
			fn Parse(&mut self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbInterfaceDescriptor) -> ::w::HRESULT
		}}
		impl IUsbInterfaceDescriptorStatics {
			#[inline] pub unsafe fn try_parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<(ComPtr<UsbInterfaceDescriptor>, bool)> {
				let mut parsed = ::std::ptr::null_mut(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryParse)(self, descriptor as *const _ as *mut _, &mut parsed, &mut out);
				if hr == ::w::S_OK { Ok((ComPtr::wrap(parsed), out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<ComPtr<UsbInterfaceDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Parse)(self, descriptor as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbInterfaceDescriptor: IUsbInterfaceDescriptor}
		RT_ACTIVATABLE!{IUsbInterfaceDescriptorStatics [CLSID_UsbInterfaceDescriptor]}
		DEFINE_CLSID!(CLSID_UsbInterfaceDescriptor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,73,110,116,101,114,102,97,99,101,68,101,115,99,114,105,112,116,111,114,0]);
		DEFINE_IID!(IID_IUsbEndpointDescriptor, 1799906009, 36343, 19264, 172, 131, 87, 143, 19, 159, 5, 117);
		RT_INTERFACE!{interface IUsbEndpointDescriptor(IUsbEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptor] {
			fn get_EndpointNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Direction(&mut self, out: *mut UsbTransferDirection) -> ::w::HRESULT,
			fn get_EndpointType(&mut self, out: *mut UsbEndpointType) -> ::w::HRESULT,
			fn get_AsBulkInEndpointDescriptor(&mut self, out: *mut *mut UsbBulkInEndpointDescriptor) -> ::w::HRESULT,
			fn get_AsInterruptInEndpointDescriptor(&mut self, out: *mut *mut UsbInterruptInEndpointDescriptor) -> ::w::HRESULT,
			fn get_AsBulkOutEndpointDescriptor(&mut self, out: *mut *mut UsbBulkOutEndpointDescriptor) -> ::w::HRESULT,
			fn get_AsInterruptOutEndpointDescriptor(&mut self, out: *mut *mut UsbInterruptOutEndpointDescriptor) -> ::w::HRESULT
		}}
		impl IUsbEndpointDescriptor {
			#[inline] pub unsafe fn get_endpoint_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_direction(&mut self) -> RtResult<UsbTransferDirection> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Direction)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_type(&mut self) -> RtResult<UsbEndpointType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_as_bulk_in_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbBulkInEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AsBulkInEndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_as_interrupt_in_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbInterruptInEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AsInterruptInEndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_as_bulk_out_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbBulkOutEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AsBulkOutEndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_as_interrupt_out_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbInterruptOutEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AsInterruptOutEndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbBulkInEndpointDescriptor: IUsbBulkInEndpointDescriptor}
		RT_CLASS!{class UsbInterruptInEndpointDescriptor: IUsbInterruptInEndpointDescriptor}
		RT_CLASS!{class UsbBulkOutEndpointDescriptor: IUsbBulkOutEndpointDescriptor}
		RT_CLASS!{class UsbInterruptOutEndpointDescriptor: IUsbInterruptOutEndpointDescriptor}
		DEFINE_IID!(IID_IUsbEndpointDescriptorStatics, 3364925953, 39530, 18782, 168, 44, 41, 91, 158, 112, 129, 6);
		RT_INTERFACE!{static interface IUsbEndpointDescriptorStatics(IUsbEndpointDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptorStatics] {
			fn TryParse(&mut self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbEndpointDescriptor, out: *mut bool) -> ::w::HRESULT,
			fn Parse(&mut self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbEndpointDescriptor) -> ::w::HRESULT
		}}
		impl IUsbEndpointDescriptorStatics {
			#[inline] pub unsafe fn try_parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<(ComPtr<UsbEndpointDescriptor>, bool)> {
				let mut parsed = ::std::ptr::null_mut(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).TryParse)(self, descriptor as *const _ as *mut _, &mut parsed, &mut out);
				if hr == ::w::S_OK { Ok((ComPtr::wrap(parsed), out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn parse(&mut self, descriptor: &UsbDescriptor) -> RtResult<ComPtr<UsbEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Parse)(self, descriptor as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbEndpointDescriptor: IUsbEndpointDescriptor}
		RT_ACTIVATABLE!{IUsbEndpointDescriptorStatics [CLSID_UsbEndpointDescriptor]}
		DEFINE_CLSID!(CLSID_UsbEndpointDescriptor = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,69,110,100,112,111,105,110,116,68,101,115,99,114,105,112,116,111,114,0]);
		DEFINE_IID!(IID_IUsbDescriptor, 176812566, 24477, 18548, 137, 4, 218, 154, 211, 245, 82, 143);
		RT_INTERFACE!{interface IUsbDescriptor(IUsbDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDescriptor] {
			fn get_Length(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_DescriptorType(&mut self, out: *mut u8) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ReadDescriptorBuffer(&mut self, buffer: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IUsbDescriptor {
			#[inline] pub unsafe fn get_length(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Length)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_descriptor_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DescriptorType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn read_descriptor_buffer(&mut self, buffer: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ReadDescriptorBuffer)(self, buffer as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterruptInEventArgs, 3081781394, 5144, 18742, 130, 9, 41, 156, 245, 96, 85, 131);
		RT_INTERFACE!{interface IUsbInterruptInEventArgs(IUsbInterruptInEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEventArgs] {
			#[cfg(feature="windows.storage")] fn get_InterruptData(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IUsbInterruptInEventArgs {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_interrupt_data(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterruptData)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbInterruptInEventArgs: IUsbInterruptInEventArgs}
		RT_ENUM! { enum UsbReadOptions: u32 {
			None (UsbReadOptions_None) = 0, AutoClearStall (UsbReadOptions_AutoClearStall) = 1, OverrideAutomaticBufferManagement (UsbReadOptions_OverrideAutomaticBufferManagement) = 2, IgnoreShortPacket (UsbReadOptions_IgnoreShortPacket) = 4, AllowPartialReads (UsbReadOptions_AllowPartialReads) = 8,
		}}
		RT_ENUM! { enum UsbWriteOptions: u32 {
			None (UsbWriteOptions_None) = 0, AutoClearStall (UsbWriteOptions_AutoClearStall) = 1, ShortPacketTerminate (UsbWriteOptions_ShortPacketTerminate) = 2,
		}}
		DEFINE_IID!(IID_IUsbBulkInPipe, 4028443963, 17736, 19792, 179, 38, 216, 44, 218, 190, 18, 32);
		RT_INTERFACE!{interface IUsbBulkInPipe(IUsbBulkInPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkInPipe] {
			fn get_MaxTransferSizeBytes(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EndpointDescriptor(&mut self, out: *mut *mut UsbBulkInEndpointDescriptor) -> ::w::HRESULT,
			fn ClearStallAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn put_ReadOptions(&mut self, value: UsbReadOptions) -> ::w::HRESULT,
			fn get_ReadOptions(&mut self, out: *mut UsbReadOptions) -> ::w::HRESULT,
			fn FlushBuffer(&mut self) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_InputStream(&mut self, out: *mut *mut super::super::storage::streams::IInputStream) -> ::w::HRESULT
		}}
		impl IUsbBulkInPipe {
			#[inline] pub unsafe fn get_max_transfer_size_bytes(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxTransferSizeBytes)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbBulkInEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear_stall_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClearStallAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_read_options(&mut self, value: UsbReadOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ReadOptions)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_read_options(&mut self) -> RtResult<UsbReadOptions> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ReadOptions)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn flush_buffer(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).FlushBuffer)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_input_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IInputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterruptInPipe, 4194332950, 34007, 18631, 138, 63, 76, 11, 35, 95, 46, 166);
		RT_INTERFACE!{interface IUsbInterruptInPipe(IUsbInterruptInPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInPipe] {
			fn get_EndpointDescriptor(&mut self, out: *mut *mut UsbInterruptInEndpointDescriptor) -> ::w::HRESULT,
			fn ClearStallAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn add_DataReceived(&mut self, handler: *mut super::super::foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_DataReceived(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IUsbInterruptInPipe {
			#[inline] pub unsafe fn get_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbInterruptInEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear_stall_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClearStallAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_data_received(&mut self, handler: &super::super::foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_DataReceived)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_data_received(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_DataReceived)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbInterruptInPipe: IUsbInterruptInPipe}
		DEFINE_IID!(IID_IUsbBulkOutPipe, 2833903214, 277, 17834, 139, 33, 55, 178, 37, 188, 206, 231);
		RT_INTERFACE!{interface IUsbBulkOutPipe(IUsbBulkOutPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutPipe] {
			fn get_EndpointDescriptor(&mut self, out: *mut *mut UsbBulkOutEndpointDescriptor) -> ::w::HRESULT,
			fn ClearStallAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn put_WriteOptions(&mut self, value: UsbWriteOptions) -> ::w::HRESULT,
			fn get_WriteOptions(&mut self, out: *mut UsbWriteOptions) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_OutputStream(&mut self, out: *mut *mut super::super::storage::streams::IOutputStream) -> ::w::HRESULT
		}}
		impl IUsbBulkOutPipe {
			#[inline] pub unsafe fn get_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbBulkOutEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear_stall_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClearStallAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_write_options(&mut self, value: UsbWriteOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_WriteOptions)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_write_options(&mut self) -> RtResult<UsbWriteOptions> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_WriteOptions)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_output_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IOutputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterruptOutPipe, 3917793449, 43769, 18896, 185, 108, 246, 97, 171, 74, 127, 149);
		RT_INTERFACE!{interface IUsbInterruptOutPipe(IUsbInterruptOutPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutPipe] {
			fn get_EndpointDescriptor(&mut self, out: *mut *mut UsbInterruptOutEndpointDescriptor) -> ::w::HRESULT,
			fn ClearStallAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn put_WriteOptions(&mut self, value: UsbWriteOptions) -> ::w::HRESULT,
			fn get_WriteOptions(&mut self, out: *mut UsbWriteOptions) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_OutputStream(&mut self, out: *mut *mut super::super::storage::streams::IOutputStream) -> ::w::HRESULT
		}}
		impl IUsbInterruptOutPipe {
			#[inline] pub unsafe fn get_endpoint_descriptor(&mut self) -> RtResult<ComPtr<UsbInterruptOutEndpointDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EndpointDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear_stall_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ClearStallAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_write_options(&mut self, value: UsbWriteOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_WriteOptions)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_write_options(&mut self) -> RtResult<UsbWriteOptions> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_WriteOptions)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_output_stream(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IOutputStream>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_OutputStream)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbBulkInPipe: IUsbBulkInPipe}
		RT_CLASS!{class UsbBulkOutPipe: IUsbBulkOutPipe}
		RT_CLASS!{class UsbInterruptOutPipe: IUsbInterruptOutPipe}
		DEFINE_IID!(IID_IUsbConfiguration, 1746367529, 13993, 18135, 184, 115, 252, 104, 146, 81, 236, 48);
		RT_INTERFACE!{interface IUsbConfiguration(IUsbConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfiguration] {
			fn get_UsbInterfaces(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterface>) -> ::w::HRESULT,
			fn get_ConfigurationDescriptor(&mut self, out: *mut *mut UsbConfigurationDescriptor) -> ::w::HRESULT,
			fn get_Descriptors(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbDescriptor>) -> ::w::HRESULT
		}}
		impl IUsbConfiguration {
			#[inline] pub unsafe fn get_usb_interfaces(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterface>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UsbInterfaces)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_configuration_descriptor(&mut self) -> RtResult<ComPtr<UsbConfigurationDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ConfigurationDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_descriptors(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Descriptors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterface, 2687642517, 32583, 18603, 167, 39, 103, 140, 37, 190, 33, 18);
		RT_INTERFACE!{interface IUsbInterface(IUsbInterfaceVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterface] {
			fn get_BulkInPipes(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbBulkInPipe>) -> ::w::HRESULT,
			fn get_InterruptInPipes(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterruptInPipe>) -> ::w::HRESULT,
			fn get_BulkOutPipes(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbBulkOutPipe>) -> ::w::HRESULT,
			fn get_InterruptOutPipes(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterruptOutPipe>) -> ::w::HRESULT,
			fn get_InterfaceSettings(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterfaceSetting>) -> ::w::HRESULT,
			fn get_InterfaceNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Descriptors(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbDescriptor>) -> ::w::HRESULT
		}}
		impl IUsbInterface {
			#[inline] pub unsafe fn get_bulk_in_pipes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbBulkInPipe>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BulkInPipes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interrupt_in_pipes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterruptInPipe>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterruptInPipes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bulk_out_pipes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbBulkOutPipe>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BulkOutPipes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interrupt_out_pipes(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterruptOutPipe>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterruptOutPipes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interface_settings(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterfaceSetting>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterfaceSettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interface_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_InterfaceNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_descriptors(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Descriptors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class UsbInterfaceSetting: IUsbInterfaceSetting}
		DEFINE_IID!(IID_IUsbInterfaceSetting, 405257127, 36263, 19191, 143, 76, 127, 48, 50, 231, 129, 245);
		RT_INTERFACE!{interface IUsbInterfaceSetting(IUsbInterfaceSettingVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceSetting] {
			fn get_BulkInEndpoints(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbBulkInEndpointDescriptor>) -> ::w::HRESULT,
			fn get_InterruptInEndpoints(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor>) -> ::w::HRESULT,
			fn get_BulkOutEndpoints(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor>) -> ::w::HRESULT,
			fn get_InterruptOutEndpoints(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor>) -> ::w::HRESULT,
			fn get_Selected(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn SelectSettingAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn get_InterfaceDescriptor(&mut self, out: *mut *mut UsbInterfaceDescriptor) -> ::w::HRESULT,
			fn get_Descriptors(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<UsbDescriptor>) -> ::w::HRESULT
		}}
		impl IUsbInterfaceSetting {
			#[inline] pub unsafe fn get_bulk_in_endpoints(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbBulkInEndpointDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BulkInEndpoints)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interrupt_in_endpoints(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterruptInEndpoints)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bulk_out_endpoints(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_BulkOutEndpoints)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interrupt_out_endpoints(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterruptOutEndpoints)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_selected(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Selected)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn select_setting_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SelectSettingAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interface_descriptor(&mut self) -> RtResult<ComPtr<UsbInterfaceDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InterfaceDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_descriptors(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<UsbDescriptor>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Descriptors)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbBulkInEndpointDescriptor, 1013860422, 1743, 17065, 157, 194, 151, 28, 27, 20, 182, 227);
		RT_INTERFACE!{interface IUsbBulkInEndpointDescriptor(IUsbBulkInEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkInEndpointDescriptor] {
			fn get_MaxPacketSize(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EndpointNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Pipe(&mut self, out: *mut *mut UsbBulkInPipe) -> ::w::HRESULT
		}}
		impl IUsbBulkInEndpointDescriptor {
			#[inline] pub unsafe fn get_max_packet_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPacketSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pipe(&mut self) -> RtResult<ComPtr<UsbBulkInPipe>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pipe)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterruptInEndpointDescriptor, 3226634599, 51473, 19514, 134, 178, 65, 156, 45, 168, 144, 57);
		RT_INTERFACE!{interface IUsbInterruptInEndpointDescriptor(IUsbInterruptInEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEndpointDescriptor] {
			fn get_MaxPacketSize(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EndpointNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Interval(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Pipe(&mut self, out: *mut *mut UsbInterruptInPipe) -> ::w::HRESULT
		}}
		impl IUsbInterruptInEndpointDescriptor {
			#[inline] pub unsafe fn get_max_packet_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPacketSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interval(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Interval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pipe(&mut self) -> RtResult<ComPtr<UsbInterruptInPipe>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pipe)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbBulkOutEndpointDescriptor, 673219706, 65518, 20320, 155, 225, 149, 108, 172, 62, 203, 101);
		RT_INTERFACE!{interface IUsbBulkOutEndpointDescriptor(IUsbBulkOutEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutEndpointDescriptor] {
			fn get_MaxPacketSize(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EndpointNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Pipe(&mut self, out: *mut *mut UsbBulkOutPipe) -> ::w::HRESULT
		}}
		impl IUsbBulkOutEndpointDescriptor {
			#[inline] pub unsafe fn get_max_packet_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPacketSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pipe(&mut self) -> RtResult<ComPtr<UsbBulkOutPipe>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pipe)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbInterruptOutEndpointDescriptor, 3433033089, 4298, 17715, 149, 45, 158, 39, 131, 65, 232, 15);
		RT_INTERFACE!{interface IUsbInterruptOutEndpointDescriptor(IUsbInterruptOutEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutEndpointDescriptor] {
			fn get_MaxPacketSize(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_EndpointNumber(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_Interval(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Pipe(&mut self, out: *mut *mut UsbInterruptOutPipe) -> ::w::HRESULT
		}}
		impl IUsbInterruptOutEndpointDescriptor {
			#[inline] pub unsafe fn get_max_packet_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxPacketSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_endpoint_number(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_EndpointNumber)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_interval(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Interval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_pipe(&mut self) -> RtResult<ComPtr<UsbInterruptOutPipe>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Pipe)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUsbDevice, 1380563346, 50262, 17621, 173, 94, 36, 245, 160, 137, 246, 59);
		RT_INTERFACE!{interface IUsbDevice(IUsbDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDevice] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn SendControlOutTransferAsync(&mut self, setupPacket: *mut UsbSetupPacket, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> ::w::HRESULT,
			fn SendControlOutTransferAsyncNoBuffer(&mut self, setupPacket: *mut UsbSetupPacket, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn SendControlInTransferAsync(&mut self, setupPacket: *mut UsbSetupPacket, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn SendControlInTransferAsyncNoBuffer(&mut self, setupPacket: *mut UsbSetupPacket, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> ::w::HRESULT,
			fn get_DefaultInterface(&mut self, out: *mut *mut UsbInterface) -> ::w::HRESULT,
			fn get_DeviceDescriptor(&mut self, out: *mut *mut UsbDeviceDescriptor) -> ::w::HRESULT,
			fn get_Configuration(&mut self, out: *mut *mut UsbConfiguration) -> ::w::HRESULT
		}}
		impl IUsbDevice {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn send_control_out_transfer_async(&mut self, setupPacket: &UsbSetupPacket, buffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendControlOutTransferAsync)(self, setupPacket as *const _ as *mut _, buffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn send_control_out_transfer_async_no_buffer(&mut self, setupPacket: &UsbSetupPacket) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendControlOutTransferAsyncNoBuffer)(self, setupPacket as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn send_control_in_transfer_async(&mut self, setupPacket: &UsbSetupPacket, buffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendControlInTransferAsync)(self, setupPacket as *const _ as *mut _, buffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn send_control_in_transfer_async_no_buffer(&mut self, setupPacket: &UsbSetupPacket) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SendControlInTransferAsyncNoBuffer)(self, setupPacket as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_interface(&mut self) -> RtResult<ComPtr<UsbInterface>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DefaultInterface)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_descriptor(&mut self) -> RtResult<ComPtr<UsbDeviceDescriptor>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceDescriptor)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_configuration(&mut self) -> RtResult<ComPtr<UsbConfiguration>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Configuration)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
} // Windows.Devices.Usb
pub mod wifi { // Windows.Devices.WiFi
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum WiFiNetworkKind: i32 {
			Any (WiFiNetworkKind_Any) = 0, Infrastructure (WiFiNetworkKind_Infrastructure) = 1, Adhoc (WiFiNetworkKind_Adhoc) = 2,
		}}
		RT_ENUM! { enum WiFiPhyKind: i32 {
			Unknown (WiFiPhyKind_Unknown) = 0, Fhss (WiFiPhyKind_Fhss) = 1, Dsss (WiFiPhyKind_Dsss) = 2, IRBaseband (WiFiPhyKind_IRBaseband) = 3, Ofdm (WiFiPhyKind_Ofdm) = 4, Hrdsss (WiFiPhyKind_Hrdsss) = 5, Erp (WiFiPhyKind_Erp) = 6, HT (WiFiPhyKind_HT) = 7, Vht (WiFiPhyKind_Vht) = 8, Dmg (WiFiPhyKind_Dmg) = 9,
		}}
		RT_ENUM! { enum WiFiAccessStatus: i32 {
			Unspecified (WiFiAccessStatus_Unspecified) = 0, Allowed (WiFiAccessStatus_Allowed) = 1, DeniedByUser (WiFiAccessStatus_DeniedByUser) = 2, DeniedBySystem (WiFiAccessStatus_DeniedBySystem) = 3,
		}}
		RT_ENUM! { enum WiFiReconnectionKind: i32 {
			Automatic (WiFiReconnectionKind_Automatic) = 0, Manual (WiFiReconnectionKind_Manual) = 1,
		}}
		RT_ENUM! { enum WiFiConnectionStatus: i32 {
			UnspecifiedFailure (WiFiConnectionStatus_UnspecifiedFailure) = 0, Success (WiFiConnectionStatus_Success) = 1, AccessRevoked (WiFiConnectionStatus_AccessRevoked) = 2, InvalidCredential (WiFiConnectionStatus_InvalidCredential) = 3, NetworkNotAvailable (WiFiConnectionStatus_NetworkNotAvailable) = 4, Timeout (WiFiConnectionStatus_Timeout) = 5, UnsupportedAuthenticationProtocol (WiFiConnectionStatus_UnsupportedAuthenticationProtocol) = 6,
		}}
		DEFINE_IID!(IID_IWiFiAdapterStatics, 3659922909, 53836, 17379, 170, 189, 196, 101, 159, 115, 15, 153);
		RT_INTERFACE!{static interface IWiFiAdapterStatics(IWiFiAdapterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAdapterStatics] {
			fn FindAllAdaptersAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WiFiAdapter>>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiAdapter>) -> ::w::HRESULT,
			fn RequestAccessAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiAccessStatus>) -> ::w::HRESULT
		}}
		impl IWiFiAdapterStatics {
			#[inline] pub unsafe fn find_all_adapters_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WiFiAdapter>>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FindAllAdaptersAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiAdapter>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn request_access_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiAccessStatus>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).RequestAccessAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiAdapter: IWiFiAdapter}
		RT_ACTIVATABLE!{IWiFiAdapterStatics [CLSID_WiFiAdapter]}
		DEFINE_CLSID!(CLSID_WiFiAdapter = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,46,87,105,70,105,65,100,97,112,116,101,114,0]);
		DEFINE_IID!(IID_IWiFiAdapter, 2797921315, 15733, 17316, 185, 222, 17, 226, 107, 114, 217, 176);
		RT_INTERFACE!{interface IWiFiAdapter(IWiFiAdapterVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAdapter] {
			#[cfg(not(feature="windows.networking"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_NetworkAdapter(&mut self, out: *mut *mut super::super::networking::connectivity::NetworkAdapter) -> ::w::HRESULT,
			fn ScanAsync(&mut self, out: *mut *mut super::super::foundation::IAsyncAction) -> ::w::HRESULT,
			fn get_NetworkReport(&mut self, out: *mut *mut WiFiNetworkReport) -> ::w::HRESULT,
			fn add_AvailableNetworksChanged(&mut self, args: *mut super::super::foundation::TypedEventHandler<WiFiAdapter, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AvailableNetworksChanged(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn ConnectAsync(&mut self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiConnectionResult>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy6(&mut self) -> (),
			#[cfg(feature="windows.security")] fn ConnectWithPasswordCredentialAsync(&mut self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: *mut super::super::security::credentials::PasswordCredential, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiConnectionResult>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.security"))] fn __Dummy7(&mut self) -> (),
			#[cfg(feature="windows.security")] fn ConnectWithPasswordCredentialAndSsidAsync(&mut self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: *mut super::super::security::credentials::PasswordCredential, ssid: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiConnectionResult>) -> ::w::HRESULT,
			fn Disconnect(&mut self) -> ::w::HRESULT
		}}
		impl IWiFiAdapter {
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_network_adapter(&mut self) -> RtResult<ComPtr<super::super::networking::connectivity::NetworkAdapter>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_NetworkAdapter)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn scan_async(&mut self) -> RtResult<ComPtr<super::super::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ScanAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_network_report(&mut self) -> RtResult<ComPtr<WiFiNetworkReport>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_NetworkReport)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_available_networks_changed(&mut self, args: &super::super::foundation::TypedEventHandler<WiFiAdapter, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AvailableNetworksChanged)(self, args as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_available_networks_changed(&mut self, eventCookie: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AvailableNetworksChanged)(self, eventCookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect_async(&mut self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiConnectionResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsync)(self, availableNetwork as *const _ as *mut _, reconnectionKind, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn connect_with_password_credential_async(&mut self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: &super::super::security::credentials::PasswordCredential) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiConnectionResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectWithPasswordCredentialAsync)(self, availableNetwork as *const _ as *mut _, reconnectionKind, passwordCredential as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn connect_with_password_credential_and_ssid_async(&mut self, availableNetwork: &WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: &super::super::security::credentials::PasswordCredential, ssid: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiConnectionResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectWithPasswordCredentialAndSsidAsync)(self, availableNetwork as *const _ as *mut _, reconnectionKind, passwordCredential as *const _ as *mut _, ssid.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn disconnect(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Disconnect)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiNetworkReport: IWiFiNetworkReport}
		RT_CLASS!{class WiFiAvailableNetwork: IWiFiAvailableNetwork}
		RT_CLASS!{class WiFiConnectionResult: IWiFiConnectionResult}
		DEFINE_IID!(IID_IWiFiNetworkReport, 2502221522, 22801, 17502, 129, 148, 190, 79, 26, 112, 72, 149);
		RT_INTERFACE!{interface IWiFiNetworkReport(IWiFiNetworkReportVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiNetworkReport] {
			fn get_Timestamp(&mut self, out: *mut super::super::foundation::DateTime) -> ::w::HRESULT,
			fn get_AvailableNetworks(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<WiFiAvailableNetwork>) -> ::w::HRESULT
		}}
		impl IWiFiNetworkReport {
			#[inline] pub unsafe fn get_timestamp(&mut self) -> RtResult<super::super::foundation::DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Timestamp)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_available_networks(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<WiFiAvailableNetwork>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AvailableNetworks)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiAvailableNetwork, 652829254, 6206, 18180, 152, 38, 113, 180, 162, 240, 246, 104);
		RT_INTERFACE!{interface IWiFiAvailableNetwork(IWiFiAvailableNetworkVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAvailableNetwork] {
			fn get_Uptime(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_Ssid(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Bssid(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ChannelCenterFrequencyInKilohertz(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_NetworkRssiInDecibelMilliwatts(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn get_SignalBars(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn get_NetworkKind(&mut self, out: *mut WiFiNetworkKind) -> ::w::HRESULT,
			fn get_PhyKind(&mut self, out: *mut WiFiPhyKind) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy8(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_SecuritySettings(&mut self, out: *mut *mut super::super::networking::connectivity::NetworkSecuritySettings) -> ::w::HRESULT,
			fn get_BeaconInterval(&mut self, out: *mut super::super::foundation::TimeSpan) -> ::w::HRESULT,
			fn get_IsWiFiDirect(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IWiFiAvailableNetwork {
			#[inline] pub unsafe fn get_uptime(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Uptime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ssid(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Ssid)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_bssid(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Bssid)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_channel_center_frequency_in_kilohertz(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ChannelCenterFrequencyInKilohertz)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_network_rssi_in_decibel_milliwatts(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NetworkRssiInDecibelMilliwatts)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_signal_bars(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SignalBars)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_network_kind(&mut self) -> RtResult<WiFiNetworkKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_NetworkKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_phy_kind(&mut self) -> RtResult<WiFiPhyKind> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PhyKind)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_security_settings(&mut self) -> RtResult<ComPtr<super::super::networking::connectivity::NetworkSecuritySettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SecuritySettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_beacon_interval(&mut self) -> RtResult<super::super::foundation::TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BeaconInterval)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_wi_fi_direct(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsWiFiDirect)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiConnectionResult, 339468249, 50045, 16574, 165, 200, 133, 123, 206, 133, 169, 49);
		RT_INTERFACE!{interface IWiFiConnectionResult(IWiFiConnectionResultVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiConnectionResult] {
			fn get_ConnectionStatus(&mut self, out: *mut WiFiConnectionStatus) -> ::w::HRESULT
		}}
		impl IWiFiConnectionResult {
			#[inline] pub unsafe fn get_connection_status(&mut self) -> RtResult<WiFiConnectionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConnectionStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
} // Windows.Devices.WiFi
pub mod wifidirect { // Windows.Devices.WiFiDirect
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum WiFiDirectConnectionStatus: i32 {
			Disconnected (WiFiDirectConnectionStatus_Disconnected) = 0, Connected (WiFiDirectConnectionStatus_Connected) = 1,
		}}
		RT_ENUM! { enum WiFiDirectError: i32 {
			Success (WiFiDirectError_Success) = 0, RadioNotAvailable (WiFiDirectError_RadioNotAvailable) = 1, ResourceInUse (WiFiDirectError_ResourceInUse) = 2,
		}}
		RT_ENUM! { enum WiFiDirectDeviceSelectorType: i32 {
			DeviceInterface (WiFiDirectDeviceSelectorType_DeviceInterface) = 0, AssociationEndpoint (WiFiDirectDeviceSelectorType_AssociationEndpoint) = 1,
		}}
		RT_ENUM! { enum WiFiDirectAdvertisementListenStateDiscoverability: i32 {
			None (WiFiDirectAdvertisementListenStateDiscoverability_None) = 0, Normal (WiFiDirectAdvertisementListenStateDiscoverability_Normal) = 1, Intensive (WiFiDirectAdvertisementListenStateDiscoverability_Intensive) = 2,
		}}
		RT_ENUM! { enum WiFiDirectAdvertisementPublisherStatus: i32 {
			Created (WiFiDirectAdvertisementPublisherStatus_Created) = 0, Started (WiFiDirectAdvertisementPublisherStatus_Started) = 1, Stopped (WiFiDirectAdvertisementPublisherStatus_Stopped) = 2, Aborted (WiFiDirectAdvertisementPublisherStatus_Aborted) = 3,
		}}
		RT_ENUM! { enum WiFiDirectConfigurationMethod: i32 {
			ProvidePin (WiFiDirectConfigurationMethod_ProvidePin) = 0, DisplayPin (WiFiDirectConfigurationMethod_DisplayPin) = 1, PushButton (WiFiDirectConfigurationMethod_PushButton) = 2,
		}}
		RT_ENUM! { enum WiFiDirectPairingProcedure: i32 {
			GroupOwnerNegotiation (WiFiDirectPairingProcedure_GroupOwnerNegotiation) = 0, Invitation (WiFiDirectPairingProcedure_Invitation) = 1,
		}}
		DEFINE_IID!(IID_IWiFiDirectDeviceStatics, 3899438460, 15020, 18513, 167, 146, 72, 42, 175, 147, 27, 4);
		RT_INTERFACE!{static interface IWiFiDirectDeviceStatics(IWiFiDirectDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics] {
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiDirectDevice>) -> ::w::HRESULT
		}}
		impl IWiFiDirectDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiDirectDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectDevice: IWiFiDirectDevice}
		RT_ACTIVATABLE!{IWiFiDirectDeviceStatics2 [CLSID_WiFiDirectDevice]}
		RT_ACTIVATABLE!{IWiFiDirectDeviceStatics [CLSID_WiFiDirectDevice]}
		DEFINE_CLSID!(CLSID_WiFiDirectDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,68,101,118,105,99,101,0]);
		DEFINE_IID!(IID_IWiFiDirectDeviceStatics2, 445988425, 45315, 17278, 146, 38, 171, 103, 151, 19, 66, 249);
		RT_INTERFACE!{static interface IWiFiDirectDeviceStatics2(IWiFiDirectDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics2] {
			fn GetDeviceSelector(&mut self, type_: WiFiDirectDeviceSelectorType, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, connectionParameters: *mut WiFiDirectConnectionParameters, out: *mut *mut super::super::foundation::IAsyncOperation<WiFiDirectDevice>) -> ::w::HRESULT
		}}
		impl IWiFiDirectDeviceStatics2 {
			#[inline] pub unsafe fn get_device_selector(&mut self, type_: WiFiDirectDeviceSelectorType) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, type_, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg, connectionParameters: &WiFiDirectConnectionParameters) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<WiFiDirectDevice>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), connectionParameters as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectConnectionParameters: IWiFiDirectConnectionParameters}
		RT_ACTIVATABLE!{IWiFiDirectConnectionParametersStatics [CLSID_WiFiDirectConnectionParameters]}
		DEFINE_CLSID!(CLSID_WiFiDirectConnectionParameters = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,67,111,110,110,101,99,116,105,111,110,80,97,114,97,109,101,116,101,114,115,0]);
		DEFINE_IID!(IID_IWiFiDirectInformationElementStatics, 3687853846, 4517, 20064, 140, 170, 52, 119, 33, 72, 55, 138);
		RT_INTERFACE!{static interface IWiFiDirectInformationElementStatics(IWiFiDirectInformationElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElementStatics] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn CreateFromBuffer(&mut self, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut super::super::foundation::collections::IVector<WiFiDirectInformationElement>) -> ::w::HRESULT,
			fn CreateFromDeviceInformation(&mut self, deviceInformation: *mut super::enumeration::DeviceInformation, out: *mut *mut super::super::foundation::collections::IVector<WiFiDirectInformationElement>) -> ::w::HRESULT
		}}
		impl IWiFiDirectInformationElementStatics {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn create_from_buffer(&mut self, buffer: &super::super::storage::streams::IBuffer) -> RtResult<ComPtr<super::super::foundation::collections::IVector<WiFiDirectInformationElement>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromBuffer)(self, buffer as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_from_device_information(&mut self, deviceInformation: &super::enumeration::DeviceInformation) -> RtResult<ComPtr<super::super::foundation::collections::IVector<WiFiDirectInformationElement>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromDeviceInformation)(self, deviceInformation as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectInformationElement: IWiFiDirectInformationElement}
		RT_ACTIVATABLE!{IWiFiDirectInformationElementStatics [CLSID_WiFiDirectInformationElement]}
		DEFINE_CLSID!(CLSID_WiFiDirectInformationElement = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,73,110,102,111,114,109,97,116,105,111,110,69,108,101,109,101,110,116,0]);
		DEFINE_IID!(IID_IWiFiDirectInformationElement, 2952491734, 30395, 18814, 172, 139, 220, 114, 131, 139, 195, 9);
		RT_INTERFACE!{interface IWiFiDirectInformationElement(IWiFiDirectInformationElementVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElement] {
			#[cfg(feature="windows.storage")] fn get_Oui(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_Oui(&mut self, value: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_OuiType(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn put_OuiType(&mut self, value: u8) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_Value(&mut self, out: *mut *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn put_Value(&mut self, value: *mut super::super::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IWiFiDirectInformationElement {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_oui(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Oui)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_oui(&mut self, value: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Oui)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_oui_type(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OuiType)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_oui_type(&mut self, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_OuiType)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_value(&mut self) -> RtResult<ComPtr<super::super::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_value(&mut self, value: &super::super::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Value)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectLegacySettings, 2790251450, 62205, 17767, 169, 27, 245, 194, 245, 50, 16, 87);
		RT_INTERFACE!{interface IWiFiDirectLegacySettings(IWiFiDirectLegacySettingsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectLegacySettings] {
			fn get_IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_Ssid(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn put_Ssid(&mut self, value: ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(feature="windows.security")] fn get_Passphrase(&mut self, out: *mut *mut super::super::security::credentials::PasswordCredential) -> ::w::HRESULT,
			#[cfg(feature="windows.security")] fn put_Passphrase(&mut self, value: *mut super::super::security::credentials::PasswordCredential) -> ::w::HRESULT
		}}
		impl IWiFiDirectLegacySettings {
			#[inline] pub unsafe fn get_is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_ssid(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Ssid)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_ssid(&mut self, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Ssid)(self, value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn get_passphrase(&mut self) -> RtResult<ComPtr<super::super::security::credentials::PasswordCredential>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Passphrase)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.security")] #[inline] pub unsafe fn set_passphrase(&mut self, value: &super::super::security::credentials::PasswordCredential) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Passphrase)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectLegacySettings: IWiFiDirectLegacySettings}
		DEFINE_IID!(IID_IWiFiDirectAdvertisement, 2874219053, 10758, 18849, 165, 132, 97, 67, 92, 121, 5, 166);
		RT_INTERFACE!{interface IWiFiDirectAdvertisement(IWiFiDirectAdvertisementVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement] {
			fn get_InformationElements(&mut self, out: *mut *mut super::super::foundation::collections::IVector<WiFiDirectInformationElement>) -> ::w::HRESULT,
			fn put_InformationElements(&mut self, value: *mut super::super::foundation::collections::IVector<WiFiDirectInformationElement>) -> ::w::HRESULT,
			fn get_ListenStateDiscoverability(&mut self, out: *mut WiFiDirectAdvertisementListenStateDiscoverability) -> ::w::HRESULT,
			fn put_ListenStateDiscoverability(&mut self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> ::w::HRESULT,
			fn get_IsAutonomousGroupOwnerEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_IsAutonomousGroupOwnerEnabled(&mut self, value: bool) -> ::w::HRESULT,
			fn get_LegacySettings(&mut self, out: *mut *mut WiFiDirectLegacySettings) -> ::w::HRESULT
		}}
		impl IWiFiDirectAdvertisement {
			#[inline] pub unsafe fn get_information_elements(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<WiFiDirectInformationElement>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_InformationElements)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_information_elements(&mut self, value: &super::super::foundation::collections::IVector<WiFiDirectInformationElement>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_InformationElements)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_listen_state_discoverability(&mut self) -> RtResult<WiFiDirectAdvertisementListenStateDiscoverability> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ListenStateDiscoverability)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_listen_state_discoverability(&mut self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ListenStateDiscoverability)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_autonomous_group_owner_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsAutonomousGroupOwnerEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_is_autonomous_group_owner_enabled(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_IsAutonomousGroupOwnerEnabled)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_legacy_settings(&mut self) -> RtResult<ComPtr<WiFiDirectLegacySettings>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LegacySettings)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectAdvertisement2, 3076106822, 55318, 18715, 145, 122, 180, 13, 125, 196, 3, 162);
		RT_INTERFACE!{interface IWiFiDirectAdvertisement2(IWiFiDirectAdvertisement2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement2] {
			fn get_SupportedConfigurationMethods(&mut self, out: *mut *mut super::super::foundation::collections::IVector<WiFiDirectConfigurationMethod>) -> ::w::HRESULT
		}}
		impl IWiFiDirectAdvertisement2 {
			#[inline] pub unsafe fn get_supported_configuration_methods(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<WiFiDirectConfigurationMethod>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedConfigurationMethods)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectAdvertisement: IWiFiDirectAdvertisement}
		DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs, 2868766012, 21633, 18150, 144, 221, 50, 17, 101, 24, 241, 146);
		RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisherStatusChangedEventArgs(IWiFiDirectAdvertisementPublisherStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs] {
			fn get_Status(&mut self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> ::w::HRESULT,
			fn get_Error(&mut self, out: *mut WiFiDirectError) -> ::w::HRESULT
		}}
		impl IWiFiDirectAdvertisementPublisherStatusChangedEventArgs {
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<WiFiDirectAdvertisementPublisherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error(&mut self) -> RtResult<WiFiDirectError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Error)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectAdvertisementPublisherStatusChangedEventArgs: IWiFiDirectAdvertisementPublisherStatusChangedEventArgs}
		DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisher, 3009031450, 39711, 17881, 146, 90, 105, 77, 102, 223, 104, 239);
		RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisher(IWiFiDirectAdvertisementPublisherVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisher] {
			fn get_Advertisement(&mut self, out: *mut *mut WiFiDirectAdvertisement) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> ::w::HRESULT,
			fn add_StatusChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_StatusChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IWiFiDirectAdvertisementPublisher {
			#[inline] pub unsafe fn get_advertisement(&mut self) -> RtResult<ComPtr<WiFiDirectAdvertisement>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Advertisement)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<WiFiDirectAdvertisementPublisherStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_status_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_StatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_status_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_StatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectAdvertisementPublisher: IWiFiDirectAdvertisementPublisher}
		DEFINE_IID!(IID_IWiFiDirectConnectionParametersStatics, 1502278803, 30274, 17775, 185, 216, 232, 169, 235, 31, 64, 26);
		RT_INTERFACE!{static interface IWiFiDirectConnectionParametersStatics(IWiFiDirectConnectionParametersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParametersStatics] {
			fn GetDevicePairingKinds(&mut self, configurationMethod: WiFiDirectConfigurationMethod, out: *mut super::enumeration::DevicePairingKinds) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionParametersStatics {
			#[inline] pub unsafe fn get_device_pairing_kinds(&mut self, configurationMethod: WiFiDirectConfigurationMethod) -> RtResult<super::enumeration::DevicePairingKinds> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetDevicePairingKinds)(self, configurationMethod, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectConnectionParameters, 3001373701, 22274, 19222, 160, 44, 187, 205, 33, 239, 96, 152);
		RT_INTERFACE!{interface IWiFiDirectConnectionParameters(IWiFiDirectConnectionParametersVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters] {
			fn get_GroupOwnerIntent(&mut self, out: *mut i16) -> ::w::HRESULT,
			fn put_GroupOwnerIntent(&mut self, value: i16) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionParameters {
			#[inline] pub unsafe fn get_group_owner_intent(&mut self) -> RtResult<i16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_GroupOwnerIntent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_group_owner_intent(&mut self, value: i16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_GroupOwnerIntent)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectConnectionParameters2, 2872774590, 43650, 17588, 136, 200, 227, 5, 107, 137, 128, 29);
		RT_INTERFACE!{interface IWiFiDirectConnectionParameters2(IWiFiDirectConnectionParameters2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters2] {
			fn get_PreferenceOrderedConfigurationMethods(&mut self, out: *mut *mut super::super::foundation::collections::IVector<WiFiDirectConfigurationMethod>) -> ::w::HRESULT,
			fn get_PreferredPairingProcedure(&mut self, out: *mut WiFiDirectPairingProcedure) -> ::w::HRESULT,
			fn put_PreferredPairingProcedure(&mut self, value: WiFiDirectPairingProcedure) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionParameters2 {
			#[inline] pub unsafe fn get_preference_ordered_configuration_methods(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVector<WiFiDirectConfigurationMethod>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PreferenceOrderedConfigurationMethods)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_preferred_pairing_procedure(&mut self) -> RtResult<WiFiDirectPairingProcedure> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PreferredPairingProcedure)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_preferred_pairing_procedure(&mut self, value: WiFiDirectPairingProcedure) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PreferredPairingProcedure)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectConnectionRequest: IWiFiDirectConnectionRequest}
		DEFINE_IID!(IID_IWiFiDirectConnectionRequestedEventArgs, 4187824318, 54157, 18511, 130, 21, 231, 182, 90, 191, 36, 76);
		RT_INTERFACE!{interface IWiFiDirectConnectionRequestedEventArgs(IWiFiDirectConnectionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequestedEventArgs] {
			fn GetConnectionRequest(&mut self, out: *mut *mut WiFiDirectConnectionRequest) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionRequestedEventArgs {
			#[inline] pub unsafe fn get_connection_request(&mut self) -> RtResult<ComPtr<WiFiDirectConnectionRequest>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetConnectionRequest)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectConnectionRequestedEventArgs: IWiFiDirectConnectionRequestedEventArgs}
		DEFINE_IID!(IID_IWiFiDirectConnectionListener, 1771838221, 36115, 20201, 185, 236, 156, 114, 248, 37, 31, 125);
		RT_INTERFACE!{interface IWiFiDirectConnectionListener(IWiFiDirectConnectionListenerVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionListener] {
			fn add_ConnectionRequested(&mut self, handler: *mut super::super::foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ConnectionRequested(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionListener {
			#[inline] pub unsafe fn add_connection_requested(&mut self, handler: &super::super::foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ConnectionRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_connection_requested(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ConnectionRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectConnectionListener: IWiFiDirectConnectionListener}
		DEFINE_IID!(IID_IWiFiDirectDevice, 1927195304, 29419, 19886, 138, 40, 133, 19, 53, 93, 39, 119);
		RT_INTERFACE!{interface IWiFiDirectDevice(IWiFiDirectDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDevice] {
			fn get_ConnectionStatus(&mut self, out: *mut WiFiDirectConnectionStatus) -> ::w::HRESULT,
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn add_ConnectionStatusChanged(&mut self, handler: *mut super::super::foundation::TypedEventHandler<WiFiDirectDevice, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_ConnectionStatusChanged(&mut self, token: super::super::foundation::EventRegistrationToken) -> ::w::HRESULT,
			#[cfg(feature="windows.networking")] fn GetConnectionEndpointPairs(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::networking::EndpointPair>) -> ::w::HRESULT
		}}
		impl IWiFiDirectDevice {
			#[inline] pub unsafe fn get_connection_status(&mut self) -> RtResult<WiFiDirectConnectionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ConnectionStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_connection_status_changed(&mut self, handler: &super::super::foundation::TypedEventHandler<WiFiDirectDevice, IInspectable>) -> RtResult<super::super::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_ConnectionStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_connection_status_changed(&mut self, token: super::super::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_ConnectionStatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_connection_endpoint_pairs(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::networking::EndpointPair>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetConnectionEndpointPairs)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectConnectionRequest, 2394527237, 37199, 18883, 166, 20, 209, 141, 197, 177, 155, 67);
		RT_INTERFACE!{interface IWiFiDirectConnectionRequest(IWiFiDirectConnectionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequest] {
			fn get_DeviceInformation(&mut self, out: *mut *mut super::enumeration::DeviceInformation) -> ::w::HRESULT
		}}
		impl IWiFiDirectConnectionRequest {
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<super::enumeration::DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
pub mod services { // Windows.Devices.WiFiDirect.Services
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum WiFiDirectServiceConfigurationMethod: i32 {
			Default (WiFiDirectServiceConfigurationMethod_Default) = 0, PinDisplay (WiFiDirectServiceConfigurationMethod_PinDisplay) = 1, PinEntry (WiFiDirectServiceConfigurationMethod_PinEntry) = 2,
		}}
		RT_ENUM! { enum WiFiDirectServiceStatus: i32 {
			Available (WiFiDirectServiceStatus_Available) = 0, Busy (WiFiDirectServiceStatus_Busy) = 1, Custom (WiFiDirectServiceStatus_Custom) = 2,
		}}
		RT_ENUM! { enum WiFiDirectServiceSessionStatus: i32 {
			Closed (WiFiDirectServiceSessionStatus_Closed) = 0, Initiated (WiFiDirectServiceSessionStatus_Initiated) = 1, Requested (WiFiDirectServiceSessionStatus_Requested) = 2, Open (WiFiDirectServiceSessionStatus_Open) = 3,
		}}
		RT_ENUM! { enum WiFiDirectServiceSessionErrorStatus: i32 {
			Ok (WiFiDirectServiceSessionErrorStatus_Ok) = 0, Disassociated (WiFiDirectServiceSessionErrorStatus_Disassociated) = 1, LocalClose (WiFiDirectServiceSessionErrorStatus_LocalClose) = 2, RemoteClose (WiFiDirectServiceSessionErrorStatus_RemoteClose) = 3, SystemFailure (WiFiDirectServiceSessionErrorStatus_SystemFailure) = 4, NoResponseFromRemote (WiFiDirectServiceSessionErrorStatus_NoResponseFromRemote) = 5,
		}}
		RT_ENUM! { enum WiFiDirectServiceAdvertisementStatus: i32 {
			Created (WiFiDirectServiceAdvertisementStatus_Created) = 0, Started (WiFiDirectServiceAdvertisementStatus_Started) = 1, Stopped (WiFiDirectServiceAdvertisementStatus_Stopped) = 2, Aborted (WiFiDirectServiceAdvertisementStatus_Aborted) = 3,
		}}
		RT_ENUM! { enum WiFiDirectServiceError: i32 {
			Success (WiFiDirectServiceError_Success) = 0, RadioNotAvailable (WiFiDirectServiceError_RadioNotAvailable) = 1, ResourceInUse (WiFiDirectServiceError_ResourceInUse) = 2, UnsupportedHardware (WiFiDirectServiceError_UnsupportedHardware) = 3, NoHardware (WiFiDirectServiceError_NoHardware) = 4,
		}}
		RT_ENUM! { enum WiFiDirectServiceIPProtocol: i32 {
			Tcp (WiFiDirectServiceIPProtocol_Tcp) = 6, Udp (WiFiDirectServiceIPProtocol_Udp) = 17,
		}}
		DEFINE_IID!(IID_IWiFiDirectServiceProvisioningInfo, 2346417406, 38873, 17826, 142, 153, 219, 80, 145, 15, 182, 166);
		RT_INTERFACE!{interface IWiFiDirectServiceProvisioningInfo(IWiFiDirectServiceProvisioningInfoVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceProvisioningInfo] {
			fn get_SelectedConfigurationMethod(&mut self, out: *mut WiFiDirectServiceConfigurationMethod) -> ::w::HRESULT,
			fn get_IsGroupFormationNeeded(&mut self, out: *mut bool) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceProvisioningInfo {
			#[inline] pub unsafe fn get_selected_configuration_method(&mut self) -> RtResult<WiFiDirectServiceConfigurationMethod> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelectedConfigurationMethod)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_group_formation_needed(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsGroupFormationNeeded)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceProvisioningInfo: IWiFiDirectServiceProvisioningInfo}
		DEFINE_IID!(IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs, 3705266206, 33759, 17381, 143, 67, 203, 232, 71, 158, 132, 235);
		RT_INTERFACE!{interface IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs(IWiFiDirectServiceAutoAcceptSessionConnectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs] {
			fn get_Session(&mut self, out: *mut *mut WiFiDirectServiceSession) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_SessionInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs {
			#[inline] pub unsafe fn get_session(&mut self) -> RtResult<ComPtr<WiFiDirectServiceSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Session)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_session_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SessionInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceSession: IWiFiDirectServiceSession}
		RT_CLASS!{class WiFiDirectServiceAutoAcceptSessionConnectedEventArgs: IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs}
		DEFINE_IID!(IID_IWiFiDirectServiceRemotePortAddedEventArgs, 3570318017, 16339, 20238, 183, 189, 120, 41, 6, 244, 68, 17);
		RT_INTERFACE!{interface IWiFiDirectServiceRemotePortAddedEventArgs(IWiFiDirectServiceRemotePortAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceRemotePortAddedEventArgs] {
			#[cfg(not(feature="windows.networking"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn get_EndpointPairs(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::networking::EndpointPair>) -> ::w::HRESULT,
			fn get_Protocol(&mut self, out: *mut WiFiDirectServiceIPProtocol) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceRemotePortAddedEventArgs {
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_endpoint_pairs(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::networking::EndpointPair>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_EndpointPairs)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_protocol(&mut self) -> RtResult<WiFiDirectServiceIPProtocol> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Protocol)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceRemotePortAddedEventArgs: IWiFiDirectServiceRemotePortAddedEventArgs}
		DEFINE_IID!(IID_IWiFiDirectServiceSessionDeferredEventArgs, 2382109055, 4609, 20255, 182, 244, 93, 241, 183, 185, 251, 46);
		RT_INTERFACE!{interface IWiFiDirectServiceSessionDeferredEventArgs(IWiFiDirectServiceSessionDeferredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionDeferredEventArgs] {
			#[cfg(feature="windows.storage")] fn get_DeferredSessionInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceSessionDeferredEventArgs {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_deferred_session_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeferredSessionInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceSessionDeferredEventArgs: IWiFiDirectServiceSessionDeferredEventArgs}
		DEFINE_IID!(IID_IWiFiDirectServiceSessionRequestedEventArgs, 1958595601, 21462, 18841, 180, 248, 108, 142, 204, 23, 113, 231);
		RT_INTERFACE!{interface IWiFiDirectServiceSessionRequestedEventArgs(IWiFiDirectServiceSessionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequestedEventArgs] {
			fn GetSessionRequest(&mut self, out: *mut *mut WiFiDirectServiceSessionRequest) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceSessionRequestedEventArgs {
			#[inline] pub unsafe fn get_session_request(&mut self) -> RtResult<ComPtr<WiFiDirectServiceSessionRequest>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSessionRequest)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceSessionRequest: IWiFiDirectServiceSessionRequest}
		RT_CLASS!{class WiFiDirectServiceSessionRequestedEventArgs: IWiFiDirectServiceSessionRequestedEventArgs}
		DEFINE_IID!(IID_IWiFiDirectServiceAdvertiserFactory, 822520845, 46150, 20243, 159, 154, 138, 233, 37, 254, 186, 43);
		RT_INTERFACE!{static interface IWiFiDirectServiceAdvertiserFactory(IWiFiDirectServiceAdvertiserFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiserFactory] {
			fn CreateWiFiDirectServiceAdvertiser(&mut self, serviceName: ::w::HSTRING, out: *mut *mut WiFiDirectServiceAdvertiser) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceAdvertiserFactory {
			#[inline] pub unsafe fn create_wi_fi_direct_service_advertiser(&mut self, serviceName: &HStringArg) -> RtResult<ComPtr<WiFiDirectServiceAdvertiser>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWiFiDirectServiceAdvertiser)(self, serviceName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectServiceAdvertiser: IWiFiDirectServiceAdvertiser [IWiFiDirectServiceAdvertiserFactory] [CLSID_WiFiDirectServiceAdvertiser]}
		DEFINE_CLSID!(CLSID_WiFiDirectServiceAdvertiser = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,65,100,118,101,114,116,105,115,101,114,0]);
		DEFINE_IID!(IID_IWiFiDirectServiceAdvertiser, 2762612449, 40335, 20303, 147, 238, 125, 222, 162, 227, 127, 70);
		RT_INTERFACE!{interface IWiFiDirectServiceAdvertiser(IWiFiDirectServiceAdvertiserVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiser] {
			fn get_ServiceName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_ServiceNamePrefixes(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HString>) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy2(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_ServiceInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_ServiceInfo(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_AutoAcceptSession(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_AutoAcceptSession(&mut self, value: bool) -> ::w::HRESULT,
			fn get_PreferGroupOwnerMode(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_PreferGroupOwnerMode(&mut self, value: bool) -> ::w::HRESULT,
			fn get_PreferredConfigurationMethods(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<WiFiDirectServiceConfigurationMethod>) -> ::w::HRESULT,
			fn get_ServiceStatus(&mut self, out: *mut WiFiDirectServiceStatus) -> ::w::HRESULT,
			fn put_ServiceStatus(&mut self, value: WiFiDirectServiceStatus) -> ::w::HRESULT,
			fn get_CustomServiceStatusCode(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_CustomServiceStatusCode(&mut self, value: u32) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy13(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_DeferredSessionInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy14(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_DeferredSessionInfo(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_AdvertisementStatus(&mut self, out: *mut WiFiDirectServiceAdvertisementStatus) -> ::w::HRESULT,
			fn get_ServiceError(&mut self, out: *mut WiFiDirectServiceError) -> ::w::HRESULT,
			fn add_SessionRequested(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SessionRequested(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_AutoAcceptSessionConnected(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AutoAcceptSessionConnected(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn add_AdvertisementStatusChanged(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_AdvertisementStatusChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn ConnectAsync(&mut self, deviceInfo: *mut super::super::enumeration::DeviceInformation, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>) -> ::w::HRESULT,
			fn ConnectAsyncWithPin(&mut self, deviceInfo: *mut super::super::enumeration::DeviceInformation, pin: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>) -> ::w::HRESULT,
			fn Start(&mut self) -> ::w::HRESULT,
			fn Stop(&mut self) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceAdvertiser {
			#[inline] pub unsafe fn get_service_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_name_prefixes(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<HString>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceNamePrefixes)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_service_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_service_info(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ServiceInfo)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_accept_session(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AutoAcceptSession)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_auto_accept_session(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AutoAcceptSession)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_prefer_group_owner_mode(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PreferGroupOwnerMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_prefer_group_owner_mode(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PreferGroupOwnerMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_preferred_configuration_methods(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVector<WiFiDirectServiceConfigurationMethod>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_PreferredConfigurationMethods)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_status(&mut self) -> RtResult<WiFiDirectServiceStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_service_status(&mut self, value: WiFiDirectServiceStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ServiceStatus)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_custom_service_status_code(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CustomServiceStatusCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_custom_service_status_code(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_CustomServiceStatusCode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_deferred_session_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeferredSessionInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_deferred_session_info(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DeferredSessionInfo)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement_status(&mut self) -> RtResult<WiFiDirectServiceAdvertisementStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AdvertisementStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_error(&mut self) -> RtResult<WiFiDirectServiceError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceError)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_session_requested(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SessionRequested)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_session_requested(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SessionRequested)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_auto_accept_session_connected(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AutoAcceptSessionConnected)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_auto_accept_session_connected(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AutoAcceptSessionConnected)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_advertisement_status_changed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_AdvertisementStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_advertisement_status_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_AdvertisementStatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect_async(&mut self, deviceInfo: &super::super::enumeration::DeviceInformation) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsync)(self, deviceInfo as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect_async_with_pin(&mut self, deviceInfo: &super::super::enumeration::DeviceInformation, pin: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsyncWithPin)(self, deviceInfo as *const _ as *mut _, pin.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Start)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Stop)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectServiceStatics, 2108948549, 64884, 18056, 183, 37, 93, 206, 134, 172, 242, 51);
		RT_INTERFACE!{static interface IWiFiDirectServiceStatics(IWiFiDirectServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceStatics] {
			fn GetSelector(&mut self, serviceName: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn GetSelectorWithFilter(&mut self, serviceName: ::w::HSTRING, serviceInfoFilter: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectService>) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceStatics {
			#[inline] pub unsafe fn get_selector(&mut self, serviceName: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSelector)(self, serviceName.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_selector_with_filter(&mut self, serviceName: &HStringArg, serviceInfoFilter: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSelectorWithFilter)(self, serviceName.get(), serviceInfoFilter as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectService>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WiFiDirectService: IWiFiDirectService}
		RT_ACTIVATABLE!{IWiFiDirectServiceStatics [CLSID_WiFiDirectService]}
		DEFINE_CLSID!(CLSID_WiFiDirectService = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,0]);
		DEFINE_IID!(IID_IWiFiDirectService, 1353366456, 24433, 17900, 132, 241, 161, 228, 252, 120, 121, 163);
		RT_INTERFACE!{interface IWiFiDirectService(IWiFiDirectServiceVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectService] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_RemoteServiceInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_SupportedConfigurationMethods(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod>) -> ::w::HRESULT,
			fn get_PreferGroupOwnerMode(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_PreferGroupOwnerMode(&mut self, value: bool) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn get_SessionInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy5(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn put_SessionInfo(&mut self, value: *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT,
			fn get_ServiceError(&mut self, out: *mut WiFiDirectServiceError) -> ::w::HRESULT,
			fn add_SessionDeferred(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SessionDeferred(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn GetProvisioningInfoAsync(&mut self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo>) -> ::w::HRESULT,
			fn ConnectAsync(&mut self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>) -> ::w::HRESULT,
			fn ConnectAsyncWithPin(&mut self, pin: ::w::HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>) -> ::w::HRESULT
		}}
		impl IWiFiDirectService {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_remote_service_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RemoteServiceInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_supported_configuration_methods(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SupportedConfigurationMethods)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_prefer_group_owner_mode(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PreferGroupOwnerMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_prefer_group_owner_mode(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PreferGroupOwnerMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_session_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SessionInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn set_session_info(&mut self, value: &::rt::gen::windows::storage::streams::IBuffer) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SessionInfo)(self, value as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_error(&mut self) -> RtResult<WiFiDirectServiceError> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ServiceError)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_session_deferred(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SessionDeferred)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_session_deferred(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SessionDeferred)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_provisioning_info_async(&mut self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetProvisioningInfoAsync)(self, selectedConfigurationMethod, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect_async(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn connect_async_with_pin(&mut self, pin: &HStringArg) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WiFiDirectServiceSession>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ConnectAsyncWithPin)(self, pin.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectServiceSessionRequest, 2699197579, 20683, 19032, 155, 207, 228, 114, 185, 159, 186, 4);
		RT_INTERFACE!{interface IWiFiDirectServiceSessionRequest(IWiFiDirectServiceSessionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequest] {
			fn get_DeviceInformation(&mut self, out: *mut *mut super::super::enumeration::DeviceInformation) -> ::w::HRESULT,
			fn get_ProvisioningInfo(&mut self, out: *mut *mut WiFiDirectServiceProvisioningInfo) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn get_SessionInfo(&mut self, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceSessionRequest {
			#[inline] pub unsafe fn get_device_information(&mut self) -> RtResult<ComPtr<super::super::enumeration::DeviceInformation>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceInformation)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_provisioning_info(&mut self) -> RtResult<ComPtr<WiFiDirectServiceProvisioningInfo>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ProvisioningInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_session_info(&mut self) -> RtResult<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SessionInfo)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWiFiDirectServiceSession, 2165580131, 58406, 18379, 134, 64, 225, 179, 88, 139, 242, 111);
		RT_INTERFACE!{interface IWiFiDirectServiceSession(IWiFiDirectServiceSessionVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSession] {
			fn get_ServiceName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut WiFiDirectServiceSessionStatus) -> ::w::HRESULT,
			fn get_ErrorStatus(&mut self, out: *mut WiFiDirectServiceSessionErrorStatus) -> ::w::HRESULT,
			fn get_SessionId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_AdvertisementId(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_ServiceAddress(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SessionAddress(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy7(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn GetConnectionEndpointPairs(&mut self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::networking::EndpointPair>) -> ::w::HRESULT,
			fn add_SessionStatusChanged(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_SessionStatusChanged(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy10(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn AddStreamSocketListenerAsync(&mut self, value: *mut ::rt::gen::windows::networking::sockets::StreamSocketListener, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> ::w::HRESULT,
			#[cfg(not(feature="windows.networking"))] fn __Dummy11(&mut self) -> (),
			#[cfg(feature="windows.networking")] fn AddDatagramSocketAsync(&mut self, value: *mut ::rt::gen::windows::networking::sockets::DatagramSocket, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> ::w::HRESULT,
			fn add_RemotePortAdded(&mut self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_RemotePortAdded(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IWiFiDirectServiceSession {
			#[inline] pub unsafe fn get_service_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<WiFiDirectServiceSessionStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_status(&mut self) -> RtResult<WiFiDirectServiceSessionErrorStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ErrorStatus)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_session_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SessionId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_advertisement_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AdvertisementId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_service_address(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ServiceAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_session_address(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SessionAddress)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn get_connection_endpoint_pairs(&mut self) -> RtResult<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::networking::EndpointPair>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetConnectionEndpointPairs)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_session_status_changed(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_SessionStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_session_status_changed(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_SessionStatusChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn add_stream_socket_listener_async(&mut self, value: &::rt::gen::windows::networking::sockets::StreamSocketListener) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AddStreamSocketListenerAsync)(self, value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.networking")] #[inline] pub unsafe fn add_datagram_socket_async(&mut self, value: &::rt::gen::windows::networking::sockets::DatagramSocket) -> RtResult<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).AddDatagramSocketAsync)(self, value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_remote_port_added(&mut self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs>) -> RtResult<::rt::gen::windows::foundation::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_RemotePortAdded)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_remote_port_added(&mut self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_RemotePortAdded)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
} // Windows.Devices.WiFiDirect.Services
} // Windows.Devices.WiFiDirect
pub mod portable { // Windows.Devices.Portable
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct PortableDeviceContract {
			
		}}
		RT_ENUM! { enum ServiceDeviceType: i32 {
			CalendarService (ServiceDeviceType_CalendarService) = 0, ContactsService (ServiceDeviceType_ContactsService) = 1, DeviceStatusService (ServiceDeviceType_DeviceStatusService) = 2, NotesService (ServiceDeviceType_NotesService) = 3, RingtonesService (ServiceDeviceType_RingtonesService) = 4, SmsService (ServiceDeviceType_SmsService) = 5, TasksService (ServiceDeviceType_TasksService) = 6,
		}}
		DEFINE_IID!(IID_IStorageDeviceStatics, 1590576366, 6947, 19922, 134, 82, 188, 22, 79, 0, 49, 40);
		RT_INTERFACE!{static interface IStorageDeviceStatics(IStorageDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStorageDeviceStatics] {
			#[cfg(not(feature="windows.storage"))] fn __Dummy0(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn FromId(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::storage::StorageFolder) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IStorageDeviceStatics {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn from_id(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::storage::StorageFolder>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromId)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IServiceDeviceStatics, 2827097313, 22983, 18976, 171, 166, 159, 103, 7, 147, 114, 48);
		RT_INTERFACE!{static interface IServiceDeviceStatics(IServiceDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IServiceDeviceStatics] {
			fn GetDeviceSelector(&mut self, serviceType: ServiceDeviceType, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetDeviceSelectorFromServiceId(&mut self, serviceId: ::Guid, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IServiceDeviceStatics {
			#[inline] pub unsafe fn get_device_selector(&mut self, serviceType: ServiceDeviceType) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, serviceType, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector_from_service_id(&mut self, serviceId: ::Guid) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelectorFromServiceId)(self, serviceId, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IStorageDeviceStatics [CLSID_StorageDevice]}
		DEFINE_CLSID!(CLSID_StorageDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,116,111,114,97,103,101,68,101,118,105,99,101,0]);
		RT_ACTIVATABLE!{IServiceDeviceStatics [CLSID_ServiceDevice]}
		DEFINE_CLSID!(CLSID_ServiceDevice = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,101,114,118,105,99,101,68,101,118,105,99,101,0]);
} // Windows.Devices.Portable
pub mod scanners { // Windows.Devices.Scanners
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct ScannerDeviceContract {
			
		}}
		RT_ENUM! { enum ImageScannerFormat: i32 {
			Jpeg (ImageScannerFormat_Jpeg) = 0, Png (ImageScannerFormat_Png) = 1, DeviceIndependentBitmap (ImageScannerFormat_DeviceIndependentBitmap) = 2, Tiff (ImageScannerFormat_Tiff) = 3, Xps (ImageScannerFormat_Xps) = 4, OpenXps (ImageScannerFormat_OpenXps) = 5, Pdf (ImageScannerFormat_Pdf) = 6,
		}}
		DEFINE_IID!(IID_IImageScannerFormatConfiguration, 2921815313, 56031, 16400, 191, 16, 204, 165, 200, 61, 203, 176);
		RT_INTERFACE!{interface IImageScannerFormatConfiguration(IImageScannerFormatConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerFormatConfiguration] {
			fn get_DefaultFormat(&mut self, out: *mut ImageScannerFormat) -> ::w::HRESULT,
			fn get_Format(&mut self, out: *mut ImageScannerFormat) -> ::w::HRESULT,
			fn put_Format(&mut self, value: ImageScannerFormat) -> ::w::HRESULT,
			fn IsFormatSupported(&mut self, value: ImageScannerFormat, out: *mut bool) -> ::w::HRESULT
		}}
		impl IImageScannerFormatConfiguration {
			#[inline] pub unsafe fn get_default_format(&mut self) -> RtResult<ImageScannerFormat> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultFormat)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_format(&mut self) -> RtResult<ImageScannerFormat> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Format)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_format(&mut self, value: ImageScannerFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Format)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_format_supported(&mut self, value: ImageScannerFormat) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsFormatSupported)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScannerAutoConfiguration: IImageScannerFormatConfiguration}
		RT_ENUM! { enum ImageScannerAutoCroppingMode: i32 {
			Disabled (ImageScannerAutoCroppingMode_Disabled) = 0, SingleRegion (ImageScannerAutoCroppingMode_SingleRegion) = 1, MultipleRegion (ImageScannerAutoCroppingMode_MultipleRegion) = 2,
		}}
		RT_ENUM! { enum ImageScannerColorMode: i32 {
			Color (ImageScannerColorMode_Color) = 0, Grayscale (ImageScannerColorMode_Grayscale) = 1, Monochrome (ImageScannerColorMode_Monochrome) = 2, AutoColor (ImageScannerColorMode_AutoColor) = 3,
		}}
		RT_STRUCT! { struct ImageScannerResolution {
			DpiX: f32, DpiY: f32,
		}}
		DEFINE_IID!(IID_IImageScannerSourceConfiguration, 3216310357, 2884, 19586, 158, 137, 32, 95, 156, 35, 78, 89);
		RT_INTERFACE!{interface IImageScannerSourceConfiguration(IImageScannerSourceConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerSourceConfiguration] {
			fn get_MinScanArea(&mut self, out: *mut super::super::foundation::Size) -> ::w::HRESULT,
			fn get_MaxScanArea(&mut self, out: *mut super::super::foundation::Size) -> ::w::HRESULT,
			fn get_SelectedScanRegion(&mut self, out: *mut super::super::foundation::Rect) -> ::w::HRESULT,
			fn put_SelectedScanRegion(&mut self, value: super::super::foundation::Rect) -> ::w::HRESULT,
			fn get_AutoCroppingMode(&mut self, out: *mut ImageScannerAutoCroppingMode) -> ::w::HRESULT,
			fn put_AutoCroppingMode(&mut self, value: ImageScannerAutoCroppingMode) -> ::w::HRESULT,
			fn IsAutoCroppingModeSupported(&mut self, value: ImageScannerAutoCroppingMode, out: *mut bool) -> ::w::HRESULT,
			fn get_MinResolution(&mut self, out: *mut ImageScannerResolution) -> ::w::HRESULT,
			fn get_MaxResolution(&mut self, out: *mut ImageScannerResolution) -> ::w::HRESULT,
			fn get_OpticalResolution(&mut self, out: *mut ImageScannerResolution) -> ::w::HRESULT,
			fn get_DesiredResolution(&mut self, out: *mut ImageScannerResolution) -> ::w::HRESULT,
			fn put_DesiredResolution(&mut self, value: ImageScannerResolution) -> ::w::HRESULT,
			fn get_ActualResolution(&mut self, out: *mut ImageScannerResolution) -> ::w::HRESULT,
			fn get_DefaultColorMode(&mut self, out: *mut ImageScannerColorMode) -> ::w::HRESULT,
			fn get_ColorMode(&mut self, out: *mut ImageScannerColorMode) -> ::w::HRESULT,
			fn put_ColorMode(&mut self, value: ImageScannerColorMode) -> ::w::HRESULT,
			fn IsColorModeSupported(&mut self, value: ImageScannerColorMode, out: *mut bool) -> ::w::HRESULT,
			fn get_MinBrightness(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MaxBrightness(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_BrightnessStep(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DefaultBrightness(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Brightness(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_Brightness(&mut self, value: i32) -> ::w::HRESULT,
			fn get_MinContrast(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_MaxContrast(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_ContrastStep(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_DefaultContrast(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Contrast(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_Contrast(&mut self, value: i32) -> ::w::HRESULT
		}}
		impl IImageScannerSourceConfiguration {
			#[inline] pub unsafe fn get_min_scan_area(&mut self) -> RtResult<super::super::foundation::Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinScanArea)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_scan_area(&mut self) -> RtResult<super::super::foundation::Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxScanArea)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_selected_scan_region(&mut self) -> RtResult<super::super::foundation::Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_SelectedScanRegion)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_selected_scan_region(&mut self, value: super::super::foundation::Rect) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_SelectedScanRegion)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_cropping_mode(&mut self) -> RtResult<ImageScannerAutoCroppingMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AutoCroppingMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_auto_cropping_mode(&mut self, value: ImageScannerAutoCroppingMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AutoCroppingMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_auto_cropping_mode_supported(&mut self, value: ImageScannerAutoCroppingMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsAutoCroppingModeSupported)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_resolution(&mut self) -> RtResult<ImageScannerResolution> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinResolution)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_resolution(&mut self) -> RtResult<ImageScannerResolution> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxResolution)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_optical_resolution(&mut self) -> RtResult<ImageScannerResolution> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_OpticalResolution)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_desired_resolution(&mut self) -> RtResult<ImageScannerResolution> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DesiredResolution)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_desired_resolution(&mut self, value: ImageScannerResolution) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_DesiredResolution)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_actual_resolution(&mut self) -> RtResult<ImageScannerResolution> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ActualResolution)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_color_mode(&mut self) -> RtResult<ImageScannerColorMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultColorMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_color_mode(&mut self) -> RtResult<ImageScannerColorMode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ColorMode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_color_mode(&mut self, value: ImageScannerColorMode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ColorMode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_color_mode_supported(&mut self, value: ImageScannerColorMode) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsColorModeSupported)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_brightness(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinBrightness)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_brightness(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxBrightness)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_brightness_step(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_BrightnessStep)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_brightness(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultBrightness)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_brightness(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Brightness)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_brightness(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Brightness)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_min_contrast(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MinContrast)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_contrast(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxContrast)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_contrast_step(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ContrastStep)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_contrast(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultContrast)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_contrast(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Contrast)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_contrast(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Contrast)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScannerFlatbedConfiguration: IImageScannerFormatConfiguration}
		DEFINE_IID!(IID_IImageScannerFeederConfiguration, 1958587630, 64151, 19479, 130, 128, 64, 227, 156, 109, 204, 103);
		RT_INTERFACE!{interface IImageScannerFeederConfiguration(IImageScannerFeederConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerFeederConfiguration] {
			fn get_CanAutoDetectPageSize(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_AutoDetectPageSize(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_AutoDetectPageSize(&mut self, value: bool) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy3(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_PageSize(&mut self, out: *mut super::super::graphics::printing::PrintMediaSize) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn put_PageSize(&mut self, value: super::super::graphics::printing::PrintMediaSize) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy5(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn get_PageOrientation(&mut self, out: *mut super::super::graphics::printing::PrintOrientation) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy6(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn put_PageOrientation(&mut self, value: super::super::graphics::printing::PrintOrientation) -> ::w::HRESULT,
			fn get_PageSizeDimensions(&mut self, out: *mut super::super::foundation::Size) -> ::w::HRESULT,
			#[cfg(not(feature="windows.graphics"))] fn __Dummy8(&mut self) -> (),
			#[cfg(feature="windows.graphics")] fn IsPageSizeSupported(&mut self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation, out: *mut bool) -> ::w::HRESULT,
			fn get_MaxNumberOfPages(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn put_MaxNumberOfPages(&mut self, value: u32) -> ::w::HRESULT,
			fn get_CanScanDuplex(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Duplex(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_Duplex(&mut self, value: bool) -> ::w::HRESULT,
			fn get_CanScanAhead(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_ScanAhead(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn put_ScanAhead(&mut self, value: bool) -> ::w::HRESULT
		}}
		impl IImageScannerFeederConfiguration {
			#[inline] pub unsafe fn get_can_auto_detect_page_size(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanAutoDetectPageSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_detect_page_size(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_AutoDetectPageSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_auto_detect_page_size(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_AutoDetectPageSize)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_page_size(&mut self) -> RtResult<super::super::graphics::printing::PrintMediaSize> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PageSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_page_size(&mut self, value: super::super::graphics::printing::PrintMediaSize) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PageSize)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn get_page_orientation(&mut self) -> RtResult<super::super::graphics::printing::PrintOrientation> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PageOrientation)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn set_page_orientation(&mut self, value: super::super::graphics::printing::PrintOrientation) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_PageOrientation)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_page_size_dimensions(&mut self) -> RtResult<super::super::foundation::Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_PageSizeDimensions)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.graphics")] #[inline] pub unsafe fn is_page_size_supported(&mut self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsPageSizeSupported)(self, pageSize, pageOrientation, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_max_number_of_pages(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_MaxNumberOfPages)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_max_number_of_pages(&mut self, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_MaxNumberOfPages)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_can_scan_duplex(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanScanDuplex)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_duplex(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Duplex)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_duplex(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Duplex)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_can_scan_ahead(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CanScanAhead)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scan_ahead(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ScanAhead)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_scan_ahead(&mut self, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ScanAhead)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScannerFeederConfiguration: IImageScannerFormatConfiguration}
		DEFINE_IID!(IID_IImageScannerScanResult, 3373671629, 36919, 20040, 132, 193, 172, 9, 117, 7, 107, 197);
		RT_INTERFACE!{interface IImageScannerScanResult(IImageScannerScanResultVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerScanResult] {
			#[cfg(feature="windows.storage")] fn get_ScannedFiles(&mut self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::storage::StorageFile>) -> ::w::HRESULT
		}}
		impl IImageScannerScanResult {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_scanned_files(&mut self) -> RtResult<ComPtr<super::super::foundation::collections::IVectorView<super::super::storage::StorageFile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_ScannedFiles)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScannerScanResult: IImageScannerScanResult}
		DEFINE_IID!(IID_IImageScannerPreviewResult, 146275982, 34961, 17437, 190, 156, 23, 111, 161, 9, 200, 187);
		RT_INTERFACE!{interface IImageScannerPreviewResult(IImageScannerPreviewResultVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerPreviewResult] {
			fn get_Succeeded(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Format(&mut self, out: *mut ImageScannerFormat) -> ::w::HRESULT
		}}
		impl IImageScannerPreviewResult {
			#[inline] pub unsafe fn get_succeeded(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Succeeded)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_format(&mut self) -> RtResult<ImageScannerFormat> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Format)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScannerPreviewResult: IImageScannerPreviewResult}
		RT_ENUM! { enum ImageScannerScanSource: i32 {
			Default (ImageScannerScanSource_Default) = 0, Flatbed (ImageScannerScanSource_Flatbed) = 1, Feeder (ImageScannerScanSource_Feeder) = 2, AutoConfigured (ImageScannerScanSource_AutoConfigured) = 3,
		}}
		DEFINE_IID!(IID_IImageScanner, 1403555704, 21144, 18592, 141, 163, 128, 135, 81, 150, 101, 224);
		RT_INTERFACE!{interface IImageScanner(IImageScannerVtbl): IInspectable(IInspectableVtbl) [IID_IImageScanner] {
			fn get_DeviceId(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DefaultScanSource(&mut self, out: *mut ImageScannerScanSource) -> ::w::HRESULT,
			fn IsScanSourceSupported(&mut self, value: ImageScannerScanSource, out: *mut bool) -> ::w::HRESULT,
			fn get_FlatbedConfiguration(&mut self, out: *mut *mut ImageScannerFlatbedConfiguration) -> ::w::HRESULT,
			fn get_FeederConfiguration(&mut self, out: *mut *mut ImageScannerFeederConfiguration) -> ::w::HRESULT,
			fn get_AutoConfiguration(&mut self, out: *mut *mut ImageScannerAutoConfiguration) -> ::w::HRESULT,
			fn IsPreviewSupported(&mut self, scanSource: ImageScannerScanSource, out: *mut bool) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ScanPreviewToStreamAsync(&mut self, scanSource: ImageScannerScanSource, targetStream: *mut super::super::storage::streams::IRandomAccessStream, out: *mut *mut super::super::foundation::IAsyncOperation<ImageScannerPreviewResult>) -> ::w::HRESULT,
			#[cfg(feature="windows.storage")] fn ScanFilesToFolderAsync(&mut self, scanSource: ImageScannerScanSource, storageFolder: *mut super::super::storage::StorageFolder, out: *mut *mut super::super::foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32>) -> ::w::HRESULT
		}}
		impl IImageScanner {
			#[inline] pub unsafe fn get_device_id(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DeviceId)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_default_scan_source(&mut self) -> RtResult<ImageScannerScanSource> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_DefaultScanSource)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_scan_source_supported(&mut self, value: ImageScannerScanSource) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsScanSourceSupported)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_flatbed_configuration(&mut self) -> RtResult<ComPtr<ImageScannerFlatbedConfiguration>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FlatbedConfiguration)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_feeder_configuration(&mut self) -> RtResult<ComPtr<ImageScannerFeederConfiguration>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_FeederConfiguration)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_auto_configuration(&mut self) -> RtResult<ComPtr<ImageScannerAutoConfiguration>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AutoConfiguration)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_preview_supported(&mut self, scanSource: ImageScannerScanSource) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsPreviewSupported)(self, scanSource, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn scan_preview_to_stream_async(&mut self, scanSource: ImageScannerScanSource, targetStream: &super::super::storage::streams::IRandomAccessStream) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ImageScannerPreviewResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ScanPreviewToStreamAsync)(self, scanSource, targetStream as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn scan_files_to_folder_async(&mut self, scanSource: ImageScannerScanSource, storageFolder: &super::super::storage::StorageFolder) -> RtResult<ComPtr<super::super::foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ScanFilesToFolderAsync)(self, scanSource, storageFolder as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IImageScannerStatics, 3159877390, 55300, 17527, 159, 181, 185, 17, 181, 71, 56, 151);
		RT_INTERFACE!{static interface IImageScannerStatics(IImageScannerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerStatics] {
			fn FromIdAsync(&mut self, deviceId: ::w::HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ImageScanner>) -> ::w::HRESULT,
			fn GetDeviceSelector(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IImageScannerStatics {
			#[inline] pub unsafe fn from_id_async(&mut self, deviceId: &HStringArg) -> RtResult<ComPtr<super::super::foundation::IAsyncOperation<ImageScanner>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).FromIdAsync)(self, deviceId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_device_selector(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDeviceSelector)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ImageScanner: IImageScanner}
		RT_ACTIVATABLE!{IImageScannerStatics [CLSID_ImageScanner]}
		DEFINE_CLSID!(CLSID_ImageScanner = &[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,99,97,110,110,101,114,115,46,73,109,97,103,101,83,99,97,110,110,101,114,0]);
} // Windows.Devices.Scanners
} // Windows.Devices
pub mod foundation { // Windows.Foundation
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		DEFINE_IID!(IID_IClosable, 819308585, 32676, 16422, 131, 187, 215, 91, 174, 78, 169, 158);
		RT_INTERFACE!{interface IClosable(IClosableVtbl): IInspectable(IInspectableVtbl) [IID_IClosable] {
			fn Close(&mut self) -> ::w::HRESULT
		}}
		impl IClosable {
			#[inline] pub unsafe fn close(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Close)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum PropertyType: i32 {
			Empty (PropertyType_Empty) = 0, UInt8 (PropertyType_UInt8) = 1, Int16 (PropertyType_Int16) = 2, UInt16 (PropertyType_UInt16) = 3, Int32 (PropertyType_Int32) = 4, UInt32 (PropertyType_UInt32) = 5, Int64 (PropertyType_Int64) = 6, UInt64 (PropertyType_UInt64) = 7, Single (PropertyType_Single) = 8, Double (PropertyType_Double) = 9, Char16 (PropertyType_Char16) = 10, Boolean (PropertyType_Boolean) = 11, String (PropertyType_String) = 12, Inspectable (PropertyType_Inspectable) = 13, DateTime (PropertyType_DateTime) = 14, TimeSpan (PropertyType_TimeSpan) = 15, Guid (PropertyType_Guid) = 16, Point (PropertyType_Point) = 17, Size (PropertyType_Size) = 18, Rect (PropertyType_Rect) = 19, OtherType (PropertyType_OtherType) = 20, UInt8Array (PropertyType_UInt8Array) = 1025, Int16Array (PropertyType_Int16Array) = 1026, UInt16Array (PropertyType_UInt16Array) = 1027, Int32Array (PropertyType_Int32Array) = 1028, UInt32Array (PropertyType_UInt32Array) = 1029, Int64Array (PropertyType_Int64Array) = 1030, UInt64Array (PropertyType_UInt64Array) = 1031, SingleArray (PropertyType_SingleArray) = 1032, DoubleArray (PropertyType_DoubleArray) = 1033, Char16Array (PropertyType_Char16Array) = 1034, BooleanArray (PropertyType_BooleanArray) = 1035, StringArray (PropertyType_StringArray) = 1036, InspectableArray (PropertyType_InspectableArray) = 1037, DateTimeArray (PropertyType_DateTimeArray) = 1038, TimeSpanArray (PropertyType_TimeSpanArray) = 1039, GuidArray (PropertyType_GuidArray) = 1040, PointArray (PropertyType_PointArray) = 1041, SizeArray (PropertyType_SizeArray) = 1042, RectArray (PropertyType_RectArray) = 1043, OtherTypeArray (PropertyType_OtherTypeArray) = 1044,
		}}
		RT_STRUCT! { struct Point {
			X: f32, Y: f32,
		}}
		RT_STRUCT! { struct Size {
			Width: f32, Height: f32,
		}}
		RT_STRUCT! { struct Rect {
			X: f32, Y: f32, Width: f32, Height: f32,
		}}
		RT_STRUCT! { struct DateTime {
			UniversalTime: i64,
		}}
		RT_STRUCT! { struct TimeSpan {
			Duration: i64,
		}}
		DEFINE_IID!(IID_IPropertyValue, 1272349405, 30036, 16617, 154, 155, 130, 101, 78, 222, 126, 98);
		RT_INTERFACE!{interface IPropertyValue(IPropertyValueVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyValue] {
			fn get_Type(&mut self, out: *mut PropertyType) -> ::w::HRESULT,
			fn get_IsNumericScalar(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn GetUInt8(&mut self, out: *mut u8) -> ::w::HRESULT,
			fn GetInt16(&mut self, out: *mut i16) -> ::w::HRESULT,
			fn GetUInt16(&mut self, out: *mut u16) -> ::w::HRESULT,
			fn GetInt32(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn GetUInt32(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn GetInt64(&mut self, out: *mut i64) -> ::w::HRESULT,
			fn GetUInt64(&mut self, out: *mut u64) -> ::w::HRESULT,
			fn GetSingle(&mut self, out: *mut f32) -> ::w::HRESULT,
			fn GetDouble(&mut self, out: *mut f64) -> ::w::HRESULT,
			fn GetChar16(&mut self, out: *mut ::Char) -> ::w::HRESULT,
			fn GetBoolean(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn GetString(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetGuid(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn GetDateTime(&mut self, out: *mut DateTime) -> ::w::HRESULT,
			fn GetTimeSpan(&mut self, out: *mut TimeSpan) -> ::w::HRESULT,
			fn GetPoint(&mut self, out: *mut Point) -> ::w::HRESULT,
			fn GetSize(&mut self, out: *mut Size) -> ::w::HRESULT,
			fn GetRect(&mut self, out: *mut Rect) -> ::w::HRESULT,
			fn GetUInt8Array(&mut self, valueSize: *mut u32, value: *mut *mut u8) -> ::w::HRESULT,
			fn GetInt16Array(&mut self, valueSize: *mut u32, value: *mut *mut i16) -> ::w::HRESULT,
			fn GetUInt16Array(&mut self, valueSize: *mut u32, value: *mut *mut u16) -> ::w::HRESULT,
			fn GetInt32Array(&mut self, valueSize: *mut u32, value: *mut *mut i32) -> ::w::HRESULT,
			fn GetUInt32Array(&mut self, valueSize: *mut u32, value: *mut *mut u32) -> ::w::HRESULT,
			fn GetInt64Array(&mut self, valueSize: *mut u32, value: *mut *mut i64) -> ::w::HRESULT,
			fn GetUInt64Array(&mut self, valueSize: *mut u32, value: *mut *mut u64) -> ::w::HRESULT,
			fn GetSingleArray(&mut self, valueSize: *mut u32, value: *mut *mut f32) -> ::w::HRESULT,
			fn GetDoubleArray(&mut self, valueSize: *mut u32, value: *mut *mut f64) -> ::w::HRESULT,
			fn GetChar16Array(&mut self, valueSize: *mut u32, value: *mut *mut ::Char) -> ::w::HRESULT,
			fn GetBooleanArray(&mut self, valueSize: *mut u32, value: *mut *mut bool) -> ::w::HRESULT,
			fn GetStringArray(&mut self, valueSize: *mut u32, value: *mut *mut ::w::HSTRING) -> ::w::HRESULT,
			fn GetInspectableArray(&mut self, valueSize: *mut u32, value: *mut *mut *mut IInspectable) -> ::w::HRESULT,
			fn GetGuidArray(&mut self, valueSize: *mut u32, value: *mut *mut ::Guid) -> ::w::HRESULT,
			fn GetDateTimeArray(&mut self, valueSize: *mut u32, value: *mut *mut DateTime) -> ::w::HRESULT,
			fn GetTimeSpanArray(&mut self, valueSize: *mut u32, value: *mut *mut TimeSpan) -> ::w::HRESULT,
			fn GetPointArray(&mut self, valueSize: *mut u32, value: *mut *mut Point) -> ::w::HRESULT,
			fn GetSizeArray(&mut self, valueSize: *mut u32, value: *mut *mut Size) -> ::w::HRESULT,
			fn GetRectArray(&mut self, valueSize: *mut u32, value: *mut *mut Rect) -> ::w::HRESULT
		}}
		impl IPropertyValue {
			#[inline] pub unsafe fn get_type(&mut self) -> RtResult<PropertyType> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Type)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_is_numeric_scalar(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_IsNumericScalar)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint8(&mut self) -> RtResult<u8> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetUInt8)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int16(&mut self) -> RtResult<i16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetInt16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint16(&mut self) -> RtResult<u16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetUInt16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int32(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetInt32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint32(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetUInt32)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int64(&mut self) -> RtResult<i64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetInt64)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint64(&mut self) -> RtResult<u64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetUInt64)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_single(&mut self) -> RtResult<f32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetSingle)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_double(&mut self) -> RtResult<f64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetDouble)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_char16(&mut self) -> RtResult<::Char> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetChar16)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetBoolean)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_string(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetString)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_guid(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetGuid)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_date_time(&mut self) -> RtResult<DateTime> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetDateTime)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_span(&mut self) -> RtResult<TimeSpan> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetTimeSpan)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_point(&mut self) -> RtResult<Point> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetPoint)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size(&mut self) -> RtResult<Size> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetSize)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rect(&mut self) -> RtResult<Rect> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetRect)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint8_array(&mut self) -> RtResult<ComArray<u8>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetUInt8Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int16_array(&mut self) -> RtResult<ComArray<i16>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInt16Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint16_array(&mut self) -> RtResult<ComArray<u16>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetUInt16Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int32_array(&mut self) -> RtResult<ComArray<i32>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInt32Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint32_array(&mut self) -> RtResult<ComArray<u32>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetUInt32Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_int64_array(&mut self) -> RtResult<ComArray<i64>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInt64Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_uint64_array(&mut self) -> RtResult<ComArray<u64>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetUInt64Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_single_array(&mut self) -> RtResult<ComArray<f32>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSingleArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_double_array(&mut self) -> RtResult<ComArray<f64>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDoubleArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_char16_array(&mut self) -> RtResult<ComArray<::Char>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetChar16Array)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_boolean_array(&mut self) -> RtResult<ComArray<bool>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetBooleanArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_string_array(&mut self) -> RtResult<ComArray<HString>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetStringArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_inspectable_array(&mut self) -> RtResult<ComArray<IInspectable>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetInspectableArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_guid_array(&mut self) -> RtResult<ComArray<::Guid>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetGuidArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_date_time_array(&mut self) -> RtResult<ComArray<DateTime>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetDateTimeArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_time_span_array(&mut self) -> RtResult<ComArray<TimeSpan>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetTimeSpanArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_point_array(&mut self) -> RtResult<ComArray<Point>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetPointArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size_array(&mut self) -> RtResult<ComArray<Size>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetSizeArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_rect_array(&mut self) -> RtResult<ComArray<Rect>> {
				let mut valueSize = 0; let mut value = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetRectArray)(self, &mut valueSize, &mut value);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(valueSize, value)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPropertyValueStatics, 1654381512, 55602, 20468, 150, 185, 141, 150, 197, 193, 232, 88);
		RT_INTERFACE!{static interface IPropertyValueStatics(IPropertyValueStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyValueStatics] {
			fn CreateEmpty(&mut self, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt8(&mut self, value: u8, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt16(&mut self, value: i16, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt16(&mut self, value: u16, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt32(&mut self, value: i32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt32(&mut self, value: u32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt64(&mut self, value: i64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt64(&mut self, value: u64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateSingle(&mut self, value: f32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateDouble(&mut self, value: f64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateChar16(&mut self, value: ::Char, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateBoolean(&mut self, value: bool, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateString(&mut self, value: ::w::HSTRING, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInspectable(&mut self, value: *mut IInspectable, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateGuid(&mut self, value: ::Guid, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateDateTime(&mut self, value: DateTime, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateTimeSpan(&mut self, value: TimeSpan, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreatePoint(&mut self, value: Point, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateSize(&mut self, value: Size, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateRect(&mut self, value: Rect, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt8Array(&mut self, valueSize: u32, value: *mut u8, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt16Array(&mut self, valueSize: u32, value: *mut i16, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt16Array(&mut self, valueSize: u32, value: *mut u16, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt32Array(&mut self, valueSize: u32, value: *mut i32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt32Array(&mut self, valueSize: u32, value: *mut u32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInt64Array(&mut self, valueSize: u32, value: *mut i64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateUInt64Array(&mut self, valueSize: u32, value: *mut u64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateSingleArray(&mut self, valueSize: u32, value: *mut f32, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateDoubleArray(&mut self, valueSize: u32, value: *mut f64, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateChar16Array(&mut self, valueSize: u32, value: *mut ::Char, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateBooleanArray(&mut self, valueSize: u32, value: *mut bool, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateStringArray(&mut self, valueSize: u32, value: *mut ::w::HSTRING, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateInspectableArray(&mut self, valueSize: u32, value: *mut *mut IInspectable, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateGuidArray(&mut self, valueSize: u32, value: *mut ::Guid, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateDateTimeArray(&mut self, valueSize: u32, value: *mut DateTime, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateTimeSpanArray(&mut self, valueSize: u32, value: *mut TimeSpan, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreatePointArray(&mut self, valueSize: u32, value: *mut Point, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateSizeArray(&mut self, valueSize: u32, value: *mut Size, out: *mut *mut IInspectable) -> ::w::HRESULT,
			fn CreateRectArray(&mut self, valueSize: u32, value: *mut Rect, out: *mut *mut IInspectable) -> ::w::HRESULT
		}}
		impl IPropertyValueStatics {
			#[inline] pub unsafe fn create_empty(&mut self) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateEmpty)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint8(&mut self, value: u8) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt8)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int16(&mut self, value: i16) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt16)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint16(&mut self, value: u16) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt16)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int32(&mut self, value: i32) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt32)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint32(&mut self, value: u32) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt32)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int64(&mut self, value: i64) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt64)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint64(&mut self, value: u64) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt64)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_single(&mut self, value: f32) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateSingle)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_double(&mut self, value: f64) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateDouble)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_char16(&mut self, value: ::Char) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateChar16)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_boolean(&mut self, value: bool) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateBoolean)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_string(&mut self, value: &HStringArg) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateString)(self, value.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_inspectable(&mut self, value: &IInspectable) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInspectable)(self, value as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_guid(&mut self, value: ::Guid) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateGuid)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_date_time(&mut self, value: DateTime) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateDateTime)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_time_span(&mut self, value: TimeSpan) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateTimeSpan)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_point(&mut self, value: Point) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreatePoint)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_size(&mut self, value: Size) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateSize)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_rect(&mut self, value: Rect) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateRect)(self, value, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint8_array(&mut self, value: &[u8]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt8Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int16_array(&mut self, value: &[i16]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt16Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint16_array(&mut self, value: &[u16]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt16Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int32_array(&mut self, value: &[i32]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt32Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint32_array(&mut self, value: &[u32]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt32Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_int64_array(&mut self, value: &[i64]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInt64Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_uint64_array(&mut self, value: &[u64]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUInt64Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_single_array(&mut self, value: &[f32]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateSingleArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_double_array(&mut self, value: &[f64]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateDoubleArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_char16_array(&mut self, value: &[::Char]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateChar16Array)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_boolean_array(&mut self, value: &[bool]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateBooleanArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_string_array(&mut self, value: &[&HStringArg]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateStringArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_inspectable_array(&mut self, value: &[&IInspectable]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateInspectableArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_guid_array(&mut self, value: &[::Guid]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateGuidArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_date_time_array(&mut self, value: &[DateTime]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateDateTimeArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_time_span_array(&mut self, value: &[TimeSpan]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateTimeSpanArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_point_array(&mut self, value: &[Point]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreatePointArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_size_array(&mut self, value: &[Size]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateSizeArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_rect_array(&mut self, value: &[Rect]) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateRectArray)(self, value.len() as u32, value.as_ptr() as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IPropertyValueStatics [CLSID_PropertyValue]}
		DEFINE_CLSID!(CLSID_PropertyValue = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,80,114,111,112,101,114,116,121,86,97,108,117,101,0]);
		DEFINE_IID!(IID_IStringable, 2520162132, 36534, 18672, 171, 206, 193, 178, 17, 230, 39, 195);
		RT_INTERFACE!{interface IStringable(IStringableVtbl): IInspectable(IInspectableVtbl) [IID_IStringable] {
			fn ToString(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IStringable {
			#[inline] pub unsafe fn to_string(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).ToString)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncActionCompletedHandler, 2767019137, 30409, 16573, 139, 230, 177, 217, 15, 178, 10, 231);
		RT_DELEGATE!{delegate AsyncActionCompletedHandler(AsyncActionCompletedHandlerVtbl, AsyncActionCompletedHandlerImpl) [IID_AsyncActionCompletedHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncAction, asyncStatus: AsyncStatus) -> ::w::HRESULT
		}}
		impl AsyncActionCompletedHandler {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncAction, asyncStatus: AsyncStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, asyncStatus);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeferral, 3592853298, 15231, 18087, 180, 11, 79, 220, 162, 162, 198, 147);
		RT_INTERFACE!{interface IDeferral(IDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IDeferral] {
			fn Complete(&mut self) -> ::w::HRESULT
		}}
		impl IDeferral {
			#[inline] pub unsafe fn complete(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Complete)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_DeferralCompletedHandler, 3979518834, 62408, 20394, 156, 251, 71, 1, 72, 218, 56, 136);
		RT_DELEGATE!{delegate DeferralCompletedHandler(DeferralCompletedHandlerVtbl, DeferralCompletedHandlerImpl) [IID_DeferralCompletedHandler] {
			fn Invoke(&mut self) -> ::w::HRESULT
		}}
		impl DeferralCompletedHandler {
			#[inline] pub unsafe fn invoke(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IDeferralFactory, 1705110725, 16309, 18482, 140, 169, 240, 97, 178, 129, 209, 58);
		RT_INTERFACE!{static interface IDeferralFactory(IDeferralFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDeferralFactory] {
			fn Create(&mut self, handler: *mut DeferralCompletedHandler, out: *mut *mut Deferral) -> ::w::HRESULT
		}}
		impl IDeferralFactory {
			#[inline] pub unsafe fn create(&mut self, handler: &DeferralCompletedHandler) -> RtResult<ComPtr<Deferral>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class Deferral: IDeferral [IDeferralFactory] [CLSID_Deferral]}
		DEFINE_CLSID!(CLSID_Deferral = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,101,102,101,114,114,97,108,0]);
		RT_ENUM! { enum AsyncStatus: i32 {
			Canceled (AsyncStatus_Canceled) = 2, Completed (AsyncStatus_Completed) = 1, Error (AsyncStatus_Error) = 3, Started (AsyncStatus_Started) = 0,
		}}
		RT_STRUCT! { struct EventRegistrationToken {
			Value: i64,
		}}
		RT_STRUCT! { struct HResult {
			Value: i32,
		}}
		DEFINE_IID!(IID_IAsyncInfo, 54, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70);
		RT_INTERFACE!{interface IAsyncInfo(IAsyncInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncInfo] {
			fn get_Id(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn get_Status(&mut self, out: *mut AsyncStatus) -> ::w::HRESULT,
			fn get_ErrorCode(&mut self, out: *mut HResult) -> ::w::HRESULT,
			fn Cancel(&mut self) -> ::w::HRESULT,
			fn Close(&mut self) -> ::w::HRESULT
		}}
		impl IAsyncInfo {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_status(&mut self) -> RtResult<AsyncStatus> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Status)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_code(&mut self) -> RtResult<HResult> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ErrorCode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn cancel(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Cancel)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn close(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Close)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAsyncAction, 1516535814, 33850, 19881, 134, 91, 157, 38, 229, 223, 173, 123);
		RT_INTERFACE!{interface IAsyncAction(IAsyncActionVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncAction] {
			fn put_Completed(&mut self, handler: *mut AsyncActionCompletedHandler) -> ::w::HRESULT,
			fn get_Completed(&mut self, out: *mut *mut AsyncActionCompletedHandler) -> ::w::HRESULT,
			fn GetResults(&mut self) -> ::w::HRESULT
		}}
		impl IAsyncAction {
			#[inline] pub unsafe fn set_completed(&mut self, handler: &AsyncActionCompletedHandler) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Completed)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_completed(&mut self) -> RtResult<ComPtr<AsyncActionCompletedHandler>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Completed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_results(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).GetResults)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncOperationWithProgressCompletedHandler, 3898471453, 27303, 18147, 168, 226, 240, 9, 216, 64, 198, 39);
		RT_DELEGATE!{delegate AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(AsyncOperationWithProgressCompletedHandlerVtbl, AsyncOperationWithProgressCompletedHandlerImpl) [IID_AsyncOperationWithProgressCompletedHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncOperationWithProgress<TResult, TProgress>, asyncStatus: AsyncStatus) -> ::w::HRESULT
		}}
		impl<TResult: RtType, TProgress: RtType> AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncOperationWithProgress<TResult, TProgress>, asyncStatus: AsyncStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, asyncStatus);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAsyncOperationWithProgress, 3050321623, 58007, 18831, 186, 96, 2, 137, 231, 110, 35, 221);
		RT_INTERFACE!{interface IAsyncOperationWithProgress<TResult, TProgress>(IAsyncOperationWithProgressVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncOperationWithProgress] {
			fn put_Progress(&mut self, handler: *mut AsyncOperationProgressHandler<TResult, TProgress>) -> ::w::HRESULT,
			fn get_Progress(&mut self, out: *mut *mut AsyncOperationProgressHandler<TResult, TProgress>) -> ::w::HRESULT,
			fn put_Completed(&mut self, handler: *mut AsyncOperationWithProgressCompletedHandler<TResult, TProgress>) -> ::w::HRESULT,
			fn get_Completed(&mut self, out: *mut *mut AsyncOperationWithProgressCompletedHandler<TResult, TProgress>) -> ::w::HRESULT,
			fn GetResults(&mut self, out: *mut TResult::Abi) -> ::w::HRESULT
		}}
		impl<TResult: RtType, TProgress: RtType> IAsyncOperationWithProgress<TResult, TProgress> {
			#[inline] pub unsafe fn set_progress(&mut self, handler: &AsyncOperationProgressHandler<TResult, TProgress>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Progress)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_progress(&mut self) -> RtResult<ComPtr<AsyncOperationProgressHandler<TResult, TProgress>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Progress)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_completed(&mut self, handler: &AsyncOperationWithProgressCompletedHandler<TResult, TProgress>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Completed)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_completed(&mut self) -> RtResult<ComPtr<AsyncOperationWithProgressCompletedHandler<TResult, TProgress>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Completed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_results(&mut self) -> RtResult<TResult::Out> {
				let mut out = TResult::uninitialized();
				let hr = ((*self.lpVtbl).GetResults)(self, &mut out);
				if hr == ::w::S_OK { Ok(TResult::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncOperationCompletedHandler, 4242337836, 58840, 17528, 145, 90, 77, 144, 183, 75, 131, 165);
		RT_DELEGATE!{delegate AsyncOperationCompletedHandler<TResult>(AsyncOperationCompletedHandlerVtbl, AsyncOperationCompletedHandlerImpl) [IID_AsyncOperationCompletedHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncOperation<TResult>, asyncStatus: AsyncStatus) -> ::w::HRESULT
		}}
		impl<TResult: RtType> AsyncOperationCompletedHandler<TResult> {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncOperation<TResult>, asyncStatus: AsyncStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, asyncStatus);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAsyncOperation, 2680336571, 58438, 17634, 170, 97, 156, 171, 143, 99, 106, 242);
		RT_INTERFACE!{interface IAsyncOperation<TResult>(IAsyncOperationVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncOperation] {
			fn put_Completed(&mut self, handler: *mut AsyncOperationCompletedHandler<TResult>) -> ::w::HRESULT,
			fn get_Completed(&mut self, out: *mut *mut AsyncOperationCompletedHandler<TResult>) -> ::w::HRESULT,
			fn GetResults(&mut self, out: *mut TResult::Abi) -> ::w::HRESULT
		}}
		impl<TResult: RtType> IAsyncOperation<TResult> {
			#[inline] pub unsafe fn set_completed(&mut self, handler: &AsyncOperationCompletedHandler<TResult>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Completed)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_completed(&mut self) -> RtResult<ComPtr<AsyncOperationCompletedHandler<TResult>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Completed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_results(&mut self) -> RtResult<TResult::Out> {
				let mut out = TResult::uninitialized();
				let hr = ((*self.lpVtbl).GetResults)(self, &mut out);
				if hr == ::w::S_OK { Ok(TResult::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncActionWithProgressCompletedHandler, 2617417617, 52356, 17661, 172, 38, 10, 108, 78, 85, 82, 129);
		RT_DELEGATE!{delegate AsyncActionWithProgressCompletedHandler<TProgress>(AsyncActionWithProgressCompletedHandlerVtbl, AsyncActionWithProgressCompletedHandlerImpl) [IID_AsyncActionWithProgressCompletedHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncActionWithProgress<TProgress>, asyncStatus: AsyncStatus) -> ::w::HRESULT
		}}
		impl<TProgress: RtType> AsyncActionWithProgressCompletedHandler<TProgress> {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncActionWithProgress<TProgress>, asyncStatus: AsyncStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, asyncStatus);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAsyncActionWithProgress, 527282776, 59395, 18593, 149, 70, 235, 115, 83, 57, 136, 132);
		RT_INTERFACE!{interface IAsyncActionWithProgress<TProgress>(IAsyncActionWithProgressVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncActionWithProgress] {
			fn put_Progress(&mut self, handler: *mut AsyncActionProgressHandler<TProgress>) -> ::w::HRESULT,
			fn get_Progress(&mut self, out: *mut *mut AsyncActionProgressHandler<TProgress>) -> ::w::HRESULT,
			fn put_Completed(&mut self, handler: *mut AsyncActionWithProgressCompletedHandler<TProgress>) -> ::w::HRESULT,
			fn get_Completed(&mut self, out: *mut *mut AsyncActionWithProgressCompletedHandler<TProgress>) -> ::w::HRESULT,
			fn GetResults(&mut self) -> ::w::HRESULT
		}}
		impl<TProgress: RtType> IAsyncActionWithProgress<TProgress> {
			#[inline] pub unsafe fn set_progress(&mut self, handler: &AsyncActionProgressHandler<TProgress>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Progress)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_progress(&mut self) -> RtResult<ComPtr<AsyncActionProgressHandler<TProgress>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Progress)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_completed(&mut self, handler: &AsyncActionWithProgressCompletedHandler<TProgress>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Completed)(self, handler as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_completed(&mut self) -> RtResult<ComPtr<AsyncActionWithProgressCompletedHandler<TProgress>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Completed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_results(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).GetResults)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncOperationProgressHandler, 1432946946, 2731, 16922, 135, 120, 248, 206, 80, 38, 215, 88);
		RT_DELEGATE!{delegate AsyncOperationProgressHandler<TResult, TProgress>(AsyncOperationProgressHandlerVtbl, AsyncOperationProgressHandlerImpl) [IID_AsyncOperationProgressHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncOperationWithProgress<TResult, TProgress>, progressInfo: TProgress::Abi) -> ::w::HRESULT
		}}
		impl<TResult: RtType, TProgress: RtType> AsyncOperationProgressHandler<TResult, TProgress> {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncOperationWithProgress<TResult, TProgress>, progressInfo: &TProgress::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, TProgress::unwrap(progressInfo));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_AsyncActionProgressHandler, 1837385816, 3327, 17808, 174, 137, 149, 165, 165, 200, 180, 184);
		RT_DELEGATE!{delegate AsyncActionProgressHandler<TProgress>(AsyncActionProgressHandlerVtbl, AsyncActionProgressHandlerImpl) [IID_AsyncActionProgressHandler] {
			fn Invoke(&mut self, asyncInfo: *mut IAsyncActionWithProgress<TProgress>, progressInfo: TProgress::Abi) -> ::w::HRESULT
		}}
		impl<TProgress: RtType> AsyncActionProgressHandler<TProgress> {
			#[inline] pub unsafe fn invoke(&mut self, asyncInfo: &IAsyncActionWithProgress<TProgress>, progressInfo: &TProgress::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, asyncInfo as *const _ as *mut _, TProgress::unwrap(progressInfo));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IReference, 1640068870, 11621, 4576, 154, 232, 212, 133, 100, 1, 84, 114);
		RT_INTERFACE!{interface IReference<T>(IReferenceVtbl): IInspectable(IInspectableVtbl) [IID_IReference] {
			fn get_Value(&mut self, out: *mut T::Abi) -> ::w::HRESULT
		}}
		impl<T: RtType> IReference<T> {
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<T::Out> {
				let mut out = T::uninitialized();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(T::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IReferenceArray, 1640068871, 11621, 4576, 154, 232, 212, 133, 100, 1, 84, 114);
		RT_INTERFACE!{interface IReferenceArray<T>(IReferenceArrayVtbl): IInspectable(IInspectableVtbl) [IID_IReferenceArray] {
			fn get_Value(&mut self, outSize: *mut u32, out: *mut *mut T::Abi) -> ::w::HRESULT
		}}
		impl<T: RtType> IReferenceArray<T> {
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<ComArray<T>> {
				let mut outSize = 0; let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut outSize, &mut out);
				if hr == ::w::S_OK { Ok(ComArray::from_raw(outSize, out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_TypedEventHandler, 2648818996, 27361, 4576, 132, 225, 24, 169, 5, 188, 197, 63);
		RT_DELEGATE!{delegate TypedEventHandler<TSender, TResult>(TypedEventHandlerVtbl, TypedEventHandlerImpl) [IID_TypedEventHandler] {
			fn Invoke(&mut self, sender: TSender::Abi, args: TResult::Abi) -> ::w::HRESULT
		}}
		impl<TSender: RtType, TResult: RtType> TypedEventHandler<TSender, TResult> {
			#[inline] pub unsafe fn invoke(&mut self, sender: &TSender::In, args: &TResult::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, TSender::unwrap(sender), TResult::unwrap(args));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_EventHandler, 2648818997, 27361, 4576, 132, 225, 24, 169, 5, 188, 197, 63);
		RT_DELEGATE!{delegate EventHandler<T>(EventHandlerVtbl, EventHandlerImpl) [IID_EventHandler] {
			fn Invoke(&mut self, sender: *mut IInspectable, args: T::Abi) -> ::w::HRESULT
		}}
		impl<T: RtType> EventHandler<T> {
			#[inline] pub unsafe fn invoke(&mut self, sender: &IInspectable, args: &T::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, T::unwrap(args));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_STRUCT! { struct FoundationContract {
			
		}}
		DEFINE_IID!(IID_IUriRuntimeClass, 2654363223, 18610, 16736, 149, 111, 199, 56, 81, 32, 187, 252);
		RT_INTERFACE!{interface IUriRuntimeClass(IUriRuntimeClassVtbl): IInspectable(IInspectableVtbl) [IID_IUriRuntimeClass] {
			fn get_AbsoluteUri(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayUri(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Domain(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Extension(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Fragment(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Host(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Password(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Path(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Query(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_QueryParsed(&mut self, out: *mut *mut WwwFormUrlDecoder) -> ::w::HRESULT,
			fn get_RawUri(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_SchemeName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_UserName(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Port(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn get_Suspicious(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn Equals(&mut self, pUri: *mut Uri, out: *mut bool) -> ::w::HRESULT,
			fn CombineUri(&mut self, relativeUri: ::w::HSTRING, out: *mut *mut Uri) -> ::w::HRESULT
		}}
		impl IUriRuntimeClass {
			#[inline] pub unsafe fn get_absolute_uri(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AbsoluteUri)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_uri(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayUri)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_domain(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Domain)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_extension(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Extension)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_fragment(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Fragment)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_host(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Host)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_password(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Password)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_path(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Path)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_query(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Query)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_query_parsed(&mut self) -> RtResult<ComPtr<WwwFormUrlDecoder>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_QueryParsed)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_raw_uri(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_RawUri)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_scheme_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_SchemeName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_user_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_UserName)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_port(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Port)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_suspicious(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Suspicious)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn equals(&mut self, pUri: &Uri) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).Equals)(self, pUri as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn combine_uri(&mut self, relativeUri: &HStringArg) -> RtResult<ComPtr<Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CombineUri)(self, relativeUri.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WwwFormUrlDecoder: IWwwFormUrlDecoderRuntimeClass [IWwwFormUrlDecoderRuntimeClassFactory] [CLSID_WwwFormUrlDecoder]}
		DEFINE_CLSID!(CLSID_WwwFormUrlDecoder = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,87,119,119,70,111,114,109,85,114,108,68,101,99,111,100,101,114,0]);
		RT_CLASS!{class Uri: IUriRuntimeClass [IUriRuntimeClassFactory] [CLSID_Uri]}
		RT_ACTIVATABLE!{IUriEscapeStatics [CLSID_Uri]}
		DEFINE_CLSID!(CLSID_Uri = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,85,114,105,0]);
		DEFINE_IID!(IID_IUriRuntimeClassWithAbsoluteCanonicalUri, 1972213345, 8732, 18447, 163, 57, 80, 101, 102, 115, 244, 111);
		RT_INTERFACE!{interface IUriRuntimeClassWithAbsoluteCanonicalUri(IUriRuntimeClassWithAbsoluteCanonicalUriVtbl): IInspectable(IInspectableVtbl) [IID_IUriRuntimeClassWithAbsoluteCanonicalUri] {
			fn get_AbsoluteCanonicalUri(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_DisplayIri(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IUriRuntimeClassWithAbsoluteCanonicalUri {
			#[inline] pub unsafe fn get_absolute_canonical_uri(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_AbsoluteCanonicalUri)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_display_iri(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_DisplayIri)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUriEscapeStatics, 3251909306, 51236, 17490, 167, 253, 81, 43, 195, 187, 233, 161);
		RT_INTERFACE!{static interface IUriEscapeStatics(IUriEscapeStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUriEscapeStatics] {
			fn UnescapeComponent(&mut self, toUnescape: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn EscapeComponent(&mut self, toEscape: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IUriEscapeStatics {
			#[inline] pub unsafe fn unescape_component(&mut self, toUnescape: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).UnescapeComponent)(self, toUnescape.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn escape_component(&mut self, toEscape: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).EscapeComponent)(self, toEscape.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IUriRuntimeClassFactory, 1151957359, 29246, 20447, 162, 24, 3, 62, 117, 176, 192, 132);
		RT_INTERFACE!{static interface IUriRuntimeClassFactory(IUriRuntimeClassFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUriRuntimeClassFactory] {
			fn CreateUri(&mut self, uri: ::w::HSTRING, out: *mut *mut Uri) -> ::w::HRESULT,
			fn CreateWithRelativeUri(&mut self, baseUri: ::w::HSTRING, relativeUri: ::w::HSTRING, out: *mut *mut Uri) -> ::w::HRESULT
		}}
		impl IUriRuntimeClassFactory {
			#[inline] pub unsafe fn create_uri(&mut self, uri: &HStringArg) -> RtResult<ComPtr<Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateUri)(self, uri.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_relative_uri(&mut self, baseUri: &HStringArg, relativeUri: &HStringArg) -> RtResult<ComPtr<Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithRelativeUri)(self, baseUri.get(), relativeUri.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWwwFormUrlDecoderEntry, 308180017, 63096, 20110, 182, 112, 32, 169, 176, 108, 81, 45);
		RT_INTERFACE!{interface IWwwFormUrlDecoderEntry(IWwwFormUrlDecoderEntryVtbl): IInspectable(IInspectableVtbl) [IID_IWwwFormUrlDecoderEntry] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Value(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IWwwFormUrlDecoderEntry {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWwwFormUrlDecoderRuntimeClass, 3562669137, 61989, 17730, 146, 150, 14, 29, 245, 210, 84, 223);
		RT_INTERFACE!{interface IWwwFormUrlDecoderRuntimeClass(IWwwFormUrlDecoderRuntimeClassVtbl): IInspectable(IInspectableVtbl) [IID_IWwwFormUrlDecoderRuntimeClass] {
			fn GetFirstValueByName(&mut self, name: ::w::HSTRING, out: *mut ::w::HSTRING) -> ::w::HRESULT
		}}
		impl IWwwFormUrlDecoderRuntimeClass {
			#[inline] pub unsafe fn get_first_value_by_name(&mut self, name: &HStringArg) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetFirstValueByName)(self, name.get(), &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IWwwFormUrlDecoderRuntimeClassFactory, 1535929149, 9390, 16821, 161, 191, 240, 195, 213, 68, 132, 91);
		RT_INTERFACE!{static interface IWwwFormUrlDecoderRuntimeClassFactory(IWwwFormUrlDecoderRuntimeClassFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWwwFormUrlDecoderRuntimeClassFactory] {
			fn CreateWwwFormUrlDecoder(&mut self, query: ::w::HSTRING, out: *mut *mut WwwFormUrlDecoder) -> ::w::HRESULT
		}}
		impl IWwwFormUrlDecoderRuntimeClassFactory {
			#[inline] pub unsafe fn create_www_form_url_decoder(&mut self, query: &HStringArg) -> RtResult<ComPtr<WwwFormUrlDecoder>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWwwFormUrlDecoder)(self, query.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class WwwFormUrlDecoderEntry: IWwwFormUrlDecoderEntry}
		DEFINE_IID!(IID_IGetActivationFactory, 1323011810, 38621, 18855, 148, 247, 70, 7, 221, 171, 142, 60);
		RT_INTERFACE!{interface IGetActivationFactory(IGetActivationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGetActivationFactory] {
			fn GetActivationFactory(&mut self, activatableClassId: ::w::HSTRING, out: *mut *mut IInspectable) -> ::w::HRESULT
		}}
		impl IGetActivationFactory {
			#[inline] pub unsafe fn get_activation_factory(&mut self, activatableClassId: &HStringArg) -> RtResult<ComPtr<IInspectable>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetActivationFactory)(self, activatableClassId.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMemoryBufferReference, 4223982889, 9307, 4580, 175, 152, 104, 148, 35, 38, 12, 248);
		RT_INTERFACE!{interface IMemoryBufferReference(IMemoryBufferReferenceVtbl): IInspectable(IInspectableVtbl) [IID_IMemoryBufferReference] {
			fn get_Capacity(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn add_Closed(&mut self, handler: *mut TypedEventHandler<IMemoryBufferReference, IInspectable>, out: *mut EventRegistrationToken) -> ::w::HRESULT,
			fn remove_Closed(&mut self, cookie: EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IMemoryBufferReference {
			#[inline] pub unsafe fn get_capacity(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Capacity)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_closed(&mut self, handler: &TypedEventHandler<IMemoryBufferReference, IInspectable>) -> RtResult<EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_Closed)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_closed(&mut self, cookie: EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_Closed)(self, cookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMemoryBuffer, 4223982890, 9307, 4580, 175, 152, 104, 148, 35, 38, 12, 248);
		RT_INTERFACE!{interface IMemoryBuffer(IMemoryBufferVtbl): IInspectable(IInspectableVtbl) [IID_IMemoryBuffer] {
			fn CreateReference(&mut self, out: *mut *mut IMemoryBufferReference) -> ::w::HRESULT
		}}
		impl IMemoryBuffer {
			#[inline] pub unsafe fn create_reference(&mut self) -> RtResult<ComPtr<IMemoryBufferReference>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateReference)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMemoryBufferFactory, 4223982891, 9307, 4580, 175, 152, 104, 148, 35, 38, 12, 248);
		RT_INTERFACE!{static interface IMemoryBufferFactory(IMemoryBufferFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMemoryBufferFactory] {
			fn Create(&mut self, capacity: u32, out: *mut *mut MemoryBuffer) -> ::w::HRESULT
		}}
		impl IMemoryBufferFactory {
			#[inline] pub unsafe fn create(&mut self, capacity: u32) -> RtResult<ComPtr<MemoryBuffer>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, capacity, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class MemoryBuffer: IMemoryBuffer [IMemoryBufferFactory] [CLSID_MemoryBuffer]}
		DEFINE_CLSID!(CLSID_MemoryBuffer = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,77,101,109,111,114,121,66,117,102,102,101,114,0]);
		RT_STRUCT! { struct UniversalApiContract {
			
		}}
		RT_PINTERFACE!{ for AsyncActionProgressHandler<f64> => [0x44825c7c,0x0da9,0x5691,0xb2,0xb4,0x91,0x4f,0x23,0x1e,0xec,0xed] as IID_AsyncActionProgressHandler_1_System_Double }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncActionProgressHandler<super::web::syndication::TransferProgress> => [0xc1610085,0x94d0,0x5706,0x9a,0xc6,0x10,0x17,0x9d,0x7d,0xeb,0x92] as IID_AsyncActionProgressHandler_1_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for AsyncActionProgressHandler<u64> => [0x55e233ca,0xf243,0x5ae2,0x85,0x3b,0xf9,0xcc,0x7c,0x0a,0xe0,0xcf] as IID_AsyncActionProgressHandler_1_System_UInt64 }
		RT_PINTERFACE!{ for AsyncActionWithProgressCompletedHandler<f64> => [0x94d64ac6,0x4491,0x53ef,0x8b,0xe8,0x36,0x48,0x1f,0x3f,0xf1,0xe8] as IID_AsyncActionWithProgressCompletedHandler_1_System_Double }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncActionWithProgressCompletedHandler<super::web::syndication::TransferProgress> => [0xf1c031c8,0x90bf,0x5cae,0xad,0xf6,0x15,0x5b,0x4a,0xed,0xfb,0x60] as IID_AsyncActionWithProgressCompletedHandler_1_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for AsyncActionWithProgressCompletedHandler<u64> => [0xe6ff857b,0xf160,0x571a,0xa9,0x34,0x2c,0x61,0xf9,0x8c,0x86,0x2d] as IID_AsyncActionWithProgressCompletedHandler_1_System_UInt64 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<::Guid> => [0x5233899b,0xba7e,0x504f,0xbb,0x83,0xce,0xeb,0xac,0x62,0xde,0xcf] as IID_AsyncOperationCompletedHandler_1_System_Guid }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<bool> => [0xc1d3d1a2,0xae17,0x5a5f,0xb5,0xa2,0xbd,0xcc,0x88,0x44,0x88,0x9a] as IID_AsyncOperationCompletedHandler_1_System_Boolean }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IMap<HString, IInspectable>> => [0x7344f356,0x8399,0x5756,0xa2,0xf8,0xab,0xd5,0x0c,0x41,0x46,0xff] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMap_2_System_String_System_Object }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IMapView<HString, IInspectable>> => [0x89981889,0x1207,0x5ae6,0x9b,0x28,0xcc,0xc5,0x8f,0x3a,0xac,0x6e] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IMapView<HString, super::perception::spatial::SpatialAnchor>> => [0x3a950aa3,0x9c65,0x586e,0xaf,0x75,0x1a,0xcf,0x07,0x19,0x0e,0x90] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMapView_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IMapView<HString, super::storage::streams::RandomAccessStreamReference>> => [0xd4cb6b80,0x821a,0x5a7b,0x89,0x8d,0xd5,0x89,0x17,0xb3,0x1a,0x36] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMapView_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IMapView<u32, super::storage::streams::IBuffer>> => [0x92c2e4d0,0x7c25,0x596b,0x91,0x35,0x10,0xd1,0x47,0x2e,0x69,0x68] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IMapView_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IPropertySet> => [0x5075a55f,0x68ba,0x56f2,0x97,0xe6,0x9b,0x1c,0xbf,0xa2,0xc5,0xf2] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IPropertySet }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVector<HString>> => [0xfae4b396,0x97c8,0x5cc3,0xbf,0x88,0xea,0x30,0x98,0xed,0xf6,0xb2] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVector_1_System_String }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVector<super::applicationmodel::contacts::Contact>> => [0x589b0543,0xeeae,0x5ca2,0xa6,0x3b,0x76,0x01,0x0c,0x64,0xfc,0xcb] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVector_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVector<super::media::faceanalysis::DetectedFace>> => [0xb0a53153,0x2015,0x58b3,0x9d,0xd0,0xbd,0xf2,0x91,0xb8,0x56,0xb2] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVector_1_Windows_Media_FaceAnalysis_DetectedFace }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<collections::IMapView<HString, IInspectable>>> => [0xa782a13a,0x16a0,0x5326,0xb9,0x85,0xc4,0xca,0x49,0xe5,0x4e,0x77] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<HString>> => [0x7c7899be,0x5f2e,0x5bf3,0xad,0xe5,0xad,0x98,0xb7,0x72,0xc7,0xcd] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_System_String }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<IInspectable>> => [0x261a9d81,0xf58f,0x5283,0x94,0x61,0xca,0x3e,0x31,0xc1,0x12,0x3c] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::appextensions::AppExtension>> => [0xcbd3ea3b,0x1275,0x5688,0x86,0x10,0x0a,0xb1,0xf8,0x34,0x42,0xfc] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_AppExtensions_AppExtension }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::AppInfo>> => [0x07f25b6f,0xf054,0x5649,0xa5,0xce,0xb3,0x48,0xdd,0xc6,0x18,0xb6] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_AppInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::appointments::Appointment>> => [0xf626345f,0x7bfc,0x5418,0x9f,0x47,0xf1,0xd8,0x63,0x06,0xe0,0x6b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::appointments::AppointmentCalendar>> => [0xf478469b,0x9777,0x553d,0xbe,0xab,0x1b,0xb5,0xee,0xe1,0xca,0x8b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::appointments::AppointmentException>> => [0x60e2023c,0xc2a9,0x5d3c,0x86,0xb1,0xcd,0x22,0x1c,0x30,0x8a,0x5e] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentException }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::appointments::AppointmentStoreChange>> => [0x3fe84fc8,0xda80,0x5fab,0x8b,0x46,0x37,0x20,0xf7,0x64,0x63,0x45] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentStoreChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::calls::PhoneCallHistoryEntry>> => [0x1ef6a805,0xfd84,0x5756,0xa1,0x80,0x35,0x3d,0xd7,0x2d,0xb2,0x75] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::ChatConversation>> => [0xa54ad656,0x836f,0x5b3e,0xae,0xbd,0x17,0xc3,0xe9,0x8d,0xe4,0x8e] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::ChatMessage>> => [0xe136bd95,0x1eca,0x5b87,0xb2,0x33,0x9d,0x47,0xd6,0xaa,0x52,0x24] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::ChatMessageChange>> => [0x38b09bc0,0x5029,0x54de,0x91,0x65,0xdc,0xd8,0xb3,0xb9,0xb5,0x49] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::ChatMessageTransport>> => [0xa40a3b3a,0x6a96,0x5297,0x8a,0xfb,0xcb,0xb4,0x97,0xd4,0x8e,0x15] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::IChatItem>> => [0x53daad1e,0x44e7,0x5a96,0x86,0x88,0x2d,0xb7,0xc0,0x0d,0x81,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_IChatItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::chat::RcsTransport>> => [0xf6555a8d,0xa624,0x5eb4,0xa2,0xf3,0xf5,0xb1,0xc5,0xc1,0xa0,0xd2] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::Contact>> => [0x22da703a,0xc764,0x58cb,0x91,0x85,0xcc,0xfa,0xc3,0x60,0x02,0x5a] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::ContactAnnotation>> => [0x92707d1c,0x79b1,0x5200,0x81,0x1a,0x43,0x54,0x1a,0xd1,0xea,0xfa] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::ContactAnnotationList>> => [0xdd802265,0xec6f,0x5573,0xa0,0x9e,0x02,0xb1,0xf1,0x8a,0x8a,0x51] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::ContactChange>> => [0x280a5e6f,0x8fd2,0x5659,0xa7,0xcc,0x7e,0xfa,0x11,0xbb,0xce,0x46] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::ContactInformation>> => [0x059f51aa,0x64c6,0x53d5,0xbd,0x28,0x76,0xd0,0xe8,0x8e,0x3b,0x8f] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::contacts::ContactList>> => [0xeaafaa0f,0x472b,0x5cb1,0xad,0x7a,0xad,0x9f,0xd5,0x05,0xe2,0xc5] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::core::AppListEntry>> => [0x51c74372,0x9452,0x57ce,0x92,0x70,0x76,0x20,0x09,0xfb,0xfe,0x4d] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Core_AppListEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailCertificateValidationStatus>> => [0x7db1b498,0x0944,0x5b7f,0x86,0x53,0x45,0xd0,0xd3,0x5d,0xdf,0xf1] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailCertificateValidationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailFolder>> => [0x1e343987,0xcbb3,0x5260,0xa6,0x9d,0xcb,0x00,0xe1,0x7c,0x8e,0x52] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailMailbox>> => [0x478ddb6a,0xe122,0x5832,0x82,0x63,0xf3,0xd9,0x0a,0x1f,0x53,0x77] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailMailboxChange>> => [0xece9e82b,0xbbc1,0x5d32,0xb3,0x06,0x1e,0x4d,0x45,0x01,0xb6,0x8a] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMailboxChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailMessage>> => [0x128697e6,0x231f,0x5c2f,0x91,0x7d,0xc3,0x30,0xde,0x1d,0xa6,0x9b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::email::EmailRecipientResolutionResult>> => [0xafee5c98,0xf2ed,0x5bbf,0x90,0xfb,0x95,0x5f,0x8e,0x6c,0x15,0xe0] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailRecipientResolutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::resources::management::IndexedResourceCandidate>> => [0x4f2b3869,0xd059,0x5739,0x90,0x6c,0x9e,0xb2,0x72,0x9c,0x2f,0xde] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Resources_Management_IndexedResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::StartupTask>> => [0x15d40795,0x41f9,0x50d7,0xa3,0x9e,0x53,0x90,0x98,0x1a,0xf6,0x51] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::store::preview::installcontrol::AppInstallItem>> => [0xf92bfe4e,0xcf96,0x54cf,0xab,0x89,0x38,0x8c,0xa0,0x04,0xb5,0xa9] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::store::preview::StorePreviewProductInfo>> => [0x167564b0,0xc6f5,0x5143,0xb6,0x6f,0xa6,0xf9,0xca,0x69,0xe7,0xa2] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_StorePreviewProductInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::store::preview::StoreSystemFeature>> => [0x7e7946ef,0xf8f0,0x53fd,0x96,0x13,0x72,0x61,0xcb,0x35,0xda,0xf4] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_StoreSystemFeature }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::store::UnfulfilledConsumable>> => [0x0451fe11,0x6b50,0x54c1,0xb7,0x65,0xd9,0x46,0xb1,0xd5,0xc8,0x8b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_UnfulfilledConsumable }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::userdataaccounts::UserDataAccount>> => [0xdc12096d,0x7e54,0x54a2,0xab,0x99,0x28,0x0f,0x30,0xf0,0xff,0x81] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::applicationmodel::wallet::WalletItem>> => [0x9302d49e,0xdda3,0x5971,0xb4,0x8a,0xdf,0xdf,0x02,0xc5,0x72,0xaf] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::data::text::TextPhoneme>> => [0x83e14307,0x0be1,0x5560,0x8b,0xfc,0x29,0x10,0x95,0xcf,0x6d,0x30] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextPhoneme }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::adc::AdcController>> => [0x7c4038c8,0xd920,0x53c7,0xa5,0xd6,0xa9,0x76,0x07,0x0d,0x76,0x37] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::geolocation::Geoposition>> => [0x6c67a1d1,0x9441,0x5aee,0xb6,0x25,0xe3,0xc1,0xb5,0x67,0x6a,0x6d] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::gpio::GpioController>> => [0xee427f2e,0x7d37,0x558f,0x97,0x18,0x9c,0xbc,0xbf,0xf4,0x0c,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::i2c::I2cController>> => [0x3b9d7cb1,0xae0b,0x56af,0x8e,0xd5,0x68,0x56,0xb1,0xe7,0xcd,0x5b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::i2c::provider::II2cControllerProvider>> => [0x771e22ed,0xda9e,0x50be,0xb7,0x30,0xa3,0xba,0xda,0x6b,0xfb,0x25] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_I2c_Provider_II2cControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::perception::PerceptionColorFrameSource>> => [0x0a36a7af,0xda9e,0x553f,0x8d,0xc5,0xe8,0x9d,0x70,0x5b,0xb4,0x0b] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::perception::PerceptionDepthFrameSource>> => [0xc06e62a4,0x965b,0x5a29,0x97,0x32,0x8a,0xc8,0x66,0x9b,0x58,0x5e] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::perception::PerceptionInfraredFrameSource>> => [0x3aac58a8,0x4454,0x57e5,0xa9,0x0b,0x24,0x49,0xc5,0xb7,0xdf,0xe8] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::pwm::PwmController>> => [0xe72bd078,0xce02,0x55ac,0xa7,0xb9,0xab,0xd0,0x12,0x48,0xd8,0x88] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::radios::Radio>> => [0xd30691e6,0x60a0,0x59c9,0x89,0x65,0x5b,0xbe,0x28,0x2e,0x82,0x08] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::sensors::ActivitySensorReading>> => [0x179fb953,0x2d58,0x5991,0x8f,0x5b,0xac,0x64,0x21,0x9a,0x11,0x01] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::sensors::PedometerReading>> => [0x5bbff840,0x59f2,0x5108,0x92,0x05,0xa0,0xbb,0xf8,0xf9,0xba,0x68] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::smartcards::SmartCard>> => [0xbfea3fad,0x411e,0x5721,0x88,0xf5,0x92,0xc9,0xb9,0xfb,0xbe,0x14] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_SmartCards_SmartCard }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::spi::provider::ISpiControllerProvider>> => [0xe9e2ae03,0x42d6,0x5211,0xab,0x52,0x32,0x5e,0x72,0x2e,0x26,0x11] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Spi_Provider_ISpiControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::spi::SpiController>> => [0xc8afc9cb,0x6807,0x57ec,0x84,0xc9,0x9f,0x3d,0xbc,0x00,0x34,0x50] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::devices::wifi::WiFiAdapter>> => [0x92902a07,0x2f18,0x56e9,0x87,0xfb,0x24,0xfe,0x19,0xf7,0x06,0x88] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::gaming::preview::gamesenumeration::GameListEntry>> => [0xeadac44b,0x7fdd,0x5589,0xb0,0x93,0x1b,0xb7,0x3c,0xc6,0x4f,0x02] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Gaming_Preview_GamesEnumeration_GameListEntry }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::graphics::imaging::ImageStream>> => [0x6683d49c,0x9fd5,0x5b08,0x89,0x9f,0xe2,0xd7,0xdc,0x5c,0xf9,0xc4] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::management::deployment::PackageVolume>> => [0x721241c2,0x0b83,0x594a,0x9b,0x61,0xce,0x7f,0x14,0x92,0xc4,0x15] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::media::capture::frames::MediaFrameSourceGroup>> => [0xcff78a64,0xbd44,0x5638,0xaf,0x2f,0x54,0x0c,0x23,0xb3,0x22,0xe7] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::media::import::PhotoImportSource>> => [0x72cde698,0x9247,0x5053,0x8c,0xbd,0xd9,0x07,0x6b,0xfd,0xfd,0xa5] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::backgroundtransfer::DownloadOperation>> => [0x1986b372,0x0ddb,0x520c,0xb7,0x2d,0xfb,0x25,0x77,0xe9,0x9f,0xf5] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::backgroundtransfer::UploadOperation>> => [0x608a29a8,0xbbc5,0x5ea3,0xb3,0xf7,0x87,0xed,0xc4,0xe7,0xbb,0xbc] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::connectivity::AttributedNetworkUsage>> => [0x96af15cc,0xf060,0x5667,0x92,0x23,0xe0,0x54,0xd1,0x42,0x39,0xec] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_AttributedNetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::connectivity::ConnectionProfile>> => [0xc523d9dd,0x4ea6,0x5115,0x80,0xe9,0x4e,0x7a,0xd4,0x76,0x97,0x98] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::connectivity::ConnectivityInterval>> => [0xb475014c,0x95f1,0x5310,0xb5,0xd1,0xc2,0x30,0x9d,0x94,0x44,0x40] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_ConnectivityInterval }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::connectivity::NetworkUsage>> => [0xe31d7e7e,0x4173,0x5c71,0xb0,0x4b,0xa0,0x96,0x58,0x00,0x25,0x90] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_NetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::EndpointPair>> => [0x20d6faab,0x3b8e,0x5a1f,0x83,0x97,0xb0,0x1c,0xb2,0x19,0xa1,0x8d] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_EndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::proximity::PeerInformation>> => [0xecf90f2c,0xe3f4,0x5b62,0xa0,0x66,0x8b,0x9c,0x81,0x8f,0xd4,0x1a] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::networking::vpn::IVpnProfile>> => [0xdac6dd72,0xa5d1,0x56d4,0xaf,0xc4,0x98,0x9f,0x84,0xdc,0xb2,0xb3] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Vpn_IVpnProfile }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::security::authentication::identity::EnterpriseKeyCredentialRegistrationInfo>> => [0x67746c40,0xade0,0x5981,0xae,0x23,0x10,0x48,0x91,0x74,0x88,0x53] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Identity_EnterpriseKeyCredentialRegistrationInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::security::authentication::identity::provider::SecondaryAuthenticationFactorInfo>> => [0x06752d25,0xd43e,0x5d2e,0xa3,0x05,0x4e,0x15,0x76,0x84,0x6f,0xee] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::security::authentication::web::provider::WebAccountClientView>> => [0x3fa6536f,0x7e7a,0x5bc9,0xb2,0x0f,0xd8,0x66,0xca,0xca,0xf8,0x1c] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Web_Provider_WebAccountClientView }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::security::credentials::WebAccount>> => [0xc2090d8c,0x37d8,0x5c47,0x95,0x81,0x0f,0x17,0xb9,0x1a,0x0c,0xd3] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::security::cryptography::certificates::Certificate>> => [0x1896faee,0x23e2,0x59ca,0x98,0x02,0x0f,0x48,0xee,0xd9,0x8e,0xf4] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::services::store::StorePackageUpdate>> => [0xf8491bcd,0x2db5,0x58e0,0x8c,0x47,0x44,0xe6,0xeb,0x10,0xc1,0x2d] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Services_Store_StorePackageUpdate }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::bulkaccess::FileInformation>> => [0xebdb2c85,0xd27a,0x5c93,0xa1,0xb3,0x6c,0xa3,0x65,0x1a,0xda,0x5d] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_FileInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::bulkaccess::FolderInformation>> => [0x020713ec,0x604a,0x5e45,0xb0,0x3f,0x1b,0x9e,0x65,0x25,0x38,0x04] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_FolderInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::bulkaccess::IStorageItemInformation>> => [0xff163034,0xece9,0x55be,0xa6,0xf8,0x08,0xc7,0x2a,0xae,0x56,0xb4] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_IStorageItemInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::IStorageItem>> => [0x51436e75,0xace1,0x5a68,0xb2,0x60,0xf8,0x43,0xb8,0x46,0xf0,0xdb] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::search::IIndexableContent>> => [0x6a29f493,0xefb7,0x5fdb,0xa1,0x3e,0xf2,0xc2,0x8b,0x4d,0xab,0x58] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_IIndexableContent }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::StorageFile>> => [0xcb4206c5,0x0988,0x5104,0xaf,0xa9,0x25,0x3c,0x29,0x8f,0x86,0xfd] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::StorageFolder>> => [0xed2d1d9b,0x26ec,0x5be7,0xa8,0xa3,0x56,0x45,0x89,0x33,0xd2,0x5f] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::storage::StorageLibraryChange>> => [0xab9cea41,0x6df8,0x535d,0x81,0x71,0x46,0xaf,0xf1,0x87,0x15,0x8f] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::system::User>> => [0x09870533,0xf7cb,0x569c,0xb7,0x97,0xdc,0xb4,0x8d,0xeb,0xd7,0x09] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::ui::input::inking::InkRecognitionResult>> => [0xece8567f,0x8080,0x5ced,0x89,0x88,0xbb,0x03,0x64,0xc8,0x03,0xd4] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_Input_Inking_InkRecognitionResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::ui::notifications::UserNotification>> => [0x9e42ed08,0x45b3,0x5643,0xb5,0xc7,0xb2,0x16,0xf5,0x78,0x15,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_Notifications_UserNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<super::ui::startscreen::SecondaryTile>> => [0xb9d6d973,0xa089,0x550a,0x83,0xb7,0xf6,0x59,0xea,0x0d,0xea,0x04] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_StartScreen_SecondaryTile }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<collections::IVectorView<u32>> => [0x55772f29,0xda64,0x5c87,0x87,0x1c,0x07,0x43,0x37,0xa8,0x45,0x73] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Collections_IVectorView_1_System_UInt32 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<diagnostics::ErrorDetails> => [0xa6997f9d,0x7195,0x5972,0x8e,0xcd,0x1c,0x73,0xaa,0x5c,0xb3,0x12] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Diagnostics_ErrorDetails }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<HString> => [0xb79a741f,0x7fb5,0x50ae,0x9e,0x99,0x91,0x12,0x01,0xec,0x3d,0x41] as IID_AsyncOperationCompletedHandler_1_System_String }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<i32> => [0xd60cae9d,0x88cb,0x59f1,0x85,0x76,0x3f,0xba,0x44,0x79,0x6b,0xe8] as IID_AsyncOperationCompletedHandler_1_System_Int32 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<i64> => [0xd3ef5872,0x7d4e,0x59bb,0x95,0xed,0x79,0xfe,0x0f,0x0d,0xbe,0x89] as IID_AsyncOperationCompletedHandler_1_System_Int64 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<IInspectable> => [0x3f08262e,0xa2e1,0x5134,0x92,0x97,0xe9,0x21,0x1f,0x48,0x1a,0x2d] as IID_AsyncOperationCompletedHandler_1_System_Object }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<IReference<DateTime>> => [0xc4225d5e,0x1b7c,0x571e,0x9b,0x88,0x2a,0xb2,0xee,0xfa,0x8c,0x8f] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_IReference_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<IReference<TimeSpan>> => [0xe137b677,0xbfef,0x54b0,0xb2,0x00,0x95,0xc5,0xc2,0x90,0x2a,0x25] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_IReference_1_Windows_Foundation_TimeSpan }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appointments::Appointment> => [0xb640ed04,0x9331,0x5b28,0x92,0x47,0x01,0x46,0xbc,0xf5,0xb7,0x2a] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appointments::AppointmentCalendar> => [0x6d9cb651,0x5af6,0x51b0,0x9c,0xd3,0x45,0xdd,0x51,0xf1,0x79,0x49] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appointments::AppointmentConflictResult> => [0x82fb40fe,0x05b1,0x523c,0x9b,0x53,0xb3,0xdd,0x75,0x9c,0x9f,0x75] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Appointments_AppointmentConflictResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appointments::AppointmentStore> => [0xbccf6d2a,0xab72,0x5f23,0xb7,0xd5,0x4c,0x2c,0x9b,0xd4,0x5b,0x79] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Appointments_AppointmentStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appservice::AppServiceConnectionStatus> => [0xb6c6bbf2,0x72ca,0x5799,0xa6,0x51,0xd1,0x99,0x06,0x70,0x09,0x7b] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_AppService_AppServiceConnectionStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appservice::AppServiceResponse> => [0x7ea7d7ec,0xe164,0x52c3,0x8e,0x32,0xbb,0xa7,0x12,0x6d,0x90,0x28] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_AppService_AppServiceResponse }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::appservice::AppServiceResponseStatus> => [0xb824383d,0x32e0,0x5579,0x86,0x70,0xa0,0x6a,0x61,0x45,0x7f,0x20] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_AppService_AppServiceResponseStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::AlarmAccessStatus> => [0x84108017,0xa8e7,0x5449,0xb7,0x13,0xdf,0x48,0x50,0x3a,0x95,0x3e] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_AlarmAccessStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::ApplicationTriggerResult> => [0xd0065ef6,0xee9d,0x55f8,0xac,0x2b,0x53,0xa9,0x1f,0xf9,0x6d,0x2e] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_ApplicationTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::BackgroundAccessStatus> => [0x26dd26e3,0x3f47,0x5709,0xb2,0xf2,0xd6,0xd0,0xad,0x32,0x88,0xf0] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_BackgroundAccessStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::DeviceConnectionChangeTrigger> => [0x3fd5a57e,0x47e4,0x5921,0xb1,0x48,0x5c,0xb5,0x86,0x16,0x6c,0xa8] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_DeviceConnectionChangeTrigger }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::DeviceTriggerResult> => [0xd5aa9506,0x1464,0x57d4,0x85,0x9d,0x7e,0xe9,0xb2,0x6c,0xb1,0xf9] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_DeviceTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::background::MediaProcessingTriggerResult> => [0x3814c6a5,0x2ad1,0x5875,0xbe,0xd5,0x50,0x31,0xcd,0x1f,0x50,0xa2] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Background_MediaProcessingTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::calls::PhoneCallHistoryEntry> => [0x3234244b,0xabee,0x561d,0xb2,0x47,0x79,0xb8,0x32,0x82,0x20,0x55] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::calls::PhoneCallHistoryStore> => [0x226a138b,0x79ea,0x56d3,0xad,0xc2,0xa4,0x0d,0xb8,0xd8,0xc9,0xb0] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Calls_PhoneCallHistoryStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::calls::VoipPhoneCallResourceReservationStatus> => [0x7a27b20f,0x647a,0x53fc,0x80,0xf0,0xa7,0x9d,0x08,0x3c,0xe5,0x31] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Calls_VoipPhoneCallResourceReservationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatCapabilities> => [0xce2d035c,0x7686,0x56bd,0xa2,0xca,0x19,0x47,0x35,0xfd,0x86,0x17] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatCapabilities }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatConversation> => [0x0b9c15f1,0x1871,0x50c5,0x86,0xde,0x6e,0x61,0x4d,0x59,0x3c,0x57] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatMessage> => [0x2704edec,0x009d,0x5abb,0xa7,0x18,0x76,0x77,0x18,0x15,0x8d,0x88] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatMessageStore> => [0xa9174f86,0x1fc7,0x50f4,0x8d,0x7e,0x10,0x3d,0x3f,0xd6,0xe5,0xa3] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatMessageStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatMessageTransport> => [0x69dc85b1,0xba0b,0x57d3,0xb7,0xc3,0x61,0x8e,0x01,0x56,0xf8,0xcb] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::ChatSyncManager> => [0x5b3512cc,0x8528,0x5e87,0xb0,0x61,0x1b,0x98,0x2a,0x64,0x7f,0xc4] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_ChatSyncManager }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::chat::RcsTransport> => [0x7851a9c5,0x1467,0x5c7d,0xaf,0x74,0x57,0xec,0x6b,0xd3,0x34,0x17] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::Contact> => [0xa1d09bee,0xc181,0x5419,0xbd,0x14,0x82,0x23,0xb9,0x5f,0x29,0xa1] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactAnnotation> => [0x23c8c9ed,0x8920,0x5d9e,0xb0,0x52,0xc3,0x5e,0x31,0xfc,0x23,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactAnnotationList> => [0xb2478ee7,0xdc89,0x5b7d,0xb4,0xa3,0xb3,0xbe,0x29,0x52,0x20,0x9f] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactAnnotationStore> => [0x558f6e19,0x2d4e,0x5a4a,0x8c,0x58,0x38,0x73,0xd6,0x23,0xb1,0xd4] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactAnnotationStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactBatch> => [0xdc49c74d,0x1ac7,0x5754,0x82,0xe9,0x25,0x18,0x0c,0x4d,0xd8,0x88] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactInformation> => [0xc94b8021,0x508b,0x589b,0x93,0xb3,0x25,0x56,0xcb,0xc7,0x3a,0x2f] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactList> => [0xd4678af2,0x2cc4,0x5890,0xb3,0xa2,0x03,0xa5,0xab,0x7b,0xb8,0xf8] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::contacts::ContactStore> => [0xd123e7f2,0x0b5b,0x590a,0xb2,0x34,0xa1,0x21,0xac,0x1e,0x0b,0xab] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Contacts_ContactStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::datatransfer::DataPackage> => [0xa93a3b99,0xe946,0x57ce,0xaa,0xd9,0xc2,0x3d,0x13,0x8c,0x35,0x3e] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_DataTransfer_DataPackage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::datatransfer::DataPackageOperation> => [0xadd21d46,0x17df,0x5a43,0xa6,0x85,0x32,0x62,0xfc,0xe8,0x46,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_DataTransfer_DataPackageOperation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailConversation> => [0x0294c89d,0x8d98,0x5342,0xb8,0x2f,0x01,0x10,0x24,0x15,0xc8,0x70] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailConversationBatch> => [0xf1406083,0x2a75,0x5726,0xba,0x48,0x90,0xe3,0x2e,0xad,0xd7,0xfa] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailConversationBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailFolder> => [0xf1b66ef7,0x0525,0x5da5,0xa3,0xd6,0xb2,0x5b,0x3f,0x53,0x3a,0xa1] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailItemCounts> => [0x02c54220,0xded8,0x5495,0x84,0x1d,0xd4,0x32,0xc8,0x79,0xb8,0x26] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailItemCounts }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMailbox> => [0x4d5f57df,0xe0dc,0x5cf5,0xb2,0xe5,0xfa,0x1e,0x5c,0x00,0x06,0xfa] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMailboxAutoReplySettings> => [0xdfc1275a,0xc7b0,0x5fe4,0x93,0x70,0x32,0xb9,0x4a,0xd0,0xba,0x8e] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMailboxAutoReplySettings }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMailboxCreateFolderResult> => [0x929f0fda,0xf350,0x55be,0x85,0x55,0xe9,0x8d,0x81,0xea,0xf1,0xa5] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMailboxCreateFolderResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMailboxDeleteFolderStatus> => [0x52604da6,0x485b,0x5445,0x8e,0x6f,0x64,0xcc,0x13,0x05,0x60,0x45] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMailboxDeleteFolderStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMailboxEmptyFolderStatus> => [0x50333005,0xdaed,0x567e,0xbb,0x88,0xb1,0xbc,0x46,0x63,0xb0,0x75] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMailboxEmptyFolderStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMessage> => [0x69d11d1e,0xf0bb,0x5f1b,0xac,0xb5,0x12,0x0c,0x26,0xfe,0xbd,0xed] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailMessageBatch> => [0xb6674195,0x87f8,0x5575,0x91,0x08,0x9c,0x56,0x21,0xd5,0x29,0xb1] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailMessageBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::email::EmailStore> => [0xddb761d3,0x71b8,0x5c4b,0xad,0x8b,0x1e,0x65,0x22,0x66,0x49,0x21] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Email_EmailStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::extendedexecution::ExtendedExecutionResult> => [0x873c5c7a,0xc638,0x5a33,0x9b,0x03,0x21,0x5c,0x72,0x47,0x16,0x63] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_ExtendedExecution_ExtendedExecutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::extendedexecution::foreground::ExtendedExecutionForegroundResult> => [0x07e1dc01,0x18ba,0x596a,0xb7,0x45,0x79,0xf9,0xcd,0xe4,0x4c,0xcc] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_ExtendedExecution_Foreground_ExtendedExecutionForegroundResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::socialinfo::provider::SocialDashboardItemUpdater> => [0x33cfd9aa,0x6c3c,0x50df,0xbb,0xc8,0x34,0xc2,0x2a,0x0e,0x5b,0x6b] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_SocialInfo_Provider_SocialDashboardItemUpdater }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::socialinfo::provider::SocialFeedUpdater> => [0x0b227474,0x80c0,0x5f33,0x9f,0xf9,0x23,0x44,0x03,0xab,0xd6,0xfa] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_SocialInfo_Provider_SocialFeedUpdater }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::StartupTask> => [0x741f7697,0x2452,0x5c80,0x83,0xc6,0x3b,0x6f,0x82,0x2b,0x90,0x4c] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::StartupTaskState> => [0x70a0bf67,0x19e8,0x5a86,0xa3,0x2e,0x3c,0x98,0x63,0x82,0x5a,0x04] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_StartupTaskState }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::FulfillmentResult> => [0x8775acc9,0xb9ae,0x5cce,0x89,0x5c,0x97,0x1b,0xf9,0x27,0x08,0x92] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_FulfillmentResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::licensemanagement::LicenseSatisfactionResult> => [0x936e8471,0x252f,0x5339,0x89,0xc3,0x94,0x28,0x41,0x20,0x86,0xca] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::ListingInformation> => [0xfdf83922,0x762e,0x57dc,0xb7,0x21,0xc7,0x2e,0xe5,0x68,0xfd,0x96] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_ListingInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::preview::installcontrol::AppInstallItem> => [0xa85c1ceb,0x0e8c,0x5422,0xb2,0xef,0xad,0x48,0xed,0x33,0x87,0x06] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::preview::StorePreviewPurchaseResults> => [0xb1ea16e7,0x8268,0x51ff,0x81,0x29,0xdc,0xef,0xd4,0x93,0xf3,0x5f] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_Preview_StorePreviewPurchaseResults }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::store::PurchaseResults> => [0x24b6922a,0xfdb1,0x5003,0xae,0x89,0xc8,0xbf,0x16,0xca,0x01,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Store_PurchaseResults }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::userdataaccounts::systemaccess::DeviceAccountConfiguration> => [0xcbee2c48,0xe3ed,0x5ebd,0xa4,0xae,0x56,0x58,0x33,0x88,0xa4,0x9a] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_UserDataAccounts_SystemAccess_DeviceAccountConfiguration }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::userdataaccounts::UserDataAccount> => [0xab92e426,0x2ac6,0x5ffb,0x88,0xca,0xcb,0xdd,0x91,0xdf,0x39,0x27] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::userdataaccounts::UserDataAccountStore> => [0x264c2ca9,0x29b4,0x5035,0xb4,0x60,0x8c,0x8d,0x0e,0x8f,0xbc,0xd9] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccountStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::voicecommands::VoiceCommand> => [0x1024f849,0xb4a1,0x52e6,0xb7,0x71,0x6d,0x2f,0x08,0xc3,0x0e,0x63] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_VoiceCommands_VoiceCommand }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::voicecommands::VoiceCommandConfirmationResult> => [0xf5244cb8,0xf912,0x50c9,0xb2,0x18,0xd7,0xa0,0x40,0x39,0x71,0xaa] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandConfirmationResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::voicecommands::VoiceCommandDisambiguationResult> => [0x46b96890,0x2942,0x5564,0x82,0xd8,0x31,0xa4,0x85,0x1b,0xd7,0xb8] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandDisambiguationResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::wallet::system::WalletItemSystemStore> => [0xfe76bd86,0x3570,0x5d56,0x93,0x2e,0xa6,0xfb,0x80,0x93,0xa5,0x57] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Wallet_System_WalletItemSystemStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::wallet::WalletItem> => [0x88b0349f,0x503d,0x5786,0xa2,0x67,0x55,0xbb,0x37,0xa8,0xa1,0xb1] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::applicationmodel::wallet::WalletItemStore> => [0x5334975e,0x205a,0x5b6c,0x96,0xfd,0x89,0x6f,0xb9,0x39,0x49,0xbd] as IID_AsyncOperationCompletedHandler_1_Windows_ApplicationModel_Wallet_WalletItemStore }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::data::pdf::PdfDocument> => [0x8d4950b3,0x629d,0x5d7d,0x84,0xcc,0x04,0xc0,0xdc,0xf7,0x94,0x2b] as IID_AsyncOperationCompletedHandler_1_Windows_Data_Pdf_PdfDocument }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::data::xml::dom::XmlDocument> => [0x5eef7817,0x93dd,0x5c0b,0x9e,0x5a,0xeb,0x49,0x04,0x08,0xf3,0xa9] as IID_AsyncOperationCompletedHandler_1_Windows_Data_Xml_Dom_XmlDocument }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::adc::AdcController> => [0xbaf66488,0x202f,0x5d51,0xb0,0x5e,0x18,0x60,0x6c,0x46,0xb8,0x08] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::alljoyn::AllJoynAboutDataView> => [0xba2da2f5,0xf9b0,0x5c66,0x8f,0xc9,0x7d,0x43,0x7a,0x67,0xf2,0x8a] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_AllJoyn_AllJoynAboutDataView }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::alljoyn::AllJoynServiceInfo> => [0xffb22299,0xa9c9,0x5c2a,0xac,0xe3,0x0c,0xd0,0xa6,0xdd,0x10,0x39] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_AllJoyn_AllJoynServiceInfo }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::alljoyn::AllJoynSession> => [0x52490f64,0xc98f,0x5019,0x83,0x61,0xb2,0xa3,0xe1,0x67,0x9f,0x27] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_AllJoyn_AllJoynSession }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::BluetoothDevice> => [0xb2e8cdd1,0x66aa,0x5892,0x85,0xa3,0x8f,0x0b,0x16,0x5e,0x43,0xfc] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_BluetoothDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::BluetoothLEDevice> => [0x9156b79f,0xc54a,0x5277,0x8f,0x8b,0xd2,0xcc,0x43,0xc7,0xe0,0x04] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_BluetoothLEDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::genericattributeprofile::GattCommunicationStatus> => [0x2154117a,0x978d,0x59db,0x99,0xcf,0x6b,0x69,0x0c,0xb3,0x38,0x9b] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCommunicationStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::genericattributeprofile::GattDeviceService> => [0x2dbcf64a,0x262b,0x5708,0xad,0xb1,0xc3,0xb8,0x75,0x0b,0xd6,0x80] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::genericattributeprofile::GattReadClientCharacteristicConfigurationDescriptorResult> => [0x98f9a6f3,0x4d29,0x5351,0x8b,0x12,0x75,0x1d,0xc9,0x77,0xa3,0x31] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattReadClientCharacteristicConfigurationDescriptorResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::genericattributeprofile::GattReadResult> => [0xd8992aa0,0xeac2,0x55b7,0x92,0xc5,0x89,0x48,0x86,0xbe,0xb0,0xca] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattReadResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::rfcomm::RfcommDeviceService> => [0x5c772518,0x442f,0x58ed,0x80,0xcb,0x53,0x8d,0x34,0xb8,0x82,0x95] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::rfcomm::RfcommDeviceServicesResult> => [0x522c25d1,0x866b,0x5de4,0xbd,0x8e,0x1f,0xeb,0x5a,0xe6,0x0d,0x47] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceServicesResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::bluetooth::rfcomm::RfcommServiceProvider> => [0x446a7f50,0x8f2e,0x51f0,0xae,0xbb,0x1b,0xc3,0xd1,0x92,0x90,0x5f] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Bluetooth_Rfcomm_RfcommServiceProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::custom::CustomDevice> => [0x1fdd39b0,0xe0e5,0x5c59,0xb2,0x7d,0xa5,0x49,0xb1,0x07,0x5c,0xe9] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Custom_CustomDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DeviceAccessStatus> => [0xee154d83,0x805b,0x53e8,0x84,0x69,0x90,0x71,0x50,0x36,0xd0,0x13] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DeviceAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DeviceInformation> => [0xbb483df2,0x7bb6,0x5923,0xa2,0x8d,0x83,0x42,0xec,0x30,0x04,0x6b] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DeviceInformationCollection> => [0x4a458732,0x527e,0x5c73,0x9a,0x68,0xa7,0x3d,0xa3,0x70,0xf7,0x82] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DeviceInformationCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DevicePairingResult> => [0x7ee0247f,0x5f57,0x5cb2,0xb4,0x0e,0x18,0xb5,0xa2,0x11,0xd6,0xc3] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DevicePairingResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DeviceThumbnail> => [0x86d455b2,0xd795,0x554c,0x9c,0x31,0xbf,0x65,0x39,0x34,0x9c,0x19] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DeviceThumbnail }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::DeviceUnpairingResult> => [0x9bbe6eb9,0xdb2d,0x5160,0xa2,0x0c,0xf0,0xc2,0x65,0xf2,0x0d,0x8e] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_DeviceUnpairingResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::pnp::PnpObject> => [0x9d615463,0x6879,0x521f,0x8e,0x97,0xe6,0x6d,0x3d,0xdb,0xc9,0x5e] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::enumeration::pnp::PnpObjectCollection> => [0x811d834c,0xa15e,0x5522,0xb7,0xf4,0xe5,0x30,0x04,0xfc,0x58,0xff] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Enumeration_Pnp_PnpObjectCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::geolocation::GeolocationAccessStatus> => [0xf3524c93,0xe5c7,0x5b88,0xbe,0xdb,0xd3,0xe6,0x37,0xcf,0xf2,0x71] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Geolocation_GeolocationAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::geolocation::Geopoint> => [0x4b5f2f60,0x19b1,0x5566,0x9d,0xf6,0x92,0xa4,0x22,0x35,0xcb,0xf9] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Geolocation_Geopoint }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::geolocation::Geoposition> => [0x7668a704,0x244e,0x5e12,0x8d,0xcb,0x92,0xa3,0x29,0x9e,0xba,0x26] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::gpio::GpioController> => [0x370167c0,0x0f7b,0x5e77,0x9b,0xae,0xd3,0x50,0x89,0xa3,0xdb,0x75] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::humaninterfacedevice::HidDevice> => [0xb0e8e149,0x0cb6,0x55a7,0xbc,0xc1,0xd9,0x96,0x32,0x4d,0x65,0xc4] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_HumanInterfaceDevice_HidDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::humaninterfacedevice::HidFeatureReport> => [0xdb643555,0x3d16,0x57fe,0xb7,0xef,0x2b,0xdb,0xd7,0x19,0xfd,0xbf] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_HumanInterfaceDevice_HidFeatureReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::humaninterfacedevice::HidInputReport> => [0x01c83770,0x03ab,0x5576,0x98,0xb4,0x8d,0x75,0xce,0x1a,0x98,0x85] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_HumanInterfaceDevice_HidInputReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::i2c::I2cController> => [0x6ff64b72,0xa5aa,0x5986,0xb5,0x63,0x27,0x61,0x2a,0xfb,0x37,0x3c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::i2c::I2cDevice> => [0x2df5bb6a,0x5e73,0x5ae3,0xa0,0xb2,0x22,0xe1,0xc9,0xd8,0xef,0x4d] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_I2c_I2cDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::lights::Lamp> => [0x191a8c6e,0x60dd,0x5a21,0xa5,0x3c,0xbf,0x3f,0x94,0x0a,0x1d,0xde] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Lights_Lamp }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::midi::IMidiOutPort> => [0xeed37805,0x2a49,0x59b4,0xb4,0xd4,0x11,0x88,0xc6,0x81,0x91,0x22] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Midi_IMidiOutPort }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::midi::MidiInPort> => [0x6c090fb2,0x8099,0x558f,0x8a,0x92,0x9a,0x8e,0xa8,0x06,0xe6,0xfb] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Midi_MidiInPort }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::midi::MidiSynthesizer> => [0x5d716335,0xd087,0x516f,0xad,0x0a,0x63,0xf6,0x1c,0xbc,0xf3,0x42] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Midi_MidiSynthesizer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionColorFrameSource> => [0x3b56acc2,0xe275,0x54fb,0xbe,0x08,0x9f,0xdc,0x8f,0x1a,0x1e,0x10] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionDepthCorrelatedCameraIntrinsics> => [0xf396602a,0x3d8d,0x5fd5,0x99,0xe3,0x1d,0x36,0x30,0xbe,0x59,0x38] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionDepthCorrelatedCameraIntrinsics }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionDepthCorrelatedCoordinateMapper> => [0x48deeda0,0x684d,0x51e6,0xb0,0x7c,0xd2,0x34,0xd1,0x00,0x6b,0xfc] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionDepthCorrelatedCoordinateMapper }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionDepthFrameSource> => [0xb48cb886,0x3476,0x58d9,0xb7,0x6d,0xfd,0xa6,0xb3,0xe8,0x1f,0x54] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionFrameSourceAccessStatus> => [0x62744ea4,0x3447,0x5722,0xab,0x5e,0x02,0x56,0x7b,0x4f,0xce,0xeb] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionFrameSourceAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionFrameSourcePropertyChangeResult> => [0x3a06099c,0xdba6,0x58a5,0x84,0x64,0xe2,0x32,0x68,0x96,0x84,0x1a] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionFrameSourcePropertyChangeResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::perception::PerceptionInfraredFrameSource> => [0xa8d4cd8e,0xb210,0x54f7,0xae,0x2b,0x77,0x70,0xe1,0x9b,0x3e,0x36] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::BarcodeScanner> => [0x8d8abf39,0x99dd,0x50a4,0xaa,0x7c,0x2f,0x73,0x01,0xb5,0xca,0x9c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_BarcodeScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::CashDrawer> => [0x57836710,0xf186,0x5636,0x89,0x1d,0xf8,0xc5,0x39,0x8e,0xa6,0xdf] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_CashDrawer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::ClaimedBarcodeScanner> => [0xff72ba2d,0xf3c4,0x5abe,0xbb,0xce,0x53,0x15,0x04,0x49,0xb6,0x37] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_ClaimedBarcodeScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::ClaimedCashDrawer> => [0xe68c3736,0xfde7,0x5cfb,0xb2,0x2f,0x92,0x11,0x97,0x23,0xe7,0x29] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_ClaimedCashDrawer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::ClaimedMagneticStripeReader> => [0x946c2d64,0x22d4,0x552d,0xab,0xfb,0x9e,0xb3,0x41,0xbd,0x67,0xf3] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_ClaimedMagneticStripeReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::ClaimedPosPrinter> => [0x01eb0dc3,0x3c30,0x5eea,0x9f,0xce,0xef,0xb3,0x98,0xe0,0xbe,0x34] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_ClaimedPosPrinter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::MagneticStripeReader> => [0x32c55f7b,0x8ee3,0x555d,0x99,0x8b,0x78,0xc9,0x8a,0xa9,0x62,0x7b] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_MagneticStripeReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pointofservice::PosPrinter> => [0x5e8dbbc8,0x8b60,0x5881,0x8b,0x6e,0xf6,0x99,0xb4,0x94,0x9d,0xba] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_PointOfService_PosPrinter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::power::Battery> => [0x97f82115,0x3822,0x507b,0x82,0xe6,0x27,0x77,0xb3,0x36,0xe9,0x8e] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Power_Battery }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::printers::Print3DDevice> => [0x8d4b123f,0x4343,0x5195,0xbb,0xc9,0xb9,0x9e,0x95,0x6e,0x05,0x7f] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Printers_Print3DDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::pwm::PwmController> => [0x5fc68e9f,0xffff,0x5d53,0xba,0x21,0x9c,0x33,0xef,0x56,0xb2,0x40] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::radios::Radio> => [0x8a5c7e3a,0x80e2,0x585b,0x86,0x30,0x7a,0x8e,0x77,0x7f,0x03,0x54] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::radios::RadioAccessStatus> => [0xbd248e73,0xf05f,0x574c,0xae,0x3d,0x9b,0x95,0xc4,0xbf,0x28,0x2a] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Radios_RadioAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::scanners::ImageScanner> => [0xb35ad6b4,0x0da0,0x5241,0x87,0xff,0xee,0xf3,0xa1,0x88,0x32,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Scanners_ImageScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::scanners::ImageScannerPreviewResult> => [0xc054a410,0xac3c,0x5353,0xb1,0xee,0xe8,0x5e,0x78,0xfa,0xf3,0xf1] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Scanners_ImageScannerPreviewResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sensors::ActivitySensor> => [0xfb0594f4,0x93d9,0x5c2f,0xb8,0xeb,0x90,0xf1,0xe9,0x25,0x8f,0xdc] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sensors_ActivitySensor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sensors::ActivitySensorReading> => [0xadc48d5d,0xb343,0x5a58,0x84,0x54,0x6e,0x2b,0xc2,0xe0,0x47,0x5c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sensors::custom::CustomSensor> => [0x808b62d7,0x6e02,0x5680,0xa5,0x9e,0x11,0x8a,0x98,0xa4,0xe7,0x0f] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sensors_Custom_CustomSensor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sensors::Pedometer> => [0xa62dbe4e,0x51de,0x5a13,0xba,0x21,0xe7,0x6d,0xf3,0xbc,0x13,0x96] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sensors_Pedometer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::serialcommunication::SerialDevice> => [0x84a34b33,0x06fc,0x5e63,0x8e,0xe2,0xea,0xb4,0xff,0x69,0xac,0xb7] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SerialCommunication_SerialDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardChallengeContext> => [0x96b172f6,0xdedb,0x5f3e,0xaf,0x90,0x7b,0x0f,0x10,0x21,0x93,0x52] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardChallengeContext }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardConnection> => [0xc71f00e6,0xaf26,0x5e5c,0x91,0x3d,0x0e,0xfe,0xb7,0xd0,0x8e,0xf7] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardConnection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardProvisioning> => [0x7a2e58dc,0x22ee,0x5cb8,0x83,0xcc,0xa7,0xa6,0x1b,0x9d,0xcd,0x2c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardProvisioning }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardReader> => [0x20d3244d,0x375a,0x5f7d,0x89,0x44,0x16,0x4f,0xdf,0xed,0x42,0x39] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardReaderStatus> => [0x3d7e6ea9,0xe739,0x555c,0x9c,0x02,0x07,0x39,0x6c,0x53,0x21,0xf5] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardReaderStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::smartcards::SmartCardStatus> => [0xbdaf4a41,0x3b4a,0x56b0,0xae,0xec,0xfe,0xe7,0x1c,0xc7,0xf3,0x28] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_SmartCards_SmartCardStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sms::ISmsMessage> => [0x4e6c4c86,0xebe6,0x55d9,0xad,0xc0,0xfe,0xcc,0x38,0xc8,0x2a,0xa2] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sms_ISmsMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sms::SmsDevice> => [0x44aa5484,0x43d0,0x5893,0xa4,0xee,0x7d,0xb0,0x01,0x13,0xae,0x60] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sms_SmsDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::sms::SmsSendMessageResult> => [0xc7d5c6fe,0x9206,0x5eb1,0xab,0xc1,0xc1,0xbc,0x21,0x80,0x4e,0xeb] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Sms_SmsSendMessageResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::spi::SpiController> => [0x5e94d949,0xa844,0x5b25,0xa3,0xcc,0xaf,0xab,0xeb,0x18,0xc1,0xd2] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::spi::SpiDevice> => [0xa88a28ba,0x6966,0x55e7,0x8c,0x81,0x7c,0x65,0xf7,0x4e,0x39,0xc0] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Spi_SpiDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::usb::UsbDevice> => [0x7331254f,0x6caf,0x587d,0x9c,0x2a,0x01,0x8c,0x66,0xd3,0x12,0xdb] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_Usb_UsbDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifi::WiFiAccessStatus> => [0x65e889ca,0xf6c9,0x5c75,0xbe,0xf9,0x05,0xab,0x88,0xa4,0x9a,0x54] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFi_WiFiAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifi::WiFiAdapter> => [0x35362f75,0x6aae,0x560d,0xb3,0xd0,0x3f,0xae,0x9c,0x72,0x60,0xa8] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifi::WiFiConnectionResult> => [0xf380eb8d,0x1e52,0x5350,0xa2,0x88,0x86,0x1c,0x96,0x3a,0x84,0xf0] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFi_WiFiConnectionResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifidirect::services::WiFiDirectService> => [0xf505a3c8,0x4837,0x5e0e,0x8a,0x4d,0x1e,0x2a,0xf5,0x47,0x7e,0x5c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFiDirect_Services_WiFiDirectService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifidirect::services::WiFiDirectServiceProvisioningInfo> => [0x94cb9568,0x040a,0x5186,0xa3,0xc9,0x52,0x68,0x0e,0xe1,0x79,0x84] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceProvisioningInfo }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifidirect::services::WiFiDirectServiceSession> => [0xb29de711,0x60b8,0x59da,0x8f,0x4d,0xfc,0x79,0xd8,0xcc,0xd4,0x22] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSession }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::devices::wifidirect::WiFiDirectDevice> => [0xd34abe17,0xfb19,0x57be,0xbc,0x41,0x0e,0xb8,0x3d,0xea,0x15,0x1c] as IID_AsyncOperationCompletedHandler_1_Windows_Devices_WiFiDirect_WiFiDirectDevice }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::input::forcefeedback::ForceFeedbackLoadEffectResult> => [0xf8220a41,0xf738,0x51e8,0x89,0xba,0x76,0xbb,0xd6,0x61,0x58,0xcb] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_Input_ForceFeedback_ForceFeedbackLoadEffectResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::xboxlive::storage::GameSaveBlobGetResult> => [0x9d96282c,0xb6ab,0x5cd3,0x99,0x1b,0xa3,0x58,0xc5,0x31,0xbc,0xb6] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::xboxlive::storage::GameSaveBlobInfoGetResult> => [0x9331e53a,0xa414,0x51e7,0xbf,0xbc,0x77,0x84,0xdf,0x83,0xdc,0x8e] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobInfoGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::xboxlive::storage::GameSaveContainerInfoGetResult> => [0x05f86a80,0xbe5b,0x5e7e,0xb9,0x77,0x82,0x57,0xc5,0xe4,0x8a,0xcc] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_XboxLive_Storage_GameSaveContainerInfoGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::xboxlive::storage::GameSaveOperationResult> => [0xee53e64f,0x5319,0x56fd,0xa2,0x8a,0x2c,0x47,0x4f,0xc4,0x2e,0x48] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_XboxLive_Storage_GameSaveOperationResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::gaming::xboxlive::storage::GameSaveProviderGetResult> => [0x7617548d,0x8e60,0x50cb,0xa1,0x1e,0x12,0x0f,0xa2,0x08,0x2e,0x5b] as IID_AsyncOperationCompletedHandler_1_Windows_Gaming_XboxLive_Storage_GameSaveProviderGetResult }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::BitmapDecoder> => [0xbb6514f2,0x3cfb,0x566f,0x82,0xbc,0x60,0xaa,0xbd,0x30,0x2d,0x53] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_BitmapDecoder }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::BitmapEncoder> => [0x5df1afc5,0x478d,0x55dd,0xb3,0x17,0x02,0x42,0x74,0x06,0x2a,0x0d] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_BitmapEncoder }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::BitmapFrame> => [0x2817455a,0x983f,0x5a06,0x9f,0xe4,0xfb,0x96,0x37,0x68,0x43,0x20] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_BitmapFrame }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::BitmapPropertySet> => [0xa8325bd7,0xa3be,0x5881,0x9f,0xa7,0x04,0xce,0xef,0xb9,0xdc,0x2f] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_BitmapPropertySet }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::ImageStream> => [0x29bb8288,0x4462,0x516e,0xa6,0x75,0x8c,0x92,0x35,0xc4,0x29,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::PixelDataProvider> => [0x37bdf4be,0x2f39,0x592c,0xa4,0xf7,0xd1,0x6a,0x09,0xd2,0xb2,0xdb] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_PixelDataProvider }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::imaging::SoftwareBitmap> => [0xb699b653,0x33ed,0x5e2d,0xa7,0x5f,0x02,0xbf,0x90,0xe3,0x26,0x19] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Imaging_SoftwareBitmap }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::printing3d::Printing3D3MFPackage> => [0x28b6b208,0x85a7,0x53f1,0x83,0xae,0x57,0x7a,0x7d,0xe6,0x6a,0x9b] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Printing3D_Printing3D3MFPackage }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::printing3d::Printing3DMeshVerificationResult> => [0x186bae17,0x5896,0x56de,0xbf,0xf4,0x4f,0x17,0x6b,0x3e,0x61,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Printing3D_Printing3DMeshVerificationResult }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::graphics::printing3d::Printing3DModel> => [0x26f4d34c,0xa11d,0x5b09,0x99,0x08,0xad,0xe8,0xb1,0xb1,0x35,0x55] as IID_AsyncOperationCompletedHandler_1_Windows_Graphics_Printing3D_Printing3DModel }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::management::deployment::PackageVolume> => [0x35fee361,0x6cea,0x5e5c,0x8e,0xda,0x34,0xb3,0xf2,0x2d,0xf4,0xe7] as IID_AsyncOperationCompletedHandler_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::audio::CreateAudioDeviceInputNodeResult> => [0x6cc56450,0xe4e8,0x59c9,0x83,0xd8,0x63,0xe4,0x6e,0xac,0xb2,0x0b] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Audio_CreateAudioDeviceInputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::audio::CreateAudioDeviceOutputNodeResult> => [0xedbc9b59,0x7cae,0x513f,0xb0,0xdc,0x17,0x66,0x6d,0x37,0xba,0x77] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Audio_CreateAudioDeviceOutputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::audio::CreateAudioFileInputNodeResult> => [0x504d1efd,0xc11c,0x506e,0xb8,0xc9,0xaf,0x17,0xc7,0x71,0xef,0xb5] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Audio_CreateAudioFileInputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::audio::CreateAudioFileOutputNodeResult> => [0xa7a95713,0xa08f,0x5fdf,0x89,0xc6,0x96,0x27,0xbc,0xf5,0xd8,0x0a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Audio_CreateAudioFileOutputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::audio::CreateAudioGraphResult> => [0x4e660bda,0xd438,0x5741,0x8b,0x66,0x85,0xfe,0x72,0x57,0x4a,0xab] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Audio_CreateAudioGraphResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::AdvancedCapturedPhoto> => [0xedf3452c,0xd918,0x5c95,0x8e,0x3a,0x24,0x50,0x44,0xdd,0x70,0xdf] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_AdvancedCapturedPhoto }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::AdvancedPhotoCapture> => [0xd1dfaec8,0xeed3,0x5ce3,0x98,0x32,0x18,0x34,0x4c,0x98,0xfa,0x71] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_AdvancedPhotoCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::CapturedPhoto> => [0xfdb0aa78,0x04e1,0x56b3,0xb6,0xfc,0xf4,0xde,0x79,0xcd,0x41,0xa0] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_CapturedPhoto }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::core::VariablePhotoSequenceCapture> => [0x18a55dd3,0x01e3,0x5ae5,0x9b,0x5e,0xc8,0x4a,0xd4,0x0c,0xf6,0xb7] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Core_VariablePhotoSequenceCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::frames::MediaFrameReader> => [0xa6214dad,0xb917,0x5c89,0xa0,0x68,0xe3,0x2c,0x9a,0x70,0x37,0xd3] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Frames_MediaFrameReader }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::frames::MediaFrameReaderStartStatus> => [0x9f49b2e5,0x2f68,0x5c58,0x8d,0x8b,0x12,0x17,0x6f,0xf6,0xea,0x50] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Frames_MediaFrameReaderStartStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::frames::MediaFrameSourceGetPropertyResult> => [0xd0577f0d,0xce46,0x5c47,0x8f,0x7c,0x4a,0xe5,0x62,0x6c,0xc7,0x6d] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Frames_MediaFrameSourceGetPropertyResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::frames::MediaFrameSourceGroup> => [0xadf10eeb,0x9fc5,0x553b,0x91,0x64,0x29,0x42,0x46,0x99,0x2a,0x2a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::frames::MediaFrameSourceSetPropertyStatus> => [0xf613663a,0xc685,0x5dc0,0xb1,0x33,0x60,0xd9,0x43,0x03,0xa6,0xe3] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_Frames_MediaFrameSourceSetPropertyStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::LowLagMediaRecording> => [0x64a8f80c,0xe646,0x52bb,0x8f,0x4b,0x2a,0x1d,0x6b,0x0b,0x82,0x19] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_LowLagMediaRecording }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::LowLagPhotoCapture> => [0x6cebb368,0x4e84,0x500a,0x9a,0x5f,0x7b,0x9a,0x1a,0xde,0x1f,0x44] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_LowLagPhotoCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::LowLagPhotoSequenceCapture> => [0x767e0fdc,0x9563,0x572d,0x84,0xe1,0x9c,0xaa,0xb0,0xde,0xb6,0x3f] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_LowLagPhotoSequenceCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::MediaCapturePauseResult> => [0xfe726311,0x26bf,0x51cd,0xbd,0xeb,0xf4,0x0f,0x8f,0x46,0x9d,0x0a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_MediaCapturePauseResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::capture::MediaCaptureStopResult> => [0x5d4e0674,0x1df4,0x5326,0xba,0x78,0x72,0xf6,0x65,0x5d,0x2a,0x76] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Capture_MediaCaptureStopResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::casting::CastingConnectionErrorStatus> => [0x7216a94a,0xa10a,0x5763,0x8e,0x96,0xbf,0x33,0xc5,0x82,0xed,0x92] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Casting_CastingConnectionErrorStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::casting::CastingDevice> => [0xf0c69b9e,0x14cb,0x510a,0x8e,0xf0,0x7e,0x86,0xd7,0x71,0xba,0xaf] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Casting_CastingDevice }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::casting::CastingPlaybackTypes> => [0xb55e550c,0xdfa8,0x50be,0xbe,0x8f,0x5d,0x42,0xc9,0xda,0xc1,0x20] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Casting_CastingPlaybackTypes }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::contentrestrictions::ContentAccessRestrictionLevel> => [0xcf61be5d,0x40c3,0x5484,0x84,0x6a,0x3f,0x82,0xb8,0xba,0x57,0x38] as IID_AsyncOperationCompletedHandler_1_Windows_Media_ContentRestrictions_ContentAccessRestrictionLevel }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::contentrestrictions::ContentRestrictionsBrowsePolicy> => [0x72ae1a16,0xc705,0x54e7,0xb1,0xc4,0xfc,0x05,0xa0,0xe0,0x7a,0x77] as IID_AsyncOperationCompletedHandler_1_Windows_Media_ContentRestrictions_ContentRestrictionsBrowsePolicy }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::core::MediaStreamSample> => [0xdf7aacc9,0xa86c,0x5c7d,0xbf,0x98,0xcc,0x37,0x1c,0x97,0xc6,0x7b] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Core_MediaStreamSample }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::dialprotocol::DialAppLaunchResult> => [0x164c0aa8,0x3d2b,0x579b,0x94,0xa3,0xcc,0x49,0x25,0xc6,0x95,0xec] as IID_AsyncOperationCompletedHandler_1_Windows_Media_DialProtocol_DialAppLaunchResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::dialprotocol::DialAppStateDetails> => [0x38c62dd5,0x1f16,0x55c0,0x8e,0xc7,0xca,0x0f,0xc8,0x41,0xd6,0x14] as IID_AsyncOperationCompletedHandler_1_Windows_Media_DialProtocol_DialAppStateDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::dialprotocol::DialAppStopResult> => [0xc755f54a,0xef7b,0x563a,0x9b,0x14,0x46,0x2e,0x72,0xd9,0x66,0x5a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_DialProtocol_DialAppStopResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::dialprotocol::DialDevice> => [0x81bc7d1b,0x7d06,0x555f,0x81,0x1b,0x42,0xec,0x0f,0xa7,0x1b,0x55] as IID_AsyncOperationCompletedHandler_1_Windows_Media_DialProtocol_DialDevice }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::editing::BackgroundAudioTrack> => [0xb8830bc7,0x188b,0x5c25,0xa3,0xbb,0x95,0x90,0x52,0xbc,0xb7,0x40] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::editing::MediaClip> => [0x60cde3bc,0x119f,0x50a8,0x9c,0xcb,0x9e,0xa5,0x7e,0xa9,0x6b,0xfd] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::editing::MediaComposition> => [0xedd253f8,0x4ebd,0x56e5,0x95,0x92,0x3c,0x09,0x37,0x5e,0xbd,0xc4] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Editing_MediaComposition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::faceanalysis::FaceDetector> => [0x3224aec6,0xe785,0x5066,0x97,0x6f,0x79,0xdd,0x08,0x1b,0x75,0xa9] as IID_AsyncOperationCompletedHandler_1_Windows_Media_FaceAnalysis_FaceDetector }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::faceanalysis::FaceTracker> => [0x57d5163d,0x9e80,0x59d2,0x93,0x66,0xd2,0xb5,0x24,0x8b,0x27,0x24] as IID_AsyncOperationCompletedHandler_1_Windows_Media_FaceAnalysis_FaceTracker }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::IMediaExtension> => [0x9c1b578e,0xfb7d,0x5bab,0xba,0x39,0x86,0x38,0x7f,0xe5,0x33,0xb6] as IID_AsyncOperationCompletedHandler_1_Windows_Media_IMediaExtension }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::import::PhotoImportSource> => [0xdc38b22a,0x872e,0x53f8,0x8e,0x97,0x45,0xed,0x85,0xdf,0x0d,0x23] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::mediaproperties::MediaEncodingProfile> => [0x37296fc1,0x86da,0x58a0,0x90,0xc0,0xc8,0x07,0xbd,0x94,0x39,0x5e] as IID_AsyncOperationCompletedHandler_1_Windows_Media_MediaProperties_MediaEncodingProfile }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::ocr::OcrResult> => [0x989c1371,0x444a,0x5e7e,0xb1,0x97,0x9e,0xaa,0xf9,0xd2,0x82,0x9a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Ocr_OcrResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::playlists::Playlist> => [0x427deafd,0xb226,0x5ef0,0x93,0x20,0xc9,0xf3,0x25,0xe3,0x74,0x74] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Playlists_Playlist }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::protection::HdcpSetProtectionResult> => [0x19344a58,0xa5c1,0x5168,0x80,0x3e,0x63,0x27,0x71,0x62,0x81,0x43] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Protection_HdcpSetProtectionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::protection::playready::INDLicenseFetchResult> => [0xf72fdf87,0x9055,0x58d8,0x96,0xab,0x2c,0xc0,0x4d,0x06,0xcc,0xd7] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Protection_PlayReady_INDLicenseFetchResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::protection::playready::INDSendResult> => [0xc6c485d0,0xfdab,0x5142,0xb0,0x79,0x97,0xaf,0x05,0x67,0xf0,0xb6] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Protection_PlayReady_INDSendResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::protection::playready::INDStartResult> => [0x1e4e3760,0xb22b,0x5f0a,0x90,0x58,0x47,0x5a,0xff,0x31,0x0d,0xb5] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Protection_PlayReady_INDStartResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::speechrecognition::SpeechRecognitionCompilationResult> => [0x78c859bd,0x14d4,0x5c40,0xab,0xff,0x49,0x06,0x16,0xd5,0xe9,0x2d] as IID_AsyncOperationCompletedHandler_1_Windows_Media_SpeechRecognition_SpeechRecognitionCompilationResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::speechrecognition::SpeechRecognitionResult> => [0xc2195c7d,0xdcc2,0x5c6d,0x91,0x62,0xc8,0xdf,0x66,0x52,0x87,0x62] as IID_AsyncOperationCompletedHandler_1_Windows_Media_SpeechRecognition_SpeechRecognitionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::speechsynthesis::SpeechSynthesisStream> => [0xc972b996,0x6165,0x50d4,0xaf,0x60,0xa8,0xc3,0xdf,0x51,0xd0,0x92] as IID_AsyncOperationCompletedHandler_1_Windows_Media_SpeechSynthesis_SpeechSynthesisStream }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::streaming::adaptive::AdaptiveMediaSourceCreationResult> => [0xbd68cc00,0x724c,0x5a76,0xa4,0x37,0x14,0x64,0xeb,0xdd,0xa4,0xac] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceCreationResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::transcoding::PrepareTranscodeResult> => [0xa44d7d07,0x8f74,0x52ee,0x9f,0x02,0xc2,0xb2,0x44,0xb4,0xff,0x2a] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Transcoding_PrepareTranscodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::transcoding::TranscodeFailureReason> => [0xc42ae2bf,0xe194,0x5179,0xb8,0xad,0x03,0xb5,0x1c,0x04,0xe1,0xda] as IID_AsyncOperationCompletedHandler_1_Windows_Media_Transcoding_TranscodeFailureReason }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::media::VideoFrame> => [0x6086f2fb,0x4a29,0x54ca,0xb6,0xa3,0xf2,0x39,0x1a,0x03,0xbc,0x3b] as IID_AsyncOperationCompletedHandler_1_Windows_Media_VideoFrame }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::backgroundtransfer::DownloadOperation> => [0x2aa63857,0xffaf,0x5cf6,0x9b,0x2c,0x0d,0xc5,0x97,0xb6,0x0a,0x60] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::backgroundtransfer::UnconstrainedTransferRequestResult> => [0x4f52bfe8,0x9b0e,0x5b22,0x91,0x6b,0x83,0x44,0x25,0xb4,0xab,0x97] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_BackgroundTransfer_UnconstrainedTransferRequestResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::backgroundtransfer::UploadOperation> => [0xead68818,0x0c38,0x5cde,0xae,0xc1,0xc6,0xa7,0x61,0x87,0x11,0xf7] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::connectivity::ConnectionProfile> => [0xe4f0c96a,0x0571,0x59f4,0xa9,0xa9,0xaf,0xac,0x3e,0x61,0xca,0xa0] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::connectivity::ConnectionSession> => [0x3bc680d8,0x9e83,0x5086,0x8f,0x49,0x7a,0x29,0xbf,0xb1,0xc7,0xe1] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Connectivity_ConnectionSession }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::connectivity::ProxyConfiguration> => [0x035b2567,0xefb9,0x5bc3,0xb6,0x09,0xf9,0xa8,0xc2,0x0b,0x70,0x01] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Connectivity_ProxyConfiguration }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::HotspotCredentialsAuthenticationResult> => [0x7f254beb,0x471f,0x5000,0x94,0xce,0x10,0x2c,0xc3,0x33,0x05,0x5f] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_HotspotCredentialsAuthenticationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandDeviceServiceCommandResult> => [0x21f0ce4f,0x8f33,0x5e71,0xa4,0x57,0xdd,0xa5,0x53,0xb0,0xd6,0xbb] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceCommandResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandModemConfiguration> => [0xc11e0649,0x8237,0x5c93,0xbb,0xdb,0x2e,0xda,0x52,0x16,0xfd,0x3f] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandModemConfiguration }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandPinOperationResult> => [0x595ad094,0x60e3,0x5349,0x8f,0xe6,0xea,0x8e,0xcb,0xbb,0x25,0x41] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandPinOperationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandUiccAppReadRecordResult> => [0xb81892b3,0x4ca9,0x5ec4,0x89,0x71,0x2f,0xbc,0x19,0xb5,0x6c,0xa9] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppReadRecordResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandUiccAppRecordDetailsResult> => [0xd0b53858,0x0e54,0x5791,0x82,0xed,0x33,0x13,0xdc,0x75,0xda,0x45] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppRecordDetailsResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::MobileBroadbandUiccAppsResult> => [0xa12bed56,0xc672,0x595e,0xa6,0x7b,0x49,0xab,0xc2,0x85,0xad,0xdc] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppsResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::NetworkOperatorTetheringOperationResult> => [0xa936b927,0x7537,0x59c6,0x89,0xde,0x33,0xf3,0x6a,0x97,0x25,0xab] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_NetworkOperatorTetheringOperationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::ProvisionFromXmlDocumentResults> => [0x7a7eee1b,0x17f9,0x5a41,0x86,0x1b,0xc3,0x0e,0xa1,0x27,0xd0,0xf1] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_ProvisionFromXmlDocumentResults }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::networkoperators::UssdReply> => [0x9385bd8f,0x5e14,0x557a,0xa7,0xf1,0x63,0xf3,0x3d,0x9e,0xca,0xcf] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_NetworkOperators_UssdReply }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::pushnotifications::PushNotificationChannel> => [0xcf7c902f,0x0f0d,0x5b22,0x90,0xb1,0x85,0x14,0x1b,0x58,0x16,0xcd] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_PushNotifications_PushNotificationChannel }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::servicediscovery::dnssd::DnssdRegistrationResult> => [0xf3632f52,0x894a,0x5345,0x9b,0xe6,0x83,0x89,0x75,0x1c,0x51,0x89] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_ServiceDiscovery_Dnssd_DnssdRegistrationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::sockets::StreamSocket> => [0x71b5d99e,0x3854,0x5e9a,0xb4,0xdc,0xd1,0xb5,0x8b,0xf1,0x98,0xfc] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Sockets_StreamSocket }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::vpn::VpnCredential> => [0x1c9c4504,0x4b75,0x57ea,0x83,0x7d,0x53,0x38,0x35,0x8b,0xb7,0x62] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Vpn_VpnCredential }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::vpn::VpnManagementErrorStatus> => [0x31229f8c,0x709d,0x5017,0x86,0x29,0x57,0xef,0x12,0x89,0xe6,0x16] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_Vpn_VpnManagementErrorStatus }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::networking::xboxlive::XboxLiveEndpointPairCreationResult> => [0xad57fa1d,0xdb1b,0x5df5,0x96,0x94,0xf7,0x1b,0x9b,0xd5,0x62,0x5b] as IID_AsyncOperationCompletedHandler_1_Windows_Networking_XboxLive_XboxLiveEndpointPairCreationResult }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::perception::spatial::SpatialAnchorStore> => [0x84c21a3a,0x037a,0x503f,0x80,0x06,0xab,0x57,0x7b,0x7f,0x6f,0x66] as IID_AsyncOperationCompletedHandler_1_Windows_Perception_Spatial_SpatialAnchorStore }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::perception::spatial::SpatialPerceptionAccessStatus> => [0x6ced54c8,0x7689,0x525a,0x80,0xe1,0x95,0x6a,0x9d,0x85,0xcd,0x83] as IID_AsyncOperationCompletedHandler_1_Windows_Perception_Spatial_SpatialPerceptionAccessStatus }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::perception::spatial::surfaces::SpatialSurfaceMesh> => [0x4680f7f6,0x44c5,0x5fc6,0x8d,0x51,0xd6,0x96,0x29,0x15,0xfa,0x23] as IID_AsyncOperationCompletedHandler_1_Windows_Perception_Spatial_Surfaces_SpatialSurfaceMesh }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::core::MicrosoftAccountMultiFactorGetSessionsResult> => [0xcecbb0ca,0x0a27,0x57d4,0xa3,0x5d,0x49,0x98,0xf1,0x99,0xda,0xc9] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorGetSessionsResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::core::MicrosoftAccountMultiFactorOneTimeCodedInfo> => [0x02e84540,0xf4a1,0x589f,0x93,0x60,0xa0,0x50,0x2e,0x6d,0xc9,0xc0] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorOneTimeCodedInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::core::MicrosoftAccountMultiFactorServiceResponse> => [0x8d7f8240,0x81cf,0x5896,0x95,0xfa,0xe7,0xb2,0x23,0xf7,0x69,0xf9] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorServiceResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::core::MicrosoftAccountMultiFactorUnregisteredAccountsAndSessionInfo> => [0x6cc53e8c,0xd0e4,0x5ded,0x94,0xf4,0x7c,0x73,0xb1,0x32,0xd2,0xa4] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorUnregisteredAccountsAndSessionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::provider::SecondaryAuthenticationFactorAuthenticationResult> => [0x2547373d,0x9684,0x5e5b,0xa9,0xb8,0xa6,0xf9,0x0c,0xe6,0x32,0xad] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorAuthenticationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::provider::SecondaryAuthenticationFactorAuthenticationStageInfo> => [0x7811d384,0x2eb8,0x58f1,0xaf,0xed,0x4b,0x4b,0x88,0x8f,0x43,0x57] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorAuthenticationStageInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::provider::SecondaryAuthenticationFactorFinishAuthenticationStatus> => [0xae1d7146,0x3d91,0x50e3,0x8f,0x13,0x61,0x3c,0xf2,0x80,0x12,0x07] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorFinishAuthenticationStatus }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::identity::provider::SecondaryAuthenticationFactorRegistrationResult> => [0xa04902e8,0xf830,0x50ea,0x89,0xea,0x96,0xe2,0xa6,0xfb,0x94,0x53] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorRegistrationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::onlineid::UserIdentity> => [0xcded76fd,0x7841,0x52a0,0xa7,0x71,0x76,0xcd,0x75,0x1d,0x13,0xcd] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_OnlineId_UserIdentity }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::web::core::WebTokenRequestResult> => [0xdeb54b22,0x70f2,0x55ab,0x97,0xc0,0x6c,0xbd,0xc5,0xdd,0xb6,0xf0] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Web_Core_WebTokenRequestResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::authentication::web::WebAuthenticationResult> => [0x3c1ec44c,0xe942,0x54e5,0xbc,0xd3,0xe3,0x29,0xc9,0x51,0xf5,0x95] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Authentication_Web_WebAuthenticationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::KeyCredentialAttestationResult> => [0x2c16e103,0xf783,0x5dd9,0xa5,0xf3,0x33,0x62,0xbc,0xbd,0xaa,0xbd] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_KeyCredentialAttestationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::KeyCredentialOperationResult> => [0x39b4609a,0x0202,0x55fa,0x80,0x05,0x6f,0x83,0x70,0x9e,0x20,0xf3] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_KeyCredentialOperationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::KeyCredentialRetrievalResult> => [0x03ea60b1,0xa874,0x58ce,0x8e,0x8e,0xff,0xf4,0x48,0xb6,0x73,0x3e] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_KeyCredentialRetrievalResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::ui::CredentialPickerResults> => [0x091a96b8,0x52a6,0x523a,0x8c,0x94,0x7f,0x9c,0x11,0xc6,0xda,0xe5] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_UI_CredentialPickerResults }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::ui::UserConsentVerificationResult> => [0x0cffc6c9,0x4c2b,0x5cd4,0xb3,0x8c,0x7b,0x8d,0xf3,0xff,0x5a,0xfb] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_UI_UserConsentVerificationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::ui::UserConsentVerifierAvailability> => [0x28988174,0xace2,0x5c15,0xa0,0xdf,0x58,0x0a,0x26,0xd9,0x42,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_UI_UserConsentVerifierAvailability }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::WebAccount> => [0x4bd6f1e5,0xca89,0x5240,0x8f,0x3d,0x7f,0x1b,0x54,0xae,0x90,0xa7] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::credentials::WebAccountProvider> => [0x9477622b,0x1340,0x5574,0x81,0xfc,0x50,0x13,0x58,0x1f,0x57,0xc9] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Credentials_WebAccountProvider }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::cryptography::certificates::CertificateChain> => [0x4c3f50e9,0x90e3,0x5a30,0x90,0x15,0x4a,0xa0,0x37,0x69,0x04,0xf3] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Cryptography_Certificates_CertificateChain }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::cryptography::certificates::SignatureValidationResult> => [0xdff50005,0x78ad,0x5f4f,0xa0,0x85,0xcb,0x61,0x4a,0x67,0x4a,0x25] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Cryptography_Certificates_SignatureValidationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::cryptography::core::CryptographicKey> => [0x04ca4378,0xf594,0x5de6,0xa5,0x55,0x30,0x4f,0x62,0xcb,0x4f,0xaf] as IID_AsyncOperationCompletedHandler_1_Windows_Security_Cryptography_Core_CryptographicKey }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::BufferProtectUnprotectResult> => [0x73d780cb,0xad38,0x59e6,0xa2,0x36,0xcc,0x0d,0xf6,0x9f,0x15,0xa8] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_BufferProtectUnprotectResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::DataProtectionInfo> => [0xe12bb475,0x3f2b,0x51c9,0x83,0xc6,0xa5,0x66,0x10,0x86,0xb6,0xc3] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_DataProtectionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::FileProtectionInfo> => [0x2918ffea,0xe091,0x53e2,0xbd,0xe5,0x61,0x7c,0x9b,0xb3,0xd8,0xfe] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_FileProtectionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::FileProtectionStatus> => [0xe104f25b,0xb957,0x5ed4,0xb1,0xc5,0x19,0x93,0x60,0x4c,0xfe,0xae] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_FileProtectionStatus }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::ProtectedContainerExportResult> => [0x560c5521,0x5008,0x5272,0xa7,0x66,0x94,0x1f,0x70,0x71,0x8b,0xc6] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_ProtectedContainerExportResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::ProtectedContainerImportResult> => [0xcfea00f8,0xd2ad,0x5ad2,0xa3,0x96,0xe4,0xf7,0x1b,0x9a,0x7c,0x3f] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_ProtectedContainerImportResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::ProtectedFileCreateResult> => [0x6c44a868,0x7c80,0x5187,0xa0,0x8d,0x37,0x9b,0xe4,0x19,0x09,0xf6] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_ProtectedFileCreateResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::enterprisedata::ProtectionPolicyEvaluationResult> => [0x2833ba54,0xa4e1,0x5c2d,0x8a,0x7a,0x13,0x6e,0x85,0x10,0xc7,0x8b] as IID_AsyncOperationCompletedHandler_1_Windows_Security_EnterpriseData_ProtectionPolicyEvaluationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::security::exchangeactivesyncprovisioning::EasComplianceResults> => [0x24a4131a,0xed31,0x5eff,0x97,0x2e,0x75,0x0b,0x95,0x64,0x04,0xd0] as IID_AsyncOperationCompletedHandler_1_Windows_Security_ExchangeActiveSyncProvisioning_EasComplianceResults }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::maps::localsearch::LocalLocationFinderResult> => [0x7b4a1b93,0x2943,0x5e50,0xa0,0x10,0xee,0x9a,0xec,0x1b,0xbf,0xe7] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Maps_LocalSearch_LocalLocationFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::maps::MapLocationFinderResult> => [0x26ceeb11,0x1221,0x5c2b,0xbb,0xf9,0xcf,0xea,0x36,0x63,0xc2,0xed] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Maps_MapLocationFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::maps::MapRouteFinderResult> => [0x6e7a2b4f,0x811c,0x54c3,0x89,0x38,0x67,0x95,0xf4,0xe6,0x70,0x09] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Maps_MapRouteFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreAcquireLicenseResult> => [0x6987c97c,0x2c19,0x5f44,0xb5,0xac,0x37,0x39,0x3f,0x3c,0x1a,0x4a] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreAcquireLicenseResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreAppLicense> => [0xceff1e09,0xe506,0x50ad,0xa9,0x08,0x52,0x03,0x8c,0x25,0x65,0x52] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreAppLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreConsumableResult> => [0x3f2bb178,0x3c4e,0x56ed,0x86,0xa5,0xad,0x13,0x79,0x7c,0xfb,0xfd] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreConsumableResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreProductPagedQueryResult> => [0xe786321f,0xb791,0x5e38,0x8b,0xc4,0x98,0xcb,0x28,0x7d,0x10,0x85] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreProductPagedQueryResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreProductQueryResult> => [0x02f4a42c,0x0458,0x58d6,0x92,0x3c,0xb4,0x4b,0xa8,0xef,0x22,0x22] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreProductQueryResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreProductResult> => [0xeb93e936,0xd515,0x5414,0x9d,0x15,0xf0,0x50,0xc0,0xb8,0xf5,0x21] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreProductResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StorePurchaseResult> => [0x1d9f89ee,0x2fce,0x54e6,0xa0,0xa9,0x52,0xd0,0x0c,0x52,0xcc,0x3a] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StorePurchaseResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::services::store::StoreSendRequestResult> => [0x7800b2a3,0xbbbc,0x5a11,0x8c,0x35,0xd2,0xbd,0xe5,0x48,0x9e,0x81] as IID_AsyncOperationCompletedHandler_1_Windows_Services_Store_StoreSendRequestResult }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::ApplicationData> => [0xabafe590,0x65fe,0x520a,0x9d,0x7c,0x6a,0xb5,0xf1,0x88,0x22,0x37] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_ApplicationData }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::BasicProperties> => [0xc8659aae,0x4926,0x52ad,0x8f,0x60,0xd8,0x9f,0xe5,0xa8,0xdf,0x5f] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_BasicProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::DocumentProperties> => [0x4452ed4c,0x642b,0x501b,0x96,0x17,0x7d,0x68,0xb4,0xac,0x3c,0x66] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_DocumentProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::ImageProperties> => [0xc63729bc,0xe4c3,0x564c,0xb1,0x37,0x2c,0xb4,0xf5,0x96,0x6a,0x83] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_ImageProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::MusicProperties> => [0xd84e1312,0xd661,0x5b7f,0x95,0x66,0x74,0x21,0xbd,0xed,0xc1,0xea] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_MusicProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::StorageItemThumbnail> => [0x6d0036f2,0xa8a8,0x505d,0xb0,0x42,0xd0,0x87,0xdc,0x1f,0xc1,0xb7] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_StorageItemThumbnail }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::fileproperties::VideoProperties> => [0x43401d34,0x61ab,0x5cf2,0x92,0x1f,0x55,0xb6,0x16,0x63,0x1d,0x1d] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_FileProperties_VideoProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::IStorageItem> => [0x92c3102f,0xa327,0x5318,0xa6,0xc1,0x76,0xf6,0xb2,0xa0,0xab,0xfb] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::provider::FileUpdateStatus> => [0xbb185a07,0x0285,0x5f37,0x9c,0x7d,0x2f,0xc6,0xa3,0xe0,0xe6,0xe5] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Provider_FileUpdateStatus }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::search::IndexedState> => [0xb67a3cba,0xf5f7,0x5e51,0x96,0x8a,0x38,0x51,0x26,0xd1,0xf9,0x18] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Search_IndexedState }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::StorageFile> => [0xe521c894,0x2c26,0x5946,0x9e,0x61,0x2b,0x5e,0x18,0x8d,0x01,0xed] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::StorageFolder> => [0xc211026e,0x9e63,0x5452,0xba,0x54,0x3a,0x07,0xd6,0xa9,0x68,0x74] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::StorageLibrary> => [0x36d560c3,0x731f,0x5c70,0xb9,0x07,0x30,0xbc,0x99,0xbc,0x30,0x0f] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_StorageLibrary }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::StorageStreamTransaction> => [0xd11739e6,0x2995,0x5d33,0xbf,0xff,0x51,0xb6,0x04,0x1f,0x68,0xc1] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_StorageStreamTransaction }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IBuffer> => [0x51c3d2fd,0xb8a1,0x5620,0xb7,0x46,0x7e,0xe6,0xd5,0x33,0xac,0xa3] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IInputStream> => [0xd0bd0125,0x9049,0x57a3,0xbd,0x66,0xe2,0x52,0x5d,0x98,0xc8,0x14] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IInputStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IOutputStream> => [0xbcb37f4f,0x3af4,0x561c,0xa9,0xe3,0xee,0xf1,0x73,0x84,0x94,0xd7] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IOutputStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IRandomAccessStream> => [0x398c4183,0x793d,0x5b00,0x81,0x9b,0x4a,0xef,0x92,0x48,0x5e,0x94] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IRandomAccessStreamReference> => [0x60847289,0xea0b,0x5df6,0x89,0xdf,0xf2,0xc6,0x2c,0xba,0x96,0x93] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamReference }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::IRandomAccessStreamWithContentType> => [0x3dddecf4,0x1d39,0x58e8,0x83,0xb1,0xdb,0xed,0x54,0x1c,0x7f,0x35] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::storage::streams::RandomAccessStreamReference> => [0x3d203732,0xded7,0x5d32,0x87,0xe6,0xc1,0x79,0x78,0x1f,0x79,0x1f] as IID_AsyncOperationCompletedHandler_1_Windows_Storage_Streams_RandomAccessStreamReference }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::LaunchQuerySupportStatus> => [0x198cac52,0xabcd,0x5529,0x93,0x3f,0x07,0x1c,0xc9,0x3f,0xd6,0x35] as IID_AsyncOperationCompletedHandler_1_Windows_System_LaunchQuerySupportStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::LaunchUriResult> => [0x70a97bf8,0xe0a5,0x59bb,0x91,0x74,0x81,0x2a,0x13,0x1d,0x85,0xa0] as IID_AsyncOperationCompletedHandler_1_Windows_System_LaunchUriResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::LaunchUriStatus> => [0x520aa58e,0x40d6,0x5a57,0xa6,0xdc,0xcb,0x5f,0xae,0xa5,0xcc,0xa5] as IID_AsyncOperationCompletedHandler_1_Windows_System_LaunchUriStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::ProcessLauncherResult> => [0x8d787ee6,0x07e4,0x5dce,0x8f,0xe5,0xb5,0x03,0xa1,0xf6,0x36,0x8c] as IID_AsyncOperationCompletedHandler_1_Windows_System_ProcessLauncherResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::RemoteLaunchUriStatus> => [0x3f8f4b1b,0xcd54,0x543c,0x81,0x7f,0x26,0x30,0x48,0x7f,0x18,0x78] as IID_AsyncOperationCompletedHandler_1_Windows_System_RemoteLaunchUriStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::remotesystems::RemoteSystem> => [0x3a0b522d,0x98d0,0x5d34,0xac,0xe6,0x2c,0x73,0x46,0x61,0x3f,0x1d] as IID_AsyncOperationCompletedHandler_1_Windows_System_RemoteSystems_RemoteSystem }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::remotesystems::RemoteSystemAccessStatus> => [0x543a221d,0xef39,0x57f5,0x97,0x41,0xb0,0x52,0xdb,0xc2,0x92,0x49] as IID_AsyncOperationCompletedHandler_1_Windows_System_RemoteSystems_RemoteSystemAccessStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::User> => [0xf913e3a2,0xd1c5,0x5308,0xbe,0xcf,0x4c,0x2d,0x81,0x67,0x82,0x4a] as IID_AsyncOperationCompletedHandler_1_Windows_System_User }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::userprofile::SetAccountPictureResult> => [0x603f3e31,0x7a51,0x518c,0x92,0x80,0xc1,0x88,0xea,0x42,0x13,0xd8] as IID_AsyncOperationCompletedHandler_1_Windows_System_UserProfile_SetAccountPictureResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::system::userprofile::SetImageFeedResult> => [0xf214731a,0x1305,0x5b44,0x93,0x2c,0xaf,0x9a,0x1e,0x4d,0x78,0xc9] as IID_AsyncOperationCompletedHandler_1_Windows_System_UserProfile_SetImageFeedResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::notifications::management::UserNotificationListenerAccessStatus> => [0xf09e843a,0x13cb,0x559b,0xa9,0xfc,0x01,0x57,0x22,0xc2,0xcd,0x57] as IID_AsyncOperationCompletedHandler_1_Windows_UI_Notifications_Management_UserNotificationListenerAccessStatus }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::popups::IUICommand> => [0xdd33fd5b,0xa24d,0x5a44,0x91,0xfe,0xdd,0x64,0x41,0x77,0x01,0x03] as IID_AsyncOperationCompletedHandler_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::startscreen::JumpList> => [0x3c047c6a,0xc55b,0x5485,0xb6,0x73,0x8d,0x4b,0xd7,0xc3,0x42,0xe2] as IID_AsyncOperationCompletedHandler_1_Windows_UI_StartScreen_JumpList }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::xaml::controls::ContentDialogResult> => [0x45c7a306,0xe330,0x54d6,0xa9,0xba,0x61,0xc9,0x1f,0x93,0xf5,0x3b] as IID_AsyncOperationCompletedHandler_1_Windows_UI_Xaml_Controls_ContentDialogResult }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::xaml::controls::maps::StreetsidePanorama> => [0xf6f3b17c,0x4527,0x5528,0x86,0xaa,0x1c,0xf1,0xfb,0x78,0xa5,0xeb] as IID_AsyncOperationCompletedHandler_1_Windows_UI_Xaml_Controls_Maps_StreetsidePanorama }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for AsyncOperationCompletedHandler<super::ui::xaml::data::LoadMoreItemsResult> => [0x10fb738b,0xa63b,0x506e,0x9e,0xd7,0x2e,0xab,0x37,0x91,0x52,0x21] as IID_AsyncOperationCompletedHandler_1_Windows_UI_Xaml_Data_LoadMoreItemsResult }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<u32> => [0x9343b6e7,0xe3d2,0x5e4a,0xab,0x2d,0x2b,0xce,0x49,0x19,0xa6,0xa4] as IID_AsyncOperationCompletedHandler_1_System_UInt32 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<u64> => [0xee8aeb02,0xfb00,0x51fa,0x8f,0x57,0x32,0x58,0x3e,0xa2,0x41,0xf9] as IID_AsyncOperationCompletedHandler_1_System_UInt64 }
		RT_PINTERFACE!{ for AsyncOperationCompletedHandler<Uri> => [0xad46f1cc,0x2bb0,0x585c,0x98,0x85,0x03,0xc2,0x78,0x0d,0x4d,0x58] as IID_AsyncOperationCompletedHandler_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for AsyncOperationProgressHandler<bool, f64> => [0xcadf3784,0x1200,0x5633,0x82,0x80,0x16,0x38,0x49,0x91,0x4a,0xb3] as IID_AsyncOperationProgressHandler_2_System_Boolean_System_Double }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<collections::IVectorView<super::devices::sms::ISmsMessage>, i32> => [0x3f9d1255,0xebf8,0x569f,0x91,0xc3,0x49,0x74,0x0d,0x59,0x44,0xce] as IID_AsyncOperationProgressHandler_2_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sms_ISmsMessage__System_Int32 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<HString, super::web::http::HttpProgress> => [0xcf0a03f6,0xa80a,0x5b46,0x9c,0x80,0xf4,0xad,0x9e,0xd6,0xe2,0xd6] as IID_AsyncOperationProgressHandler_2_System_String_Windows_Web_Http_HttpProgress }
		RT_PINTERFACE!{ for AsyncOperationProgressHandler<HString, u64> => [0x14da7de7,0x40df,0x5d4c,0x82,0x3f,0xcf,0x31,0x06,0x25,0xad,0x39] as IID_AsyncOperationProgressHandler_2_System_String_System_UInt64 }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::devices::scanners::ImageScannerScanResult, u32> => [0xd1662baa,0x4f20,0x5d18,0x97,0xf1,0xa0,0x1a,0x6d,0x0d,0xd9,0x80] as IID_AsyncOperationProgressHandler_2_Windows_Devices_Scanners_ImageScannerScanResult_System_UInt32 }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::gaming::input::custom::GipFirmwareUpdateResult, super::gaming::input::custom::GipFirmwareUpdateProgress> => [0x065c16af,0x49dc,0x5c94,0xaf,0xe2,0x93,0x85,0x93,0x7f,0xac,0xc9] as IID_AsyncOperationProgressHandler_2_Windows_Gaming_Input_Custom_GipFirmwareUpdateResult_Windows_Gaming_Input_Custom_GipFirmwareUpdateProgress }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::management::deployment::DeploymentResult, super::management::deployment::DeploymentProgress> => [0xf1b926d1,0x1796,0x597a,0x9b,0xea,0x6c,0x64,0x49,0xd0,0x3e,0xef] as IID_AsyncOperationProgressHandler_2_Windows_Management_Deployment_DeploymentResult_Windows_Management_Deployment_DeploymentProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::media::import::PhotoImportDeleteImportedItemsFromSourceResult, f64> => [0xac6e425d,0x49e8,0x50d7,0x98,0x8c,0xcd,0x5e,0x42,0x03,0x85,0x77] as IID_AsyncOperationProgressHandler_2_Windows_Media_Import_PhotoImportDeleteImportedItemsFromSourceResult_System_Double }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::media::import::PhotoImportFindItemsResult, u32> => [0x91190f62,0x7956,0x5e8f,0x83,0xf1,0x84,0xf9,0xfe,0x01,0x1b,0x21] as IID_AsyncOperationProgressHandler_2_Windows_Media_Import_PhotoImportFindItemsResult_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::media::import::PhotoImportImportItemsResult, super::media::import::PhotoImportProgress> => [0xacd8a978,0xb2e1,0x55d0,0xbb,0xf6,0x8d,0xc5,0x08,0x8d,0x72,0x8a] as IID_AsyncOperationProgressHandler_2_Windows_Media_Import_PhotoImportImportItemsResult_Windows_Media_Import_PhotoImportProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::media::protection::RenewalStatus, u32> => [0xb9da4aa0,0x26e0,0x5d69,0xa0,0xc8,0x05,0x71,0x6a,0x40,0x62,0x35] as IID_AsyncOperationProgressHandler_2_Windows_Media_Protection_RenewalStatus_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::media::transcoding::TranscodeFailureReason, f64> => [0x009c6245,0x0e59,0x53b0,0x9f,0xd2,0xd2,0x50,0xe4,0x5a,0x00,0xa3] as IID_AsyncOperationProgressHandler_2_Windows_Media_Transcoding_TranscodeFailureReason_System_Double }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::networking::backgroundtransfer::DownloadOperation, super::networking::backgroundtransfer::DownloadOperation> => [0xb2ff13f1,0xc743,0x54f4,0xbc,0xcc,0xf0,0x8e,0x16,0xa8,0x78,0x90] as IID_AsyncOperationProgressHandler_2_Windows_Networking_BackgroundTransfer_DownloadOperation_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::networking::backgroundtransfer::UploadOperation, super::networking::backgroundtransfer::UploadOperation> => [0xccd13730,0xfed3,0x54e8,0x84,0x71,0x09,0x6e,0x4b,0x64,0xca,0xdd] as IID_AsyncOperationProgressHandler_2_Windows_Networking_BackgroundTransfer_UploadOperation_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::services::store::StorePackageUpdateResult, super::services::store::StorePackageUpdateStatus> => [0x961260f1,0x7352,0x5edf,0x96,0x66,0x1f,0x9a,0x0a,0x8e,0xe4,0x77] as IID_AsyncOperationProgressHandler_2_Windows_Services_Store_StorePackageUpdateResult_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IBuffer, super::web::http::HttpProgress> => [0x9eb2b852,0xe019,0x5440,0x8f,0x88,0x0d,0xd7,0xd5,0x6f,0xea,0x47] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IBuffer, u32> => [0xbf666554,0x7605,0x5d9a,0xb1,0x4e,0x18,0xd8,0xc8,0x47,0x2a,0xfe] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_System_UInt32 }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IBuffer, u64> => [0xd17f5eb6,0xb422,0x5e26,0xa8,0x17,0x7e,0x0f,0xd0,0x8f,0x75,0xd5] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IBuffer_System_UInt64 }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IInputStream, super::web::http::HttpProgress> => [0x04682e89,0x6e8b,0x54b1,0xa4,0x66,0x43,0x2e,0x13,0x0c,0xf9,0xa6] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IInputStream_Windows_Web_Http_HttpProgress }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IInputStream, super::web::syndication::RetrievalProgress> => [0x6136b327,0x4152,0x54e3,0xaa,0x34,0x38,0xa0,0xc1,0x21,0xdc,0x4d] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IInputStream_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::storage::streams::IInputStream, u64> => [0xf9b2e7f6,0x762f,0x50db,0x95,0xdd,0x7f,0x6c,0x6e,0xc4,0x70,0x90] as IID_AsyncOperationProgressHandler_2_Windows_Storage_Streams_IInputStream_System_UInt64 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::web::atompub::ServiceDocument, super::web::syndication::RetrievalProgress> => [0xdd2a6d54,0x55aa,0x5d09,0xb7,0x90,0x95,0x20,0xd4,0xeb,0x4f,0x19] as IID_AsyncOperationProgressHandler_2_Windows_Web_AtomPub_ServiceDocument_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::web::http::HttpResponseMessage, super::web::http::HttpProgress> => [0x68e4606a,0x76ec,0x5816,0xb2,0xfe,0xa0,0x4e,0xcd,0xe4,0x12,0x6a] as IID_AsyncOperationProgressHandler_2_Windows_Web_Http_HttpResponseMessage_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::web::syndication::SyndicationFeed, super::web::syndication::RetrievalProgress> => [0x1017bbe0,0x9d10,0x543e,0x8f,0x03,0x88,0x51,0x22,0xa0,0x82,0xf3] as IID_AsyncOperationProgressHandler_2_Windows_Web_Syndication_SyndicationFeed_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::web::syndication::SyndicationItem, super::web::syndication::RetrievalProgress> => [0xb670d335,0xe83b,0x58b1,0xad,0x7b,0x84,0x03,0x96,0x08,0x5c,0x65] as IID_AsyncOperationProgressHandler_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationProgressHandler<super::web::syndication::SyndicationItem, super::web::syndication::TransferProgress> => [0x1ffb57b2,0xd2de,0x5559,0x8d,0xe2,0x50,0x10,0x9c,0x63,0x53,0x9b] as IID_AsyncOperationProgressHandler_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for AsyncOperationProgressHandler<u32, u32> => [0xea0fe405,0xd432,0x5ac7,0x9e,0xf8,0x5a,0x65,0xe1,0xf9,0x7d,0x7e] as IID_AsyncOperationProgressHandler_2_System_UInt32_System_UInt32 }
		RT_PINTERFACE!{ for AsyncOperationProgressHandler<u64, u64> => [0xffb2b65d,0x4120,0x5d13,0x82,0x6d,0x10,0x78,0x51,0xe6,0xbb,0x1c] as IID_AsyncOperationProgressHandler_2_System_UInt64_System_UInt64 }
		RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<bool, f64> => [0x0ec5345b,0xb37a,0x5cd5,0x83,0xd7,0x95,0x90,0xcd,0xf4,0x45,0xb5] as IID_AsyncOperationWithProgressCompletedHandler_2_System_Boolean_System_Double }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<collections::IVectorView<super::devices::sms::ISmsMessage>, i32> => [0xc0454cfc,0x2f2f,0x5e0c,0x8d,0xe9,0x58,0xb9,0xe8,0x2a,0x03,0xba] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sms_ISmsMessage__System_Int32 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<HString, super::web::http::HttpProgress> => [0x98ab9acb,0x38db,0x588f,0xa5,0xf9,0x9f,0x48,0x4b,0x22,0x00,0xcd] as IID_AsyncOperationWithProgressCompletedHandler_2_System_String_Windows_Web_Http_HttpProgress }
		RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<HString, u64> => [0xbd75eebe,0xe7b5,0x5af6,0x84,0x15,0xa4,0xb9,0xc9,0x04,0x52,0x02] as IID_AsyncOperationWithProgressCompletedHandler_2_System_String_System_UInt64 }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::devices::scanners::ImageScannerScanResult, u32> => [0xbd8bdbd8,0x459a,0x52dc,0xb1,0x01,0x75,0xb3,0x98,0xa6,0x1a,0xef] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Devices_Scanners_ImageScannerScanResult_System_UInt32 }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::gaming::input::custom::GipFirmwareUpdateResult, super::gaming::input::custom::GipFirmwareUpdateProgress> => [0x61b95949,0xa027,0x51d8,0x9f,0x33,0x37,0x92,0x74,0x51,0x50,0x2b] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Gaming_Input_Custom_GipFirmwareUpdateResult_Windows_Gaming_Input_Custom_GipFirmwareUpdateProgress }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::management::deployment::DeploymentResult, super::management::deployment::DeploymentProgress> => [0x6e1c7129,0x61e0,0x5d88,0x9f,0xd4,0xf3,0xce,0x65,0xa0,0x57,0x19] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Management_Deployment_DeploymentResult_Windows_Management_Deployment_DeploymentProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::media::import::PhotoImportDeleteImportedItemsFromSourceResult, f64> => [0x5e24e7c1,0xf356,0x59c1,0xb0,0xe5,0xb2,0xdf,0xb2,0x25,0xeb,0x4e] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Media_Import_PhotoImportDeleteImportedItemsFromSourceResult_System_Double }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::media::import::PhotoImportFindItemsResult, u32> => [0xdd7a69d4,0x2456,0x5250,0x96,0x53,0x31,0xbd,0x2d,0x48,0x71,0x04] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Media_Import_PhotoImportFindItemsResult_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::media::import::PhotoImportImportItemsResult, super::media::import::PhotoImportProgress> => [0x0d141ec2,0xee90,0x53a0,0x93,0x18,0x10,0xf0,0xab,0x7f,0x2d,0x17] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Media_Import_PhotoImportImportItemsResult_Windows_Media_Import_PhotoImportProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::media::protection::RenewalStatus, u32> => [0xec067827,0x67d9,0x59a6,0xa5,0x7b,0x3e,0x7c,0xa1,0x2b,0x89,0xc1] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Media_Protection_RenewalStatus_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::media::transcoding::TranscodeFailureReason, f64> => [0x080f1890,0x4fca,0x5165,0xa9,0x89,0x4b,0x07,0xda,0x8e,0x0b,0x53] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Media_Transcoding_TranscodeFailureReason_System_Double }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::networking::backgroundtransfer::DownloadOperation, super::networking::backgroundtransfer::DownloadOperation> => [0x781b479c,0x0207,0x5d15,0xa4,0xe5,0x78,0x37,0xd1,0x3b,0xf9,0x3d] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Networking_BackgroundTransfer_DownloadOperation_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::networking::backgroundtransfer::UploadOperation, super::networking::backgroundtransfer::UploadOperation> => [0x79fcae93,0x53ec,0x5f66,0xab,0x34,0x82,0x6a,0xf7,0x8e,0xc1,0x1a] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Networking_BackgroundTransfer_UploadOperation_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::services::store::StorePackageUpdateResult, super::services::store::StorePackageUpdateStatus> => [0xb3be0c8b,0xef1d,0x56dc,0x85,0x47,0x4d,0xa0,0x6e,0xa5,0x63,0xdf] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Services_Store_StorePackageUpdateResult_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IBuffer, super::web::http::HttpProgress> => [0xb0cf2f85,0x6992,0x52be,0x8f,0x0b,0x93,0x96,0x4b,0x14,0xd9,0x63] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IBuffer, u32> => [0x06386a7a,0xe009,0x5b0b,0xab,0x68,0xa8,0xe4,0x8b,0x51,0x66,0x47] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_System_UInt32 }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IBuffer, u64> => [0xabc81235,0x39c7,0x59bf,0x99,0x48,0x2d,0x14,0xa9,0x3d,0x40,0xfd] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IBuffer_System_UInt64 }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IInputStream, super::web::http::HttpProgress> => [0x504a34ec,0x5499,0x5a16,0xbf,0xfc,0x3c,0xcb,0x64,0xa3,0x54,0x7a] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IInputStream_Windows_Web_Http_HttpProgress }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IInputStream, super::web::syndication::RetrievalProgress> => [0x76772ec1,0xc26f,0x5f6e,0x8d,0x3b,0x83,0x14,0x10,0x7c,0xef,0xeb] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IInputStream_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::storage::streams::IInputStream, u64> => [0x8db69706,0x3dd1,0x5a28,0x98,0x6a,0x93,0xbe,0x07,0x76,0xd9,0xc3] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Storage_Streams_IInputStream_System_UInt64 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::web::atompub::ServiceDocument, super::web::syndication::RetrievalProgress> => [0x5f03b1d3,0x470d,0x5be7,0x81,0x76,0x1c,0x9a,0x46,0x01,0x09,0x00] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Web_AtomPub_ServiceDocument_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::web::http::HttpResponseMessage, super::web::http::HttpProgress> => [0xbeadb572,0xf9a3,0x5e93,0xb6,0xca,0xe3,0x11,0xb6,0x59,0x33,0xfc] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Web_Http_HttpResponseMessage_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::web::syndication::SyndicationFeed, super::web::syndication::RetrievalProgress> => [0x0e3d7f70,0x4e8c,0x5260,0xa7,0xe5,0x78,0x6e,0x05,0xbd,0xed,0x99] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Web_Syndication_SyndicationFeed_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::web::syndication::SyndicationItem, super::web::syndication::RetrievalProgress> => [0x9de7422b,0x4bc3,0x5546,0x87,0xb8,0x2e,0xeb,0xfd,0x60,0xbe,0x48] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<super::web::syndication::SyndicationItem, super::web::syndication::TransferProgress> => [0x8a796ea9,0xff95,0x50ef,0x93,0xea,0x71,0x1b,0xf7,0x94,0x64,0x73] as IID_AsyncOperationWithProgressCompletedHandler_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<u32, u32> => [0x1e466dc5,0x840f,0x54f9,0xb8,0x77,0x5e,0x3a,0x9f,0x4b,0x6c,0x74] as IID_AsyncOperationWithProgressCompletedHandler_2_System_UInt32_System_UInt32 }
		RT_PINTERFACE!{ for AsyncOperationWithProgressCompletedHandler<u64, u64> => [0xd2024e41,0x5500,0x5b5a,0xba,0x46,0xcb,0x70,0x09,0x59,0x6a,0x2f] as IID_AsyncOperationWithProgressCompletedHandler_2_System_UInt64_System_UInt64 }
		RT_PINTERFACE!{ for EventHandler<diagnostics::TracingStatusChangedEventArgs> => [0x2bf27008,0x2eb4,0x5675,0xb1,0xcd,0xe9,0x90,0x6c,0xc5,0xce,0x64] as IID_EventHandler_1_Windows_Foundation_Diagnostics_TracingStatusChangedEventArgs }
		RT_PINTERFACE!{ for EventHandler<IInspectable> => [0xc50898f6,0xc536,0x5f47,0x85,0x83,0x8b,0x2c,0x24,0x38,0xa1,0x3b] as IID_EventHandler_1_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for EventHandler<super::applicationmodel::activation::BackgroundActivatedEventArgs> => [0x49a07732,0xe7b8,0x5c5b,0x9d,0xe7,0x22,0xe3,0x3c,0xb9,0x70,0x04] as IID_EventHandler_1_Windows_ApplicationModel_Activation_BackgroundActivatedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for EventHandler<super::applicationmodel::core::UnhandledErrorDetectedEventArgs> => [0xf68bc421,0x6b54,0x559b,0x9c,0xdd,0x48,0x9a,0xad,0x0b,0xd4,0x1d] as IID_EventHandler_1_Windows_ApplicationModel_Core_UnhandledErrorDetectedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for EventHandler<super::applicationmodel::EnteredBackgroundEventArgs> => [0xe0739c32,0xfc14,0x5361,0xa8,0xb3,0x08,0x09,0x69,0x9f,0xbc,0xbd] as IID_EventHandler_1_Windows_ApplicationModel_EnteredBackgroundEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for EventHandler<super::applicationmodel::LeavingBackgroundEventArgs> => [0x9b6171c2,0xabb2,0x5194,0xaf,0xc0,0xce,0xf1,0x67,0xc4,0x24,0xeb] as IID_EventHandler_1_Windows_ApplicationModel_LeavingBackgroundEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for EventHandler<super::applicationmodel::SuspendingEventArgs> => [0x338579bf,0x1a35,0x5cc4,0xa6,0x22,0xa6,0xf3,0x84,0xfd,0x89,0x2c] as IID_EventHandler_1_Windows_ApplicationModel_SuspendingEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for EventHandler<super::devices::pointofservice::ClaimedBarcodeScanner> => [0xc0acd2ae,0x5b55,0x588d,0x81,0x1b,0xbe,0x33,0xa4,0xfd,0xda,0x57] as IID_EventHandler_1_Windows_Devices_PointOfService_ClaimedBarcodeScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for EventHandler<super::devices::pointofservice::ClaimedMagneticStripeReader> => [0x8006bf5d,0x0895,0x5b8c,0x80,0x8a,0x6b,0xb8,0xf2,0x67,0x94,0xfa] as IID_EventHandler_1_Windows_Devices_PointOfService_ClaimedMagneticStripeReader }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for EventHandler<super::gaming::input::ArcadeStick> => [0x6afb8188,0xd28d,0x539b,0xbb,0x69,0xea,0x17,0x63,0xfb,0x99,0x20] as IID_EventHandler_1_Windows_Gaming_Input_ArcadeStick }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for EventHandler<super::gaming::input::Gamepad> => [0x8a7639ee,0x624a,0x501a,0xbb,0x53,0x56,0x2d,0x1e,0xc1,0x1b,0x52] as IID_EventHandler_1_Windows_Gaming_Input_Gamepad }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for EventHandler<super::gaming::input::RacingWheel> => [0x352ec824,0xf64b,0x5353,0x80,0xea,0x7f,0xf5,0x8e,0x3b,0x92,0xa4] as IID_EventHandler_1_Windows_Gaming_Input_RacingWheel }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for EventHandler<super::gaming::input::UINavigationController> => [0x9eaec424,0x75c1,0x5871,0x8d,0xa9,0xce,0x59,0x0c,0x65,0x30,0x45] as IID_EventHandler_1_Windows_Gaming_Input_UINavigationController }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for EventHandler<super::media::playback::MediaPlayerDataReceivedEventArgs> => [0x078fc818,0x19f5,0x5b8a,0xac,0x82,0x25,0x19,0x3b,0xea,0x56,0xee] as IID_EventHandler_1_Windows_Media_Playback_MediaPlayerDataReceivedEventArgs }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for EventHandler<super::security::authentication::identity::provider::SecondaryAuthenticationFactorAuthenticationStageChangedEventArgs> => [0x10409b3c,0x42e4,0x586f,0x84,0xc1,0x80,0x3d,0xa2,0x37,0x65,0xaf] as IID_EventHandler_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorAuthenticationStageChangedEventArgs }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for EventHandler<super::security::enterprisedata::ProtectedAccessResumedEventArgs> => [0x9efe4d36,0x6549,0x5222,0x9b,0xc2,0x4d,0x5d,0x92,0x9d,0x00,0x5c] as IID_EventHandler_1_Windows_Security_EnterpriseData_ProtectedAccessResumedEventArgs }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for EventHandler<super::security::enterprisedata::ProtectedAccessSuspendingEventArgs> => [0xfe8bb4d8,0x0d3d,0x5416,0xb3,0x90,0x9e,0xad,0x5d,0xd9,0xb3,0x84] as IID_EventHandler_1_Windows_Security_EnterpriseData_ProtectedAccessSuspendingEventArgs }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for EventHandler<super::security::enterprisedata::ProtectedContentRevokedEventArgs> => [0x4ff76357,0x6805,0x573e,0xa6,0x7d,0x2c,0x59,0x4f,0x50,0x04,0xb7] as IID_EventHandler_1_Windows_Security_EnterpriseData_ProtectedContentRevokedEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for EventHandler<super::system::AppMemoryUsageLimitChangingEventArgs> => [0x6030e7c3,0xf93f,0x5e9c,0x9b,0xa2,0x9a,0x01,0x8d,0x2b,0x09,0xc0] as IID_EventHandler_1_Windows_System_AppMemoryUsageLimitChangingEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for EventHandler<super::system::UserDeviceAssociationChangedEventArgs> => [0xd3a3d4c5,0xd8b6,0x5a0e,0x88,0xed,0xa5,0x49,0x9c,0x37,0x7b,0xe3] as IID_EventHandler_1_Windows_System_UserDeviceAssociationChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for EventHandler<super::ui::core::BackRequestedEventArgs> => [0xca821060,0x002b,0x526d,0x81,0x22,0x98,0x26,0x30,0xd7,0xcd,0xbe] as IID_EventHandler_1_Windows_UI_Core_BackRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for EventHandler<super::ui::xaml::controls::DatePickerValueChangedEventArgs> => [0x18a84f8e,0xc1ec,0x5b25,0xac,0x98,0x81,0x82,0x67,0xe6,0xf9,0xa4] as IID_EventHandler_1_Windows_UI_Xaml_Controls_DatePickerValueChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for EventHandler<super::ui::xaml::controls::ScrollViewerViewChangedEventArgs> => [0x354c0f34,0xe691,0x502a,0xa4,0x44,0xd5,0xf0,0x7a,0xee,0x31,0x0e] as IID_EventHandler_1_Windows_UI_Xaml_Controls_ScrollViewerViewChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for EventHandler<super::ui::xaml::controls::ScrollViewerViewChangingEventArgs> => [0xe0c06ef2,0xdbc9,0x511c,0xba,0xb6,0x25,0x75,0x6d,0xd5,0x16,0xa3] as IID_EventHandler_1_Windows_UI_Xaml_Controls_ScrollViewerViewChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for EventHandler<super::ui::xaml::controls::TimePickerValueChangedEventArgs> => [0xebc4d41b,0x356a,0x59ca,0xb1,0x35,0x0e,0xc3,0x4f,0x68,0xc3,0x07] as IID_EventHandler_1_Windows_UI_Xaml_Controls_TimePickerValueChangedEventArgs }
		RT_PINTERFACE!{ for IAsyncActionWithProgress<f64> => [0x4f1430a6,0xa825,0x56ca,0xb0,0x47,0x1a,0x9b,0xad,0x52,0xba,0x67] as IID_IAsyncActionWithProgress_1_System_Double }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncActionWithProgress<super::web::syndication::TransferProgress> => [0xb7eb83f5,0xa746,0x50f2,0xb9,0x1f,0x31,0x80,0x31,0x61,0xcc,0xc7] as IID_IAsyncActionWithProgress_1_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for IAsyncActionWithProgress<u64> => [0x43f713d0,0xc49d,0x5e55,0xae,0xbf,0xaf,0x39,0x57,0x68,0x35,0x1e] as IID_IAsyncActionWithProgress_1_System_UInt64 }
		RT_PINTERFACE!{ for IAsyncOperation<::Guid> => [0x6607bc41,0x294b,0x5975,0x9c,0x3f,0x4b,0x49,0x83,0x6d,0x09,0x16] as IID_IAsyncOperation_1_System_Guid }
		RT_PINTERFACE!{ for IAsyncOperation<bool> => [0xcdb5efb3,0x5788,0x509d,0x9b,0xe1,0x71,0xcc,0xb8,0xa3,0x36,0x2a] as IID_IAsyncOperation_1_System_Boolean }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IMap<HString, IInspectable>> => [0x127e39c7,0x07c1,0x58e5,0xb4,0x8e,0x3a,0x47,0x29,0x83,0x9f,0xec] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IMap_2_System_String_System_Object }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IMapView<HString, IInspectable>> => [0x5dcbee48,0x9965,0x51da,0xa4,0x61,0x17,0x7c,0x88,0x5b,0xe7,0xe5] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IAsyncOperation<collections::IMapView<HString, super::perception::spatial::SpatialAnchor>> => [0xbbe07728,0xda33,0x52c5,0xaa,0xe0,0xa5,0xe7,0x4c,0xdf,0x04,0x71] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IMapView_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IMapView<HString, super::storage::streams::RandomAccessStreamReference>> => [0xfc012d44,0x2dcf,0x5162,0xbe,0x9a,0x76,0x68,0x67,0x5a,0xa5,0x90] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IMapView_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IMapView<u32, super::storage::streams::IBuffer>> => [0xd4904ded,0xbc1d,0x5933,0xae,0xcf,0xe4,0x2c,0x5d,0x46,0x5b,0xff] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IMapView_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IPropertySet> => [0x490b0686,0xafd7,0x5037,0x96,0x47,0xd8,0xfe,0x24,0x8f,0x18,0x2c] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IPropertySet }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IVector<HString>> => [0x92b02cd3,0xaa6e,0x573d,0xbc,0x03,0x8d,0x23,0x09,0xcb,0xa3,0xeb] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVector_1_System_String }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVector<super::applicationmodel::contacts::Contact>> => [0x0f0ff4e8,0xd25d,0x53a8,0xba,0x87,0x1a,0x6b,0x23,0xe4,0x31,0x5c] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVector_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVector<super::media::faceanalysis::DetectedFace>> => [0x37f1d7dc,0xa1a4,0x5a94,0xb3,0x3b,0x74,0x20,0x5a,0x65,0xa1,0xed] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVector_1_Windows_Media_FaceAnalysis_DetectedFace }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<collections::IMapView<HString, IInspectable>>> => [0xfc227365,0x219d,0x5d59,0x8b,0x5b,0x58,0xeb,0x0a,0x91,0xca,0x0a] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<HString>> => [0x2f92b529,0x119b,0x575a,0xa4,0x19,0x39,0x04,0xb4,0xe4,0x1a,0xf2] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_System_String }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<IInspectable>> => [0xd671d332,0x22aa,0x5597,0x8d,0xcc,0x24,0x59,0xea,0xb4,0x94,0x18] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::appextensions::AppExtension>> => [0x83295bb9,0x10df,0x530f,0xa0,0xd7,0xbe,0x05,0xba,0x80,0xcb,0x18] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_AppExtensions_AppExtension }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::AppInfo>> => [0x07543d91,0x8610,0x5152,0xb0,0xe4,0x43,0xd6,0xe4,0xcd,0xd0,0xcb] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_AppInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::appointments::Appointment>> => [0xa6bb6962,0xe2c1,0x5da2,0x99,0x38,0x15,0xef,0x82,0xcb,0xd1,0xcc] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::appointments::AppointmentCalendar>> => [0xd26021ac,0x99b4,0x5c40,0xb0,0xd2,0xd6,0x83,0x5d,0x2e,0x92,0x02] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::appointments::AppointmentException>> => [0x87e171ac,0x53fe,0x50ea,0xbe,0xb3,0x05,0x89,0x99,0x3a,0xc9,0x84] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentException }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::appointments::AppointmentStoreChange>> => [0xd54944b9,0xb72e,0x50bc,0xa6,0x4a,0x19,0x39,0x6e,0x0d,0x1b,0xcc] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentStoreChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::calls::PhoneCallHistoryEntry>> => [0x2258b912,0xeb70,0x5361,0xb2,0x0a,0x73,0x1e,0x15,0xbb,0x90,0x97] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::ChatConversation>> => [0xd531f714,0xd3c7,0x589b,0x87,0x5c,0xbf,0xaa,0x27,0x52,0x24,0x78] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::ChatMessage>> => [0xd9f6a9dd,0x7fcf,0x5e9e,0x86,0xc7,0x15,0x16,0x63,0xdb,0x67,0xcc] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::ChatMessageChange>> => [0x831968b7,0xaa61,0x58cc,0x87,0x13,0x98,0xf6,0x5c,0xad,0x4e,0xd9] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::ChatMessageTransport>> => [0xd558786d,0x95ce,0x5f23,0x9e,0x90,0x53,0x99,0x02,0xac,0x92,0xa6] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::IChatItem>> => [0x65b3eea1,0x7b6f,0x51a0,0xa2,0xeb,0x7f,0xb1,0xdc,0x47,0x30,0x22] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_IChatItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::chat::RcsTransport>> => [0x17e1f428,0x6e60,0x5153,0xb0,0xa6,0x5f,0xaf,0x18,0x65,0x61,0xc1] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::Contact>> => [0x938328e5,0xd460,0x50cc,0x9c,0x94,0x70,0x26,0xa6,0xb2,0xe5,0xb2] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::ContactAnnotation>> => [0x8ebd10f1,0xc10b,0x50a4,0xa7,0xe5,0xb1,0xae,0x2c,0x32,0xba,0xb7] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::ContactAnnotationList>> => [0xa549e2bf,0x9e24,0x5352,0x92,0x3d,0xff,0x18,0x4f,0x96,0xac,0xbb] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::ContactChange>> => [0x48db578e,0x9eab,0x5e97,0x82,0xee,0x0f,0xd0,0x79,0x96,0xc6,0x66] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::ContactInformation>> => [0xeab8500a,0x6a6f,0x5b05,0x89,0xc2,0x8d,0xcd,0x66,0x02,0x3b,0x3d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::contacts::ContactList>> => [0x79fd4783,0x5cc9,0x571b,0xbc,0x42,0xe2,0xe2,0xf8,0xdd,0xf9,0x67] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::core::AppListEntry>> => [0xd3bcf8a0,0x3538,0x5dae,0x98,0xd7,0x1f,0x2a,0xb8,0x8c,0x3f,0x01] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Core_AppListEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailCertificateValidationStatus>> => [0xf3e7ef5b,0x8894,0x5488,0x97,0xef,0x02,0x9c,0xa4,0x91,0x39,0x47] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailCertificateValidationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailFolder>> => [0x0c1ca8b9,0x7f85,0x534d,0x98,0xf1,0x0f,0x5c,0xd8,0xe7,0x2c,0x1f] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailMailbox>> => [0x5bed07ec,0xf5d5,0x5b25,0xb0,0x67,0x9b,0x22,0xa4,0xa7,0x62,0xea] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailMailboxChange>> => [0x81153d29,0xd502,0x5050,0xaf,0x64,0xb1,0x33,0x34,0x62,0xd1,0x6a] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMailboxChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailMessage>> => [0x47065121,0xdc80,0x59f9,0x87,0x19,0x3f,0x0c,0x6e,0xef,0x87,0x53] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::email::EmailRecipientResolutionResult>> => [0x12a76f8e,0xed11,0x5c2b,0x81,0xc6,0x11,0x02,0x96,0xfc,0x7a,0x43] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Email_EmailRecipientResolutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::resources::management::IndexedResourceCandidate>> => [0xd2d41b8a,0x6616,0x5de8,0xaa,0xf9,0x32,0xae,0x51,0xf6,0x7f,0xcb] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Resources_Management_IndexedResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::StartupTask>> => [0x16543165,0x5b65,0x5683,0x8a,0x02,0xc3,0x85,0x65,0x91,0x58,0xbd] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::store::preview::installcontrol::AppInstallItem>> => [0x9267e107,0x2ac6,0x5e0d,0x86,0xe9,0x31,0x54,0xf6,0x16,0xc6,0x8b] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::store::preview::StorePreviewProductInfo>> => [0x49c36a66,0x3908,0x51b3,0x84,0x02,0xeb,0x8e,0x94,0xc6,0x88,0x64] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_StorePreviewProductInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::store::preview::StoreSystemFeature>> => [0xb1713163,0xee1b,0x5290,0x83,0x16,0xf7,0xeb,0xb9,0xd5,0x31,0x63] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_Preview_StoreSystemFeature }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::store::UnfulfilledConsumable>> => [0xf1cd679a,0x3a8f,0x5e1b,0x82,0xf1,0xf2,0xfd,0x09,0x16,0xca,0x3f] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Store_UnfulfilledConsumable }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::userdataaccounts::UserDataAccount>> => [0x8461a475,0x5f2f,0x5a03,0xb9,0xf8,0x01,0xe1,0x32,0x4d,0xef,0x3b] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::applicationmodel::wallet::WalletItem>> => [0x23540ddd,0x166f,0x5b93,0x86,0x69,0xe3,0x40,0xb5,0xe1,0x82,0x0d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::data::text::TextPhoneme>> => [0x6bc3019d,0xdd10,0x5510,0xb1,0x64,0x80,0x8c,0x23,0x2b,0x7d,0x64] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextPhoneme }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::adc::AdcController>> => [0x1b0cddfb,0xd255,0x5a93,0xbc,0xb9,0xde,0x20,0x47,0xa3,0xe4,0xf3] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::geolocation::Geoposition>> => [0x9454b533,0xefb4,0x5385,0x8d,0x3a,0x43,0x7f,0xab,0xc3,0x2d,0x91] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::gpio::GpioController>> => [0x5da3faf4,0x60a7,0x5a14,0x93,0x19,0x39,0x41,0xdf,0xb1,0x3f,0xed] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::i2c::I2cController>> => [0x77f52ff7,0xaba0,0x54bb,0x89,0x1a,0x49,0x35,0x1a,0x83,0x8e,0x33] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::i2c::provider::II2cControllerProvider>> => [0x5fe77838,0x1125,0x5b2c,0xa2,0x81,0xe0,0x6a,0x3d,0xfb,0xb7,0x6e] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_I2c_Provider_II2cControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::perception::PerceptionColorFrameSource>> => [0x33845b5f,0xd59e,0x5271,0xbb,0x68,0xf7,0x4e,0x9d,0x6a,0x53,0x8d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::perception::PerceptionDepthFrameSource>> => [0xe20a534d,0xd406,0x5964,0x84,0x65,0xe6,0xdc,0x75,0xc5,0x82,0x1d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::perception::PerceptionInfraredFrameSource>> => [0xb11eecaa,0x6f8c,0x5040,0x8d,0x46,0xc3,0x20,0x4c,0x56,0x25,0x82] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::pwm::PwmController>> => [0xe4151e8d,0x4688,0x5023,0x9f,0x5d,0x00,0x8b,0xbd,0x90,0x48,0x91] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::radios::Radio>> => [0x040b54a1,0x203e,0x58f5,0x94,0x3f,0xc1,0xcc,0xa8,0x6b,0xd5,0x32] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::sensors::ActivitySensorReading>> => [0xcd781b82,0x7900,0x51a3,0x80,0xce,0x90,0x3e,0x2e,0x0a,0x4f,0x0e] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::sensors::PedometerReading>> => [0x2aeac503,0xa3a8,0x57b3,0xa8,0xa9,0xe1,0x6b,0x0c,0xd4,0xc0,0xa4] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::smartcards::SmartCard>> => [0x3b2691b2,0xfc5e,0x59ff,0x8c,0x6f,0xe6,0xdd,0x29,0xa9,0x67,0xfc] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_SmartCards_SmartCard }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::spi::provider::ISpiControllerProvider>> => [0xb3af3490,0xdede,0x59d1,0xb5,0x62,0x1f,0x6b,0xe7,0x1a,0xe1,0x39] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Spi_Provider_ISpiControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::spi::SpiController>> => [0x89624331,0xf802,0x56f7,0x9b,0x33,0x17,0xc6,0x16,0xec,0xbc,0xfa] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::devices::wifi::WiFiAdapter>> => [0x3140802b,0x987c,0x5c56,0xa4,0x30,0x90,0xfb,0xc1,0x89,0x8d,0xda] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::gaming::preview::gamesenumeration::GameListEntry>> => [0x721a94fb,0xa733,0x5e19,0x8a,0xbf,0x03,0x24,0x9c,0x29,0x87,0x0e] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Gaming_Preview_GamesEnumeration_GameListEntry }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::graphics::imaging::ImageStream>> => [0xa58d867e,0xbeef,0x5f17,0xb7,0xcf,0xe4,0xc8,0x7b,0xe2,0x2e,0xe4] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::management::deployment::PackageVolume>> => [0x1e357e07,0xd337,0x5c07,0xae,0x06,0x90,0x0c,0x1b,0x9a,0x77,0xc1] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::media::capture::frames::MediaFrameSourceGroup>> => [0xa795889f,0x6d49,0x5687,0xaa,0xbe,0xf2,0xfc,0x62,0x37,0xfa,0x1a] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::media::import::PhotoImportSource>> => [0x3ef45f6e,0x39b9,0x5976,0x86,0x43,0x6b,0xaf,0xea,0x4d,0x14,0x79] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::backgroundtransfer::DownloadOperation>> => [0xae42cddf,0x3042,0x5d92,0xa0,0x1e,0x64,0x3c,0x25,0x2b,0x80,0x50] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::backgroundtransfer::UploadOperation>> => [0x3e4c6a3c,0x48a4,0x5e22,0xb2,0x9a,0x3e,0x42,0x94,0x69,0x46,0x2f] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::connectivity::AttributedNetworkUsage>> => [0x9d8a4113,0xe7f3,0x552d,0x9a,0x8c,0x1c,0x25,0xe2,0x13,0x72,0x53] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_AttributedNetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::connectivity::ConnectionProfile>> => [0xc0023294,0xc2cb,0x52f0,0xa9,0xf4,0x21,0x91,0x60,0x32,0xf6,0x9d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::connectivity::ConnectivityInterval>> => [0xaf96d70b,0x41c7,0x5dc6,0x98,0x95,0xea,0x04,0x3a,0x88,0x5d,0x8d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_ConnectivityInterval }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::connectivity::NetworkUsage>> => [0x05c9e081,0x6229,0x5049,0x8e,0xea,0xa4,0x98,0x40,0x7c,0x00,0xd5] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Connectivity_NetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::EndpointPair>> => [0xafc2ff8e,0xe393,0x566a,0x89,0xc4,0xd0,0x43,0xe9,0x40,0x05,0x0d] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_EndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::proximity::PeerInformation>> => [0xa36ec4bc,0x607a,0x5180,0xa7,0x85,0x40,0x42,0xf8,0x79,0x5c,0x8b] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::networking::vpn::IVpnProfile>> => [0x69d957be,0x045e,0x538f,0x98,0xf6,0x1a,0xa6,0x5c,0xee,0x24,0x4a] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Networking_Vpn_IVpnProfile }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::security::authentication::identity::EnterpriseKeyCredentialRegistrationInfo>> => [0x0bd64c2f,0x8b1d,0x56d4,0xa7,0x07,0xfa,0xb5,0x31,0x5e,0x72,0x78] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Identity_EnterpriseKeyCredentialRegistrationInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::security::authentication::identity::provider::SecondaryAuthenticationFactorInfo>> => [0x47eb155b,0xabe0,0x55a5,0x93,0x10,0xfe,0xb1,0xdd,0x57,0xdc,0xa5] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::security::authentication::web::provider::WebAccountClientView>> => [0x116827c1,0x187e,0x5095,0xa1,0x4b,0xdf,0x41,0x11,0xc6,0x38,0xc2] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Authentication_Web_Provider_WebAccountClientView }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::security::credentials::WebAccount>> => [0x66b59040,0x7c93,0x5f96,0xb5,0x2f,0x2c,0x09,0x8d,0x15,0x57,0xd0] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::security::cryptography::certificates::Certificate>> => [0x9b26648e,0xb32f,0x5909,0xa6,0x35,0x78,0xe6,0xd3,0xbb,0x40,0x67] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::services::store::StorePackageUpdate>> => [0x0ac66c33,0x45b8,0x546b,0xaa,0xaf,0xd5,0x8d,0x62,0xa4,0xc5,0xc5] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Services_Store_StorePackageUpdate }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::bulkaccess::FileInformation>> => [0x222f6bb6,0xe71e,0x55cb,0x88,0x5d,0xe0,0x51,0xe3,0x59,0x95,0xdc] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_FileInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::bulkaccess::FolderInformation>> => [0x7f10e569,0x2bf7,0x5752,0x8f,0x75,0x60,0x28,0x09,0xa7,0xd3,0x04] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_FolderInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::bulkaccess::IStorageItemInformation>> => [0x413d160c,0x3e1a,0x5603,0xac,0xba,0x1e,0x17,0x6d,0x6a,0x60,0x82] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_BulkAccess_IStorageItemInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::IStorageItem>> => [0x4b1c0fd7,0x7a01,0x5e7a,0xa6,0xfe,0xbe,0x45,0x00,0x28,0x3f,0x23] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::search::IIndexableContent>> => [0x919850e1,0x084b,0x5f9b,0xa0,0xa0,0x50,0xdb,0x0c,0xd5,0xda,0x91] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_Search_IIndexableContent }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::StorageFile>> => [0x03362e33,0xe413,0x5f29,0x97,0xd0,0x48,0xa4,0x78,0x09,0x35,0xf9] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::StorageFolder>> => [0xca40b21b,0xaeb1,0x5a61,0x9e,0x08,0x3b,0xd5,0xd9,0x59,0x40,0x23] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::storage::StorageLibraryChange>> => [0x66e11b8a,0x9003,0x52c9,0x84,0xa8,0xae,0x5c,0xce,0xbe,0x8c,0xf9] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_Storage_StorageLibraryChange }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::system::User>> => [0xe44ea1df,0xbb85,0x5a8c,0xbd,0xdc,0xc8,0xe9,0x60,0xc3,0x55,0xc9] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_System_User }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::ui::input::inking::InkRecognitionResult>> => [0xb1923f59,0xd674,0x5365,0xb9,0x9a,0x3f,0x1e,0x52,0x26,0x8c,0x7f] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_Input_Inking_InkRecognitionResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::ui::notifications::UserNotification>> => [0xbf7f3d3c,0x230f,0x54ea,0xad,0x74,0x0c,0xf6,0xc5,0x5c,0xd8,0xd1] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_Notifications_UserNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<super::ui::startscreen::SecondaryTile>> => [0xf72d55b2,0xb004,0x5e35,0xb5,0xc4,0x22,0xe8,0x76,0x19,0xb3,0x0a] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_Windows_UI_StartScreen_SecondaryTile }
		RT_PINTERFACE!{ for IAsyncOperation<collections::IVectorView<u32>> => [0x52c56f3c,0x713a,0x5162,0x9e,0x62,0x36,0x2c,0xe7,0xed,0x53,0xbe] as IID_IAsyncOperation_1_Windows_Foundation_Collections_IVectorView_1_System_UInt32 }
		RT_PINTERFACE!{ for IAsyncOperation<diagnostics::ErrorDetails> => [0x9b05106d,0x77e0,0x5c24,0x82,0xb0,0x9b,0x2d,0xc8,0xf7,0x96,0x71] as IID_IAsyncOperation_1_Windows_Foundation_Diagnostics_ErrorDetails }
		RT_PINTERFACE!{ for IAsyncOperation<HString> => [0x3e1fe603,0xf897,0x5263,0xb3,0x28,0x08,0x06,0x42,0x6b,0x8a,0x79] as IID_IAsyncOperation_1_System_String }
		RT_PINTERFACE!{ for IAsyncOperation<i32> => [0x968b9665,0x06ed,0x5774,0x8f,0x53,0x8e,0xde,0xab,0xd5,0xf7,0xb5] as IID_IAsyncOperation_1_System_Int32 }
		RT_PINTERFACE!{ for IAsyncOperation<i64> => [0xcc468085,0x4bef,0x5584,0x90,0x7c,0x92,0x23,0xd2,0x67,0x90,0x19] as IID_IAsyncOperation_1_System_Int64 }
		RT_PINTERFACE!{ for IAsyncOperation<IInspectable> => [0xabf53c57,0xee50,0x5342,0xb5,0x2a,0x26,0xe3,0xb8,0xcc,0x02,0x4f] as IID_IAsyncOperation_1_System_Object }
		RT_PINTERFACE!{ for IAsyncOperation<IReference<DateTime>> => [0x2025b34f,0x4214,0x56ab,0xab,0xfe,0x2f,0xbe,0x65,0x95,0xda,0x9d] as IID_IAsyncOperation_1_Windows_Foundation_IReference_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IAsyncOperation<IReference<TimeSpan>> => [0x24a901ad,0x910f,0x5c0f,0xb2,0x3c,0x67,0x00,0x75,0x77,0xa5,0x58] as IID_IAsyncOperation_1_Windows_Foundation_IReference_1_Windows_Foundation_TimeSpan }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appointments::Appointment> => [0x0c5732f8,0x5bb9,0x5bb3,0x93,0xe5,0xb8,0x7e,0x43,0xe0,0xcd,0x6a] as IID_IAsyncOperation_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appointments::AppointmentCalendar> => [0x6bb17a95,0x918e,0x5ad0,0xbb,0xc2,0xbc,0xc5,0xfa,0x1f,0xf9,0x36] as IID_IAsyncOperation_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appointments::AppointmentConflictResult> => [0xb376080f,0xe5b2,0x5ae2,0x99,0x01,0x86,0xcf,0x77,0xba,0x5d,0x00] as IID_IAsyncOperation_1_Windows_ApplicationModel_Appointments_AppointmentConflictResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appointments::AppointmentStore> => [0x63798415,0x4d1f,0x5fc7,0x87,0x29,0x79,0xa2,0x82,0xbc,0xec,0xa4] as IID_IAsyncOperation_1_Windows_ApplicationModel_Appointments_AppointmentStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appservice::AppServiceConnectionStatus> => [0x0d0e6663,0x2639,0x5a9a,0x9c,0xbc,0x30,0xd7,0xd4,0xce,0x53,0x3b] as IID_IAsyncOperation_1_Windows_ApplicationModel_AppService_AppServiceConnectionStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appservice::AppServiceResponse> => [0x48755a7c,0xc88f,0x5ef0,0x9b,0x4c,0x87,0x6f,0xcc,0x26,0x10,0xb4] as IID_IAsyncOperation_1_Windows_ApplicationModel_AppService_AppServiceResponse }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::appservice::AppServiceResponseStatus> => [0x98fdb842,0x5a0b,0x539a,0xa3,0x5c,0x55,0xac,0x5f,0x22,0x86,0x12] as IID_IAsyncOperation_1_Windows_ApplicationModel_AppService_AppServiceResponseStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::AlarmAccessStatus> => [0xa55a747d,0x59f6,0x5cb6,0xb4,0x39,0xc8,0xaa,0xd6,0x70,0x90,0x5c] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_AlarmAccessStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::ApplicationTriggerResult> => [0x47cbd985,0x0f08,0x5a3d,0x92,0xcf,0xb2,0x79,0x60,0x50,0x6e,0xd6] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_ApplicationTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::BackgroundAccessStatus> => [0x7b44e581,0xcfa9,0x5763,0xbe,0xd7,0x6a,0x65,0x73,0x9f,0x0d,0xbf] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_BackgroundAccessStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::DeviceConnectionChangeTrigger> => [0x9d01424d,0x5653,0x59f8,0xba,0x6b,0xd0,0xc0,0x77,0x34,0x6d,0x2d] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_DeviceConnectionChangeTrigger }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::DeviceTriggerResult> => [0xb5136c46,0x2f2e,0x511d,0x9e,0x8e,0x5e,0xf4,0xde,0xcb,0x1d,0xa7] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_DeviceTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::background::MediaProcessingTriggerResult> => [0x2595482c,0x1cbf,0x5691,0xa3,0x0d,0x21,0x64,0x90,0x9c,0x67,0x12] as IID_IAsyncOperation_1_Windows_ApplicationModel_Background_MediaProcessingTriggerResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::calls::PhoneCallHistoryEntry> => [0x785e7cca,0x90e2,0x5d03,0x8f,0x23,0xb3,0x35,0x8d,0x09,0xc9,0x51] as IID_IAsyncOperation_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::calls::PhoneCallHistoryStore> => [0x0d9a97b0,0x8796,0x52bf,0x80,0xda,0xb1,0x43,0x5f,0xe6,0x4a,0x26] as IID_IAsyncOperation_1_Windows_ApplicationModel_Calls_PhoneCallHistoryStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::calls::VoipPhoneCallResourceReservationStatus> => [0x8528be80,0x7ce9,0x5668,0x8e,0x48,0x46,0x9a,0xe5,0xba,0x9e,0xad] as IID_IAsyncOperation_1_Windows_ApplicationModel_Calls_VoipPhoneCallResourceReservationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatCapabilities> => [0x30889035,0xc687,0x573b,0x86,0xe4,0x02,0x4e,0x38,0xf2,0xaa,0x6d] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatCapabilities }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatConversation> => [0xc4d8e414,0x0e54,0x5adf,0x88,0xc3,0xe5,0x6d,0x4e,0x88,0xb5,0xd4] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatMessage> => [0xee129c22,0xda8f,0x5c55,0x90,0xb6,0xa7,0x3b,0xac,0xc9,0xd7,0x35] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatMessageStore> => [0x19642405,0x0e06,0x5119,0x9a,0xc5,0x16,0xcf,0xd1,0x06,0xb3,0x37] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatMessageStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatMessageTransport> => [0x275e7895,0x3a8e,0x5175,0xb7,0x6f,0x21,0xd2,0xe0,0x45,0xbd,0x2f] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::ChatSyncManager> => [0xa4667a6a,0x1c64,0x51f6,0x97,0x2e,0xa1,0x05,0x07,0x19,0xf8,0xea] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_ChatSyncManager }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::chat::RcsTransport> => [0xf88774e8,0x9664,0x5df5,0xab,0xbd,0xc6,0x45,0x56,0xd2,0x50,0x62] as IID_IAsyncOperation_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::Contact> => [0x857db963,0xf62c,0x53c4,0xa3,0xa0,0xf6,0xbf,0x0c,0x8f,0xd3,0xd3] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactAnnotation> => [0x61ea54c3,0xd629,0x5b5e,0xb5,0x81,0x63,0x05,0x04,0xb5,0x17,0x02] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactAnnotationList> => [0x3a0a5967,0xc17c,0x579f,0xba,0x05,0xcc,0x56,0xe0,0xa1,0xd0,0x91] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactAnnotationStore> => [0xc6912277,0x5dd3,0x5e50,0xa7,0xeb,0xa5,0x66,0x06,0x46,0xd4,0x32] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactAnnotationStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactBatch> => [0x446fb5e0,0x5d2b,0x591d,0xb8,0xde,0xfb,0x7c,0x95,0xfc,0x9f,0x37] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactInformation> => [0x0e51c030,0x27aa,0x561f,0xbb,0xd8,0x2f,0x57,0xc0,0x8f,0xef,0x83] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactList> => [0xae816b3d,0x57a8,0x50a7,0x80,0x7e,0x2c,0x76,0x8a,0x36,0x4a,0x4f] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::contacts::ContactStore> => [0x235e0791,0x9a3e,0x5723,0x87,0xf0,0x44,0xff,0xb7,0x86,0xc9,0xe1] as IID_IAsyncOperation_1_Windows_ApplicationModel_Contacts_ContactStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::datatransfer::DataPackage> => [0xa16f2d07,0xead3,0x53e4,0x94,0x90,0x75,0xbd,0xba,0xeb,0x7a,0x5b] as IID_IAsyncOperation_1_Windows_ApplicationModel_DataTransfer_DataPackage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::datatransfer::DataPackageOperation> => [0x8b98aea9,0x64f0,0x5672,0xb3,0x0e,0xdf,0xd9,0xc2,0xe4,0xf6,0xfe] as IID_IAsyncOperation_1_Windows_ApplicationModel_DataTransfer_DataPackageOperation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailConversation> => [0x6885966c,0x13b9,0x59cc,0xb3,0x58,0xad,0xf8,0x2e,0xec,0x84,0x2a] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailConversationBatch> => [0x7d87db9c,0x947d,0x5e0c,0x8c,0xf2,0x24,0x59,0x98,0xd1,0x9d,0x8f] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailConversationBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailFolder> => [0x6132274f,0x733d,0x5391,0x90,0x77,0x08,0x67,0xfc,0x33,0x09,0x16] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailItemCounts> => [0x5856790d,0x5204,0x5a99,0xb6,0x9e,0xc7,0x16,0x2f,0xd2,0x58,0x69] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailItemCounts }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMailbox> => [0x6f01f05e,0x988d,0x5b28,0xab,0xa8,0xdb,0xaa,0xbb,0x4e,0xb0,0xd9] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMailboxAutoReplySettings> => [0xb354d4c4,0xe4a0,0x5a3c,0xb8,0x97,0x8d,0xeb,0x45,0x8a,0xc6,0x73] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMailboxAutoReplySettings }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMailboxCreateFolderResult> => [0x6d5a0e81,0x6949,0x50f9,0xbf,0xfb,0x92,0xbe,0x12,0x16,0x72,0x4d] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMailboxCreateFolderResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMailboxDeleteFolderStatus> => [0x6860f87f,0x0297,0x5adf,0xaa,0x16,0x9f,0x1f,0x08,0xe2,0xd9,0x50] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMailboxDeleteFolderStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMailboxEmptyFolderStatus> => [0x0033a74e,0x9baa,0x5f50,0x8d,0x6e,0x23,0x86,0x35,0xe6,0xfd,0xd3] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMailboxEmptyFolderStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMessage> => [0x73157119,0xfa58,0x5d2d,0x81,0x7c,0xb5,0x63,0x0c,0x15,0x11,0xe4] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailMessageBatch> => [0x37fea119,0x0f1e,0x5012,0x88,0xbb,0xf0,0x17,0x9f,0x8f,0x4d,0xe5] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailMessageBatch }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::email::EmailStore> => [0x7c9df991,0x5d99,0x55b4,0xb4,0x39,0x06,0x4e,0xdd,0x09,0x7a,0xc4] as IID_IAsyncOperation_1_Windows_ApplicationModel_Email_EmailStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::extendedexecution::ExtendedExecutionResult> => [0x1dbb1bc9,0x6cd7,0x5947,0x8c,0xd1,0x29,0x63,0x2b,0x5a,0xa9,0x50] as IID_IAsyncOperation_1_Windows_ApplicationModel_ExtendedExecution_ExtendedExecutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::extendedexecution::foreground::ExtendedExecutionForegroundResult> => [0xb18ea00f,0x8c20,0x5ac2,0x92,0x46,0x3e,0xf4,0x05,0x27,0x1f,0x1a] as IID_IAsyncOperation_1_Windows_ApplicationModel_ExtendedExecution_Foreground_ExtendedExecutionForegroundResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::socialinfo::provider::SocialDashboardItemUpdater> => [0x8bbca9a4,0xa4fc,0x5fe2,0xb6,0xb1,0x0e,0x5a,0x75,0xd0,0x5b,0x07] as IID_IAsyncOperation_1_Windows_ApplicationModel_SocialInfo_Provider_SocialDashboardItemUpdater }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::socialinfo::provider::SocialFeedUpdater> => [0x4efa4da9,0xc556,0x59f4,0x9d,0x99,0xe7,0x80,0x1c,0x5b,0x0f,0x45] as IID_IAsyncOperation_1_Windows_ApplicationModel_SocialInfo_Provider_SocialFeedUpdater }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::StartupTask> => [0xcbec7a4e,0xa046,0x5330,0x87,0x3d,0x0f,0xce,0x22,0x87,0x92,0xfa] as IID_IAsyncOperation_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::StartupTaskState> => [0x5239a934,0x80e2,0x518f,0xb8,0x19,0x1f,0x31,0x6f,0x37,0x9a,0x3f] as IID_IAsyncOperation_1_Windows_ApplicationModel_StartupTaskState }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::FulfillmentResult> => [0x5c8531ac,0x5d8d,0x5e07,0xb6,0xee,0x7c,0xab,0x96,0x93,0x0e,0x8a] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_FulfillmentResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::licensemanagement::LicenseSatisfactionResult> => [0xb8447bc9,0xa9f8,0x5867,0x8b,0x30,0xcd,0x34,0x72,0x0e,0xdc,0x31] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::ListingInformation> => [0x161600f7,0x6d4f,0x500d,0x93,0xa8,0x09,0xad,0x6b,0x5a,0xc4,0xab] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_ListingInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::preview::installcontrol::AppInstallItem> => [0x83b51cbf,0x35e0,0x59ad,0xab,0x3e,0xff,0xb3,0xf0,0x37,0x04,0xf9] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::preview::StorePreviewPurchaseResults> => [0x9aa2af80,0x0dcb,0x5ec1,0x84,0x35,0x0b,0x68,0x7e,0xd3,0x74,0xa5] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_Preview_StorePreviewPurchaseResults }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::store::PurchaseResults> => [0x241f6b10,0x6af6,0x5164,0x85,0xeb,0xba,0xe6,0xbd,0xae,0x0b,0xe8] as IID_IAsyncOperation_1_Windows_ApplicationModel_Store_PurchaseResults }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::userdataaccounts::systemaccess::DeviceAccountConfiguration> => [0x469859f3,0x6b7b,0x5399,0x8a,0x8c,0xfe,0x61,0x5b,0x95,0xae,0x07] as IID_IAsyncOperation_1_Windows_ApplicationModel_UserDataAccounts_SystemAccess_DeviceAccountConfiguration }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::userdataaccounts::UserDataAccount> => [0xf0aeb2af,0xa69b,0x5caa,0xa2,0x83,0x32,0xe6,0x97,0xa6,0x5d,0x31] as IID_IAsyncOperation_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::userdataaccounts::UserDataAccountStore> => [0x06b68f1e,0x9937,0x5296,0xa5,0x5e,0xd4,0x3d,0xd8,0xa7,0x54,0x5c] as IID_IAsyncOperation_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccountStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::voicecommands::VoiceCommand> => [0x815f1854,0x4d79,0x570d,0x9b,0x57,0x5b,0x47,0xe2,0x82,0xcd,0x66] as IID_IAsyncOperation_1_Windows_ApplicationModel_VoiceCommands_VoiceCommand }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::voicecommands::VoiceCommandConfirmationResult> => [0x3b39db5f,0xd2a4,0x5d88,0x85,0x1f,0xe9,0xa0,0xea,0x0d,0x94,0x7e] as IID_IAsyncOperation_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandConfirmationResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::voicecommands::VoiceCommandDisambiguationResult> => [0xb03d44c8,0x060f,0x5b98,0x95,0x3a,0xfd,0x1e,0xb1,0xd4,0x6a,0xbc] as IID_IAsyncOperation_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandDisambiguationResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::wallet::system::WalletItemSystemStore> => [0x587c5f4f,0x7c55,0x5f74,0xb2,0x6a,0xf8,0x0e,0x3b,0xc6,0xd4,0xf2] as IID_IAsyncOperation_1_Windows_ApplicationModel_Wallet_System_WalletItemSystemStore }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::wallet::WalletItem> => [0x8e64ddb0,0xea5c,0x5593,0xa1,0xf3,0x0b,0x82,0x09,0xdf,0x39,0x05] as IID_IAsyncOperation_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IAsyncOperation<super::applicationmodel::wallet::WalletItemStore> => [0x9664f3ba,0x0049,0x5cbf,0x84,0x5f,0x8f,0x0b,0xca,0xd2,0xb1,0x4c] as IID_IAsyncOperation_1_Windows_ApplicationModel_Wallet_WalletItemStore }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IAsyncOperation<super::data::pdf::PdfDocument> => [0xd6b166ec,0x099a,0x5ee2,0xad,0x2e,0xf4,0xc8,0x86,0x14,0xaa,0xbb] as IID_IAsyncOperation_1_Windows_Data_Pdf_PdfDocument }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IAsyncOperation<super::data::xml::dom::XmlDocument> => [0xf858e239,0x1896,0x5982,0x84,0x95,0x14,0x31,0x68,0x47,0x8e,0xb8] as IID_IAsyncOperation_1_Windows_Data_Xml_Dom_XmlDocument }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::adc::AdcController> => [0x69420262,0x35c9,0x583f,0xa4,0x0e,0xc2,0x69,0x45,0x62,0xc9,0xe2] as IID_IAsyncOperation_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::alljoyn::AllJoynAboutDataView> => [0x3757414e,0xf54b,0x51c4,0x8f,0x2f,0xe0,0x47,0x75,0x59,0xb2,0xad] as IID_IAsyncOperation_1_Windows_Devices_AllJoyn_AllJoynAboutDataView }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::alljoyn::AllJoynServiceInfo> => [0xb9ce48c1,0x16cc,0x5e46,0x91,0xd5,0xe5,0xcd,0x06,0xf8,0x02,0x6e] as IID_IAsyncOperation_1_Windows_Devices_AllJoyn_AllJoynServiceInfo }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::alljoyn::AllJoynSession> => [0x74ae55f8,0x3d63,0x5472,0x91,0x3d,0x74,0xe9,0xa1,0x12,0x5d,0xd3] as IID_IAsyncOperation_1_Windows_Devices_AllJoyn_AllJoynSession }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::BluetoothDevice> => [0xb58d8d19,0x44bd,0x5ac0,0xa0,0xd6,0x1b,0x50,0x80,0x0f,0x31,0x81] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_BluetoothDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::BluetoothLEDevice> => [0x375f9d67,0x74a2,0x5f91,0xa1,0x1d,0x16,0x90,0x93,0x71,0x8d,0x41] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_BluetoothLEDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::genericattributeprofile::GattCommunicationStatus> => [0x3ff69516,0x1bfb,0x52e9,0x9e,0xe6,0xe5,0xcd,0xb7,0x8e,0x16,0x83] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCommunicationStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::genericattributeprofile::GattDeviceService> => [0xe5e90272,0x408f,0x5055,0x9b,0xd3,0x88,0x40,0x89,0x82,0xd3,0x01] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::genericattributeprofile::GattReadClientCharacteristicConfigurationDescriptorResult> => [0xcf4444cc,0x4077,0x5719,0x83,0x66,0x46,0xe8,0x6b,0x98,0x36,0x85] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattReadClientCharacteristicConfigurationDescriptorResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::genericattributeprofile::GattReadResult> => [0xd40432a8,0x1e14,0x51d0,0xb4,0x9b,0xae,0x2c,0xe1,0xaa,0x05,0xe5] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattReadResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::rfcomm::RfcommDeviceService> => [0x0df56bd7,0xc8f6,0x5c32,0x96,0x44,0xaa,0x0b,0xcf,0x28,0xd7,0x8c] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::rfcomm::RfcommDeviceServicesResult> => [0xb7f2f74d,0xbf9c,0x5721,0xbf,0x6e,0x03,0xf1,0xb4,0x40,0x95,0x88] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceServicesResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::bluetooth::rfcomm::RfcommServiceProvider> => [0xfed44828,0xe232,0x554d,0x85,0xd1,0x2f,0x04,0xd1,0x32,0x2e,0x69] as IID_IAsyncOperation_1_Windows_Devices_Bluetooth_Rfcomm_RfcommServiceProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::custom::CustomDevice> => [0x2a6344aa,0x0568,0x548e,0xa1,0xa2,0xb6,0xbb,0x45,0x1d,0x22,0x8c] as IID_IAsyncOperation_1_Windows_Devices_Custom_CustomDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DeviceAccessStatus> => [0xc00bc2f2,0xa7f8,0x5f3f,0x80,0xd1,0x28,0x08,0xef,0x6b,0xca,0x10] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DeviceAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DeviceInformation> => [0x07faa053,0xeb2f,0x5cba,0xb2,0x5b,0xd9,0xd5,0x7b,0xe6,0x71,0x5f] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DeviceInformationCollection> => [0x45180254,0x082e,0x5274,0xb2,0xe7,0xac,0x05,0x17,0xf4,0x4d,0x07] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DeviceInformationCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DevicePairingResult> => [0x1002db74,0x8948,0x591e,0x81,0x5d,0xe4,0x0b,0x66,0x75,0x99,0xa3] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DevicePairingResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DeviceThumbnail> => [0xbac083a3,0x3a19,0x5072,0x9d,0x90,0x13,0x33,0x23,0xa0,0x49,0xba] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DeviceThumbnail }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::DeviceUnpairingResult> => [0x2bb4df3d,0xbd7e,0x5fe0,0x90,0x20,0x56,0xdc,0x0d,0x30,0xb9,0x35] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_DeviceUnpairingResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::pnp::PnpObject> => [0x22b0fb93,0x30e6,0x501a,0xbd,0x3b,0x9f,0xa3,0x06,0x3e,0x9c,0x16] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::enumeration::pnp::PnpObjectCollection> => [0xf383c2cc,0xf326,0x5bbe,0x95,0xd1,0xcb,0xc2,0x47,0x14,0xef,0x86] as IID_IAsyncOperation_1_Windows_Devices_Enumeration_Pnp_PnpObjectCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::geolocation::GeolocationAccessStatus> => [0xde2b24d0,0xb726,0x57b1,0xa7,0xc5,0xe5,0xa1,0x39,0x32,0xb7,0xde] as IID_IAsyncOperation_1_Windows_Devices_Geolocation_GeolocationAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::geolocation::Geopoint> => [0x3723e070,0xc2ae,0x538f,0x84,0x6e,0x0f,0x9d,0x28,0x03,0x10,0xc0] as IID_IAsyncOperation_1_Windows_Devices_Geolocation_Geopoint }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::geolocation::Geoposition> => [0xee73ecf0,0x099d,0x57e5,0x84,0x07,0x5b,0x32,0xe5,0xaf,0x1c,0xc4] as IID_IAsyncOperation_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::gpio::GpioController> => [0xed045917,0x96c7,0x5735,0xb4,0xbe,0xd7,0x96,0x19,0xd4,0x83,0x5e] as IID_IAsyncOperation_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::humaninterfacedevice::HidDevice> => [0xa76a4fbf,0x5177,0x5256,0x84,0xa8,0xb3,0x1a,0x8d,0xcf,0x10,0x48] as IID_IAsyncOperation_1_Windows_Devices_HumanInterfaceDevice_HidDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::humaninterfacedevice::HidFeatureReport> => [0xd72fb6f9,0x42f6,0x5f45,0xbf,0xe3,0x29,0xaf,0x24,0x7c,0x2e,0x85] as IID_IAsyncOperation_1_Windows_Devices_HumanInterfaceDevice_HidFeatureReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::humaninterfacedevice::HidInputReport> => [0xb3e28917,0xcd48,0x57b3,0xa0,0xb1,0x32,0x14,0x32,0xe8,0x5b,0xd6] as IID_IAsyncOperation_1_Windows_Devices_HumanInterfaceDevice_HidInputReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::i2c::I2cController> => [0xa4fb1dd4,0x80c9,0x5a61,0xae,0x8d,0xc8,0xa7,0xaf,0xc0,0x32,0x75] as IID_IAsyncOperation_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::i2c::I2cDevice> => [0x1e8a7cd8,0xe41b,0x5a41,0x82,0xb1,0x80,0x05,0x50,0x12,0xae,0x00] as IID_IAsyncOperation_1_Windows_Devices_I2c_I2cDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::lights::Lamp> => [0x52a69dfd,0xf0d6,0x5931,0xb8,0xe1,0xf3,0x80,0x66,0xd7,0x1b,0xf2] as IID_IAsyncOperation_1_Windows_Devices_Lights_Lamp }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::midi::IMidiOutPort> => [0x32699a4d,0x1cc0,0x5a1c,0x9d,0xa6,0x87,0x51,0x97,0x87,0x50,0x86] as IID_IAsyncOperation_1_Windows_Devices_Midi_IMidiOutPort }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::midi::MidiInPort> => [0xcc664f0e,0xedb1,0x55c8,0x9e,0xf7,0xec,0x90,0x07,0xe4,0x56,0x1c] as IID_IAsyncOperation_1_Windows_Devices_Midi_MidiInPort }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::midi::MidiSynthesizer> => [0x9388b978,0x13f1,0x5e37,0x81,0x33,0x94,0x43,0x0d,0x90,0xdd,0x50] as IID_IAsyncOperation_1_Windows_Devices_Midi_MidiSynthesizer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionColorFrameSource> => [0x9647fec8,0x2c56,0x5348,0x86,0xc8,0xa9,0xc3,0xa9,0x7f,0xb9,0x44] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionDepthCorrelatedCameraIntrinsics> => [0x702b0f49,0xa742,0x5c3a,0xab,0xd6,0x77,0xf9,0x99,0x9b,0x8a,0x09] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionDepthCorrelatedCameraIntrinsics }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionDepthCorrelatedCoordinateMapper> => [0xf04b9d99,0xc0d5,0x5b48,0x9a,0xe5,0x98,0x02,0x09,0x3c,0xb4,0x5e] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionDepthCorrelatedCoordinateMapper }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionDepthFrameSource> => [0x4382b038,0xd4b1,0x540b,0x85,0x9a,0x70,0x16,0x62,0x6b,0xb9,0x9d] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionFrameSourceAccessStatus> => [0x2c2f22a8,0xf383,0x5802,0xba,0x2c,0x0c,0xbb,0xcd,0x98,0x9c,0x9a] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionFrameSourceAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionFrameSourcePropertyChangeResult> => [0x4a7bcb69,0x2b09,0x55d1,0xaf,0x68,0xb5,0xaa,0x5c,0x2c,0x64,0x71] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionFrameSourcePropertyChangeResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::perception::PerceptionInfraredFrameSource> => [0x55122e42,0xcc65,0x5ccd,0x8f,0x6c,0x84,0xce,0xd0,0x9d,0xb2,0x4e] as IID_IAsyncOperation_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::BarcodeScanner> => [0x616494dd,0x30a2,0x523f,0xb1,0xa2,0x9a,0x11,0x74,0xde,0x3b,0x17] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_BarcodeScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::CashDrawer> => [0x45007467,0x92f2,0x5bff,0xb1,0x91,0xaa,0x50,0x00,0xfe,0xdd,0x9e] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_CashDrawer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::ClaimedBarcodeScanner> => [0xc9704809,0xa0e2,0x5e1d,0x87,0xcf,0x75,0xa1,0xd4,0x9d,0x7b,0xdb] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_ClaimedBarcodeScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::ClaimedCashDrawer> => [0x9230e7aa,0x20a0,0x5752,0x9c,0x20,0x4b,0xf4,0x49,0x34,0xa8,0x7e] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_ClaimedCashDrawer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::ClaimedMagneticStripeReader> => [0x41630bd4,0xf45a,0x590d,0x8a,0x4e,0xf7,0x0c,0x9e,0x49,0xad,0x01] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_ClaimedMagneticStripeReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::ClaimedPosPrinter> => [0xb4476f95,0x355a,0x503d,0xb8,0x44,0x17,0x56,0xc8,0xcf,0xda,0x98] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_ClaimedPosPrinter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::MagneticStripeReader> => [0x93726e09,0x817c,0x5f33,0xbe,0xe4,0x09,0x0d,0xe7,0x07,0x4f,0x19] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_MagneticStripeReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pointofservice::PosPrinter> => [0x024f77ce,0x51c3,0x5afc,0x9f,0x30,0x24,0xb3,0xc0,0xf3,0xb2,0x5a] as IID_IAsyncOperation_1_Windows_Devices_PointOfService_PosPrinter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::power::Battery> => [0xdaa3d556,0x1529,0x56d2,0xa5,0xf8,0xbf,0xb6,0xc2,0x2a,0x3d,0xfe] as IID_IAsyncOperation_1_Windows_Devices_Power_Battery }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::printers::Print3DDevice> => [0x7cfc4a8f,0x5eb7,0x5af7,0xbc,0x9f,0x78,0xa7,0xe4,0x07,0xcd,0x2e] as IID_IAsyncOperation_1_Windows_Devices_Printers_Print3DDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::pwm::PwmController> => [0x0a288d41,0x1f20,0x5d16,0x85,0xdd,0x52,0x85,0x5b,0x11,0x56,0x9a] as IID_IAsyncOperation_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::radios::Radio> => [0xeac62c40,0x8dbc,0x5854,0x8b,0xa0,0xb7,0xb9,0x94,0x0e,0x73,0x89] as IID_IAsyncOperation_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::radios::RadioAccessStatus> => [0x21fb30ef,0x072f,0x502c,0x98,0x98,0xd0,0xc3,0xb2,0xcd,0x9a,0xc5] as IID_IAsyncOperation_1_Windows_Devices_Radios_RadioAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::scanners::ImageScanner> => [0x75d78736,0x6c52,0x551e,0xab,0x5f,0x50,0x67,0x4f,0x32,0x34,0x31] as IID_IAsyncOperation_1_Windows_Devices_Scanners_ImageScanner }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::scanners::ImageScannerPreviewResult> => [0x2f74576f,0x0498,0x5348,0xbc,0x3b,0xa7,0x0d,0x1a,0x77,0x17,0x18] as IID_IAsyncOperation_1_Windows_Devices_Scanners_ImageScannerPreviewResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sensors::ActivitySensor> => [0xc33003ae,0xe7ae,0x572b,0x8d,0x55,0x7d,0xb1,0x97,0x35,0x6c,0x30] as IID_IAsyncOperation_1_Windows_Devices_Sensors_ActivitySensor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sensors::ActivitySensorReading> => [0x79a87969,0x327f,0x5b7a,0xa0,0xd3,0x73,0xea,0xb1,0x6d,0xe2,0x1c] as IID_IAsyncOperation_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sensors::custom::CustomSensor> => [0x7fbfbe55,0x9674,0x54e3,0xa2,0x69,0x9c,0xaa,0x82,0x0e,0xd2,0x3c] as IID_IAsyncOperation_1_Windows_Devices_Sensors_Custom_CustomSensor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sensors::Pedometer> => [0x9414388f,0x1b3e,0x55f5,0x81,0x9b,0xab,0x38,0x33,0x64,0x60,0x55] as IID_IAsyncOperation_1_Windows_Devices_Sensors_Pedometer }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::serialcommunication::SerialDevice> => [0x44ef26ed,0xc1ff,0x546a,0xa4,0x6b,0x6a,0x37,0xde,0x91,0x87,0xfb] as IID_IAsyncOperation_1_Windows_Devices_SerialCommunication_SerialDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardChallengeContext> => [0x1c650663,0x3f68,0x599b,0xb9,0xd4,0xc3,0x50,0xf1,0x3e,0xe4,0xe4] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardChallengeContext }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardConnection> => [0x779bbc5b,0xa75c,0x5988,0x97,0x8f,0x34,0xdb,0xc6,0x29,0xd5,0x76] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardConnection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardProvisioning> => [0x6184fc80,0xb752,0x5ce8,0xa1,0x36,0xf5,0x71,0x74,0xbb,0x93,0x09] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardProvisioning }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardReader> => [0x036a830d,0xbbca,0x5cb9,0x97,0x7f,0xb2,0x9e,0xa3,0x04,0x21,0x49] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardReader }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardReaderStatus> => [0x5ae402fa,0x1f22,0x5570,0xa0,0xc8,0xb2,0x32,0x0a,0xde,0xdb,0x81] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardReaderStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::smartcards::SmartCardStatus> => [0xe2223376,0x8cf6,0x51bd,0x99,0x07,0x13,0x44,0xaa,0x66,0x5e,0x5d] as IID_IAsyncOperation_1_Windows_Devices_SmartCards_SmartCardStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sms::ISmsMessage> => [0xabf9b459,0x48c3,0x5eac,0x97,0x49,0x4c,0x6d,0xb4,0xd5,0x07,0xe6] as IID_IAsyncOperation_1_Windows_Devices_Sms_ISmsMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sms::SmsDevice> => [0xab710de1,0xfcbb,0x5bd6,0x9f,0x2f,0x28,0x5f,0xa9,0xfb,0x44,0xe8] as IID_IAsyncOperation_1_Windows_Devices_Sms_SmsDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::sms::SmsSendMessageResult> => [0xfc0a0b0f,0x4dcc,0x5257,0xbc,0x61,0x34,0x35,0xe3,0x02,0xce,0x1f] as IID_IAsyncOperation_1_Windows_Devices_Sms_SmsSendMessageResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::spi::SpiController> => [0xb6b0df6f,0xc097,0x5844,0x93,0xbd,0x78,0x21,0x99,0x8f,0xdb,0x8e] as IID_IAsyncOperation_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::spi::SpiDevice> => [0xfeb8466a,0x878f,0x577b,0xbb,0xca,0x89,0x57,0x5c,0xfc,0x56,0xe4] as IID_IAsyncOperation_1_Windows_Devices_Spi_SpiDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::usb::UsbDevice> => [0x2138c5ed,0xb71a,0x5166,0x99,0x48,0xd5,0x57,0x92,0x74,0x8f,0x5c] as IID_IAsyncOperation_1_Windows_Devices_Usb_UsbDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifi::WiFiAccessStatus> => [0xf8c75a3a,0x739a,0x57aa,0x98,0x6d,0x1f,0x76,0x04,0xd7,0xe3,0x86] as IID_IAsyncOperation_1_Windows_Devices_WiFi_WiFiAccessStatus }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifi::WiFiAdapter> => [0x1dcf739d,0x10b7,0x59e9,0xab,0x47,0x8b,0x02,0x77,0xe2,0x01,0x93] as IID_IAsyncOperation_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifi::WiFiConnectionResult> => [0xffa41f49,0x4c30,0x50d3,0x95,0x49,0xe4,0xf0,0x55,0xb4,0x17,0xb4] as IID_IAsyncOperation_1_Windows_Devices_WiFi_WiFiConnectionResult }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifidirect::services::WiFiDirectService> => [0xc4fa2ae8,0x4ff7,0x5aa0,0xaf,0x97,0xed,0x85,0xea,0x66,0xf9,0xae] as IID_IAsyncOperation_1_Windows_Devices_WiFiDirect_Services_WiFiDirectService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifidirect::services::WiFiDirectServiceProvisioningInfo> => [0xd7fa4dc4,0x4730,0x506e,0xbf,0xf0,0x80,0x1e,0xb4,0xa8,0x31,0xa8] as IID_IAsyncOperation_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceProvisioningInfo }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifidirect::services::WiFiDirectServiceSession> => [0xc2da4e97,0x728b,0x5401,0xa9,0xd9,0x3a,0x01,0x85,0x45,0x0a,0xf2] as IID_IAsyncOperation_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSession }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperation<super::devices::wifidirect::WiFiDirectDevice> => [0xdad01b61,0xa82d,0x566c,0xba,0x82,0x22,0x4c,0x11,0x50,0x06,0x69] as IID_IAsyncOperation_1_Windows_Devices_WiFiDirect_WiFiDirectDevice }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::input::forcefeedback::ForceFeedbackLoadEffectResult> => [0x21f834fc,0xe845,0x5ab9,0xbf,0x85,0x95,0x34,0xe2,0x39,0x77,0x98] as IID_IAsyncOperation_1_Windows_Gaming_Input_ForceFeedback_ForceFeedbackLoadEffectResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::xboxlive::storage::GameSaveBlobGetResult> => [0x7023b023,0x7aed,0x526c,0xb3,0xbc,0xbe,0x12,0xe3,0x5c,0xe1,0xcf] as IID_IAsyncOperation_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::xboxlive::storage::GameSaveBlobInfoGetResult> => [0xd7b7f3b4,0x6028,0x522f,0x84,0x9d,0xa6,0x94,0x95,0xe4,0xdc,0xd0] as IID_IAsyncOperation_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobInfoGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::xboxlive::storage::GameSaveContainerInfoGetResult> => [0xcff8afeb,0x5a18,0x5f51,0xb6,0x1b,0x94,0x38,0x87,0xf7,0x29,0xee] as IID_IAsyncOperation_1_Windows_Gaming_XboxLive_Storage_GameSaveContainerInfoGetResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::xboxlive::storage::GameSaveOperationResult> => [0x1c27fb97,0x1e1a,0x516f,0xab,0xb2,0x12,0xc1,0x8e,0x18,0x21,0x8d] as IID_IAsyncOperation_1_Windows_Gaming_XboxLive_Storage_GameSaveOperationResult }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperation<super::gaming::xboxlive::storage::GameSaveProviderGetResult> => [0x3dc36085,0x5fec,0x541b,0x96,0xcf,0x62,0x7b,0x2a,0xd8,0x0d,0x36] as IID_IAsyncOperation_1_Windows_Gaming_XboxLive_Storage_GameSaveProviderGetResult }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::BitmapDecoder> => [0xaa94d8e9,0xcaef,0x53f6,0x82,0x3d,0x91,0xb6,0xe8,0x34,0x05,0x10] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_BitmapDecoder }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::BitmapEncoder> => [0x151bd1c5,0x4675,0x5af5,0xa2,0x89,0x00,0x1e,0xdc,0x66,0xb8,0x6a] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_BitmapEncoder }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::BitmapFrame> => [0xcb1483d1,0x1464,0x5bf9,0x93,0x46,0xd5,0x37,0x73,0x5d,0xfb,0xd6] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_BitmapFrame }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::BitmapPropertySet> => [0x464ac000,0xb1f1,0x5246,0x82,0x68,0x91,0x2a,0x25,0x93,0xd8,0x89] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_BitmapPropertySet }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::ImageStream> => [0x684165be,0x0011,0x56d6,0xbe,0xbf,0x43,0x00,0x16,0xd5,0x1b,0x7a] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::PixelDataProvider> => [0x8c2dfeb0,0x6c22,0x5863,0x88,0xd8,0x85,0xc1,0xfb,0xc7,0x56,0x97] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_PixelDataProvider }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::imaging::SoftwareBitmap> => [0xc4a10980,0x714b,0x5501,0x8d,0xa2,0xdb,0xda,0xcc,0xe7,0x0f,0x73] as IID_IAsyncOperation_1_Windows_Graphics_Imaging_SoftwareBitmap }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::printing3d::Printing3D3MFPackage> => [0x6cf2eb38,0xe068,0x5558,0x94,0xb0,0x01,0x61,0x19,0x2c,0x5f,0x19] as IID_IAsyncOperation_1_Windows_Graphics_Printing3D_Printing3D3MFPackage }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::printing3d::Printing3DMeshVerificationResult> => [0x0f9eb6c4,0x19f5,0x5be9,0x9a,0xdb,0x64,0xf2,0x4a,0xf1,0x15,0xd8] as IID_IAsyncOperation_1_Windows_Graphics_Printing3D_Printing3DMeshVerificationResult }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IAsyncOperation<super::graphics::printing3d::Printing3DModel> => [0x1b27900b,0x10d5,0x53ff,0x9a,0x34,0x4b,0x31,0xf3,0x15,0x82,0xb0] as IID_IAsyncOperation_1_Windows_Graphics_Printing3D_Printing3DModel }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IAsyncOperation<super::management::deployment::PackageVolume> => [0x0315edb6,0xdc58,0x51cc,0xa5,0x19,0x44,0x90,0x1a,0xd2,0xcf,0x15] as IID_IAsyncOperation_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::audio::CreateAudioDeviceInputNodeResult> => [0x71ab4481,0xec4a,0x5ee9,0xa3,0x42,0x3a,0x31,0x74,0x78,0x29,0xb8] as IID_IAsyncOperation_1_Windows_Media_Audio_CreateAudioDeviceInputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::audio::CreateAudioDeviceOutputNodeResult> => [0xf810d730,0xde15,0x58e0,0xa5,0xf4,0xc1,0x59,0xf7,0x36,0x69,0xed] as IID_IAsyncOperation_1_Windows_Media_Audio_CreateAudioDeviceOutputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::audio::CreateAudioFileInputNodeResult> => [0x473b06bf,0x387b,0x56ca,0xbe,0xe1,0x52,0x74,0x80,0x27,0x2b,0x0f] as IID_IAsyncOperation_1_Windows_Media_Audio_CreateAudioFileInputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::audio::CreateAudioFileOutputNodeResult> => [0x1164517d,0xe953,0x5415,0xa5,0xb3,0x42,0x49,0xa9,0x69,0xbe,0x7b] as IID_IAsyncOperation_1_Windows_Media_Audio_CreateAudioFileOutputNodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::audio::CreateAudioGraphResult> => [0x3e13b431,0x65ce,0x5bfb,0xb0,0xaa,0xfa,0xc8,0xdf,0x95,0x8b,0x95] as IID_IAsyncOperation_1_Windows_Media_Audio_CreateAudioGraphResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::AdvancedCapturedPhoto> => [0x8f71b217,0x61ec,0x58ab,0xa6,0x46,0xee,0xde,0x01,0x42,0xd5,0x68] as IID_IAsyncOperation_1_Windows_Media_Capture_AdvancedCapturedPhoto }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::AdvancedPhotoCapture> => [0x8eb156d9,0x2ce4,0x5ecd,0x81,0xf4,0xa0,0x87,0x31,0xfb,0x74,0xcf] as IID_IAsyncOperation_1_Windows_Media_Capture_AdvancedPhotoCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::CapturedPhoto> => [0xaf5235b1,0x4778,0x55e1,0xb4,0x9f,0x60,0x80,0x48,0xea,0x9b,0xd9] as IID_IAsyncOperation_1_Windows_Media_Capture_CapturedPhoto }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::core::VariablePhotoSequenceCapture> => [0x0327c8bc,0x3148,0x53f3,0x8a,0x3d,0xcd,0xb1,0x2e,0x49,0xe1,0x32] as IID_IAsyncOperation_1_Windows_Media_Capture_Core_VariablePhotoSequenceCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::frames::MediaFrameReader> => [0xa10cb14d,0x7935,0x5c87,0x90,0x26,0x8a,0xbe,0x79,0x2a,0x3b,0xe5] as IID_IAsyncOperation_1_Windows_Media_Capture_Frames_MediaFrameReader }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::frames::MediaFrameReaderStartStatus> => [0xdb8e251a,0xadc6,0x5753,0x87,0x84,0xc4,0x4b,0x4d,0x7c,0x5b,0x07] as IID_IAsyncOperation_1_Windows_Media_Capture_Frames_MediaFrameReaderStartStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::frames::MediaFrameSourceGetPropertyResult> => [0x80003979,0x4986,0x52a7,0xb2,0x27,0xae,0x6b,0xe4,0xd2,0xb5,0xcd] as IID_IAsyncOperation_1_Windows_Media_Capture_Frames_MediaFrameSourceGetPropertyResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::frames::MediaFrameSourceGroup> => [0xf3256a87,0xb1cf,0x5943,0xb6,0x64,0x9f,0x19,0x36,0x7d,0x27,0x79] as IID_IAsyncOperation_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::frames::MediaFrameSourceSetPropertyStatus> => [0xa1507c16,0x5f84,0x586e,0x8c,0xa9,0x22,0x4f,0x37,0xe0,0xe0,0xde] as IID_IAsyncOperation_1_Windows_Media_Capture_Frames_MediaFrameSourceSetPropertyStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::LowLagMediaRecording> => [0x4febefcc,0xbec0,0x5433,0xa7,0xba,0x76,0x03,0xd1,0xed,0xc7,0xb9] as IID_IAsyncOperation_1_Windows_Media_Capture_LowLagMediaRecording }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::LowLagPhotoCapture> => [0xaf24404b,0x7e0d,0x5ffe,0xbb,0xc8,0xaa,0xf6,0xff,0xe2,0x08,0xfc] as IID_IAsyncOperation_1_Windows_Media_Capture_LowLagPhotoCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::LowLagPhotoSequenceCapture> => [0xac9f0460,0x9d14,0x5af0,0xb1,0x7b,0x37,0xea,0x2d,0x76,0xa8,0x0d] as IID_IAsyncOperation_1_Windows_Media_Capture_LowLagPhotoSequenceCapture }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::MediaCapturePauseResult> => [0x202a2618,0x5478,0x5eba,0x9b,0xd3,0x9d,0x83,0xf4,0x62,0x74,0x7e] as IID_IAsyncOperation_1_Windows_Media_Capture_MediaCapturePauseResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::capture::MediaCaptureStopResult> => [0xeb798827,0xa4a9,0x533a,0x9e,0x83,0x0f,0xb0,0x85,0xb2,0xad,0x36] as IID_IAsyncOperation_1_Windows_Media_Capture_MediaCaptureStopResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::casting::CastingConnectionErrorStatus> => [0x25c821bc,0xdeb8,0x5850,0x8a,0xf2,0xd3,0xac,0x35,0x42,0x6b,0xd2] as IID_IAsyncOperation_1_Windows_Media_Casting_CastingConnectionErrorStatus }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::casting::CastingDevice> => [0x1b4ee058,0x4c69,0x5e70,0x88,0x34,0xc1,0xd1,0x71,0xcc,0x1b,0x22] as IID_IAsyncOperation_1_Windows_Media_Casting_CastingDevice }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::casting::CastingPlaybackTypes> => [0xdff10e53,0x4c5e,0x5dba,0x92,0x69,0xcd,0x61,0x88,0x1b,0xb8,0xb3] as IID_IAsyncOperation_1_Windows_Media_Casting_CastingPlaybackTypes }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::contentrestrictions::ContentAccessRestrictionLevel> => [0x860c0179,0xbe01,0x546d,0xa9,0xce,0x59,0x56,0x46,0x4c,0x98,0xab] as IID_IAsyncOperation_1_Windows_Media_ContentRestrictions_ContentAccessRestrictionLevel }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::contentrestrictions::ContentRestrictionsBrowsePolicy> => [0xae3399b2,0xc7d5,0x5f1b,0x9f,0xb9,0xf8,0xbd,0x81,0xe9,0xf9,0xbe] as IID_IAsyncOperation_1_Windows_Media_ContentRestrictions_ContentRestrictionsBrowsePolicy }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::core::MediaStreamSample> => [0x3cdc5e86,0x4ada,0x5ef7,0x96,0x7a,0xe1,0x37,0xa4,0x62,0x19,0x07] as IID_IAsyncOperation_1_Windows_Media_Core_MediaStreamSample }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::dialprotocol::DialAppLaunchResult> => [0x4512c15e,0x1fc4,0x5648,0xbd,0x49,0x51,0x53,0x3a,0x3f,0xe6,0xb4] as IID_IAsyncOperation_1_Windows_Media_DialProtocol_DialAppLaunchResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::dialprotocol::DialAppStateDetails> => [0xe50a07a2,0x2cef,0x5fc7,0xb1,0x4c,0xd6,0xdd,0x85,0x17,0xc5,0x8e] as IID_IAsyncOperation_1_Windows_Media_DialProtocol_DialAppStateDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::dialprotocol::DialAppStopResult> => [0x8598f24e,0x0d62,0x517a,0x96,0x1c,0x31,0xfc,0xa7,0x3a,0xce,0xdd] as IID_IAsyncOperation_1_Windows_Media_DialProtocol_DialAppStopResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::dialprotocol::DialDevice> => [0x471cada5,0x1ee4,0x51c0,0xb6,0xb5,0xbf,0x72,0xf5,0xf5,0x04,0x22] as IID_IAsyncOperation_1_Windows_Media_DialProtocol_DialDevice }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::editing::BackgroundAudioTrack> => [0x493dc898,0x6076,0x55f5,0xab,0x84,0xcc,0xf9,0x73,0xac,0x03,0x97] as IID_IAsyncOperation_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::editing::MediaClip> => [0xb5e699dd,0xb6f1,0x51c0,0xb7,0x52,0xe0,0x2f,0xa0,0x06,0x8d,0x79] as IID_IAsyncOperation_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::editing::MediaComposition> => [0xe170e898,0xd11f,0x5054,0xab,0x13,0x10,0x80,0xa4,0x80,0x76,0x36] as IID_IAsyncOperation_1_Windows_Media_Editing_MediaComposition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::faceanalysis::FaceDetector> => [0xc0141cd2,0x7a65,0x514c,0xbf,0xc4,0xb4,0x9e,0x99,0x1f,0x03,0xeb] as IID_IAsyncOperation_1_Windows_Media_FaceAnalysis_FaceDetector }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::faceanalysis::FaceTracker> => [0x7f32c680,0xe37e,0x539a,0x89,0x93,0x2a,0xbb,0xea,0x71,0xaf,0xda] as IID_IAsyncOperation_1_Windows_Media_FaceAnalysis_FaceTracker }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::IMediaExtension> => [0xf5cb3303,0x1c1f,0x5d30,0xb4,0x02,0xef,0xa1,0x92,0xe8,0x0c,0x49] as IID_IAsyncOperation_1_Windows_Media_IMediaExtension }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::import::PhotoImportSource> => [0xc8c5dc1e,0xeb47,0x50b8,0xb5,0xd9,0xaa,0xfe,0x1a,0x82,0x31,0x8a] as IID_IAsyncOperation_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::mediaproperties::MediaEncodingProfile> => [0xd4f86f16,0xc6cf,0x57c8,0x97,0x43,0x5e,0xc2,0x0c,0x31,0xab,0x79] as IID_IAsyncOperation_1_Windows_Media_MediaProperties_MediaEncodingProfile }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::ocr::OcrResult> => [0xc7d7118e,0xae36,0x59c0,0xac,0x76,0x7b,0xad,0xee,0x71,0x1c,0x8b] as IID_IAsyncOperation_1_Windows_Media_Ocr_OcrResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::playlists::Playlist> => [0x8ffb74ab,0x912f,0x5bc1,0x87,0xfa,0x28,0x65,0xf6,0x73,0xcb,0xfc] as IID_IAsyncOperation_1_Windows_Media_Playlists_Playlist }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::protection::HdcpSetProtectionResult> => [0x5061ee0f,0x899a,0x569c,0xa0,0xa3,0xc2,0x56,0x6e,0xb8,0x81,0x42] as IID_IAsyncOperation_1_Windows_Media_Protection_HdcpSetProtectionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::protection::playready::INDLicenseFetchResult> => [0x9b9d0c68,0x3ad2,0x5b01,0x8d,0xc7,0x6f,0x7f,0xc1,0xee,0xd6,0xf6] as IID_IAsyncOperation_1_Windows_Media_Protection_PlayReady_INDLicenseFetchResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::protection::playready::INDSendResult> => [0x6c3788a8,0x0e6d,0x5e29,0x9a,0xd1,0xd8,0x8a,0x65,0xeb,0x50,0x0b] as IID_IAsyncOperation_1_Windows_Media_Protection_PlayReady_INDSendResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::protection::playready::INDStartResult> => [0x01fab63e,0x6aab,0x54a2,0x80,0xf7,0xdb,0xed,0x22,0xf5,0x8d,0x56] as IID_IAsyncOperation_1_Windows_Media_Protection_PlayReady_INDStartResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::speechrecognition::SpeechRecognitionCompilationResult> => [0xa392249a,0xe28a,0x564a,0x9e,0x73,0x1d,0xda,0x63,0xca,0x64,0x3c] as IID_IAsyncOperation_1_Windows_Media_SpeechRecognition_SpeechRecognitionCompilationResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::speechrecognition::SpeechRecognitionResult> => [0xba3eebe8,0x8d7c,0x51f2,0x9e,0xd4,0xeb,0xaf,0xe3,0x67,0x4d,0xb4] as IID_IAsyncOperation_1_Windows_Media_SpeechRecognition_SpeechRecognitionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::speechsynthesis::SpeechSynthesisStream> => [0xdf9d48ad,0x9cea,0x560c,0x9e,0xdc,0xcb,0x88,0x52,0xcb,0x55,0xe3] as IID_IAsyncOperation_1_Windows_Media_SpeechSynthesis_SpeechSynthesisStream }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::streaming::adaptive::AdaptiveMediaSourceCreationResult> => [0xbe0bcc1d,0xd606,0x59d2,0xb2,0xf9,0xff,0x20,0x45,0x43,0xda,0x12] as IID_IAsyncOperation_1_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceCreationResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::transcoding::PrepareTranscodeResult> => [0xf5f07c13,0x3047,0x5bab,0x8e,0xb7,0x6e,0x5d,0x7d,0x14,0xaf,0xae] as IID_IAsyncOperation_1_Windows_Media_Transcoding_PrepareTranscodeResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::transcoding::TranscodeFailureReason> => [0x02132510,0x3899,0x5257,0xbe,0xd9,0xa4,0x3e,0x51,0x49,0xd2,0x8c] as IID_IAsyncOperation_1_Windows_Media_Transcoding_TranscodeFailureReason }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperation<super::media::VideoFrame> => [0xf12e515d,0xac45,0x5153,0x96,0xb2,0xce,0x53,0xab,0x59,0x4a,0x57] as IID_IAsyncOperation_1_Windows_Media_VideoFrame }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::backgroundtransfer::DownloadOperation> => [0x43ef3a5f,0xcc7d,0x566d,0xa9,0x2a,0x4c,0xaa,0x76,0xb9,0x2a,0x1f] as IID_IAsyncOperation_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::backgroundtransfer::UnconstrainedTransferRequestResult> => [0xa8dc2a04,0x3f44,0x5046,0x81,0x82,0xcd,0x0e,0xc1,0x47,0xe1,0x7d] as IID_IAsyncOperation_1_Windows_Networking_BackgroundTransfer_UnconstrainedTransferRequestResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::backgroundtransfer::UploadOperation> => [0x44212ea1,0xb524,0x5aee,0xa3,0x20,0x71,0x99,0x22,0x53,0x81,0xd1] as IID_IAsyncOperation_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::connectivity::ConnectionProfile> => [0x5bf519ca,0x8adb,0x5ab5,0xab,0xb8,0xff,0x1b,0xbe,0x5d,0x2d,0xe8] as IID_IAsyncOperation_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::connectivity::ConnectionSession> => [0x94fc6211,0x4702,0x5d24,0x81,0xbf,0x17,0x0c,0xa7,0x81,0x89,0x95] as IID_IAsyncOperation_1_Windows_Networking_Connectivity_ConnectionSession }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::connectivity::ProxyConfiguration> => [0x1e7651f6,0x6562,0x59c7,0x9a,0xf3,0x87,0x56,0x63,0x6e,0xee,0xe2] as IID_IAsyncOperation_1_Windows_Networking_Connectivity_ProxyConfiguration }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::HotspotCredentialsAuthenticationResult> => [0x522781d8,0x29c8,0x5d89,0x89,0x37,0x1d,0x1c,0x20,0x32,0xf0,0xc8] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_HotspotCredentialsAuthenticationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandDeviceServiceCommandResult> => [0x2c673aa8,0x6a35,0x50fd,0x94,0x22,0x36,0x15,0xa1,0xc2,0x8c,0xcb] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceCommandResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandModemConfiguration> => [0xcdbe0003,0xdaaa,0x5c89,0x92,0xe6,0xa4,0x7f,0xfc,0x24,0x18,0xa2] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandModemConfiguration }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandPinOperationResult> => [0x2f76661c,0x2f74,0x5ce2,0x99,0xf9,0x47,0xd1,0xa3,0xa1,0x36,0x33] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandPinOperationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandUiccAppReadRecordResult> => [0x27fc8483,0x30d8,0x5be3,0xbc,0x1e,0x8c,0xca,0x0b,0x24,0x1d,0xf3] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppReadRecordResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandUiccAppRecordDetailsResult> => [0x0774f4a6,0xbdbe,0x59ff,0xaa,0x1c,0xa6,0x2e,0x3c,0x6f,0x9d,0x37] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppRecordDetailsResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::MobileBroadbandUiccAppsResult> => [0xcf1ce97f,0x1a81,0x5ce6,0x8a,0xd5,0x55,0xff,0x8b,0x0e,0x8d,0x1b] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccAppsResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::NetworkOperatorTetheringOperationResult> => [0x601b30ed,0x9b7f,0x54b6,0xb6,0x1b,0x24,0xa0,0x9b,0xc5,0x63,0x04] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_NetworkOperatorTetheringOperationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::ProvisionFromXmlDocumentResults> => [0x9f8fe338,0xc6b1,0x5614,0xa1,0x4f,0x89,0x77,0xa7,0x7e,0x17,0xf2] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_ProvisionFromXmlDocumentResults }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::networkoperators::UssdReply> => [0x9dd0a063,0x6153,0x5afd,0x82,0x88,0x87,0x70,0xdd,0xcf,0xf2,0xdb] as IID_IAsyncOperation_1_Windows_Networking_NetworkOperators_UssdReply }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::pushnotifications::PushNotificationChannel> => [0x70945a09,0x331a,0x5e40,0xb8,0x54,0x66,0xb7,0xa3,0x23,0x3b,0xab] as IID_IAsyncOperation_1_Windows_Networking_PushNotifications_PushNotificationChannel }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::servicediscovery::dnssd::DnssdRegistrationResult> => [0x0c251e73,0x52c9,0x5026,0xa8,0x75,0xf6,0x85,0xa5,0x0c,0xbf,0xfd] as IID_IAsyncOperation_1_Windows_Networking_ServiceDiscovery_Dnssd_DnssdRegistrationResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::sockets::StreamSocket> => [0xfb3e3d3c,0x6fe5,0x5e27,0xa1,0x32,0x90,0x22,0x47,0xe2,0xa9,0x3e] as IID_IAsyncOperation_1_Windows_Networking_Sockets_StreamSocket }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::vpn::VpnCredential> => [0x216a6f97,0xdba1,0x5f71,0xa1,0x4b,0x28,0x18,0xad,0x3c,0x4c,0x69] as IID_IAsyncOperation_1_Windows_Networking_Vpn_VpnCredential }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::vpn::VpnManagementErrorStatus> => [0xe99b86dc,0x6b65,0x5f23,0x94,0x19,0x90,0xb5,0x58,0x52,0xf2,0x83] as IID_IAsyncOperation_1_Windows_Networking_Vpn_VpnManagementErrorStatus }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperation<super::networking::xboxlive::XboxLiveEndpointPairCreationResult> => [0xa4b9d41e,0x4b2c,0x5bf9,0xa1,0x9d,0xed,0x39,0x5b,0x23,0x82,0x3c] as IID_IAsyncOperation_1_Windows_Networking_XboxLive_XboxLiveEndpointPairCreationResult }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IAsyncOperation<super::perception::spatial::SpatialAnchorStore> => [0x1cd05e51,0x1457,0x5023,0x8f,0x5d,0xfe,0x5e,0x5a,0x95,0x34,0x23] as IID_IAsyncOperation_1_Windows_Perception_Spatial_SpatialAnchorStore }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IAsyncOperation<super::perception::spatial::SpatialPerceptionAccessStatus> => [0xb425d126,0x1069,0x563f,0xa8,0x63,0x44,0xa3,0x0a,0x8f,0x07,0x1d] as IID_IAsyncOperation_1_Windows_Perception_Spatial_SpatialPerceptionAccessStatus }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IAsyncOperation<super::perception::spatial::surfaces::SpatialSurfaceMesh> => [0xf5938fad,0xa8a1,0x5f7e,0x94,0x40,0xbd,0xb7,0x81,0xad,0x26,0xb6] as IID_IAsyncOperation_1_Windows_Perception_Spatial_Surfaces_SpatialSurfaceMesh }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::core::MicrosoftAccountMultiFactorGetSessionsResult> => [0x544cc4e9,0xa3da,0x5398,0xa3,0x08,0xe3,0x32,0xa5,0x89,0x61,0xf6] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorGetSessionsResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::core::MicrosoftAccountMultiFactorOneTimeCodedInfo> => [0xae63588e,0x1fc2,0x58a3,0xaf,0x36,0x6f,0x67,0xb8,0x92,0x2b,0xe7] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorOneTimeCodedInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::core::MicrosoftAccountMultiFactorServiceResponse> => [0x05953b8e,0x5adb,0x51b9,0xa9,0x4a,0xad,0x03,0x00,0x30,0xb8,0xe3] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorServiceResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::core::MicrosoftAccountMultiFactorUnregisteredAccountsAndSessionInfo> => [0x989f4c21,0xef69,0x56ad,0xba,0x8c,0xe5,0xd2,0x5a,0x3c,0x62,0x4e] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorUnregisteredAccountsAndSessionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::provider::SecondaryAuthenticationFactorAuthenticationResult> => [0x18b0a73c,0xdb59,0x5279,0xa7,0x6d,0x02,0x41,0x6b,0x2d,0x90,0xb6] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorAuthenticationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::provider::SecondaryAuthenticationFactorAuthenticationStageInfo> => [0x864a2317,0xb440,0x5e9e,0xae,0x55,0x45,0x50,0xbb,0x63,0x07,0xdf] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorAuthenticationStageInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::provider::SecondaryAuthenticationFactorFinishAuthenticationStatus> => [0x9159437a,0x4397,0x546e,0xbe,0x61,0x2e,0xf1,0x61,0x71,0x7e,0x06] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorFinishAuthenticationStatus }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::identity::provider::SecondaryAuthenticationFactorRegistrationResult> => [0x05da520c,0xaba4,0x584c,0xbc,0x08,0x19,0xc5,0x38,0x9a,0x70,0xe2] as IID_IAsyncOperation_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorRegistrationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::onlineid::UserIdentity> => [0xb8cc25e1,0x409f,0x57f4,0xbb,0xe4,0x3b,0x95,0xb7,0x4b,0x86,0xc8] as IID_IAsyncOperation_1_Windows_Security_Authentication_OnlineId_UserIdentity }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::web::core::WebTokenRequestResult> => [0x0a815852,0x7c44,0x5674,0xb3,0xd2,0xfa,0x2e,0x4c,0x1e,0x46,0xc9] as IID_IAsyncOperation_1_Windows_Security_Authentication_Web_Core_WebTokenRequestResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::authentication::web::WebAuthenticationResult> => [0xb34952ac,0x265e,0x5947,0x87,0x35,0xe9,0x31,0x8f,0x43,0x01,0xff] as IID_IAsyncOperation_1_Windows_Security_Authentication_Web_WebAuthenticationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::KeyCredentialAttestationResult> => [0xb83d29e9,0xf4e4,0x5aa4,0x92,0xd5,0xb2,0x62,0xcb,0x40,0xc6,0x22] as IID_IAsyncOperation_1_Windows_Security_Credentials_KeyCredentialAttestationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::KeyCredentialOperationResult> => [0x6576e5b3,0x9535,0x50d6,0x98,0xf6,0xc6,0x7d,0x6a,0xac,0xa2,0xc5] as IID_IAsyncOperation_1_Windows_Security_Credentials_KeyCredentialOperationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::KeyCredentialRetrievalResult> => [0x89d0ad1e,0xbd4c,0x55b4,0x81,0x0e,0xbd,0xdd,0x4c,0xec,0x7a,0x2a] as IID_IAsyncOperation_1_Windows_Security_Credentials_KeyCredentialRetrievalResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::ui::CredentialPickerResults> => [0x83fd09a4,0x21fd,0x5c01,0x9c,0xf6,0x82,0x93,0xb2,0x92,0x9a,0x9f] as IID_IAsyncOperation_1_Windows_Security_Credentials_UI_CredentialPickerResults }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::ui::UserConsentVerificationResult> => [0xfd596ffd,0x2318,0x558f,0x9d,0xbe,0xd2,0x1d,0xf4,0x37,0x64,0xa5] as IID_IAsyncOperation_1_Windows_Security_Credentials_UI_UserConsentVerificationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::ui::UserConsentVerifierAvailability> => [0xddd384f3,0xd818,0x5d83,0xab,0x4b,0x32,0x11,0x9c,0x28,0x58,0x7c] as IID_IAsyncOperation_1_Windows_Security_Credentials_UI_UserConsentVerifierAvailability }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::WebAccount> => [0xacd76b54,0x297f,0x5a18,0x91,0x43,0x20,0xa3,0x09,0xe2,0xdf,0xd3] as IID_IAsyncOperation_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::credentials::WebAccountProvider> => [0x88c66009,0x12f7,0x58e2,0x8d,0xbe,0x6e,0xfc,0x62,0x0c,0x85,0xba] as IID_IAsyncOperation_1_Windows_Security_Credentials_WebAccountProvider }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::cryptography::certificates::CertificateChain> => [0xf618c7d4,0xaee1,0x58ae,0xaf,0xe8,0xfc,0x33,0x6d,0xaf,0x03,0x95] as IID_IAsyncOperation_1_Windows_Security_Cryptography_Certificates_CertificateChain }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::cryptography::certificates::SignatureValidationResult> => [0xf09c0bcf,0xce3b,0x5dff,0x97,0x1f,0x2c,0x3f,0xfe,0x6f,0xd0,0x4d] as IID_IAsyncOperation_1_Windows_Security_Cryptography_Certificates_SignatureValidationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::cryptography::core::CryptographicKey> => [0x81ca789b,0x98df,0x5c6a,0x95,0x31,0x96,0x62,0x38,0xe3,0xe7,0xae] as IID_IAsyncOperation_1_Windows_Security_Cryptography_Core_CryptographicKey }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::BufferProtectUnprotectResult> => [0x11f95a2e,0x2e87,0x5449,0xbc,0xa3,0xdc,0xdf,0x2a,0xe6,0xe1,0x7a] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_BufferProtectUnprotectResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::DataProtectionInfo> => [0xc8ef3f16,0xdd70,0x5e88,0x93,0x23,0x85,0xdd,0xdd,0xcd,0x2c,0xa5] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_DataProtectionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::FileProtectionInfo> => [0x67e04591,0x2d11,0x5018,0x9f,0xf0,0x0b,0x85,0x52,0x0b,0x88,0x8b] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_FileProtectionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::FileProtectionStatus> => [0x033efe7c,0x709e,0x53a8,0x8e,0x64,0xcd,0xab,0x6b,0xd1,0xed,0x59] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_FileProtectionStatus }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::ProtectedContainerExportResult> => [0xc99f0b2e,0x67ad,0x518a,0x86,0x6f,0xe3,0x9b,0x45,0x67,0xb1,0x10] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_ProtectedContainerExportResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::ProtectedContainerImportResult> => [0x384e9499,0xd491,0x5297,0xbe,0xba,0xb3,0x3a,0x3d,0x67,0xf2,0x07] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_ProtectedContainerImportResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::ProtectedFileCreateResult> => [0xd7f98a9c,0x738e,0x50f6,0x93,0xe3,0x26,0x08,0xba,0xf5,0x4b,0xe9] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_ProtectedFileCreateResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::enterprisedata::ProtectionPolicyEvaluationResult> => [0xe8d81715,0xc56c,0x5a6b,0xb7,0x38,0x5d,0xf6,0xc2,0x77,0x5b,0x7b] as IID_IAsyncOperation_1_Windows_Security_EnterpriseData_ProtectionPolicyEvaluationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IAsyncOperation<super::security::exchangeactivesyncprovisioning::EasComplianceResults> => [0xfc3a733a,0x7ded,0x5e92,0xa5,0x69,0xb4,0x33,0x89,0xee,0x88,0x27] as IID_IAsyncOperation_1_Windows_Security_ExchangeActiveSyncProvisioning_EasComplianceResults }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::maps::localsearch::LocalLocationFinderResult> => [0x08e69b32,0xf420,0x5280,0xa7,0x21,0x07,0x5b,0x4f,0xd0,0x3d,0x94] as IID_IAsyncOperation_1_Windows_Services_Maps_LocalSearch_LocalLocationFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::maps::MapLocationFinderResult> => [0xe5e5ee33,0xabd8,0x5695,0x9f,0xe5,0xac,0x95,0x85,0x0d,0x71,0x98] as IID_IAsyncOperation_1_Windows_Services_Maps_MapLocationFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::maps::MapRouteFinderResult> => [0xecaa3e7f,0xc526,0x5097,0xb6,0x24,0xcf,0x74,0x3d,0x78,0xa9,0xba] as IID_IAsyncOperation_1_Windows_Services_Maps_MapRouteFinderResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreAcquireLicenseResult> => [0xdd6c4705,0xa76c,0x528e,0x99,0xa5,0xcd,0xd1,0x31,0x97,0xd4,0xcf] as IID_IAsyncOperation_1_Windows_Services_Store_StoreAcquireLicenseResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreAppLicense> => [0x3866370b,0xafc6,0x5d01,0x84,0xc2,0x45,0x74,0x62,0x8d,0xe5,0x39] as IID_IAsyncOperation_1_Windows_Services_Store_StoreAppLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreConsumableResult> => [0x873c497b,0xc3f7,0x5657,0xb9,0x21,0x3e,0x58,0xce,0x48,0xee,0x50] as IID_IAsyncOperation_1_Windows_Services_Store_StoreConsumableResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreProductPagedQueryResult> => [0x3079e7db,0x1ba4,0x5b9e,0x85,0x6a,0x65,0x76,0xbf,0x7f,0x9c,0x8a] as IID_IAsyncOperation_1_Windows_Services_Store_StoreProductPagedQueryResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreProductQueryResult> => [0x9699e7bb,0xea1f,0x5e03,0x94,0x39,0xc8,0x0e,0x69,0x77,0xb7,0x11] as IID_IAsyncOperation_1_Windows_Services_Store_StoreProductQueryResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreProductResult> => [0x9e61e86b,0x6afb,0x50ae,0xaf,0xc1,0xc5,0x9f,0x54,0x51,0x08,0xdd] as IID_IAsyncOperation_1_Windows_Services_Store_StoreProductResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StorePurchaseResult> => [0x33d8cc30,0x78f5,0x5f81,0xaa,0x2d,0xa4,0xfa,0x2a,0x3b,0x1c,0x68] as IID_IAsyncOperation_1_Windows_Services_Store_StorePurchaseResult }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperation<super::services::store::StoreSendRequestResult> => [0x2acdffe8,0x259c,0x5eae,0x93,0xc1,0x13,0xa2,0x3c,0x74,0xdf,0xee] as IID_IAsyncOperation_1_Windows_Services_Store_StoreSendRequestResult }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::ApplicationData> => [0x31456b58,0xa5cb,0x5c5b,0xbd,0x6e,0xcc,0xce,0x3a,0x7b,0xf4,0xb4] as IID_IAsyncOperation_1_Windows_Storage_ApplicationData }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::BasicProperties> => [0x5186131a,0x4467,0x504b,0x97,0x7a,0x07,0x85,0xa8,0x23,0x04,0x85] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_BasicProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::DocumentProperties> => [0x6c86e97c,0x5699,0x5700,0x8d,0x35,0xd3,0x50,0xad,0x3e,0x4d,0xf2] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_DocumentProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::ImageProperties> => [0xfcd07511,0xe7f8,0x5bda,0x8c,0x04,0x79,0x5a,0x63,0x9d,0xae,0x8f] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_ImageProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::MusicProperties> => [0x0d023b76,0x20a7,0x56f3,0x84,0xab,0xce,0x31,0xe6,0x54,0x4b,0x71] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_MusicProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::StorageItemThumbnail> => [0x11c7cc5e,0xc04e,0x50e7,0xa6,0x5e,0x6f,0x69,0x03,0x69,0x0c,0x16] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_StorageItemThumbnail }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::fileproperties::VideoProperties> => [0x447d4590,0xd3f9,0x58bf,0xac,0x58,0x6f,0x9a,0x50,0x83,0x9e,0xfe] as IID_IAsyncOperation_1_Windows_Storage_FileProperties_VideoProperties }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::IStorageItem> => [0x5fc9c137,0xebb7,0x5e6c,0x9c,0xba,0x68,0x6f,0x2e,0xc2,0xb0,0xbb] as IID_IAsyncOperation_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::provider::FileUpdateStatus> => [0x8f0f439e,0x87d0,0x531f,0x85,0xb1,0x54,0xf4,0x52,0x8f,0x29,0xc3] as IID_IAsyncOperation_1_Windows_Storage_Provider_FileUpdateStatus }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::search::IndexedState> => [0x88694b1f,0xf380,0x574d,0x8a,0x05,0x4f,0x67,0xbd,0x52,0xcd,0x11] as IID_IAsyncOperation_1_Windows_Storage_Search_IndexedState }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::StorageFile> => [0x5e52f8ce,0xaced,0x5a42,0x95,0xb4,0xf6,0x74,0xdd,0x84,0x88,0x5e] as IID_IAsyncOperation_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::StorageFolder> => [0x6be9e7d7,0xe83a,0x5cbc,0x80,0x2c,0x17,0x68,0x96,0x0b,0x52,0xc3] as IID_IAsyncOperation_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::StorageLibrary> => [0x2f160a19,0x99c1,0x52b9,0x8d,0xca,0x14,0xe4,0xab,0x79,0xf2,0x87] as IID_IAsyncOperation_1_Windows_Storage_StorageLibrary }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::StorageStreamTransaction> => [0x0d81405a,0x9bd3,0x5e87,0x82,0xf4,0x9b,0x41,0x28,0xa8,0x87,0xeb] as IID_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IBuffer> => [0x3bee8834,0xb9a7,0x5a80,0xa7,0x46,0x5e,0xf0,0x97,0x22,0x78,0x78] as IID_IAsyncOperation_1_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IInputStream> => [0xa8fe0732,0x556d,0x5841,0xb7,0xee,0xb3,0x45,0x0f,0xb5,0x26,0x66] as IID_IAsyncOperation_1_Windows_Storage_Streams_IInputStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IOutputStream> => [0xe8736833,0xd013,0x5361,0x97,0x7d,0xc5,0xe9,0x99,0x34,0x68,0x0e] as IID_IAsyncOperation_1_Windows_Storage_Streams_IOutputStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IRandomAccessStream> => [0x430ecece,0x1418,0x5d19,0x81,0xb2,0x5d,0xdb,0x38,0x16,0x03,0xcc] as IID_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IRandomAccessStreamReference> => [0x65178d50,0xe6a2,0x5d16,0xb2,0x44,0x65,0xe9,0x72,0x5e,0x5a,0x0c] as IID_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamReference }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::IRandomAccessStreamWithContentType> => [0xc4a57c5e,0x32b0,0x55b3,0xad,0x13,0xce,0x1c,0x23,0x04,0x1e,0xd6] as IID_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperation<super::storage::streams::RandomAccessStreamReference> => [0xd90442ca,0x543c,0x504b,0x9e,0xb9,0x29,0x4b,0xca,0xd8,0xa2,0x83] as IID_IAsyncOperation_1_Windows_Storage_Streams_RandomAccessStreamReference }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::LaunchQuerySupportStatus> => [0xe7539992,0x2220,0x5d2d,0x82,0xc4,0x3d,0x44,0xf8,0x75,0x0d,0x91] as IID_IAsyncOperation_1_Windows_System_LaunchQuerySupportStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::LaunchUriResult> => [0x7f97fc15,0x1cd6,0x54b7,0xa2,0x90,0xac,0xb6,0x0d,0xba,0x81,0xa1] as IID_IAsyncOperation_1_Windows_System_LaunchUriResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::LaunchUriStatus> => [0xab3d721b,0xa4f3,0x5861,0xb0,0x34,0x03,0x0b,0x15,0x23,0x3c,0x52] as IID_IAsyncOperation_1_Windows_System_LaunchUriStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::ProcessLauncherResult> => [0xe6827240,0x7a8d,0x51be,0x8d,0x21,0xe0,0x93,0x26,0x8c,0xcc,0x15] as IID_IAsyncOperation_1_Windows_System_ProcessLauncherResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::RemoteLaunchUriStatus> => [0xbb70e5cd,0x62c2,0x5f78,0xac,0x8d,0xf4,0xb9,0x73,0x98,0x1d,0xa4] as IID_IAsyncOperation_1_Windows_System_RemoteLaunchUriStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::remotesystems::RemoteSystem> => [0x0d39f546,0x0eca,0x5236,0xa5,0xca,0x7e,0x36,0x60,0x65,0x84,0x62] as IID_IAsyncOperation_1_Windows_System_RemoteSystems_RemoteSystem }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::remotesystems::RemoteSystemAccessStatus> => [0xd76da678,0xdd76,0x5460,0x87,0x45,0x91,0x5b,0x44,0x10,0xc9,0x05] as IID_IAsyncOperation_1_Windows_System_RemoteSystems_RemoteSystemAccessStatus }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::User> => [0xa895d2f9,0x2399,0x5104,0xa5,0x32,0x5b,0xa4,0x4a,0xb4,0xb1,0x65] as IID_IAsyncOperation_1_Windows_System_User }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::userprofile::SetAccountPictureResult> => [0x6809e406,0x6d3b,0x5164,0x8f,0x32,0xb8,0x45,0xb0,0x78,0x14,0x05] as IID_IAsyncOperation_1_Windows_System_UserProfile_SetAccountPictureResult }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IAsyncOperation<super::system::userprofile::SetImageFeedResult> => [0x5361bfc9,0x0740,0x544a,0x97,0x97,0x1f,0xfe,0x5e,0x73,0xc5,0x4e] as IID_IAsyncOperation_1_Windows_System_UserProfile_SetImageFeedResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::notifications::management::UserNotificationListenerAccessStatus> => [0x0fbad8c7,0x086f,0x5bf9,0x81,0xe2,0x8d,0x79,0xe7,0x18,0x48,0x03] as IID_IAsyncOperation_1_Windows_UI_Notifications_Management_UserNotificationListenerAccessStatus }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::popups::IUICommand> => [0xb8770535,0x6a4b,0x52b1,0xb5,0x78,0xf3,0xcd,0xc5,0x00,0x7a,0x1f] as IID_IAsyncOperation_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::startscreen::JumpList> => [0x1c008c58,0x733b,0x5b42,0x96,0x2a,0xb3,0x33,0x28,0x23,0x6c,0xd3] as IID_IAsyncOperation_1_Windows_UI_StartScreen_JumpList }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::xaml::controls::ContentDialogResult> => [0x1f23bdd1,0x06dc,0x5be9,0x9a,0x60,0x0b,0x4d,0x94,0xd4,0xd7,0x2c] as IID_IAsyncOperation_1_Windows_UI_Xaml_Controls_ContentDialogResult }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::xaml::controls::maps::StreetsidePanorama> => [0x6ad8ea47,0x6670,0x51d8,0xa1,0xdb,0x33,0xfe,0x75,0x49,0x1f,0x0c] as IID_IAsyncOperation_1_Windows_UI_Xaml_Controls_Maps_StreetsidePanorama }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IAsyncOperation<super::ui::xaml::data::LoadMoreItemsResult> => [0xc788089d,0x37ab,0x5ba2,0xb8,0x65,0x5a,0x30,0x9a,0xcd,0xfc,0x4d] as IID_IAsyncOperation_1_Windows_UI_Xaml_Data_LoadMoreItemsResult }
		RT_PINTERFACE!{ for IAsyncOperation<u32> => [0xef60385f,0xbe78,0x584b,0xaa,0xef,0x78,0x29,0xad,0xa2,0xb0,0xde] as IID_IAsyncOperation_1_System_UInt32 }
		RT_PINTERFACE!{ for IAsyncOperation<u64> => [0x2a70d630,0x0767,0x5f0a,0xa1,0xc2,0xde,0xb0,0x81,0x26,0xe2,0x6e] as IID_IAsyncOperation_1_System_UInt64 }
		RT_PINTERFACE!{ for IAsyncOperation<Uri> => [0x641cb9dd,0xa28d,0x59e2,0xb8,0xdb,0xa2,0x27,0xed,0xa6,0xcf,0x2e] as IID_IAsyncOperation_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for IAsyncOperationWithProgress<bool, f64> => [0xaf873c66,0x2df0,0x5a95,0xab,0x54,0x25,0x63,0x4d,0xa3,0xff,0xa9] as IID_IAsyncOperationWithProgress_2_System_Boolean_System_Double }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<collections::IVectorView<super::devices::sms::ISmsMessage>, i32> => [0x12f85589,0x415d,0x5b5d,0xb0,0xd0,0xfd,0xa3,0xb0,0x29,0x5a,0xdc] as IID_IAsyncOperationWithProgress_2_Windows_Foundation_Collections_IVectorView_1_Windows_Devices_Sms_ISmsMessage__System_Int32 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<HString, super::web::http::HttpProgress> => [0x91ecbe45,0xe889,0x5518,0xbd,0x8d,0xc5,0xbd,0xe1,0x63,0x10,0x9b] as IID_IAsyncOperationWithProgress_2_System_String_Windows_Web_Http_HttpProgress }
		RT_PINTERFACE!{ for IAsyncOperationWithProgress<HString, u64> => [0xc8bbcb29,0x6b64,0x5ce2,0xa8,0x31,0x03,0x8f,0x6e,0x02,0x19,0x9e] as IID_IAsyncOperationWithProgress_2_System_String_System_UInt64 }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::devices::scanners::ImageScannerScanResult, u32> => [0x6e6e228a,0xf618,0x5d33,0x85,0x23,0x02,0xd1,0x66,0x72,0x66,0x5b] as IID_IAsyncOperationWithProgress_2_Windows_Devices_Scanners_ImageScannerScanResult_System_UInt32 }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::gaming::input::custom::GipFirmwareUpdateResult, super::gaming::input::custom::GipFirmwareUpdateProgress> => [0xbfaa48bd,0x155f,0x5112,0xbd,0x86,0xe0,0x1d,0x6f,0x7c,0xd4,0x05] as IID_IAsyncOperationWithProgress_2_Windows_Gaming_Input_Custom_GipFirmwareUpdateResult_Windows_Gaming_Input_Custom_GipFirmwareUpdateProgress }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::management::deployment::DeploymentResult, super::management::deployment::DeploymentProgress> => [0x5a97aab7,0xb6ea,0x55ac,0xa5,0xdc,0xd5,0xb1,0x64,0xd9,0x4e,0x94] as IID_IAsyncOperationWithProgress_2_Windows_Management_Deployment_DeploymentResult_Windows_Management_Deployment_DeploymentProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::media::import::PhotoImportDeleteImportedItemsFromSourceResult, f64> => [0x3e2371a9,0x281a,0x5226,0xae,0x85,0xca,0xa5,0x5c,0x0d,0x61,0xde] as IID_IAsyncOperationWithProgress_2_Windows_Media_Import_PhotoImportDeleteImportedItemsFromSourceResult_System_Double }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::media::import::PhotoImportFindItemsResult, u32> => [0x6e6f9b4e,0xc6e1,0x5364,0xa6,0x50,0x11,0xc3,0x52,0x11,0xbe,0xad] as IID_IAsyncOperationWithProgress_2_Windows_Media_Import_PhotoImportFindItemsResult_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::media::import::PhotoImportImportItemsResult, super::media::import::PhotoImportProgress> => [0xd874ec64,0x0951,0x5459,0xa0,0xdd,0x0f,0x8b,0xf3,0x91,0x7e,0xb1] as IID_IAsyncOperationWithProgress_2_Windows_Media_Import_PhotoImportImportItemsResult_Windows_Media_Import_PhotoImportProgress }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::media::protection::RenewalStatus, u32> => [0x595dcc09,0x9ad3,0x5094,0x80,0x0a,0x08,0x83,0xcc,0xe1,0xef,0x01] as IID_IAsyncOperationWithProgress_2_Windows_Media_Protection_RenewalStatus_System_UInt32 }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::media::transcoding::TranscodeFailureReason, f64> => [0x272eec20,0x4b64,0x5d53,0xa6,0x44,0xf9,0x91,0x7b,0x3d,0x19,0xd8] as IID_IAsyncOperationWithProgress_2_Windows_Media_Transcoding_TranscodeFailureReason_System_Double }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::networking::backgroundtransfer::DownloadOperation, super::networking::backgroundtransfer::DownloadOperation> => [0xe86a4f5d,0x743a,0x5f18,0x9d,0x4c,0xbc,0x8e,0xd5,0x94,0x26,0x59] as IID_IAsyncOperationWithProgress_2_Windows_Networking_BackgroundTransfer_DownloadOperation_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::networking::backgroundtransfer::UploadOperation, super::networking::backgroundtransfer::UploadOperation> => [0x35ddaefa,0xdb6a,0x5d0d,0xba,0x54,0xa0,0x72,0x84,0x01,0x17,0x1e] as IID_IAsyncOperationWithProgress_2_Windows_Networking_BackgroundTransfer_UploadOperation_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::services::store::StorePackageUpdateResult, super::services::store::StorePackageUpdateStatus> => [0x42c436ca,0x51f7,0x50b2,0x8f,0xe4,0x7b,0x75,0x40,0x62,0xe6,0xeb] as IID_IAsyncOperationWithProgress_2_Windows_Services_Store_StorePackageUpdateResult_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IBuffer, super::web::http::HttpProgress> => [0x88d9bb75,0xafb4,0x5f32,0x9d,0x7e,0xd3,0xbf,0x37,0x85,0x35,0x4c] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IBuffer, u32> => [0xd26b2819,0x897f,0x5c7d,0x84,0xd6,0x56,0xd7,0x96,0x56,0x14,0x31] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_System_UInt32 }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IBuffer, u64> => [0xad960e7f,0xd73b,0x56e4,0xa5,0x8c,0x6e,0xc7,0x67,0x8c,0xfd,0x88] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer_System_UInt64 }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IInputStream, super::web::http::HttpProgress> => [0x0b97c784,0xdf17,0x571f,0x83,0x37,0x44,0x7d,0xff,0x06,0x8a,0x9c] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IInputStream_Windows_Web_Http_HttpProgress }
		#[cfg(all(feature="windows.storage",feature="windows.web"))] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IInputStream, super::web::syndication::RetrievalProgress> => [0xf71cff65,0xe737,0x5345,0xb3,0x8f,0xfd,0x44,0x5d,0x2d,0xc7,0xe2] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IInputStream_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::storage::streams::IInputStream, u64> => [0x455aa601,0xf13e,0x5dee,0xb9,0xcb,0x16,0xb5,0x31,0x99,0x63,0x27] as IID_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IInputStream_System_UInt64 }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::web::atompub::ServiceDocument, super::web::syndication::RetrievalProgress> => [0xda07abf4,0x91fa,0x5c96,0x84,0xcb,0x45,0x9e,0xa9,0x7b,0x93,0x4d] as IID_IAsyncOperationWithProgress_2_Windows_Web_AtomPub_ServiceDocument_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::web::http::HttpResponseMessage, super::web::http::HttpProgress> => [0x5d144364,0x77d7,0x5eca,0x8b,0x09,0x93,0x6a,0x69,0x44,0x66,0x52] as IID_IAsyncOperationWithProgress_2_Windows_Web_Http_HttpResponseMessage_Windows_Web_Http_HttpProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::web::syndication::SyndicationFeed, super::web::syndication::RetrievalProgress> => [0x92eaf151,0x415e,0x5f87,0x80,0x95,0x78,0x16,0x23,0xc8,0x89,0x98] as IID_IAsyncOperationWithProgress_2_Windows_Web_Syndication_SyndicationFeed_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::web::syndication::SyndicationItem, super::web::syndication::RetrievalProgress> => [0x44fa5a15,0x1204,0x521c,0x85,0xe5,0x01,0x25,0x93,0x01,0xd5,0x27] as IID_IAsyncOperationWithProgress_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_RetrievalProgress }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IAsyncOperationWithProgress<super::web::syndication::SyndicationItem, super::web::syndication::TransferProgress> => [0xe57d0717,0x27c0,0x561e,0xb4,0xb3,0x72,0xaa,0x2b,0x1e,0x3f,0xc9] as IID_IAsyncOperationWithProgress_2_Windows_Web_Syndication_SyndicationItem_Windows_Web_Syndication_TransferProgress }
		RT_PINTERFACE!{ for IAsyncOperationWithProgress<u32, u32> => [0xeccb574a,0xc684,0x5572,0xa6,0x79,0x6b,0x08,0x42,0xcf,0xb5,0x7f] as IID_IAsyncOperationWithProgress_2_System_UInt32_System_UInt32 }
		RT_PINTERFACE!{ for IAsyncOperationWithProgress<u64, u64> => [0x8f1db6e3,0x6556,0x5516,0x82,0x5c,0x10,0x21,0xee,0x27,0xcd,0x0c] as IID_IAsyncOperationWithProgress_2_System_UInt64_System_UInt64 }
		RT_PINTERFACE!{ for IReference<::Char> => [0xfb393ef3,0xbbac,0x5bd5,0x91,0x44,0x84,0xf2,0x35,0x76,0xf4,0x15] as IID_IReference_1_System_Char }
		RT_PINTERFACE!{ for IReference<::Guid> => [0x7d50f649,0x632c,0x51f9,0x84,0x9a,0xee,0x49,0x42,0x89,0x33,0xea] as IID_IReference_1_System_Guid }
		RT_PINTERFACE!{ for IReference<bool> => [0x3c00fd60,0x2950,0x5939,0xa2,0x1a,0x2d,0x12,0xc5,0xa0,0x1b,0x8a] as IID_IReference_1_System_Boolean }
		RT_PINTERFACE!{ for IReference<DateTime> => [0x5541d8a7,0x497c,0x5aa4,0x86,0xfc,0x77,0x13,0xad,0xbf,0x2a,0x2c] as IID_IReference_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IReference<f32> => [0x719cc2ba,0x3e76,0x5def,0x9f,0x1a,0x38,0xd8,0x5a,0x14,0x5e,0xa8] as IID_IReference_1_System_Single }
		RT_PINTERFACE!{ for IReference<f64> => [0x2f2d6c29,0x5473,0x5f3e,0x92,0xe7,0x96,0x57,0x2b,0xb9,0x90,0xe2] as IID_IReference_1_System_Double }
		RT_PINTERFACE!{ for IReference<HString> => [0xfd416dfb,0x2a07,0x52eb,0xaa,0xe3,0xdf,0xce,0x14,0x11,0x6c,0x05] as IID_IReference_1_System_String }
		RT_PINTERFACE!{ for IReference<i16> => [0x6ec9e41b,0x6709,0x5647,0x99,0x18,0xa1,0x27,0x01,0x10,0xfc,0x4e] as IID_IReference_1_System_Int16 }
		RT_PINTERFACE!{ for IReference<i32> => [0x548cefbd,0xbc8a,0x5fa0,0x8d,0xf2,0x95,0x74,0x40,0xfc,0x8b,0xf4] as IID_IReference_1_System_Int32 }
		RT_PINTERFACE!{ for IReference<i64> => [0x4dda9e24,0xe69f,0x5c6a,0xa0,0xa6,0x93,0x42,0x73,0x65,0xaf,0x2a] as IID_IReference_1_System_Int64 }
		RT_PINTERFACE!{ for IReference<i8> => [0x95500129,0xfbf6,0x5afc,0x89,0xdf,0x70,0x64,0x2d,0x74,0x19,0x90] as IID_IReference_1_System_SByte }
		RT_PINTERFACE!{ for IReference<IInspectable> => [0x06dccc90,0xa058,0x5c88,0x87,0xb7,0x6f,0x33,0x60,0xa2,0xfc,0x16] as IID_IReference_1_System_Object }
		RT_PINTERFACE!{ for IReference<numerics::Matrix4x4> => [0xdacbffdc,0x68ef,0x5fd0,0xb6,0x57,0x78,0x2d,0x0a,0xc9,0x80,0x7e] as IID_IReference_1_Windows_Foundation_Numerics_Matrix4x4 }
		RT_PINTERFACE!{ for IReference<numerics::Quaternion> => [0xb27004bb,0xc014,0x5dce,0x9a,0x21,0x79,0x9c,0x5a,0x3c,0x14,0x61] as IID_IReference_1_Windows_Foundation_Numerics_Quaternion }
		RT_PINTERFACE!{ for IReference<numerics::Vector3> => [0x1ee770ff,0xc954,0x59ca,0xa7,0x54,0x61,0x99,0xa9,0xbe,0x28,0x2c] as IID_IReference_1_Windows_Foundation_Numerics_Vector3 }
		RT_PINTERFACE!{ for IReference<Point> => [0x84f14c22,0xa00a,0x5272,0x8d,0x3d,0x82,0x11,0x2e,0x66,0xdf,0x00] as IID_IReference_1_Windows_Foundation_Point }
		RT_PINTERFACE!{ for IReference<Rect> => [0x80423f11,0x054f,0x5eac,0xaf,0xd3,0x63,0xb6,0xce,0x15,0xe7,0x7b] as IID_IReference_1_Windows_Foundation_Rect }
		RT_PINTERFACE!{ for IReference<Size> => [0x61723086,0x8e53,0x5276,0x9f,0x36,0x2a,0x4b,0xb9,0x3e,0x2b,0x75] as IID_IReference_1_Windows_Foundation_Size }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IReference<super::applicationmodel::email::EmailMailboxSmimeEncryptionAlgorithm> => [0x433b124d,0x60e6,0x5b7a,0x96,0xbc,0x86,0x81,0xde,0x5f,0x5e,0x75] as IID_IReference_1_Windows_ApplicationModel_Email_EmailMailboxSmimeEncryptionAlgorithm }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IReference<super::applicationmodel::email::EmailMailboxSmimeSigningAlgorithm> => [0xe498a622,0xf168,0x5104,0xa5,0x3b,0xfa,0xf9,0x96,0xf5,0x16,0x32] as IID_IReference_1_Windows_ApplicationModel_Email_EmailMailboxSmimeSigningAlgorithm }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IReference<super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFlags> => [0x91c0ba96,0x9e69,0x5b82,0xbf,0x1d,0x83,0xab,0x2a,0x50,0x9c,0x53] as IID_IReference_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementFlags }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IReference<super::devices::geolocation::BasicGeoposition> => [0xe4d5dda6,0xf57c,0x57cc,0xb6,0x7f,0x29,0x39,0xa9,0x01,0xda,0xbe] as IID_IReference_1_Windows_Devices_Geolocation_BasicGeoposition }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IReference<super::graphics::holographic::HolographicStereoTransform> => [0x6e67ce78,0xcc67,0x52c0,0xb6,0x35,0x99,0x1d,0xb0,0xbf,0xf5,0xca] as IID_IReference_1_Windows_Graphics_Holographic_HolographicStereoTransform }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IReference<super::media::capture::WhiteBalanceGain> => [0x79c7838a,0x39e2,0x5287,0xac,0x3b,0xb1,0x18,0xdb,0x25,0x10,0x02] as IID_IReference_1_Windows_Media_Capture_WhiteBalanceGain }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IReference<super::media::devices::CaptureSceneMode> => [0xe20596aa,0x0bbe,0x5203,0xbe,0x6b,0x6b,0x71,0xff,0x5b,0x08,0x43] as IID_IReference_1_Windows_Media_Devices_CaptureSceneMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IReference<super::media::devices::ManualFocusDistance> => [0xb0060b8a,0x1105,0x5ad4,0x96,0x3d,0xf6,0xcf,0x19,0x05,0xd3,0x49] as IID_IReference_1_Windows_Media_Devices_ManualFocusDistance }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IReference<super::media::devices::MediaCaptureFocusState> => [0x58820185,0x5da0,0x5faa,0x86,0xda,0x9b,0xd9,0xf0,0x39,0x74,0xfa] as IID_IReference_1_Windows_Media_Devices_MediaCaptureFocusState }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IReference<super::media::protection::HdcpProtection> => [0x8e330979,0x2fef,0x5d68,0x88,0xaa,0xa9,0xee,0x66,0x97,0xd1,0x17] as IID_IReference_1_Windows_Media_Protection_HdcpProtection }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IReference<super::perception::spatial::SpatialBoundingFrustum> => [0xf434face,0x0c36,0x5749,0xa8,0xa0,0x0b,0xb6,0xce,0x78,0xa6,0x14] as IID_IReference_1_Windows_Perception_Spatial_SpatialBoundingFrustum }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IReference<super::perception::spatial::SpatialBoundingOrientedBox> => [0x09f88309,0x9f81,0x5207,0xbd,0xb2,0xab,0xef,0x92,0x6d,0xb1,0x8f] as IID_IReference_1_Windows_Perception_Spatial_SpatialBoundingOrientedBox }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IReference<super::ui::Color> => [0xab8e5d11,0xb0c1,0x5a21,0x95,0xae,0xf1,0x6b,0xf3,0xa3,0x76,0x24] as IID_IReference_1_Windows_UI_Color }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IReference<super::ui::text::UnderlineType> => [0x1b63ec17,0x7b2b,0x59fe,0xab,0x9d,0xb6,0x0e,0xa4,0xf9,0xc9,0xb8] as IID_IReference_1_Windows_UI_Text_UnderlineType }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IReference<super::ui::viewmanagement::UIElementType> => [0xe17e08c9,0x7deb,0x51d1,0x84,0x87,0x33,0x4e,0xb3,0xfe,0x46,0x91] as IID_IReference_1_Windows_UI_ViewManagement_UIElementType }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IReference<super::ui::xaml::Thickness> => [0xa19f7ba8,0xd8cd,0x5df2,0xab,0x44,0xfe,0xfd,0x26,0x64,0x44,0x84] as IID_IReference_1_Windows_UI_Xaml_Thickness }
		RT_PINTERFACE!{ for IReference<TimeSpan> => [0x604d0c4c,0x91de,0x5c2a,0x93,0x5f,0x36,0x2f,0x13,0xea,0xf8,0x00] as IID_IReference_1_Windows_Foundation_TimeSpan }
		RT_PINTERFACE!{ for IReference<u16> => [0x5ab7d2c3,0x6b62,0x5e71,0xa4,0xb6,0x2d,0x49,0xc4,0xf2,0x38,0xfd] as IID_IReference_1_System_UInt16 }
		RT_PINTERFACE!{ for IReference<u32> => [0x513ef3af,0xe784,0x5325,0xa9,0x1e,0x97,0xc2,0xb8,0x11,0x1c,0xf3] as IID_IReference_1_System_UInt32 }
		RT_PINTERFACE!{ for IReference<u64> => [0x6755e376,0x53bb,0x568b,0xa1,0x1d,0x17,0x23,0x98,0x68,0x30,0x9e] as IID_IReference_1_System_UInt64 }
		RT_PINTERFACE!{ for IReference<u8> => [0xe5198cc8,0x2873,0x55f5,0xb0,0xa1,0x84,0xff,0x9e,0x4a,0xad,0x62] as IID_IReference_1_System_Byte }
		RT_PINTERFACE!{ for IReferenceArray<::Char> => [0xa4095aab,0xeb7d,0x5782,0x8f,0xad,0x16,0x09,0xde,0xa2,0x49,0xad] as IID_IReferenceArray_1_System_Char }
		RT_PINTERFACE!{ for IReferenceArray<::Guid> => [0xeecf9838,0xc1c2,0x5b4a,0x97,0x6f,0xce,0xc2,0x61,0xae,0x1d,0x55] as IID_IReferenceArray_1_System_Guid }
		RT_PINTERFACE!{ for IReferenceArray<bool> => [0xe8e72666,0x48cc,0x593f,0xba,0x85,0x26,0x63,0x49,0x69,0x56,0xe3] as IID_IReferenceArray_1_System_Boolean }
		RT_PINTERFACE!{ for IReferenceArray<DateTime> => [0x1b8e9594,0x588e,0x5a07,0x9e,0x65,0x07,0x31,0xa4,0xc9,0xa2,0xdb] as IID_IReferenceArray_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IReferenceArray<f32> => [0x6ab1ea83,0xcb41,0x5f99,0x92,0xcc,0x23,0xbd,0x43,0x36,0xa1,0xfb] as IID_IReferenceArray_1_System_Single }
		RT_PINTERFACE!{ for IReferenceArray<f64> => [0xd301f253,0xe0a3,0x5d2b,0x9a,0x41,0xa4,0xd6,0x2b,0xec,0x46,0x23] as IID_IReferenceArray_1_System_Double }
		RT_PINTERFACE!{ for IReferenceArray<HString> => [0x0385688e,0xe3c7,0x5c5e,0xa3,0x89,0x55,0x24,0xed,0xe3,0x49,0xf1] as IID_IReferenceArray_1_System_String }
		RT_PINTERFACE!{ for IReferenceArray<i16> => [0x912f8fd7,0xadc0,0x5d60,0xa8,0x96,0x7e,0xd7,0x60,0x89,0xcc,0x5b] as IID_IReferenceArray_1_System_Int16 }
		RT_PINTERFACE!{ for IReferenceArray<i32> => [0xa6d080a5,0xb087,0x5bc2,0x9a,0x9f,0x5c,0xd6,0x87,0xb4,0xd1,0xf7] as IID_IReferenceArray_1_System_Int32 }
		RT_PINTERFACE!{ for IReferenceArray<i64> => [0x6e333271,0x2e2a,0x5955,0x87,0x90,0x83,0x6c,0x76,0xee,0x53,0xb6] as IID_IReferenceArray_1_System_Int64 }
		RT_PINTERFACE!{ for IReferenceArray<i8> => [0x08de13ea,0xbbbf,0x50db,0xa4,0x03,0x57,0x84,0x20,0xbb,0x49,0xef] as IID_IReferenceArray_1_System_SByte }
		RT_PINTERFACE!{ for IReferenceArray<IInspectable> => [0x9cd7a84f,0x0c80,0x59c5,0xb4,0x4e,0x97,0x78,0x41,0xbb,0x43,0xd9] as IID_IReferenceArray_1_System_Object }
		RT_PINTERFACE!{ for IReferenceArray<Point> => [0x39313214,0x5c7d,0x599d,0xae,0x5a,0x17,0xd9,0xd6,0x49,0x22,0x58] as IID_IReferenceArray_1_Windows_Foundation_Point }
		RT_PINTERFACE!{ for IReferenceArray<Rect> => [0x8a444256,0xd661,0x5e9a,0xa7,0x2b,0xd8,0xf1,0xd7,0x96,0x2d,0x0c] as IID_IReferenceArray_1_Windows_Foundation_Rect }
		RT_PINTERFACE!{ for IReferenceArray<Size> => [0x3b40e9d4,0xe0c3,0x56f6,0xb8,0x8b,0xe5,0x05,0xeb,0x73,0x75,0x7b] as IID_IReferenceArray_1_Windows_Foundation_Size }
		RT_PINTERFACE!{ for IReferenceArray<TimeSpan> => [0xad73197d,0x2cfa,0x57a6,0x89,0x93,0x9f,0xac,0x40,0xfe,0xb7,0x91] as IID_IReferenceArray_1_Windows_Foundation_TimeSpan }
		RT_PINTERFACE!{ for IReferenceArray<u16> => [0x6624a2dd,0x83f7,0x519c,0x9d,0x55,0xbb,0x1f,0x65,0x60,0x45,0x6b] as IID_IReferenceArray_1_System_UInt16 }
		RT_PINTERFACE!{ for IReferenceArray<u32> => [0x97374b68,0xeb87,0x56cc,0xb1,0x8e,0x27,0xef,0x0f,0x9c,0xfc,0x0c] as IID_IReferenceArray_1_System_UInt32 }
		RT_PINTERFACE!{ for IReferenceArray<u64> => [0x38b60434,0xd67c,0x523e,0x9d,0x0e,0x24,0xd6,0x43,0x41,0x10,0x73] as IID_IReferenceArray_1_System_UInt64 }
		RT_PINTERFACE!{ for IReferenceArray<u8> => [0x2af22683,0x3734,0x56d0,0xa6,0x0e,0x68,0x8c,0xc8,0x5d,0x16,0x19] as IID_IReferenceArray_1_System_Byte }
		RT_PINTERFACE!{ for TypedEventHandler<diagnostics::IFileLoggingSession, diagnostics::LogFileGeneratedEventArgs> => [0x0c6563b0,0x9d8b,0x5b60,0x99,0x4b,0xde,0xe1,0x17,0x4d,0x1e,0xfb] as IID_TypedEventHandler_2_Windows_Foundation_Diagnostics_IFileLoggingSession_Windows_Foundation_Diagnostics_LogFileGeneratedEventArgs }
		RT_PINTERFACE!{ for TypedEventHandler<diagnostics::ILoggingChannel, IInspectable> => [0x52c9c2a1,0x54a3,0x5ef9,0x9a,0xff,0x01,0x4e,0x7c,0x45,0x46,0x55] as IID_TypedEventHandler_2_Windows_Foundation_Diagnostics_ILoggingChannel_System_Object }
		RT_PINTERFACE!{ for TypedEventHandler<IInspectable, IInspectable> => [0xc7e65ce2,0xfad5,0x5e3b,0x9c,0x58,0x18,0x6c,0xa8,0xc1,0xdd,0x57] as IID_TypedEventHandler_2_System_Object_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::applicationmodel::extendedexecution::ExtendedExecutionRevokedEventArgs> => [0xb6d68d9c,0x9546,0x50b3,0x8a,0xf6,0x9c,0x98,0x5a,0x37,0x2b,0xa8] as IID_TypedEventHandler_2_System_Object_Windows_ApplicationModel_ExtendedExecution_ExtendedExecutionRevokedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::applicationmodel::extendedexecution::foreground::ExtendedExecutionForegroundRevokedEventArgs> => [0xf874197a,0xbf19,0x5482,0x9a,0xb1,0x34,0x92,0x3d,0xe6,0x73,0x8d] as IID_TypedEventHandler_2_System_Object_Windows_ApplicationModel_ExtendedExecution_Foreground_ExtendedExecutionForegroundRevokedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::media::devices::DefaultAudioCaptureDeviceChangedEventArgs> => [0x97d07327,0x2c78,0x57bc,0x98,0xe6,0xa2,0x4c,0xd0,0x24,0xcf,0x5b] as IID_TypedEventHandler_2_System_Object_Windows_Media_Devices_DefaultAudioCaptureDeviceChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::media::devices::DefaultAudioRenderDeviceChangedEventArgs> => [0xfd732aca,0xdafc,0x5b7d,0xbf,0x72,0xb5,0x60,0xb7,0x8d,0x26,0x0c] as IID_TypedEventHandler_2_System_Object_Windows_Media_Devices_DefaultAudioRenderDeviceChangedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::networking::proximity::ConnectionRequestedEventArgs> => [0x512c383c,0x8b29,0x5079,0x95,0x3e,0x8d,0xee,0x8f,0x8a,0x82,0x24] as IID_TypedEventHandler_2_System_Object_Windows_Networking_Proximity_ConnectionRequestedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::networking::proximity::TriggeredConnectionStateChangedEventArgs> => [0x2e5ad6fa,0x3ca6,0x5518,0xbd,0x4d,0xfe,0xfc,0x45,0x35,0x58,0x0e] as IID_TypedEventHandler_2_System_Object_Windows_Networking_Proximity_TriggeredConnectionStateChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::composition::CompositionBatchCompletedEventArgs> => [0x9df03456,0x3383,0x508b,0x9c,0x75,0xee,0x84,0x0a,0x7e,0x1a,0x39] as IID_TypedEventHandler_2_System_Object_Windows_UI_Composition_CompositionBatchCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::CharacterReceivedEventArgs> => [0x5aa4a848,0x86b2,0x506b,0x89,0xab,0x5e,0xb5,0x78,0x64,0x20,0xc6] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_CharacterReceivedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::CoreWindowEventArgs> => [0x1a8ac270,0xa777,0x50f7,0x88,0xa1,0xe3,0x4e,0x56,0xc0,0x94,0x49] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_CoreWindowEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::InputEnabledEventArgs> => [0xc9965f1c,0x3641,0x51b6,0xb8,0x23,0x04,0x8e,0xc3,0x62,0x8f,0xb0] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_InputEnabledEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::KeyEventArgs> => [0xeadffdf7,0xd70e,0x5688,0x90,0x6c,0xc2,0xb1,0x22,0x9e,0xa1,0x6d] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_KeyEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::PointerEventArgs> => [0x26aabf41,0xa0fd,0x5e66,0xb1,0x88,0x6c,0x74,0x18,0x2d,0x00,0xcd] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<IInspectable, super::ui::core::TouchHitTestingEventArgs> => [0xc76e9d25,0x6a96,0x58fd,0x87,0x4f,0xae,0x52,0xbd,0x60,0x3a,0xf8] as IID_TypedEventHandler_2_System_Object_Windows_UI_Core_TouchHitTestingEventArgs }
		RT_PINTERFACE!{ for TypedEventHandler<IMemoryBufferReference, IInspectable> => [0xf4637d4a,0x0760,0x5431,0xbf,0xc0,0x24,0xeb,0x1d,0x4f,0x6c,0x4f] as IID_TypedEventHandler_2_Windows_Foundation_IMemoryBufferReference_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::activation::SplashScreen, IInspectable> => [0x7725b2a5,0x287d,0x5ed2,0xa7,0x89,0x2a,0x6a,0x26,0x73,0xc7,0xfe] as IID_TypedEventHandler_2_Windows_ApplicationModel_Activation_SplashScreen_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appextensions::AppExtensionCatalog, super::applicationmodel::appextensions::AppExtensionPackageInstalledEventArgs> => [0x26460556,0x9f0a,0x562e,0x91,0x65,0x9e,0xb9,0xe1,0x89,0x8b,0x1e] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppExtensions_AppExtensionCatalog_Windows_ApplicationModel_AppExtensions_AppExtensionPackageInstalledEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appextensions::AppExtensionCatalog, super::applicationmodel::appextensions::AppExtensionPackageStatusChangedEventArgs> => [0x61a2a9c0,0xd3bb,0x5953,0x8d,0xf7,0x59,0x1f,0xdd,0x5b,0xd7,0x4a] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppExtensions_AppExtensionCatalog_Windows_ApplicationModel_AppExtensions_AppExtensionPackageStatusChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appextensions::AppExtensionCatalog, super::applicationmodel::appextensions::AppExtensionPackageUninstallingEventArgs> => [0x60e847e8,0x2eca,0x54be,0x8b,0x13,0x9e,0x62,0xdb,0xd5,0xb9,0x5d] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppExtensions_AppExtensionCatalog_Windows_ApplicationModel_AppExtensions_AppExtensionPackageUninstallingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appextensions::AppExtensionCatalog, super::applicationmodel::appextensions::AppExtensionPackageUpdatedEventArgs> => [0xa7e0dc0b,0x525e,0x52b1,0xb1,0xd9,0x2d,0x5b,0x4b,0x52,0x94,0xa5] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppExtensions_AppExtensionCatalog_Windows_ApplicationModel_AppExtensions_AppExtensionPackageUpdatedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appextensions::AppExtensionCatalog, super::applicationmodel::appextensions::AppExtensionPackageUpdatingEventArgs> => [0x91f40910,0x6acf,0x510d,0x8d,0x7b,0x0b,0xd0,0x5b,0x83,0x58,0x83] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppExtensions_AppExtensionCatalog_Windows_ApplicationModel_AppExtensions_AppExtensionPackageUpdatingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::AppointmentCalendarSyncManager, IInspectable> => [0xbd1308de,0x6d2e,0x5541,0xb2,0x54,0xbd,0xb6,0x18,0x39,0xba,0xc1] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_AppointmentCalendarSyncManager_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::AppointmentStore, super::applicationmodel::appointments::AppointmentStoreChangedEventArgs> => [0x9e628351,0xc639,0x5cef,0xab,0x1d,0x8b,0xea,0xe9,0xd7,0x5d,0x52] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_AppointmentStore_Windows_ApplicationModel_Appointments_AppointmentStoreChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarCancelMeetingRequestEventArgs> => [0x0e9cc1d8,0x0d26,0x5207,0xb7,0xd9,0x9a,0xd1,0xbf,0x66,0xe1,0xe6] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarCancelMeetingRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs> => [0xb45150b9,0xdf09,0x5c86,0xb5,0x7d,0x3e,0x6d,0xef,0xf2,0x47,0x67] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarForwardMeetingRequestEventArgs> => [0x8961d738,0xecdc,0x53c8,0xb0,0xec,0xe7,0x29,0xd8,0x10,0x94,0x59] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarForwardMeetingRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs> => [0x4fe460a4,0xe875,0x5836,0x9e,0xec,0x27,0x3d,0x52,0xc8,0x6a,0xb3] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarSyncManagerSyncRequestEventArgs> => [0x37f52677,0x5f3a,0x57e6,0x82,0xf5,0xcb,0xab,0x2e,0x4d,0xbe,0x8e] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarSyncManagerSyncRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appointments::dataprovider::AppointmentDataProviderConnection, super::applicationmodel::appointments::dataprovider::AppointmentCalendarUpdateMeetingResponseRequestEventArgs> => [0x5370df2b,0x62cd,0x5133,0x93,0xe6,0xfc,0x80,0xa5,0x02,0xaf,0x64] as IID_TypedEventHandler_2_Windows_ApplicationModel_Appointments_DataProvider_AppointmentDataProviderConnection_Windows_ApplicationModel_Appointments_DataProvider_AppointmentCalendarUpdateMeetingResponseRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appservice::AppServiceConnection, super::applicationmodel::appservice::AppServiceClosedEventArgs> => [0xe4efa98d,0x4bfc,0x5e61,0xa2,0x33,0x68,0x8f,0x5f,0x06,0x52,0x1f] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppService_AppServiceConnection_Windows_ApplicationModel_AppService_AppServiceClosedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::appservice::AppServiceConnection, super::applicationmodel::appservice::AppServiceRequestReceivedEventArgs> => [0x18c67d61,0x4176,0x5553,0xb1,0x8d,0xd8,0xf5,0x7f,0xe7,0x95,0x52] as IID_TypedEventHandler_2_Windows_ApplicationModel_AppService_AppServiceConnection_Windows_ApplicationModel_AppService_AppServiceRequestReceivedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::LockScreenCallUI, IInspectable> => [0xaddada2a,0xe5a7,0x5921,0xb7,0xe0,0x17,0x32,0x3a,0xdf,0x73,0x82] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_LockScreenCallUI_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::LockScreenCallUI, super::applicationmodel::calls::LockScreenCallEndRequestedEventArgs> => [0x92f7c40e,0xe7b9,0x5f68,0x98,0xf0,0x56,0xfb,0x89,0x01,0x58,0x06] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_LockScreenCallUI_Windows_ApplicationModel_Calls_LockScreenCallEndRequestedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::VoipCallCoordinator, super::applicationmodel::calls::MuteChangeEventArgs> => [0xecafec77,0x4bf6,0x57b7,0x86,0xc6,0xe2,0xfe,0xca,0x5b,0x5a,0xee] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_VoipCallCoordinator_Windows_ApplicationModel_Calls_MuteChangeEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::VoipPhoneCall, super::applicationmodel::calls::CallAnswerEventArgs> => [0xd47be4da,0xc00c,0x5faa,0xbf,0xa5,0x1b,0x11,0xe0,0xc3,0xcc,0xc1] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_VoipPhoneCall_Windows_ApplicationModel_Calls_CallAnswerEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::VoipPhoneCall, super::applicationmodel::calls::CallRejectEventArgs> => [0xd06255ce,0x0967,0x5441,0x8f,0xe6,0xed,0x2e,0x70,0x08,0x19,0x7e] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_VoipPhoneCall_Windows_ApplicationModel_Calls_CallRejectEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::calls::VoipPhoneCall, super::applicationmodel::calls::CallStateChangeEventArgs> => [0x1e00c6cc,0xe14c,0x51ce,0x93,0xf3,0x0a,0x0a,0x9a,0x3f,0x3e,0xec] as IID_TypedEventHandler_2_Windows_ApplicationModel_Calls_VoipPhoneCall_Windows_ApplicationModel_Calls_CallStateChangeEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::chat::ChatConversation, super::applicationmodel::chat::RemoteParticipantComposingChangedEventArgs> => [0x09e43bb2,0x692d,0x5330,0xb9,0xe7,0xad,0xf6,0x9a,0xd5,0xc1,0xa9] as IID_TypedEventHandler_2_Windows_ApplicationModel_Chat_ChatConversation_Windows_ApplicationModel_Chat_RemoteParticipantComposingChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::chat::ChatMessageStore, super::applicationmodel::chat::ChatMessageChangedEventArgs> => [0x2a4ed3d1,0x0d01,0x5133,0xb9,0xe4,0xdd,0xf6,0x8f,0x09,0x94,0x85] as IID_TypedEventHandler_2_Windows_ApplicationModel_Chat_ChatMessageStore_Windows_ApplicationModel_Chat_ChatMessageChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::chat::ChatMessageStore, super::applicationmodel::chat::ChatMessageStoreChangedEventArgs> => [0x3b5903d7,0xa037,0x5c7c,0x83,0x36,0x88,0x42,0x3d,0x81,0xe4,0x08] as IID_TypedEventHandler_2_Windows_ApplicationModel_Chat_ChatMessageStore_Windows_ApplicationModel_Chat_ChatMessageStoreChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::chat::RcsEndUserMessageManager, super::applicationmodel::chat::RcsEndUserMessageAvailableEventArgs> => [0x8d6beb36,0xf6ce,0x5769,0x96,0xc2,0x25,0x32,0x6e,0xb4,0x63,0xf6] as IID_TypedEventHandler_2_Windows_ApplicationModel_Chat_RcsEndUserMessageManager_Windows_ApplicationModel_Chat_RcsEndUserMessageAvailableEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::chat::RcsTransport, super::applicationmodel::chat::RcsServiceKindSupportedChangedEventArgs> => [0xe5f1c3a4,0xe498,0x50b0,0x91,0xfe,0x94,0xeb,0xb0,0x1d,0xe0,0xab] as IID_TypedEventHandler_2_Windows_ApplicationModel_Chat_RcsTransport_Windows_ApplicationModel_Chat_RcsServiceKindSupportedChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::ContactList, super::applicationmodel::contacts::ContactChangedEventArgs> => [0xc953dc00,0x30be,0x5379,0xbc,0xac,0x43,0x5c,0x6b,0xad,0x3c,0xe6] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_ContactList_Windows_ApplicationModel_Contacts_ContactChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::ContactListSyncManager, IInspectable> => [0xf0c4ce23,0x4e80,0x5cb1,0x9f,0x43,0xfb,0xdc,0x1c,0x60,0x91,0x22] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_ContactListSyncManager_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::ContactStore, super::applicationmodel::contacts::ContactChangedEventArgs> => [0x5da35e68,0x7513,0x5ead,0xaa,0xd4,0xcd,0xd3,0xde,0x4e,0x5a,0xe7] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_ContactStore_Windows_ApplicationModel_Contacts_ContactChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::dataprovider::ContactDataProviderConnection, super::applicationmodel::contacts::dataprovider::ContactListServerSearchReadBatchRequestEventArgs> => [0xbaee1b2f,0xa5b6,0x5a03,0xae,0x59,0xfb,0x18,0xf3,0xe0,0x25,0xb7] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_DataProvider_ContactDataProviderConnection_Windows_ApplicationModel_Contacts_DataProvider_ContactListServerSearchReadBatchRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::dataprovider::ContactDataProviderConnection, super::applicationmodel::contacts::dataprovider::ContactListSyncManagerSyncRequestEventArgs> => [0xbb9f410f,0xa739,0x5280,0x9b,0xb7,0xb6,0xa9,0x38,0xc7,0xa6,0x20] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_DataProvider_ContactDataProviderConnection_Windows_ApplicationModel_Contacts_DataProvider_ContactListSyncManagerSyncRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::contacts::provider::ContactPickerUI, super::applicationmodel::contacts::provider::ContactRemovedEventArgs> => [0xa39aeb7e,0x765c,0x5e83,0xb2,0x31,0x84,0xbe,0xad,0x98,0xe9,0xa0] as IID_TypedEventHandler_2_Windows_ApplicationModel_Contacts_Provider_ContactPickerUI_Windows_ApplicationModel_Contacts_Provider_ContactRemovedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::core::CoreApplicationView, super::applicationmodel::activation::IActivatedEventArgs> => [0xcf193a96,0xeb13,0x5e3b,0x8b,0xdf,0x87,0xb6,0xef,0xae,0x83,0x39] as IID_TypedEventHandler_2_Windows_ApplicationModel_Core_CoreApplicationView_Windows_ApplicationModel_Activation_IActivatedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::core::CoreApplicationView, super::applicationmodel::core::HostedViewClosingEventArgs> => [0xd9a3f433,0x9bcc,0x54d6,0xb3,0xcf,0x7b,0x01,0xf0,0x26,0xd4,0xcd] as IID_TypedEventHandler_2_Windows_ApplicationModel_Core_CoreApplicationView_Windows_ApplicationModel_Core_HostedViewClosingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::core::CoreApplicationViewTitleBar, IInspectable> => [0x28342e21,0xdad3,0x5e32,0xba,0xe1,0xaf,0xe7,0xb2,0x6c,0x66,0xfb] as IID_TypedEventHandler_2_Windows_ApplicationModel_Core_CoreApplicationViewTitleBar_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::datatransfer::DataPackage, IInspectable> => [0xc156b0c3,0x1cbc,0x5ca4,0x90,0x1c,0x62,0xc5,0xa8,0xca,0x5c,0xb5] as IID_TypedEventHandler_2_Windows_ApplicationModel_DataTransfer_DataPackage_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::datatransfer::DataPackage, super::applicationmodel::datatransfer::OperationCompletedEventArgs> => [0xdd48af6c,0xef9a,0x59cb,0xb3,0x26,0x57,0xd9,0xe2,0x41,0x1f,0x21] as IID_TypedEventHandler_2_Windows_ApplicationModel_DataTransfer_DataPackage_Windows_ApplicationModel_DataTransfer_OperationCompletedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::datatransfer::DataTransferManager, super::applicationmodel::datatransfer::DataRequestedEventArgs> => [0xec6f9cc8,0x46d0,0x5e0e,0xb4,0xd2,0x7d,0x77,0x73,0xae,0x37,0xa0] as IID_TypedEventHandler_2_Windows_ApplicationModel_DataTransfer_DataTransferManager_Windows_ApplicationModel_DataTransfer_DataRequestedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::datatransfer::DataTransferManager, super::applicationmodel::datatransfer::TargetApplicationChosenEventArgs> => [0xc4ac1ba2,0x7851,0x5a44,0xbc,0x8d,0x3d,0x7c,0x71,0x3f,0x1f,0x41] as IID_TypedEventHandler_2_Windows_ApplicationModel_DataTransfer_DataTransferManager_Windows_ApplicationModel_DataTransfer_TargetApplicationChosenEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::datatransfer::dragdrop::core::CoreDragDropManager, super::applicationmodel::datatransfer::dragdrop::core::CoreDropOperationTargetRequestedEventArgs> => [0xa4c3b1c1,0xb8ad,0x58cb,0xac,0xc0,0x8e,0xf3,0x7e,0xae,0x4e,0xd4] as IID_TypedEventHandler_2_Windows_ApplicationModel_DataTransfer_DragDrop_Core_CoreDragDropManager_Windows_ApplicationModel_DataTransfer_DragDrop_Core_CoreDropOperationTargetRequestedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxCreateFolderRequestEventArgs> => [0x8c7db52d,0x496e,0x5419,0xbd,0x78,0xb8,0xb6,0x57,0xcf,0x4e,0x66] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxCreateFolderRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxDeleteFolderRequestEventArgs> => [0xd962a9b6,0xbbb4,0x5d82,0x84,0xb4,0x8f,0x70,0x3b,0xf3,0x08,0x6f] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxDeleteFolderRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxDownloadAttachmentRequestEventArgs> => [0xd2e92019,0xb997,0x5cd6,0x8f,0x88,0x4d,0xbc,0x6f,0x96,0x9f,0x15] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxDownloadAttachmentRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxDownloadMessageRequestEventArgs> => [0xe1b59b2f,0xddd5,0x5159,0xae,0x9a,0x14,0xa8,0x66,0x91,0x20,0x95] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxDownloadMessageRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxEmptyFolderRequestEventArgs> => [0x9a851b84,0xbcb1,0x5121,0xab,0x61,0x3e,0xfe,0x56,0x8f,0x68,0x3d] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxEmptyFolderRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxForwardMeetingRequestEventArgs> => [0x9d6a017f,0x5a70,0x5d83,0xa6,0x80,0xd2,0x80,0x67,0x48,0xca,0x0b] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxForwardMeetingRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxGetAutoReplySettingsRequestEventArgs> => [0x587c6f92,0xa969,0x57b3,0x89,0x5f,0x9a,0x06,0xb3,0x65,0x0d,0x3a] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxGetAutoReplySettingsRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxMoveFolderRequestEventArgs> => [0x2c6bf2c8,0x42f3,0x523d,0x80,0xdb,0x17,0x0e,0x4f,0xb1,0x56,0x7f] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxMoveFolderRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxProposeNewTimeForMeetingRequestEventArgs> => [0x309d8bde,0x1e60,0x524b,0x82,0x8c,0x5a,0x3d,0x64,0xa6,0x72,0xaa] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxProposeNewTimeForMeetingRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxResolveRecipientsRequestEventArgs> => [0xec14e586,0xe4fb,0x5fc0,0x91,0xfc,0x93,0x1c,0xe1,0x7a,0x3f,0xc3] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxResolveRecipientsRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxServerSearchReadBatchRequestEventArgs> => [0xf8bf9067,0x7d11,0x56a0,0xa3,0x03,0x16,0x34,0x35,0xc1,0x40,0x16] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxServerSearchReadBatchRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxSetAutoReplySettingsRequestEventArgs> => [0xaa4f8fb3,0x05e0,0x54e6,0xaf,0xac,0xa2,0x8e,0x85,0x3e,0x75,0x6e] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxSetAutoReplySettingsRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxSyncManagerSyncRequestEventArgs> => [0xb65fc3ec,0x9476,0x51c4,0xba,0x70,0x15,0x05,0xd7,0x98,0x26,0xb9] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxSyncManagerSyncRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxUpdateMeetingResponseRequestEventArgs> => [0x3274fbfd,0xc10a,0x5b30,0xad,0xea,0x2b,0x4b,0x86,0x0b,0x4a,0x0d] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxUpdateMeetingResponseRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::dataprovider::EmailDataProviderConnection, super::applicationmodel::email::dataprovider::EmailMailboxValidateCertificatesRequestEventArgs> => [0xde2625f7,0xe16f,0x512e,0xa8,0xc6,0xb7,0x44,0x55,0x32,0xbc,0xc6] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_DataProvider_EmailDataProviderConnection_Windows_ApplicationModel_Email_DataProvider_EmailMailboxValidateCertificatesRequestEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::EmailMailbox, super::applicationmodel::email::EmailMailboxChangedEventArgs> => [0x20789b0d,0x1555,0x51fc,0x87,0xa5,0x22,0x22,0x25,0x0b,0x9b,0x06] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_EmailMailbox_Windows_ApplicationModel_Email_EmailMailboxChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::email::EmailMailboxSyncManager, IInspectable> => [0x5cbe61bb,0xd615,0x5b82,0xbb,0x11,0x41,0x2e,0x32,0x66,0x4c,0x07] as IID_TypedEventHandler_2_Windows_ApplicationModel_Email_EmailMailboxSyncManager_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::lockscreen::LockApplicationHost, super::applicationmodel::lockscreen::LockScreenUnlockingEventArgs> => [0x002e5776,0x8a5b,0x5b93,0x8c,0x6c,0x9c,0x4c,0x87,0x88,0xf5,0xb4] as IID_TypedEventHandler_2_Windows_ApplicationModel_LockScreen_LockApplicationHost_Windows_ApplicationModel_LockScreen_LockScreenUnlockingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::lockscreen::LockScreenInfo, IInspectable> => [0x8be9e6a3,0xf88a,0x5429,0x8d,0xa3,0x67,0x6b,0x7d,0x4f,0x1a,0x5b] as IID_TypedEventHandler_2_Windows_ApplicationModel_LockScreen_LockScreenInfo_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::PackageCatalog, super::applicationmodel::PackageInstallingEventArgs> => [0xa8a900c6,0xda0b,0x5bcc,0xa7,0x1a,0xbe,0x0b,0x92,0x65,0xd8,0x7a] as IID_TypedEventHandler_2_Windows_ApplicationModel_PackageCatalog_Windows_ApplicationModel_PackageInstallingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::PackageCatalog, super::applicationmodel::PackageStagingEventArgs> => [0x1726f52d,0x2b8c,0x524a,0x98,0xc6,0xf2,0xcf,0x08,0x93,0xc0,0xf2] as IID_TypedEventHandler_2_Windows_ApplicationModel_PackageCatalog_Windows_ApplicationModel_PackageStagingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::PackageCatalog, super::applicationmodel::PackageStatusChangedEventArgs> => [0xb32d7d63,0xcd0e,0x5c2e,0xa2,0x51,0xfb,0x8d,0x29,0x08,0x24,0xe4] as IID_TypedEventHandler_2_Windows_ApplicationModel_PackageCatalog_Windows_ApplicationModel_PackageStatusChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::PackageCatalog, super::applicationmodel::PackageUninstallingEventArgs> => [0xbd636cf1,0x541f,0x53ea,0x8e,0xfc,0xe1,0x60,0x4a,0x39,0x5b,0x1a] as IID_TypedEventHandler_2_Windows_ApplicationModel_PackageCatalog_Windows_ApplicationModel_PackageUninstallingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::PackageCatalog, super::applicationmodel::PackageUpdatingEventArgs> => [0xc23e15f6,0xc618,0x522a,0x82,0xab,0x4f,0xab,0x36,0x66,0x5c,0xe5] as IID_TypedEventHandler_2_Windows_ApplicationModel_PackageCatalog_Windows_ApplicationModel_PackageUpdatingEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::preview::notes::NotesWindowManagerPreview, IInspectable> => [0x6f2755fb,0x6c33,0x543c,0x9a,0xb4,0xde,0x48,0x6b,0xc7,0xbf,0xe2] as IID_TypedEventHandler_2_Windows_ApplicationModel_Preview_Notes_NotesWindowManagerPreview_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::preview::notes::NotesWindowManagerPreview, super::applicationmodel::preview::notes::NotePlacementChangedPreviewEventArgs> => [0xa28af2c7,0x4012,0x5999,0xa3,0x22,0x52,0x36,0xb3,0x0d,0x99,0x5f] as IID_TypedEventHandler_2_Windows_ApplicationModel_Preview_Notes_NotesWindowManagerPreview_Windows_ApplicationModel_Preview_Notes_NotePlacementChangedPreviewEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::preview::notes::NotesWindowManagerPreview, super::applicationmodel::preview::notes::NoteVisibilityChangedPreviewEventArgs> => [0x16d825c8,0x5271,0x51c8,0xa0,0x0f,0x0c,0xfb,0x1b,0x02,0x9a,0xb6] as IID_TypedEventHandler_2_Windows_ApplicationModel_Preview_Notes_NotesWindowManagerPreview_Windows_ApplicationModel_Preview_Notes_NoteVisibilityChangedPreviewEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::core::SearchSuggestionManager, super::applicationmodel::search::core::RequestingFocusOnKeyboardInputEventArgs> => [0xbb198760,0x4739,0x5559,0x80,0xe6,0xf0,0xe1,0xaf,0x53,0x55,0xfd] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_Core_SearchSuggestionManager_Windows_ApplicationModel_Search_Core_RequestingFocusOnKeyboardInputEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::core::SearchSuggestionManager, super::applicationmodel::search::core::SearchSuggestionsRequestedEventArgs> => [0x7e7f3cdf,0x80d9,0x5646,0x87,0x43,0xec,0x1e,0x38,0x64,0x5d,0x68] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_Core_SearchSuggestionManager_Windows_ApplicationModel_Search_Core_SearchSuggestionsRequestedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::SearchPane, super::applicationmodel::search::SearchPaneQueryChangedEventArgs> => [0x7ccd7da1,0x8767,0x5eef,0x97,0x2d,0x31,0xd0,0x9f,0x1b,0xf3,0x08] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_SearchPane_Windows_ApplicationModel_Search_SearchPaneQueryChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::SearchPane, super::applicationmodel::search::SearchPaneQuerySubmittedEventArgs> => [0x5f05121b,0x61a6,0x5f6b,0xb0,0x07,0x20,0x81,0x6d,0xfe,0x70,0x09] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_SearchPane_Windows_ApplicationModel_Search_SearchPaneQuerySubmittedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::SearchPane, super::applicationmodel::search::SearchPaneResultSuggestionChosenEventArgs> => [0xec31e5d4,0x3b8c,0x5757,0x96,0xbf,0x14,0x09,0x6b,0xe9,0x46,0xcd] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_SearchPane_Windows_ApplicationModel_Search_SearchPaneResultSuggestionChosenEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::SearchPane, super::applicationmodel::search::SearchPaneSuggestionsRequestedEventArgs> => [0x95088dc0,0x6c14,0x55b8,0x8a,0x8f,0x9d,0xf1,0xca,0x44,0xd1,0xd4] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_SearchPane_Windows_ApplicationModel_Search_SearchPaneSuggestionsRequestedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::search::SearchPane, super::applicationmodel::search::SearchPaneVisibilityChangedEventArgs> => [0x3975ff72,0x971b,0x54b6,0x9b,0x5f,0xcc,0x44,0x2e,0x2a,0x87,0xf0] as IID_TypedEventHandler_2_Windows_ApplicationModel_Search_SearchPane_Windows_ApplicationModel_Search_SearchPaneVisibilityChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::store::preview::installcontrol::AppInstallItem, IInspectable> => [0x92730467,0x501e,0x5b05,0x88,0x26,0x92,0x6f,0x86,0x92,0x5b,0x03] as IID_TypedEventHandler_2_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::store::preview::installcontrol::AppInstallManager, super::applicationmodel::store::preview::installcontrol::AppInstallManagerItemEventArgs> => [0xabf1c837,0xdacd,0x5446,0xa0,0x32,0x3e,0xe9,0x02,0x88,0x02,0x44] as IID_TypedEventHandler_2_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallManager_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallManagerItemEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::userdataaccounts::UserDataAccountStore, super::applicationmodel::userdataaccounts::UserDataAccountStoreChangedEventArgs> => [0x7b27aec8,0x0690,0x5063,0xbe,0xb0,0xd9,0xe2,0xeb,0x1a,0x12,0x01] as IID_TypedEventHandler_2_Windows_ApplicationModel_UserDataAccounts_UserDataAccountStore_Windows_ApplicationModel_UserDataAccounts_UserDataAccountStoreChangedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::voicecommands::VoiceCommandServiceConnection, super::applicationmodel::voicecommands::VoiceCommandCompletedEventArgs> => [0x780a6352,0xb400,0x5767,0x99,0x3b,0x90,0x87,0x57,0x10,0xd9,0x37] as IID_TypedEventHandler_2_Windows_ApplicationModel_VoiceCommands_VoiceCommandServiceConnection_Windows_ApplicationModel_VoiceCommands_VoiceCommandCompletedEventArgs }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::wallet::system::WalletItemSystemStore, IInspectable> => [0x3c619943,0xa672,0x57ee,0xad,0x32,0xf6,0xd9,0x7a,0x6f,0x42,0x17] as IID_TypedEventHandler_2_Windows_ApplicationModel_Wallet_System_WalletItemSystemStore_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for TypedEventHandler<super::applicationmodel::wallet::WalletItemStore, IInspectable> => [0x07fc9084,0x9ea1,0x5505,0x89,0xcc,0x4d,0x75,0x47,0x19,0xf5,0x82] as IID_TypedEventHandler_2_Windows_ApplicationModel_Wallet_WalletItemStore_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynAcceptSessionJoinerEventArgs> => [0xdd224d96,0xf45c,0x5e3d,0x88,0x60,0x85,0x96,0xd0,0xe4,0x74,0xf0] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynAcceptSessionJoinerEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynAuthenticationCompleteEventArgs> => [0xe4fd18b4,0x4cde,0x508e,0x80,0x84,0x63,0xe7,0x28,0x32,0x62,0xc5] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynAuthenticationCompleteEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynBusAttachmentStateChangedEventArgs> => [0x82a8561d,0x3693,0x5c90,0x8c,0xf2,0x58,0xde,0x83,0xd8,0x02,0x43] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynBusAttachmentStateChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynCredentialsRequestedEventArgs> => [0xab2196e7,0x4b41,0x53bd,0x95,0xb1,0xb8,0x0c,0xad,0x82,0x47,0x95] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynCredentialsRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynCredentialsVerificationRequestedEventArgs> => [0x7ef99c96,0x51b1,0x5670,0xa4,0x1f,0xae,0x40,0x4f,0x2f,0xf5,0x3f] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynCredentialsVerificationRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusAttachment, super::devices::alljoyn::AllJoynSessionJoinedEventArgs> => [0x56bb8d26,0x39b6,0x53fa,0x80,0x13,0x37,0x81,0xaa,0x27,0xa0,0xbc] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusAttachment_Windows_Devices_AllJoyn_AllJoynSessionJoinedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynBusObject, super::devices::alljoyn::AllJoynBusObjectStoppedEventArgs> => [0x9871592f,0x823d,0x5630,0xbe,0x72,0xca,0x8f,0x17,0x84,0x6b,0x71] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynBusObject_Windows_Devices_AllJoyn_AllJoynBusObjectStoppedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynSession, super::devices::alljoyn::AllJoynSessionLostEventArgs> => [0xdffc2b25,0x5ae2,0x52f1,0xbb,0xc4,0x36,0x3c,0xef,0xed,0xa0,0x3f] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynSession_Windows_Devices_AllJoyn_AllJoynSessionLostEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynSession, super::devices::alljoyn::AllJoynSessionMemberAddedEventArgs> => [0x330baa61,0x1c24,0x5faa,0xaf,0x3c,0x4d,0x69,0xad,0x2f,0x1e,0x31] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynSession_Windows_Devices_AllJoyn_AllJoynSessionMemberAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::alljoyn::AllJoynSession, super::devices::alljoyn::AllJoynSessionMemberRemovedEventArgs> => [0x2969ed7c,0xdb6c,0x58aa,0x9f,0x6d,0x89,0xe7,0xfe,0x08,0x9f,0xc1] as IID_TypedEventHandler_2_Windows_Devices_AllJoyn_AllJoynSession_Windows_Devices_AllJoyn_AllJoynSessionMemberRemovedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::advertisement::BluetoothLEAdvertisementPublisher, super::devices::bluetooth::advertisement::BluetoothLEAdvertisementPublisherStatusChangedEventArgs> => [0xc2ffa4f1,0x5893,0x54a8,0xbd,0x94,0xaa,0x11,0x98,0xb0,0x5d,0x07] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementPublisher_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementPublisherStatusChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::advertisement::BluetoothLEAdvertisementWatcher, super::devices::bluetooth::advertisement::BluetoothLEAdvertisementReceivedEventArgs> => [0x90eb4eca,0xd465,0x5ea0,0xa6,0x1c,0x03,0x3c,0x8c,0x5e,0xce,0xf2] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementWatcher_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::advertisement::BluetoothLEAdvertisementWatcher, super::devices::bluetooth::advertisement::BluetoothLEAdvertisementWatcherStoppedEventArgs> => [0x9936a4db,0xdc99,0x55c3,0x9e,0x9b,0xbf,0x48,0x54,0xbd,0x9e,0xab] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementWatcher_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementWatcherStoppedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::BluetoothDevice, IInspectable> => [0xdb56ce1c,0x5e9f,0x5138,0x92,0x27,0xb1,0xa6,0x6d,0x60,0xbc,0x1b] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_BluetoothDevice_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::BluetoothLEDevice, IInspectable> => [0xa90661e2,0x372e,0x5d1e,0xbb,0xbb,0xb8,0xa2,0xce,0x0e,0x7c,0x4d] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_BluetoothLEDevice_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::bluetooth::genericattributeprofile::GattCharacteristic, super::devices::bluetooth::genericattributeprofile::GattValueChangedEventArgs> => [0xc1f420f6,0x6292,0x5760,0xa2,0xc9,0x9d,0xdf,0x98,0x68,0x3c,0xfc] as IID_TypedEventHandler_2_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCharacteristic_Windows_Devices_Bluetooth_GenericAttributeProfile_GattValueChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DeviceAccessInformation, super::devices::enumeration::DeviceAccessChangedEventArgs> => [0x4c71d028,0xb793,0x5bce,0xae,0x59,0xfa,0x77,0xf4,0x5a,0x40,0xd8] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DeviceAccessInformation_Windows_Devices_Enumeration_DeviceAccessChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DeviceInformationCustomPairing, super::devices::enumeration::DevicePairingRequestedEventArgs> => [0xfa65231f,0x4178,0x5de1,0xb2,0xcc,0x03,0xe2,0x2d,0x77,0x02,0xb4] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DeviceInformationCustomPairing_Windows_Devices_Enumeration_DevicePairingRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DevicePicker, IInspectable> => [0x62c6d98c,0x57ee,0x5bb8,0xa4,0x1c,0x95,0x8d,0x20,0xc3,0xf3,0xe8] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DevicePicker_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DevicePicker, super::devices::enumeration::DeviceDisconnectButtonClickedEventArgs> => [0x35dd0319,0x5723,0x506c,0x88,0x96,0x1a,0x28,0xb8,0x2b,0xe7,0x98] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DevicePicker_Windows_Devices_Enumeration_DeviceDisconnectButtonClickedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DevicePicker, super::devices::enumeration::DeviceSelectedEventArgs> => [0x47e48c88,0x1c56,0x5b58,0x96,0xa2,0x8e,0x81,0x3d,0x25,0x07,0x7a] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DevicePicker_Windows_Devices_Enumeration_DeviceSelectedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DeviceWatcher, IInspectable> => [0x9234630f,0x1ff4,0x54f6,0x9e,0x3f,0xac,0x20,0x36,0x9b,0x77,0x25] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DeviceWatcher_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DeviceWatcher, super::devices::enumeration::DeviceInformation> => [0x03c5a07b,0x990c,0x5d09,0xb0,0xb8,0x57,0x34,0xea,0xa3,0x82,0x22] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DeviceWatcher_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::DeviceWatcher, super::devices::enumeration::DeviceInformationUpdate> => [0x906f1254,0x79ad,0x54fc,0x93,0xc4,0xcd,0xb9,0x9b,0x43,0x78,0x99] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_DeviceWatcher_Windows_Devices_Enumeration_DeviceInformationUpdate }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::pnp::PnpObjectWatcher, IInspectable> => [0x2ee2b4c9,0xb696,0x5ecc,0xb2,0x9b,0xf1,0xe0,0xef,0x5f,0xe1,0xf7] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_Pnp_PnpObjectWatcher_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::pnp::PnpObjectWatcher, super::devices::enumeration::pnp::PnpObject> => [0xd578eed2,0x58e5,0x5825,0x8a,0xf2,0x12,0xf8,0x93,0x87,0xb6,0x56] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_Pnp_PnpObjectWatcher_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::enumeration::pnp::PnpObjectWatcher, super::devices::enumeration::pnp::PnpObjectUpdate> => [0xaf8f929d,0x8058,0x5c38,0xa3,0xd8,0x30,0xaa,0x7a,0x08,0xb5,0x88] as IID_TypedEventHandler_2_Windows_Devices_Enumeration_Pnp_PnpObjectWatcher_Windows_Devices_Enumeration_Pnp_PnpObjectUpdate }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::geolocation::geofencing::GeofenceMonitor, IInspectable> => [0xecc5af2c,0xe47a,0x59ce,0x86,0xbe,0x9c,0x30,0x66,0xfe,0x26,0xf7] as IID_TypedEventHandler_2_Windows_Devices_Geolocation_Geofencing_GeofenceMonitor_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::geolocation::Geolocator, super::devices::geolocation::PositionChangedEventArgs> => [0xdf3c6164,0x4e7b,0x5e8e,0x9a,0x7e,0x13,0xda,0x05,0x9d,0xec,0x1e] as IID_TypedEventHandler_2_Windows_Devices_Geolocation_Geolocator_Windows_Devices_Geolocation_PositionChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::geolocation::Geolocator, super::devices::geolocation::StatusChangedEventArgs> => [0x97fcf582,0xde6b,0x5cd3,0x96,0x90,0xe2,0xec,0xbb,0x66,0xda,0x4d] as IID_TypedEventHandler_2_Windows_Devices_Geolocation_Geolocator_Windows_Devices_Geolocation_StatusChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::gpio::GpioPin, super::devices::gpio::GpioPinValueChangedEventArgs> => [0x44ba689b,0x7d42,0x5374,0xad,0xd9,0xab,0x41,0xe8,0x77,0xa3,0x4b] as IID_TypedEventHandler_2_Windows_Devices_Gpio_GpioPin_Windows_Devices_Gpio_GpioPinValueChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::gpio::provider::IGpioPinProvider, super::devices::gpio::provider::GpioPinProviderValueChangedEventArgs> => [0xaf259d89,0x9e01,0x529e,0xa8,0x79,0xc6,0x76,0x31,0x42,0xd1,0x60] as IID_TypedEventHandler_2_Windows_Devices_Gpio_Provider_IGpioPinProvider_Windows_Devices_Gpio_Provider_GpioPinProviderValueChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::humaninterfacedevice::HidDevice, super::devices::humaninterfacedevice::HidInputReportReceivedEventArgs> => [0x31e757c8,0x8f6a,0x540b,0x93,0x8b,0xab,0xa7,0x9b,0x6f,0x03,0xec] as IID_TypedEventHandler_2_Windows_Devices_HumanInterfaceDevice_HidDevice_Windows_Devices_HumanInterfaceDevice_HidInputReportReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::input::MouseDevice, super::devices::input::MouseEventArgs> => [0x5d72e594,0x28e4,0x5895,0xa3,0x4b,0xea,0x91,0x0f,0x70,0xfd,0xbb] as IID_TypedEventHandler_2_Windows_Devices_Input_MouseDevice_Windows_Devices_Input_MouseEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::lights::Lamp, super::devices::lights::LampAvailabilityChangedEventArgs> => [0x556a02d9,0x7685,0x576f,0x89,0xca,0xb6,0x2d,0xc4,0x81,0xd2,0x9d] as IID_TypedEventHandler_2_Windows_Devices_Lights_Lamp_Windows_Devices_Lights_LampAvailabilityChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::midi::MidiInPort, super::devices::midi::MidiMessageReceivedEventArgs> => [0x50017240,0xcc39,0x5775,0x8a,0x6b,0xf6,0xf2,0x23,0x86,0xbf,0xca] as IID_TypedEventHandler_2_Windows_Devices_Midi_MidiInPort_Windows_Devices_Midi_MidiMessageReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameReader, super::devices::perception::PerceptionColorFrameArrivedEventArgs> => [0xa4a50ea5,0x778d,0x5056,0xa1,0xcf,0x54,0x6a,0x1b,0xe2,0xc0,0x10] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameReader_Windows_Devices_Perception_PerceptionColorFrameArrivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameSource, IInspectable> => [0x023444d9,0x7b47,0x5497,0x95,0x69,0x43,0x99,0xfa,0xf9,0x67,0x17] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameSource_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameSource, super::devices::perception::PerceptionFrameSourcePropertiesChangedEventArgs> => [0xb2c3a488,0x7ed9,0x5110,0x80,0x4a,0x97,0x92,0xef,0x7f,0x26,0xbe] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameSource_Windows_Devices_Perception_PerceptionFrameSourcePropertiesChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameSourceWatcher, IInspectable> => [0xb3f5bf64,0x7fc0,0x5d8c,0x97,0x8c,0xa3,0x8d,0x5b,0x18,0xa5,0x1d] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameSourceWatcher_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameSourceWatcher, super::devices::perception::PerceptionColorFrameSourceAddedEventArgs> => [0x7202e817,0x22b8,0x5e7b,0x86,0xb5,0xc4,0xa9,0x0c,0xcc,0x23,0xaa] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameSourceWatcher_Windows_Devices_Perception_PerceptionColorFrameSourceAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionColorFrameSourceWatcher, super::devices::perception::PerceptionColorFrameSourceRemovedEventArgs> => [0xc7131ddd,0xff22,0x5fb7,0xad,0xa0,0x96,0x1e,0x3b,0x28,0x91,0x7b] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionColorFrameSourceWatcher_Windows_Devices_Perception_PerceptionColorFrameSourceRemovedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionControlSession, IInspectable> => [0xabc21152,0x2495,0x5e8c,0xae,0xd3,0x7d,0xc5,0x53,0x09,0xac,0x08] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionControlSession_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameReader, super::devices::perception::PerceptionDepthFrameArrivedEventArgs> => [0x4d529b7e,0xeea0,0x511b,0x82,0x85,0x47,0xe8,0xc8,0x5d,0x02,0x95] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameReader_Windows_Devices_Perception_PerceptionDepthFrameArrivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameSource, IInspectable> => [0x135ba76a,0xab44,0x5f69,0xb2,0x08,0xe7,0x32,0xcc,0xe9,0x40,0x3b] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameSource_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameSource, super::devices::perception::PerceptionFrameSourcePropertiesChangedEventArgs> => [0x188fdef2,0xd829,0x548b,0xa8,0x9d,0x38,0xa3,0x4c,0x5c,0xb6,0x41] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameSource_Windows_Devices_Perception_PerceptionFrameSourcePropertiesChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameSourceWatcher, IInspectable> => [0xc5efa976,0xd948,0x50c7,0x85,0x55,0x66,0x41,0x90,0xf9,0xa9,0x68] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameSourceWatcher_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameSourceWatcher, super::devices::perception::PerceptionDepthFrameSourceAddedEventArgs> => [0xa3c1e25f,0x3574,0x5a27,0xa7,0x91,0x16,0xe1,0xbc,0xc4,0x24,0xf4] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameSourceWatcher_Windows_Devices_Perception_PerceptionDepthFrameSourceAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionDepthFrameSourceWatcher, super::devices::perception::PerceptionDepthFrameSourceRemovedEventArgs> => [0x5cf5faf7,0x0785,0x5589,0xa6,0x21,0x08,0x9d,0x90,0x04,0x12,0xc8] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionDepthFrameSourceWatcher_Windows_Devices_Perception_PerceptionDepthFrameSourceRemovedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameReader, super::devices::perception::PerceptionInfraredFrameArrivedEventArgs> => [0x687fef67,0x8871,0x56fe,0x8e,0x7e,0x1d,0x29,0x29,0xcc,0x6f,0x42] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameReader_Windows_Devices_Perception_PerceptionInfraredFrameArrivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameSource, IInspectable> => [0x31edabbd,0xd123,0x5e88,0x89,0xd8,0xc8,0x0e,0xe8,0xf0,0xf2,0xca] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameSource_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameSource, super::devices::perception::PerceptionFrameSourcePropertiesChangedEventArgs> => [0xb6c1b828,0xa157,0x54ed,0x9c,0x18,0x69,0x19,0xb9,0xf9,0x1b,0xe9] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameSource_Windows_Devices_Perception_PerceptionFrameSourcePropertiesChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameSourceWatcher, IInspectable> => [0x1555a628,0x3dff,0x5fd0,0xb1,0x0a,0xca,0x6a,0xdb,0x24,0x40,0xc6] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameSourceWatcher_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameSourceWatcher, super::devices::perception::PerceptionInfraredFrameSourceAddedEventArgs> => [0xa8180cd1,0xc25b,0x5c7f,0x94,0xdd,0x19,0x84,0x23,0xbb,0x56,0xd5] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameSourceWatcher_Windows_Devices_Perception_PerceptionInfraredFrameSourceAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::perception::PerceptionInfraredFrameSourceWatcher, super::devices::perception::PerceptionInfraredFrameSourceRemovedEventArgs> => [0x2ca3a9b7,0x3348,0x5953,0x8d,0x0d,0xef,0x8d,0x78,0x64,0x0b,0x23] as IID_TypedEventHandler_2_Windows_Devices_Perception_PerceptionInfraredFrameSourceWatcher_Windows_Devices_Perception_PerceptionInfraredFrameSourceRemovedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::BarcodeScanner, super::devices::pointofservice::BarcodeScannerStatusUpdatedEventArgs> => [0xcfc8a053,0xf611,0x521a,0x8a,0xb0,0xa4,0x60,0xe1,0xf7,0x16,0x4d] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_BarcodeScanner_Windows_Devices_PointOfService_BarcodeScannerStatusUpdatedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::CashDrawer, super::devices::pointofservice::CashDrawerStatusUpdatedEventArgs> => [0x64662ef4,0xcb0e,0x5c6f,0xa8,0x20,0x7d,0x0a,0x76,0x95,0x54,0xc9] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_CashDrawer_Windows_Devices_PointOfService_CashDrawerStatusUpdatedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::CashDrawerCloseAlarm, IInspectable> => [0xc54fbda4,0x5e0b,0x54c3,0x94,0xf2,0x83,0x35,0x1e,0x41,0xc4,0x6f] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_CashDrawerCloseAlarm_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::CashDrawerEventSource, super::devices::pointofservice::CashDrawerClosedEventArgs> => [0x81495aa4,0x4476,0x577f,0xbf,0x88,0x7f,0xe8,0xa1,0x28,0x64,0x44] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_CashDrawerEventSource_Windows_Devices_PointOfService_CashDrawerClosedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::CashDrawerEventSource, super::devices::pointofservice::CashDrawerOpenedEventArgs> => [0x27648799,0xe7d5,0x5ce3,0x97,0xce,0x2f,0x41,0x10,0xdd,0x32,0x98] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_CashDrawerEventSource_Windows_Devices_PointOfService_CashDrawerOpenedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedBarcodeScanner, super::devices::pointofservice::BarcodeScannerDataReceivedEventArgs> => [0x4f64e49a,0xbd8c,0x549d,0x97,0x0c,0xa5,0xa2,0x50,0xbd,0x27,0xca] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedBarcodeScanner_Windows_Devices_PointOfService_BarcodeScannerDataReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedBarcodeScanner, super::devices::pointofservice::BarcodeScannerErrorOccurredEventArgs> => [0xba42ff49,0xde12,0x5406,0x97,0x9e,0x06,0xc4,0x5c,0xa2,0xd5,0xa4] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedBarcodeScanner_Windows_Devices_PointOfService_BarcodeScannerErrorOccurredEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedBarcodeScanner, super::devices::pointofservice::BarcodeScannerImagePreviewReceivedEventArgs> => [0xfba116af,0x2a39,0x516f,0xa5,0x79,0xcc,0x3e,0xaf,0x36,0xa3,0x4b] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedBarcodeScanner_Windows_Devices_PointOfService_BarcodeScannerImagePreviewReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedCashDrawer, IInspectable> => [0xdb886581,0x2462,0x5c81,0x88,0x0c,0x06,0x11,0x2c,0xa7,0x00,0x12] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedCashDrawer_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedMagneticStripeReader, super::devices::pointofservice::MagneticStripeReaderAamvaCardDataReceivedEventArgs> => [0x29e08f92,0xc3ab,0x57ea,0xaa,0xba,0x78,0x9f,0x79,0x2d,0x7a,0x46] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedMagneticStripeReader_Windows_Devices_PointOfService_MagneticStripeReaderAamvaCardDataReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedMagneticStripeReader, super::devices::pointofservice::MagneticStripeReaderBankCardDataReceivedEventArgs> => [0x6a41d015,0x245e,0x51ba,0xbd,0x6c,0x44,0x77,0x5d,0x70,0xbf,0xa2] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedMagneticStripeReader_Windows_Devices_PointOfService_MagneticStripeReaderBankCardDataReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedMagneticStripeReader, super::devices::pointofservice::MagneticStripeReaderErrorOccurredEventArgs> => [0x1464a1e6,0x9d92,0x547e,0xb4,0xac,0xf2,0x55,0xac,0x85,0xf9,0x50] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedMagneticStripeReader_Windows_Devices_PointOfService_MagneticStripeReaderErrorOccurredEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedMagneticStripeReader, super::devices::pointofservice::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs> => [0x959124ba,0xee44,0x560c,0x81,0x83,0x61,0xc6,0xa2,0x30,0x8d,0x8f] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedMagneticStripeReader_Windows_Devices_PointOfService_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::ClaimedPosPrinter, super::devices::pointofservice::PosPrinterReleaseDeviceRequestedEventArgs> => [0x31424f6f,0xcfeb,0x5031,0x8a,0x95,0xbe,0xa5,0x9b,0x09,0xe5,0x84] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_ClaimedPosPrinter_Windows_Devices_PointOfService_PosPrinterReleaseDeviceRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::MagneticStripeReader, super::devices::pointofservice::MagneticStripeReaderStatusUpdatedEventArgs> => [0x722d8bfa,0xe10e,0x548d,0xaf,0x29,0x28,0xdd,0x90,0x6f,0x6f,0xc9] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_MagneticStripeReader_Windows_Devices_PointOfService_MagneticStripeReaderStatusUpdatedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::pointofservice::PosPrinter, super::devices::pointofservice::PosPrinterStatusUpdatedEventArgs> => [0x20b0c66a,0x5f41,0x5a32,0xb4,0x5a,0x34,0x4f,0x12,0xe7,0x0a,0x34] as IID_TypedEventHandler_2_Windows_Devices_PointOfService_PosPrinter_Windows_Devices_PointOfService_PosPrinterStatusUpdatedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::power::Battery, IInspectable> => [0x4d4aa646,0x767f,0x5645,0xaf,0x5c,0x54,0x64,0x64,0xd3,0xec,0x09] as IID_TypedEventHandler_2_Windows_Devices_Power_Battery_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::printers::extensions::Print3DWorkflow, super::devices::printers::extensions::Print3DWorkflowPrinterChangedEventArgs> => [0xb4b5ddc2,0x1a74,0x5905,0x9f,0xc5,0xdd,0xaa,0xe9,0xa3,0xab,0x93] as IID_TypedEventHandler_2_Windows_Devices_Printers_Extensions_Print3DWorkflow_Windows_Devices_Printers_Extensions_Print3DWorkflowPrinterChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::printers::extensions::Print3DWorkflow, super::devices::printers::extensions::Print3DWorkflowPrintRequestedEventArgs> => [0x5f4c6603,0x5512,0x59aa,0x8d,0x96,0xb1,0x38,0x9d,0x8b,0x57,0x96] as IID_TypedEventHandler_2_Windows_Devices_Printers_Extensions_Print3DWorkflow_Windows_Devices_Printers_Extensions_Print3DWorkflowPrintRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::printers::extensions::PrintTaskConfiguration, super::devices::printers::extensions::PrintTaskConfigurationSaveRequestedEventArgs> => [0x0363f57a,0xb7a2,0x5e20,0xa1,0x56,0x25,0x34,0x23,0xe7,0xee,0x40] as IID_TypedEventHandler_2_Windows_Devices_Printers_Extensions_PrintTaskConfiguration_Windows_Devices_Printers_Extensions_PrintTaskConfigurationSaveRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::radios::Radio, IInspectable> => [0xfc6aa329,0xb586,0x5ebb,0x9e,0x85,0x3f,0x6b,0x84,0xeb,0xdf,0x18] as IID_TypedEventHandler_2_Windows_Devices_Radios_Radio_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Accelerometer, super::devices::sensors::AccelerometerReadingChangedEventArgs> => [0xa5e83e40,0xb597,0x5b83,0x92,0xf5,0x5b,0xed,0x39,0x26,0xca,0x80] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Accelerometer_Windows_Devices_Sensors_AccelerometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Accelerometer, super::devices::sensors::AccelerometerShakenEventArgs> => [0x3e5d6eaf,0xf169,0x5d60,0x92,0xb0,0x98,0xcd,0x6b,0xd8,0xf8,0x08] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Accelerometer_Windows_Devices_Sensors_AccelerometerShakenEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::ActivitySensor, super::devices::sensors::ActivitySensorReadingChangedEventArgs> => [0xa5b72e01,0x546c,0x5fbb,0xb8,0x47,0x49,0x20,0x0a,0xaa,0xaa,0xc5] as IID_TypedEventHandler_2_Windows_Devices_Sensors_ActivitySensor_Windows_Devices_Sensors_ActivitySensorReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Altimeter, super::devices::sensors::AltimeterReadingChangedEventArgs> => [0xd775d699,0x9d74,0x5473,0x9c,0x1b,0xd5,0x1a,0x89,0xdb,0x66,0x42] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Altimeter_Windows_Devices_Sensors_AltimeterReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Barometer, super::devices::sensors::BarometerReadingChangedEventArgs> => [0xe4caf459,0xd101,0x5ca5,0xa4,0xea,0xde,0xb0,0x91,0x7a,0xe2,0x7e] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Barometer_Windows_Devices_Sensors_BarometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Compass, super::devices::sensors::CompassReadingChangedEventArgs> => [0xe787d73d,0xa121,0x5ae6,0xb4,0x97,0xab,0x93,0x48,0x37,0xe5,0x7f] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Compass_Windows_Devices_Sensors_CompassReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::custom::CustomSensor, super::devices::sensors::custom::CustomSensorReadingChangedEventArgs> => [0xaa9460cb,0xf08c,0x5963,0xb2,0x32,0xcc,0x40,0x75,0xe9,0x84,0xe7] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Custom_CustomSensor_Windows_Devices_Sensors_Custom_CustomSensorReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Gyrometer, super::devices::sensors::GyrometerReadingChangedEventArgs> => [0x15171524,0x5786,0x59a5,0xaf,0x5b,0xa0,0x12,0x45,0x72,0x6c,0x44] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Gyrometer_Windows_Devices_Sensors_GyrometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Inclinometer, super::devices::sensors::InclinometerReadingChangedEventArgs> => [0x6f3b411f,0xd147,0x59f1,0xbb,0xe4,0x7b,0xec,0x39,0x6c,0x7b,0x6e] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Inclinometer_Windows_Devices_Sensors_InclinometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::LightSensor, super::devices::sensors::LightSensorReadingChangedEventArgs> => [0x1ecf183a,0x9f0a,0x5f73,0x92,0x25,0x5a,0x33,0xea,0xb5,0x59,0x4f] as IID_TypedEventHandler_2_Windows_Devices_Sensors_LightSensor_Windows_Devices_Sensors_LightSensorReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Magnetometer, super::devices::sensors::MagnetometerReadingChangedEventArgs> => [0xf9a0da76,0xc4fd,0x50ab,0x98,0xb6,0xbf,0xd2,0x6d,0x6d,0x3d,0x82] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Magnetometer_Windows_Devices_Sensors_MagnetometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::OrientationSensor, super::devices::sensors::OrientationSensorReadingChangedEventArgs> => [0x91ae0c43,0xe1f7,0x577d,0xa1,0x61,0x8a,0xaf,0x27,0x5e,0xb9,0x27] as IID_TypedEventHandler_2_Windows_Devices_Sensors_OrientationSensor_Windows_Devices_Sensors_OrientationSensorReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::Pedometer, super::devices::sensors::PedometerReadingChangedEventArgs> => [0xdcd47693,0xaad5,0x5b3c,0x9c,0x8d,0x14,0x0b,0x8b,0xc2,0x12,0x2b] as IID_TypedEventHandler_2_Windows_Devices_Sensors_Pedometer_Windows_Devices_Sensors_PedometerReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::ProximitySensor, super::devices::sensors::ProximitySensorReadingChangedEventArgs> => [0x9f7e222b,0x892a,0x5e68,0xb0,0x8a,0x10,0x38,0x4b,0x5f,0x92,0xb9] as IID_TypedEventHandler_2_Windows_Devices_Sensors_ProximitySensor_Windows_Devices_Sensors_ProximitySensorReadingChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sensors::SimpleOrientationSensor, super::devices::sensors::SimpleOrientationSensorOrientationChangedEventArgs> => [0x92437fa7,0xea7b,0x5fc5,0x8e,0xcf,0x1b,0x91,0x1b,0xea,0x2b,0xfc] as IID_TypedEventHandler_2_Windows_Devices_Sensors_SimpleOrientationSensor_Windows_Devices_Sensors_SimpleOrientationSensorOrientationChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::serialcommunication::SerialDevice, super::devices::serialcommunication::ErrorReceivedEventArgs> => [0xd92ea323,0xb7bf,0x5e02,0xb9,0xfb,0xc6,0x1f,0x97,0xd0,0x80,0xe9] as IID_TypedEventHandler_2_Windows_Devices_SerialCommunication_SerialDevice_Windows_Devices_SerialCommunication_ErrorReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::serialcommunication::SerialDevice, super::devices::serialcommunication::PinChangedEventArgs> => [0xe496c3ef,0x5802,0x5ac4,0xac,0x2e,0x96,0xbc,0x23,0xfa,0x94,0x47] as IID_TypedEventHandler_2_Windows_Devices_SerialCommunication_SerialDevice_Windows_Devices_SerialCommunication_PinChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::smartcards::SmartCardReader, super::devices::smartcards::CardAddedEventArgs> => [0xd36f2db9,0x5674,0x5f74,0x9f,0x69,0x3c,0xdc,0x45,0x59,0x99,0x9f] as IID_TypedEventHandler_2_Windows_Devices_SmartCards_SmartCardReader_Windows_Devices_SmartCards_CardAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::smartcards::SmartCardReader, super::devices::smartcards::CardRemovedEventArgs> => [0x69da07c6,0xb266,0x5a1c,0x93,0x7c,0xd8,0x2b,0x4a,0x82,0x32,0xc6] as IID_TypedEventHandler_2_Windows_Devices_SmartCards_SmartCardReader_Windows_Devices_SmartCards_CardRemovedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sms::SmsDevice2, IInspectable> => [0x3f3808e6,0x3dee,0x57a6,0xa8,0x8d,0xba,0xcf,0xb0,0x66,0xc7,0xfb] as IID_TypedEventHandler_2_Windows_Devices_Sms_SmsDevice2_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::sms::SmsMessageRegistration, super::devices::sms::SmsMessageReceivedTriggerDetails> => [0x33f985c7,0xdcfa,0x531f,0x9c,0xce,0xee,0x5e,0x6c,0x26,0xb1,0xe6] as IID_TypedEventHandler_2_Windows_Devices_Sms_SmsMessageRegistration_Windows_Devices_Sms_SmsMessageReceivedTriggerDetails }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::usb::UsbInterruptInPipe, super::devices::usb::UsbInterruptInEventArgs> => [0xe6db9449,0xf36a,0x50f2,0x92,0x6c,0x2a,0xfd,0x85,0xc4,0x9f,0x01] as IID_TypedEventHandler_2_Windows_Devices_Usb_UsbInterruptInPipe_Windows_Devices_Usb_UsbInterruptInEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifi::WiFiAdapter, IInspectable> => [0xf6c02d1b,0x43e8,0x5fc8,0x8e,0x8e,0xee,0x7b,0x80,0x94,0xb6,0x83] as IID_TypedEventHandler_2_Windows_Devices_WiFi_WiFiAdapter_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectService, super::devices::wifidirect::services::WiFiDirectServiceSessionDeferredEventArgs> => [0xfc3dfc2c,0x9cfa,0x5822,0xba,0x3f,0xff,0x3a,0xfb,0x65,0x77,0x7e] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectService_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSessionDeferredEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectServiceAdvertiser, IInspectable> => [0x67fc3121,0xc1a0,0x5c23,0xaf,0x58,0xec,0xb7,0xf2,0xa7,0xd7,0x73] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceAdvertiser_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectServiceAdvertiser, super::devices::wifidirect::services::WiFiDirectServiceAutoAcceptSessionConnectedEventArgs> => [0x3be2d508,0xa856,0x5c09,0x99,0x98,0x52,0x25,0x97,0xb4,0x4b,0x07] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceAdvertiser_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceAutoAcceptSessionConnectedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectServiceAdvertiser, super::devices::wifidirect::services::WiFiDirectServiceSessionRequestedEventArgs> => [0xcb98fd74,0x871d,0x5730,0x91,0xfe,0x81,0xef,0x94,0x7f,0xe7,0x8f] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceAdvertiser_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSessionRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectServiceSession, IInspectable> => [0x10c33301,0xe31c,0x5cce,0xb2,0xa0,0xc1,0xdc,0x2d,0x8d,0x0e,0x13] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSession_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::services::WiFiDirectServiceSession, super::devices::wifidirect::services::WiFiDirectServiceRemotePortAddedEventArgs> => [0x8326a337,0x3c19,0x57a7,0x80,0xec,0xcc,0xa2,0xea,0x62,0xef,0x12] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceSession_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceRemotePortAddedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::WiFiDirectAdvertisementPublisher, super::devices::wifidirect::WiFiDirectAdvertisementPublisherStatusChangedEventArgs> => [0xde73cba7,0x370d,0x550c,0xb2,0x3a,0x53,0xdd,0x0b,0x4e,0x48,0x0d] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_WiFiDirectAdvertisementPublisher_Windows_Devices_WiFiDirect_WiFiDirectAdvertisementPublisherStatusChangedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::WiFiDirectConnectionListener, super::devices::wifidirect::WiFiDirectConnectionRequestedEventArgs> => [0xd04b0403,0x1fe2,0x532f,0x8e,0x47,0x48,0x23,0xa1,0x4e,0x62,0x4f] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_WiFiDirectConnectionListener_Windows_Devices_WiFiDirect_WiFiDirectConnectionRequestedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for TypedEventHandler<super::devices::wifidirect::WiFiDirectDevice, IInspectable> => [0x9208929a,0x2a3c,0x50ad,0xaa,0x08,0xa0,0xa9,0x86,0xed,0xba,0xbe] as IID_TypedEventHandler_2_Windows_Devices_WiFiDirect_WiFiDirectDevice_System_Object }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for TypedEventHandler<super::gaming::input::IGameController, super::gaming::input::Headset> => [0x07b2f2b7,0x8825,0x5c4e,0xa0,0x52,0xfc,0xfe,0xdf,0x3a,0xee,0xa1] as IID_TypedEventHandler_2_Windows_Gaming_Input_IGameController_Windows_Gaming_Input_Headset }
		#[cfg(all(feature="windows.gaming",feature="windows.system"))] RT_PINTERFACE!{ for TypedEventHandler<super::gaming::input::IGameController, super::system::UserChangedEventArgs> => [0xcb753f2c,0x2f36,0x5a8f,0xad,0xad,0x05,0x7b,0xea,0xe7,0x3a,0xa4] as IID_TypedEventHandler_2_Windows_Gaming_Input_IGameController_Windows_System_UserChangedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::display::DisplayInformation, IInspectable> => [0x86c4f619,0x67b6,0x51c7,0xb3,0x0d,0xd8,0xcf,0x13,0x62,0x53,0x27] as IID_TypedEventHandler_2_Windows_Graphics_Display_DisplayInformation_System_Object }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::holographic::HolographicSpace, super::graphics::holographic::HolographicSpaceCameraAddedEventArgs> => [0x71d80b7c,0x1d27,0x5102,0x83,0xd1,0x4f,0x0e,0xfc,0x7c,0x9d,0x6f] as IID_TypedEventHandler_2_Windows_Graphics_Holographic_HolographicSpace_Windows_Graphics_Holographic_HolographicSpaceCameraAddedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::holographic::HolographicSpace, super::graphics::holographic::HolographicSpaceCameraRemovedEventArgs> => [0xdb68cfc3,0x0874,0x502a,0xa3,0xb9,0x2b,0x1f,0xe8,0x6c,0x67,0xbe] as IID_TypedEventHandler_2_Windows_Graphics_Holographic_HolographicSpace_Windows_Graphics_Holographic_HolographicSpaceCameraRemovedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::optiondetails::PrintTaskOptionDetails, IInspectable> => [0x5c88455c,0x5b59,0x557c,0x80,0x64,0x5e,0x4f,0x3d,0x59,0xa8,0xec] as IID_TypedEventHandler_2_Windows_Graphics_Printing_OptionDetails_PrintTaskOptionDetails_System_Object }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::optiondetails::PrintTaskOptionDetails, super::graphics::printing::optiondetails::PrintTaskOptionChangedEventArgs> => [0x1b1f456b,0x8821,0x592e,0xb4,0xa7,0x9b,0x4c,0x37,0x12,0x51,0x8e] as IID_TypedEventHandler_2_Windows_Graphics_Printing_OptionDetails_PrintTaskOptionDetails_Windows_Graphics_Printing_OptionDetails_PrintTaskOptionChangedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::PrintManager, super::graphics::printing::PrintTaskRequestedEventArgs> => [0x8a8cb877,0x70c5,0x54ce,0x8b,0x42,0xd7,0x90,0xe2,0x91,0x48,0x59] as IID_TypedEventHandler_2_Windows_Graphics_Printing_PrintManager_Windows_Graphics_Printing_PrintTaskRequestedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::PrintTask, IInspectable> => [0x4cc141d4,0xc0d9,0x5220,0xb1,0xce,0x80,0xff,0xf3,0xbd,0x2d,0x44] as IID_TypedEventHandler_2_Windows_Graphics_Printing_PrintTask_System_Object }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::PrintTask, super::graphics::printing::PrintTaskCompletedEventArgs> => [0xb0b02549,0xb9ad,0x5226,0x89,0x8a,0x7b,0x56,0x3b,0x46,0x64,0x0c] as IID_TypedEventHandler_2_Windows_Graphics_Printing_PrintTask_Windows_Graphics_Printing_PrintTaskCompletedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing::PrintTask, super::graphics::printing::PrintTaskProgressingEventArgs> => [0xc08d0524,0x5899,0x536c,0x8f,0x46,0x55,0xfd,0xaa,0x4c,0xf7,0x8b] as IID_TypedEventHandler_2_Windows_Graphics_Printing_PrintTask_Windows_Graphics_Printing_PrintTaskProgressingEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing3d::Print3DManager, super::graphics::printing3d::Print3DTaskRequestedEventArgs> => [0x77c464a3,0xa7c6,0x5512,0x98,0x59,0x41,0x2d,0xb3,0xf6,0x6a,0xc4] as IID_TypedEventHandler_2_Windows_Graphics_Printing3D_Print3DManager_Windows_Graphics_Printing3D_Print3DTaskRequestedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing3d::Print3DTask, IInspectable> => [0xc0081611,0x7485,0x58a8,0x88,0xbe,0x82,0xe7,0x12,0xd8,0xc1,0xba] as IID_TypedEventHandler_2_Windows_Graphics_Printing3D_Print3DTask_System_Object }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing3d::Print3DTask, super::graphics::printing3d::Print3DTaskCompletedEventArgs> => [0xbccf7095,0xbc8e,0x5ff5,0x83,0xc0,0xd5,0x69,0x1e,0x0a,0xa2,0x4d] as IID_TypedEventHandler_2_Windows_Graphics_Printing3D_Print3DTask_Windows_Graphics_Printing3D_Print3DTaskCompletedEventArgs }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for TypedEventHandler<super::graphics::printing3d::Print3DTask, super::graphics::printing3d::Print3DTaskSourceChangedEventArgs> => [0x58d36055,0x0241,0x555d,0xaf,0x7b,0x9f,0x05,0xe5,0xda,0xa4,0x12] as IID_TypedEventHandler_2_Windows_Graphics_Printing3D_Print3DTask_Windows_Graphics_Printing3D_Print3DTaskSourceChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::audio::AudioFileInputNode, IInspectable> => [0x4481085b,0x8b8b,0x5520,0x98,0x25,0xe9,0x67,0x1d,0xa2,0xa8,0x9f] as IID_TypedEventHandler_2_Windows_Media_Audio_AudioFileInputNode_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::audio::AudioFrameInputNode, super::media::audio::AudioFrameCompletedEventArgs> => [0xad59dcfe,0x71b0,0x5e16,0x99,0xc2,0xcd,0x90,0x64,0x4d,0x8e,0xe8] as IID_TypedEventHandler_2_Windows_Media_Audio_AudioFrameInputNode_Windows_Media_Audio_AudioFrameCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::audio::AudioFrameInputNode, super::media::audio::FrameInputNodeQuantumStartedEventArgs> => [0x4530d121,0xbb9a,0x57fe,0x92,0x2f,0xa9,0x8e,0xee,0xdf,0x59,0xaf] as IID_TypedEventHandler_2_Windows_Media_Audio_AudioFrameInputNode_Windows_Media_Audio_FrameInputNodeQuantumStartedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::audio::AudioGraph, IInspectable> => [0xe1407134,0x09e7,0x53de,0xb5,0x4c,0x8a,0x06,0x59,0x39,0x7b,0x88] as IID_TypedEventHandler_2_Windows_Media_Audio_AudioGraph_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::audio::AudioGraph, super::media::audio::AudioGraphUnrecoverableErrorOccurredEventArgs> => [0x899670c9,0xdd7f,0x5f12,0x98,0xcb,0x8b,0x17,0xfe,0x80,0xa4,0x7f] as IID_TypedEventHandler_2_Windows_Media_Audio_AudioGraph_Windows_Media_Audio_AudioGraphUnrecoverableErrorOccurredEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::AdvancedPhotoCapture, IInspectable> => [0x5cb4a98f,0xabf1,0x5518,0x90,0x94,0x26,0xdb,0x32,0x6a,0x5f,0x4e] as IID_TypedEventHandler_2_Windows_Media_Capture_AdvancedPhotoCapture_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::AdvancedPhotoCapture, super::media::capture::OptionalReferencePhotoCapturedEventArgs> => [0x843e69ba,0x5702,0x5d97,0xab,0x81,0xef,0x07,0x8d,0xe3,0xf9,0xb1] as IID_TypedEventHandler_2_Windows_Media_Capture_AdvancedPhotoCapture_Windows_Media_Capture_OptionalReferencePhotoCapturedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::AppCapture, IInspectable> => [0xf5cb24b5,0xff00,0x58df,0xb4,0x60,0x17,0xbb,0xf2,0xcd,0x64,0xd3] as IID_TypedEventHandler_2_Windows_Media_Capture_AppCapture_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::core::VariablePhotoSequenceCapture, IInspectable> => [0x2210a640,0x0e7b,0x5e8f,0xa6,0x17,0x2c,0xbb,0x10,0x31,0x4a,0x5a] as IID_TypedEventHandler_2_Windows_Media_Capture_Core_VariablePhotoSequenceCapture_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::core::VariablePhotoSequenceCapture, super::media::capture::core::VariablePhotoCapturedEventArgs> => [0xbab30230,0x3dcd,0x58e2,0xaa,0xc5,0xa4,0x5f,0x3e,0x6f,0x80,0x97] as IID_TypedEventHandler_2_Windows_Media_Capture_Core_VariablePhotoSequenceCapture_Windows_Media_Capture_Core_VariablePhotoCapturedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::frames::MediaFrameReader, super::media::capture::frames::MediaFrameArrivedEventArgs> => [0xd3dd49cb,0x8d25,0x591a,0x80,0xf7,0x83,0x63,0xd5,0xc0,0x3e,0xc9] as IID_TypedEventHandler_2_Windows_Media_Capture_Frames_MediaFrameReader_Windows_Media_Capture_Frames_MediaFrameArrivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::frames::MediaFrameSource, IInspectable> => [0xc7e61aa7,0x4716,0x5514,0xa9,0x13,0xef,0x17,0x96,0xb9,0x8d,0xbd] as IID_TypedEventHandler_2_Windows_Media_Capture_Frames_MediaFrameSource_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::LowLagPhotoSequenceCapture, super::media::capture::PhotoCapturedEventArgs> => [0xb98aab3a,0xfe80,0x5b27,0x88,0xc3,0xe7,0x7f,0xf5,0x85,0xa9,0x6b] as IID_TypedEventHandler_2_Windows_Media_Capture_LowLagPhotoSequenceCapture_Windows_Media_Capture_PhotoCapturedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::MediaCapture, IInspectable> => [0x44c588f1,0x1bb7,0x5e12,0x84,0x13,0x3c,0xf0,0x37,0x3c,0x0b,0xc8] as IID_TypedEventHandler_2_Windows_Media_Capture_MediaCapture_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::MediaCapture, super::media::capture::MediaCaptureFocusChangedEventArgs> => [0x0561d9e8,0x0290,0x5332,0xb1,0x5e,0xb0,0xd5,0x1a,0xbe,0x73,0x7c] as IID_TypedEventHandler_2_Windows_Media_Capture_MediaCapture_Windows_Media_Capture_MediaCaptureFocusChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::capture::MediaCapture, super::media::capture::PhotoConfirmationCapturedEventArgs> => [0x37dc3b13,0xb096,0x5f43,0x81,0x04,0xf0,0xdc,0x43,0x02,0xe2,0xb5] as IID_TypedEventHandler_2_Windows_Media_Capture_MediaCapture_Windows_Media_Capture_PhotoConfirmationCapturedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::casting::CastingConnection, IInspectable> => [0xf1576170,0x9b08,0x5a9b,0x87,0xd2,0xc1,0xac,0x47,0xbc,0x66,0x81] as IID_TypedEventHandler_2_Windows_Media_Casting_CastingConnection_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::casting::CastingConnection, super::media::casting::CastingConnectionErrorOccurredEventArgs> => [0x78afbbd0,0x9811,0x5f0e,0x95,0x66,0x47,0xc3,0xe8,0xcd,0xd9,0x29] as IID_TypedEventHandler_2_Windows_Media_Casting_CastingConnection_Windows_Media_Casting_CastingConnectionErrorOccurredEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::casting::CastingDevicePicker, IInspectable> => [0xa64b972b,0xaa63,0x5c61,0x9c,0xde,0xcd,0x6f,0xfe,0xa8,0xa2,0x47] as IID_TypedEventHandler_2_Windows_Media_Casting_CastingDevicePicker_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::casting::CastingDevicePicker, super::media::casting::CastingDeviceSelectedEventArgs> => [0xb3655b33,0xc4ad,0x5f4c,0xa1,0x87,0xb2,0xe4,0xc7,0x70,0xa1,0x6b] as IID_TypedEventHandler_2_Windows_Media_Casting_CastingDevicePicker_Windows_Media_Casting_CastingDeviceSelectedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::AudioTrack, super::media::core::AudioTrackOpenFailedEventArgs> => [0xb5b7e554,0x2476,0x5667,0x9c,0x9a,0x1c,0x7a,0x7d,0x09,0xac,0xe2] as IID_TypedEventHandler_2_Windows_Media_Core_AudioTrack_Windows_Media_Core_AudioTrackOpenFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::FaceDetectionEffect, super::media::core::FaceDetectedEventArgs> => [0x01f0d7a6,0xf9bd,0x5bc1,0xaa,0xa9,0xdf,0xf3,0x96,0xf7,0x2f,0x87] as IID_TypedEventHandler_2_Windows_Media_Core_FaceDetectionEffect_Windows_Media_Core_FaceDetectedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::ISingleSelectMediaTrackList, IInspectable> => [0x21eb6e39,0x728a,0x56a9,0x8d,0xce,0x06,0x2b,0xa4,0xc8,0x1b,0xf5] as IID_TypedEventHandler_2_Windows_Media_Core_ISingleSelectMediaTrackList_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaBinder, super::media::core::MediaBindingEventArgs> => [0x5b133719,0xee98,0x59b2,0xb4,0x32,0x1c,0x9a,0x5a,0x56,0xab,0x05] as IID_TypedEventHandler_2_Windows_Media_Core_MediaBinder_Windows_Media_Core_MediaBindingEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaBindingEventArgs, IInspectable> => [0x3f3b10e2,0xb2e9,0x55c6,0xab,0xb3,0x4a,0x25,0x80,0x72,0xeb,0xb9] as IID_TypedEventHandler_2_Windows_Media_Core_MediaBindingEventArgs_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaSource, super::media::core::MediaSourceOpenOperationCompletedEventArgs> => [0x425d53e3,0xfba6,0x5ea3,0xb7,0x13,0xdb,0x4d,0x70,0x78,0x74,0x36] as IID_TypedEventHandler_2_Windows_Media_Core_MediaSource_Windows_Media_Core_MediaSourceOpenOperationCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaSource, super::media::core::MediaSourceStateChangedEventArgs> => [0x2274d3a6,0x1ba0,0x5230,0xbb,0x86,0xde,0x90,0x05,0x8b,0x64,0x03] as IID_TypedEventHandler_2_Windows_Media_Core_MediaSource_Windows_Media_Core_MediaSourceStateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSample, IInspectable> => [0xd4dc5ef1,0xc1cb,0x5c32,0x80,0x3d,0xf2,0xf9,0xa7,0xad,0x99,0x16] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSample_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, IInspectable> => [0x6fd6ded7,0x421b,0x5ef5,0x8b,0xf5,0xed,0xea,0x45,0x40,0x16,0x65] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, super::media::core::MediaStreamSourceClosedEventArgs> => [0x238cc251,0xd0b8,0x5a34,0x81,0xd4,0x0d,0xd1,0xf9,0x36,0xa2,0x0d] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_Windows_Media_Core_MediaStreamSourceClosedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, super::media::core::MediaStreamSourceSampleRenderedEventArgs> => [0x9d812c70,0x9f0d,0x5ad5,0x82,0x74,0xf7,0x60,0xc9,0xca,0x0c,0x38] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_Windows_Media_Core_MediaStreamSourceSampleRenderedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, super::media::core::MediaStreamSourceSampleRequestedEventArgs> => [0x4f1a3ae3,0xb8b7,0x5689,0x90,0x1d,0xb0,0xb6,0x23,0xf5,0xa1,0x72] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_Windows_Media_Core_MediaStreamSourceSampleRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, super::media::core::MediaStreamSourceStartingEventArgs> => [0xa93d5846,0xc660,0x586e,0xb6,0xb5,0xa5,0x2f,0xb8,0x1f,0x92,0x40] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_Windows_Media_Core_MediaStreamSourceStartingEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MediaStreamSource, super::media::core::MediaStreamSourceSwitchStreamsRequestedEventArgs> => [0x452b2e4a,0x5511,0x5b3c,0x8a,0x8e,0xee,0x65,0x95,0x76,0xa4,0xc1] as IID_TypedEventHandler_2_Windows_Media_Core_MediaStreamSource_Windows_Media_Core_MediaStreamSourceSwitchStreamsRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MseSourceBuffer, IInspectable> => [0x187fd3d7,0xbb9d,0x541a,0x94,0xfd,0x43,0xc3,0x1d,0xd8,0x4a,0x67] as IID_TypedEventHandler_2_Windows_Media_Core_MseSourceBuffer_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MseSourceBufferList, IInspectable> => [0x0ff01695,0xfbb2,0x5e95,0x8e,0xc7,0xda,0x17,0xd8,0xe9,0x9f,0x16] as IID_TypedEventHandler_2_Windows_Media_Core_MseSourceBufferList_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::MseStreamSource, IInspectable> => [0x724bf4ef,0xde7a,0x5dbd,0x81,0x5e,0x52,0x2a,0x87,0xbc,0x33,0x44] as IID_TypedEventHandler_2_Windows_Media_Core_MseStreamSource_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::SceneAnalysisEffect, super::media::core::SceneAnalyzedEventArgs> => [0x48630f8c,0xdbde,0x569e,0xa0,0xc8,0x75,0x88,0xd1,0xd2,0xbd,0x03] as IID_TypedEventHandler_2_Windows_Media_Core_SceneAnalysisEffect_Windows_Media_Core_SceneAnalyzedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::TimedMetadataTrack, super::media::core::MediaCueEventArgs> => [0x4aac9411,0xc355,0x5c95,0x8c,0x78,0x5a,0x0f,0x5c,0xa1,0xa5,0x4d] as IID_TypedEventHandler_2_Windows_Media_Core_TimedMetadataTrack_Windows_Media_Core_MediaCueEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::TimedMetadataTrack, super::media::core::TimedMetadataTrackFailedEventArgs> => [0x8dc73162,0x255b,0x532e,0xb0,0xc7,0x9a,0x6d,0x70,0xb4,0xbb,0x9e] as IID_TypedEventHandler_2_Windows_Media_Core_TimedMetadataTrack_Windows_Media_Core_TimedMetadataTrackFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::TimedTextSource, super::media::core::TimedTextSourceResolveResultEventArgs> => [0x0220562a,0x5de4,0x5ad2,0xac,0x20,0x6c,0xd2,0x6f,0x11,0x17,0x45] as IID_TypedEventHandler_2_Windows_Media_Core_TimedTextSource_Windows_Media_Core_TimedTextSourceResolveResultEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::VideoStabilizationEffect, super::media::core::VideoStabilizationEffectEnabledChangedEventArgs> => [0x897592e2,0xbfcc,0x5f16,0x88,0x34,0x2c,0x9c,0x4f,0x20,0x55,0x9b] as IID_TypedEventHandler_2_Windows_Media_Core_VideoStabilizationEffect_Windows_Media_Core_VideoStabilizationEffectEnabledChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::core::VideoTrack, super::media::core::VideoTrackOpenFailedEventArgs> => [0xb1e4bd43,0x541b,0x53f3,0xad,0x6c,0xdd,0xaa,0xc4,0x81,0x30,0x23] as IID_TypedEventHandler_2_Windows_Media_Core_VideoTrack_Windows_Media_Core_VideoTrackOpenFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::dialprotocol::DialDevicePicker, IInspectable> => [0xdac94028,0x1b44,0x5f45,0xb9,0xe3,0xab,0xcf,0x4a,0xb0,0x44,0xbf] as IID_TypedEventHandler_2_Windows_Media_DialProtocol_DialDevicePicker_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::dialprotocol::DialDevicePicker, super::media::dialprotocol::DialDeviceSelectedEventArgs> => [0x8375c0d7,0xe7c3,0x56bc,0x98,0x80,0x46,0xb6,0x9c,0xa1,0x0d,0x45] as IID_TypedEventHandler_2_Windows_Media_DialProtocol_DialDevicePicker_Windows_Media_DialProtocol_DialDeviceSelectedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::dialprotocol::DialDevicePicker, super::media::dialprotocol::DialDisconnectButtonClickedEventArgs> => [0x13492af0,0x1c7f,0x57e8,0xb5,0x7e,0xa5,0xae,0x8f,0x2c,0x46,0x2e] as IID_TypedEventHandler_2_Windows_Media_DialProtocol_DialDevicePicker_Windows_Media_DialProtocol_DialDisconnectButtonClickedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::effects::AudioCaptureEffectsManager, IInspectable> => [0xa1c5e803,0xa275,0x5bb1,0x9d,0x44,0x2a,0xc8,0xae,0x9f,0xfb,0x89] as IID_TypedEventHandler_2_Windows_Media_Effects_AudioCaptureEffectsManager_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::effects::AudioRenderEffectsManager, IInspectable> => [0x4be29c7e,0x449c,0x576e,0xa7,0xb8,0x3a,0x40,0xf2,0xf0,0x1d,0xc8] as IID_TypedEventHandler_2_Windows_Media_Effects_AudioRenderEffectsManager_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::import::PhotoImportFindItemsResult, super::media::import::PhotoImportItemImportedEventArgs> => [0xa3cce94d,0xf26e,0x58d9,0x81,0x38,0x59,0x9a,0xd6,0x3c,0x70,0x69] as IID_TypedEventHandler_2_Windows_Media_Import_PhotoImportFindItemsResult_Windows_Media_Import_PhotoImportItemImportedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::import::PhotoImportFindItemsResult, super::media::import::PhotoImportSelectionChangedEventArgs> => [0xe67279fe,0x692f,0x5602,0x82,0x0b,0x86,0x50,0x98,0xd9,0xb4,0x3e] as IID_TypedEventHandler_2_Windows_Media_Import_PhotoImportFindItemsResult_Windows_Media_Import_PhotoImportSelectionChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::MediaTimelineController, IInspectable> => [0x5c43e195,0x7d39,0x5d0d,0xa3,0x09,0x19,0x91,0xe6,0x8a,0xcd,0xb7] as IID_TypedEventHandler_2_Windows_Media_MediaTimelineController_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaBreakManager, super::media::playback::MediaBreakEndedEventArgs> => [0x04afafa9,0xd83a,0x5ccb,0x8c,0xab,0x82,0xc9,0xd9,0x2a,0x19,0xab] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaBreakManager_Windows_Media_Playback_MediaBreakEndedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaBreakManager, super::media::playback::MediaBreakSeekedOverEventArgs> => [0xa6954c30,0x99dc,0x5f84,0xb4,0x82,0x7d,0x06,0x92,0xc0,0x27,0x7b] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaBreakManager_Windows_Media_Playback_MediaBreakSeekedOverEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaBreakManager, super::media::playback::MediaBreakSkippedEventArgs> => [0xc530fa5d,0x1a56,0x582a,0xa2,0x54,0x1b,0x1a,0xe1,0x7b,0x8d,0x2d] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaBreakManager_Windows_Media_Playback_MediaBreakSkippedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaBreakManager, super::media::playback::MediaBreakStartedEventArgs> => [0x4bf2cca1,0xcd9d,0x5d88,0x9e,0x47,0x18,0x81,0x20,0x1b,0xb7,0x2d] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaBreakManager_Windows_Media_Playback_MediaBreakStartedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaBreakSchedule, IInspectable> => [0x3c57acbf,0xca07,0x586a,0x8a,0xdb,0x80,0x47,0xdc,0x91,0x65,0xa6] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaBreakSchedule_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs> => [0x824845b8,0xc5df,0x560b,0xa7,0x22,0xc1,0x5b,0x25,0xd4,0x46,0x3a] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs> => [0xd7cd6ce3,0x516f,0x5b34,0xbe,0xaf,0x3e,0xe9,0x0b,0x62,0x28,0x72] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerFastForwardReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerNextReceivedEventArgs> => [0xce41af40,0x93a6,0x52bf,0x9c,0xad,0x4d,0x5f,0xff,0xd1,0x0e,0xe0] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerNextReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerPauseReceivedEventArgs> => [0x79eb2ad3,0x0781,0x5f64,0xb0,0xcd,0x31,0xe1,0x14,0x5d,0x10,0x9f] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerPauseReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerPlayReceivedEventArgs> => [0x76d59f7c,0xedf3,0x5dde,0x95,0x29,0x6f,0x80,0x6b,0xdb,0x1f,0xcb] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerPlayReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerPositionReceivedEventArgs> => [0xd863b1c4,0x7442,0x53c4,0x94,0xd2,0x20,0xd8,0x97,0x3d,0xf5,0x85] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerPositionReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs> => [0x25726db4,0x8913,0x5967,0x90,0xeb,0x10,0xf0,0x9f,0x30,0xdd,0x33] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerPreviousReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerRateReceivedEventArgs> => [0x3f8a8ea1,0xff9a,0x5613,0x98,0x46,0x33,0x79,0x9f,0x6b,0x8c,0x8a] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerRateReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerRewindReceivedEventArgs> => [0x3c37e026,0x8d0b,0x5d73,0xa6,0x50,0x9f,0x18,0xab,0xbc,0x35,0x3d] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerRewindReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManager, super::media::playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs> => [0x6c972f91,0xf626,0x5799,0xba,0x86,0x5e,0x94,0x1f,0x02,0x02,0xc8] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManager_Windows_Media_Playback_MediaPlaybackCommandManagerShuffleReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackCommandManagerCommandBehavior, IInspectable> => [0x2675973a,0xeb2d,0x56a1,0x82,0xa0,0x34,0x0b,0x0f,0xf0,0x41,0xe6] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackCommandManagerCommandBehavior_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackItem, collections::IVectorChangedEventArgs> => [0x2dd51918,0x4525,0x5be5,0xa6,0xc1,0x40,0x9b,0xc7,0x28,0x63,0xa6] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackItem_Windows_Foundation_Collections_IVectorChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackList, super::media::playback::CurrentMediaPlaybackItemChangedEventArgs> => [0x404c5f9d,0x250d,0x5f8c,0x96,0x27,0x6b,0x41,0x05,0xc3,0x2d,0x09] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackList_Windows_Media_Playback_CurrentMediaPlaybackItemChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackList, super::media::playback::MediaPlaybackItemFailedEventArgs> => [0x23319e7d,0x34b1,0x57b7,0x97,0xe5,0x84,0x49,0x48,0xba,0x47,0x19] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackList_Windows_Media_Playback_MediaPlaybackItemFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackList, super::media::playback::MediaPlaybackItemOpenedEventArgs> => [0x6732bbef,0x3311,0x5f83,0x9c,0x9d,0x82,0xa5,0xcf,0x3c,0xd8,0x2a] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackList_Windows_Media_Playback_MediaPlaybackItemOpenedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackSession, IInspectable> => [0x7c70f38d,0x2aa1,0x5522,0xa6,0xd6,0x34,0xb5,0x2b,0x98,0x8a,0xe7] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackSession_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlaybackTimedMetadataTrackList, super::media::playback::TimedMetadataPresentationModeChangedEventArgs> => [0x40213c85,0xbf23,0x5f78,0xb9,0xc4,0xe0,0x3f,0x3b,0xe2,0xb4,0x1c] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlaybackTimedMetadataTrackList_Windows_Media_Playback_TimedMetadataPresentationModeChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlayer, IInspectable> => [0xf1a6a51e,0xd078,0x5c40,0xba,0x3f,0x34,0x88,0x70,0xba,0x5c,0x87] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlayer_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlayer, super::media::playback::MediaPlayerFailedEventArgs> => [0x362c45a7,0x3a0a,0x5e27,0x99,0xce,0xcf,0xf6,0xd1,0xb7,0x70,0xe1] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlayer_Windows_Media_Playback_MediaPlayerFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlayer, super::media::playback::MediaPlayerRateChangedEventArgs> => [0xba51d31a,0x5688,0x5d4d,0xaf,0x42,0x12,0x20,0x70,0xb1,0xee,0xfa] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlayer_Windows_Media_Playback_MediaPlayerRateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playback::MediaPlayer, super::media::playback::PlaybackMediaMarkerReachedEventArgs> => [0x67a4f43c,0xc254,0x57f0,0xa3,0x9d,0xa4,0x75,0xa3,0x42,0xd2,0x1d] as IID_TypedEventHandler_2_Windows_Media_Playback_MediaPlayer_Windows_Media_Playback_PlaybackMediaMarkerReachedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToConnection, super::media::playto::PlayToConnectionErrorEventArgs> => [0x8f599f3d,0x3655,0x5993,0xa1,0x19,0x74,0x1e,0xc4,0xee,0x6e,0x42] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToConnection_Windows_Media_PlayTo_PlayToConnectionErrorEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToConnection, super::media::playto::PlayToConnectionStateChangedEventArgs> => [0xdef77c1c,0x9363,0x5b47,0xb9,0xf8,0xa2,0x36,0xc5,0x0d,0x37,0x2e] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToConnection_Windows_Media_PlayTo_PlayToConnectionStateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToConnection, super::media::playto::PlayToConnectionTransferredEventArgs> => [0x7278e7f2,0x0360,0x5571,0x8c,0x3e,0xea,0x03,0x27,0x67,0xc4,0x73] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToConnection_Windows_Media_PlayTo_PlayToConnectionTransferredEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToManager, super::media::playto::PlayToSourceRequestedEventArgs> => [0x6ac9f3a4,0x39b6,0x51d8,0x8e,0x08,0xf1,0x37,0x90,0x8e,0x92,0x2f] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToManager_Windows_Media_PlayTo_PlayToSourceRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToManager, super::media::playto::PlayToSourceSelectedEventArgs> => [0xbf87431a,0x7451,0x52a5,0xa5,0xe2,0xbf,0xaf,0x40,0x8e,0x0c,0x88] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToManager_Windows_Media_PlayTo_PlayToSourceSelectedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, IInspectable> => [0x7a89b9c2,0x78d4,0x5866,0x88,0xf1,0x4c,0xdc,0x0a,0x0e,0x75,0xb8] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, super::media::playto::CurrentTimeChangeRequestedEventArgs> => [0x42abdf9f,0x14a6,0x5c1f,0x83,0x9b,0x86,0x02,0x95,0x05,0xb1,0xd0] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_Windows_Media_PlayTo_CurrentTimeChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, super::media::playto::MuteChangeRequestedEventArgs> => [0x0674cf85,0xb6fd,0x5926,0x9b,0x72,0x35,0xfe,0x51,0x7a,0x3f,0x44] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_Windows_Media_PlayTo_MuteChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, super::media::playto::PlaybackRateChangeRequestedEventArgs> => [0xe7594396,0x58c3,0x5316,0xbc,0x4f,0x1d,0x13,0xea,0xdb,0xef,0xfd] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_Windows_Media_PlayTo_PlaybackRateChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, super::media::playto::SourceChangeRequestedEventArgs> => [0x1466d074,0xb7b4,0x5814,0xb2,0xd7,0x84,0x7c,0x5a,0xe7,0xd8,0x7d] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_Windows_Media_PlayTo_SourceChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::playto::PlayToReceiver, super::media::playto::VolumeChangeRequestedEventArgs> => [0x9c3f7c84,0x9b4d,0x5cdc,0x81,0x44,0x1c,0x2f,0x61,0x7b,0x6e,0xde] as IID_TypedEventHandler_2_Windows_Media_PlayTo_PlayToReceiver_Windows_Media_PlayTo_VolumeChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::HdcpSession, IInspectable> => [0xf82ae043,0x54fb,0x5366,0xa6,0x07,0x19,0xb6,0x8e,0x6b,0xab,0x8c] as IID_TypedEventHandler_2_Windows_Media_Protection_HdcpSession_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::playready::NDClient, IInspectable> => [0xd20f3387,0xb3f5,0x5010,0x9b,0x0b,0xe8,0x51,0xae,0x84,0x94,0x0d] as IID_TypedEventHandler_2_Windows_Media_Protection_PlayReady_NDClient_System_Object }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::playready::NDClient, super::media::protection::playready::INDClosedCaptionDataReceivedEventArgs> => [0x36ec9e44,0x25f6,0x5d3d,0x87,0xee,0x8a,0xd1,0x0a,0x33,0x5c,0x83] as IID_TypedEventHandler_2_Windows_Media_Protection_PlayReady_NDClient_Windows_Media_Protection_PlayReady_INDClosedCaptionDataReceivedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::playready::NDClient, super::media::protection::playready::INDLicenseFetchCompletedEventArgs> => [0xa5401278,0xe2c1,0x5354,0x85,0x8f,0x6f,0x32,0xcb,0xdf,0xbe,0xa7] as IID_TypedEventHandler_2_Windows_Media_Protection_PlayReady_NDClient_Windows_Media_Protection_PlayReady_INDLicenseFetchCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::playready::NDClient, super::media::protection::playready::INDProximityDetectionCompletedEventArgs> => [0xb545268a,0xc7ce,0x51f8,0xbd,0xdc,0x02,0x9d,0x2c,0x66,0xb6,0x6b] as IID_TypedEventHandler_2_Windows_Media_Protection_PlayReady_NDClient_Windows_Media_Protection_PlayReady_INDProximityDetectionCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::protection::playready::NDClient, super::media::protection::playready::INDRegistrationCompletedEventArgs> => [0x46b3f056,0xc1a0,0x51c0,0x85,0x21,0xcd,0xe2,0x22,0x15,0x7e,0xff] as IID_TypedEventHandler_2_Windows_Media_Protection_PlayReady_NDClient_Windows_Media_Protection_PlayReady_INDRegistrationCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::speechrecognition::SpeechContinuousRecognitionSession, super::media::speechrecognition::SpeechContinuousRecognitionCompletedEventArgs> => [0x8103c018,0x7952,0x59f9,0x9f,0x41,0x23,0xb1,0x7d,0x6e,0x45,0x2d] as IID_TypedEventHandler_2_Windows_Media_SpeechRecognition_SpeechContinuousRecognitionSession_Windows_Media_SpeechRecognition_SpeechContinuousRecognitionCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::speechrecognition::SpeechContinuousRecognitionSession, super::media::speechrecognition::SpeechContinuousRecognitionResultGeneratedEventArgs> => [0x26192073,0xa2c9,0x527d,0x9b,0xd3,0x91,0x1c,0x05,0xe0,0x01,0x1e] as IID_TypedEventHandler_2_Windows_Media_SpeechRecognition_SpeechContinuousRecognitionSession_Windows_Media_SpeechRecognition_SpeechContinuousRecognitionResultGeneratedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::speechrecognition::SpeechRecognizer, super::media::speechrecognition::SpeechRecognitionHypothesisGeneratedEventArgs> => [0x4cb45aba,0x7573,0x545a,0xb2,0x9a,0xe9,0xbe,0x35,0xbd,0x46,0x82] as IID_TypedEventHandler_2_Windows_Media_SpeechRecognition_SpeechRecognizer_Windows_Media_SpeechRecognition_SpeechRecognitionHypothesisGeneratedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::speechrecognition::SpeechRecognizer, super::media::speechrecognition::SpeechRecognitionQualityDegradingEventArgs> => [0x15ca7918,0x61d2,0x57b2,0xb9,0x33,0x44,0x06,0x3e,0x8b,0xb6,0x62] as IID_TypedEventHandler_2_Windows_Media_SpeechRecognition_SpeechRecognizer_Windows_Media_SpeechRecognition_SpeechRecognitionQualityDegradingEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::speechrecognition::SpeechRecognizer, super::media::speechrecognition::SpeechRecognizerStateChangedEventArgs> => [0xd1185e92,0x5c30,0x5561,0xb3,0xe2,0xe8,0x2d,0xdb,0xd8,0x72,0xc3] as IID_TypedEventHandler_2_Windows_Media_SpeechRecognition_SpeechRecognizer_Windows_Media_SpeechRecognition_SpeechRecognizerStateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::streaming::adaptive::AdaptiveMediaSource, super::media::streaming::adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs> => [0xad268caf,0x7da0,0x5ad4,0x85,0x85,0xce,0xeb,0x90,0x3d,0xbd,0x50] as IID_TypedEventHandler_2_Windows_Media_Streaming_Adaptive_AdaptiveMediaSource_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceDownloadBitrateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::streaming::adaptive::AdaptiveMediaSource, super::media::streaming::adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs> => [0xcef775dd,0x25b2,0x5588,0x8d,0x51,0xda,0xcd,0xea,0x66,0x0a,0x7d] as IID_TypedEventHandler_2_Windows_Media_Streaming_Adaptive_AdaptiveMediaSource_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceDownloadCompletedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::streaming::adaptive::AdaptiveMediaSource, super::media::streaming::adaptive::AdaptiveMediaSourceDownloadFailedEventArgs> => [0x6ee5cc44,0x49ad,0x5138,0xab,0x47,0xf5,0xc0,0x75,0xa2,0xbc,0x34] as IID_TypedEventHandler_2_Windows_Media_Streaming_Adaptive_AdaptiveMediaSource_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceDownloadFailedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::streaming::adaptive::AdaptiveMediaSource, super::media::streaming::adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs> => [0xd3b7dbf1,0xfd8e,0x589e,0x9c,0x7f,0xba,0x67,0x39,0x7e,0x50,0xcd] as IID_TypedEventHandler_2_Windows_Media_Streaming_Adaptive_AdaptiveMediaSource_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourceDownloadRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::streaming::adaptive::AdaptiveMediaSource, super::media::streaming::adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs> => [0xdf4f4e89,0x6173,0x539b,0x94,0xd8,0x69,0xb7,0xcb,0x75,0x78,0xa7] as IID_TypedEventHandler_2_Windows_Media_Streaming_Adaptive_AdaptiveMediaSource_Windows_Media_Streaming_Adaptive_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::AutoRepeatModeChangeRequestedEventArgs> => [0xa6214bde,0x02d5,0x55b3,0xab,0x0d,0xc6,0x03,0x1b,0xe7,0x0d,0xa1] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_AutoRepeatModeChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::PlaybackPositionChangeRequestedEventArgs> => [0x44e34f15,0xbdc0,0x50a7,0xac,0xe4,0x39,0xe9,0x1f,0xb7,0x53,0xf1] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_PlaybackPositionChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::PlaybackRateChangeRequestedEventArgs> => [0x15eb0182,0x6366,0x5b9f,0xbd,0x8c,0x8a,0xb4,0xfa,0x9d,0x7c,0xd9] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_PlaybackRateChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::ShuffleEnabledChangeRequestedEventArgs> => [0x17ecea80,0x27e4,0x5dae,0xab,0xb4,0xc8,0x58,0xad,0x1c,0x53,0x07] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_ShuffleEnabledChangeRequestedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::SystemMediaTransportControlsButtonPressedEventArgs> => [0x0557e996,0x7b23,0x5bae,0xaa,0x81,0xea,0x0d,0x67,0x11,0x43,0xa4] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_SystemMediaTransportControlsButtonPressedEventArgs }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for TypedEventHandler<super::media::SystemMediaTransportControls, super::media::SystemMediaTransportControlsPropertyChangedEventArgs> => [0x9fd61dad,0x1746,0x5fa1,0xa9,0x08,0xef,0x7c,0xb4,0x60,0x3c,0x85] as IID_TypedEventHandler_2_Windows_Media_SystemMediaTransportControls_Windows_Media_SystemMediaTransportControlsPropertyChangedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::networkoperators::MobileBroadbandAccountWatcher, IInspectable> => [0xe4dc9cfc,0xf462,0x5afd,0x85,0x6d,0x04,0xac,0xe2,0x29,0xd0,0x0e] as IID_TypedEventHandler_2_Windows_Networking_NetworkOperators_MobileBroadbandAccountWatcher_System_Object }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::networkoperators::MobileBroadbandAccountWatcher, super::networking::networkoperators::MobileBroadbandAccountEventArgs> => [0x423cc41e,0xfe8c,0x5a7d,0x9f,0xee,0xaa,0xe0,0x4e,0xf8,0x57,0x00] as IID_TypedEventHandler_2_Windows_Networking_NetworkOperators_MobileBroadbandAccountWatcher_Windows_Networking_NetworkOperators_MobileBroadbandAccountEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::networkoperators::MobileBroadbandAccountWatcher, super::networking::networkoperators::MobileBroadbandAccountUpdatedEventArgs> => [0x0e865096,0x1ffa,0x5792,0x8d,0x4f,0x86,0x23,0xe3,0xc7,0x7f,0x56] as IID_TypedEventHandler_2_Windows_Networking_NetworkOperators_MobileBroadbandAccountWatcher_Windows_Networking_NetworkOperators_MobileBroadbandAccountUpdatedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::networkoperators::MobileBroadbandDeviceServiceDataSession, super::networking::networkoperators::MobileBroadbandDeviceServiceDataReceivedEventArgs> => [0x31f89ca6,0xdd7f,0x5325,0x90,0x20,0x62,0x7d,0x8b,0x47,0xea,0x02] as IID_TypedEventHandler_2_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceDataSession_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceDataReceivedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::proximity::PeerWatcher, IInspectable> => [0xf4979ea1,0x7e06,0x50a8,0x88,0xdc,0x3f,0x29,0x52,0x4e,0x4f,0xdb] as IID_TypedEventHandler_2_Windows_Networking_Proximity_PeerWatcher_System_Object }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::proximity::PeerWatcher, super::networking::proximity::PeerInformation> => [0xad674bbf,0x6281,0x5943,0x97,0x72,0xe0,0xfd,0x76,0x64,0xd4,0xe1] as IID_TypedEventHandler_2_Windows_Networking_Proximity_PeerWatcher_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::pushnotifications::PushNotificationChannel, super::networking::pushnotifications::PushNotificationReceivedEventArgs> => [0x55fa217d,0x1fc3,0x5863,0xb9,0x80,0x70,0x94,0xd4,0x37,0x96,0x94] as IID_TypedEventHandler_2_Windows_Networking_PushNotifications_PushNotificationChannel_Windows_Networking_PushNotifications_PushNotificationReceivedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::servicediscovery::dnssd::DnssdServiceWatcher, IInspectable> => [0x6a6cc5d5,0x9f43,0x545a,0x91,0xd7,0x3a,0x40,0x05,0x54,0x75,0xda] as IID_TypedEventHandler_2_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceWatcher_System_Object }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::servicediscovery::dnssd::DnssdServiceWatcher, super::networking::servicediscovery::dnssd::DnssdServiceInstance> => [0xe617711e,0xcdd5,0x5975,0x8f,0xb3,0x8e,0xaa,0xae,0xd2,0x4e,0x7b] as IID_TypedEventHandler_2_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceWatcher_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceInstance }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::DatagramSocket, super::networking::sockets::DatagramSocketMessageReceivedEventArgs> => [0x4482e19b,0x2389,0x5767,0x9b,0x0b,0x8d,0x7a,0x8e,0xf5,0x57,0x43] as IID_TypedEventHandler_2_Windows_Networking_Sockets_DatagramSocket_Windows_Networking_Sockets_DatagramSocketMessageReceivedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::IWebSocket, super::networking::sockets::WebSocketClosedEventArgs> => [0x03cf8f90,0x1669,0x5f4d,0x94,0x04,0x2b,0x78,0x46,0x78,0xe6,0xdd] as IID_TypedEventHandler_2_Windows_Networking_Sockets_IWebSocket_Windows_Networking_Sockets_WebSocketClosedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::MessageWebSocket, super::networking::sockets::MessageWebSocketMessageReceivedEventArgs> => [0xde980538,0x6dcd,0x52b0,0x80,0x2f,0x4b,0x6c,0xf5,0x9a,0x01,0xab] as IID_TypedEventHandler_2_Windows_Networking_Sockets_MessageWebSocket_Windows_Networking_Sockets_MessageWebSocketMessageReceivedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::MessageWebSocket, super::networking::sockets::WebSocketServerCustomValidationRequestedEventArgs> => [0x2c34c585,0x9cf6,0x56c7,0x8d,0xd1,0x5d,0xa2,0x6e,0x32,0x20,0x78] as IID_TypedEventHandler_2_Windows_Networking_Sockets_MessageWebSocket_Windows_Networking_Sockets_WebSocketServerCustomValidationRequestedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::StreamSocketListener, super::networking::sockets::StreamSocketListenerConnectionReceivedEventArgs> => [0x33d00d41,0xc94f,0x5a61,0x9a,0xb7,0x28,0x0d,0xce,0xfa,0x0b,0x08] as IID_TypedEventHandler_2_Windows_Networking_Sockets_StreamSocketListener_Windows_Networking_Sockets_StreamSocketListenerConnectionReceivedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::sockets::StreamWebSocket, super::networking::sockets::WebSocketServerCustomValidationRequestedEventArgs> => [0x18b143d3,0x897e,0x595e,0xac,0xc1,0xef,0x35,0x61,0x4b,0x4c,0xec] as IID_TypedEventHandler_2_Windows_Networking_Sockets_StreamWebSocket_Windows_Networking_Sockets_WebSocketServerCustomValidationRequestedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::vpn::VpnChannel, super::networking::vpn::VpnChannelActivityEventArgs> => [0x39907949,0xa8cc,0x5ce5,0x9e,0x0a,0x06,0xe3,0xb2,0xd3,0x15,0x70] as IID_TypedEventHandler_2_Windows_Networking_Vpn_VpnChannel_Windows_Networking_Vpn_VpnChannelActivityEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::vpn::VpnChannel, super::networking::vpn::VpnChannelActivityStateChangedArgs> => [0x2cfcf1ba,0xbffc,0x5746,0xb8,0x68,0x2e,0x45,0xa4,0x6d,0x29,0x58] as IID_TypedEventHandler_2_Windows_Networking_Vpn_VpnChannel_Windows_Networking_Vpn_VpnChannelActivityStateChangedArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::xboxlive::XboxLiveDeviceAddress, IInspectable> => [0x7fa76199,0xd1b8,0x5494,0xa0,0x42,0x70,0x02,0xa4,0x16,0xad,0xc3] as IID_TypedEventHandler_2_Windows_Networking_XboxLive_XboxLiveDeviceAddress_System_Object }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::xboxlive::XboxLiveEndpointPair, super::networking::xboxlive::XboxLiveEndpointPairStateChangedEventArgs> => [0x51037260,0x4609,0x58c1,0xad,0xb3,0x06,0x18,0xb8,0x9b,0x99,0x75] as IID_TypedEventHandler_2_Windows_Networking_XboxLive_XboxLiveEndpointPair_Windows_Networking_XboxLive_XboxLiveEndpointPairStateChangedEventArgs }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for TypedEventHandler<super::networking::xboxlive::XboxLiveEndpointPairTemplate, super::networking::xboxlive::XboxLiveInboundEndpointPairCreatedEventArgs> => [0x2aef5136,0x6e7a,0x51f8,0x88,0x53,0xcc,0x0c,0xe4,0x66,0xfe,0xf9] as IID_TypedEventHandler_2_Windows_Networking_XboxLive_XboxLiveEndpointPairTemplate_Windows_Networking_XboxLive_XboxLiveInboundEndpointPairCreatedEventArgs }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for TypedEventHandler<super::perception::spatial::SpatialAnchor, super::perception::spatial::SpatialAnchorRawCoordinateSystemAdjustedEventArgs> => [0xfa43f9e4,0x3558,0x59c8,0x9a,0x77,0x6e,0x8b,0x76,0x5a,0xdc,0xc8] as IID_TypedEventHandler_2_Windows_Perception_Spatial_SpatialAnchor_Windows_Perception_Spatial_SpatialAnchorRawCoordinateSystemAdjustedEventArgs }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for TypedEventHandler<super::perception::spatial::SpatialLocator, IInspectable> => [0xdbb08ab5,0x6b40,0x55fb,0x83,0xd3,0x50,0xd5,0x37,0x3a,0x3b,0x20] as IID_TypedEventHandler_2_Windows_Perception_Spatial_SpatialLocator_System_Object }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for TypedEventHandler<super::perception::spatial::SpatialLocator, super::perception::spatial::SpatialLocatorPositionalTrackingDeactivatingEventArgs> => [0x34bf236c,0xe5d6,0x501f,0x86,0x93,0xbc,0x1d,0x8d,0x43,0x1d,0x7e] as IID_TypedEventHandler_2_Windows_Perception_Spatial_SpatialLocator_Windows_Perception_Spatial_SpatialLocatorPositionalTrackingDeactivatingEventArgs }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for TypedEventHandler<super::perception::spatial::surfaces::SpatialSurfaceObserver, IInspectable> => [0x8b31274a,0x7693,0x52be,0x90,0x14,0xb0,0xf5,0xf6,0x5a,0x35,0x39] as IID_TypedEventHandler_2_Windows_Perception_Spatial_Surfaces_SpatialSurfaceObserver_System_Object }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for TypedEventHandler<super::security::authentication::web::core::WebAccountMonitor, IInspectable> => [0xc8cb498d,0xe0da,0x52a1,0xab,0xf9,0x71,0x98,0xc7,0xf5,0xcb,0x42] as IID_TypedEventHandler_2_Windows_Security_Authentication_Web_Core_WebAccountMonitor_System_Object }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for TypedEventHandler<super::security::authentication::web::core::WebAccountMonitor, super::security::authentication::web::core::WebAccountEventArgs> => [0xfa704f04,0x87b6,0x516b,0x95,0x96,0xcd,0x7c,0xc0,0x92,0x16,0x9b] as IID_TypedEventHandler_2_Windows_Security_Authentication_Web_Core_WebAccountMonitor_Windows_Security_Authentication_Web_Core_WebAccountEventArgs }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::maps::guidance::GuidanceNavigator, IInspectable> => [0x3f496c35,0x3dca,0x5e91,0x87,0x30,0x6e,0xf7,0x7e,0x9d,0x70,0xbd] as IID_TypedEventHandler_2_Windows_Services_Maps_Guidance_GuidanceNavigator_System_Object }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::maps::guidance::GuidanceNavigator, super::services::maps::guidance::GuidanceAudioNotificationRequestedEventArgs> => [0x743db36f,0xe9aa,0x557a,0x9f,0xd7,0x30,0x4c,0x9b,0x04,0x99,0xdf] as IID_TypedEventHandler_2_Windows_Services_Maps_Guidance_GuidanceNavigator_Windows_Services_Maps_Guidance_GuidanceAudioNotificationRequestedEventArgs }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::maps::guidance::GuidanceNavigator, super::services::maps::guidance::GuidanceReroutedEventArgs> => [0x61b92b1b,0xf22f,0x581b,0xbf,0xa0,0x48,0x68,0xc3,0x14,0xc6,0x3a] as IID_TypedEventHandler_2_Windows_Services_Maps_Guidance_GuidanceNavigator_Windows_Services_Maps_Guidance_GuidanceReroutedEventArgs }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::maps::guidance::GuidanceNavigator, super::services::maps::guidance::GuidanceUpdatedEventArgs> => [0x82b3f7df,0xbf13,0x5445,0xaa,0xdc,0xec,0x61,0xb5,0x0f,0xbb,0x46] as IID_TypedEventHandler_2_Windows_Services_Maps_Guidance_GuidanceNavigator_Windows_Services_Maps_Guidance_GuidanceUpdatedEventArgs }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::store::StoreContext, IInspectable> => [0xd5a00ac7,0x082d,0x547c,0xa0,0x4b,0x25,0x40,0xc1,0xcd,0xe9,0x7a] as IID_TypedEventHandler_2_Windows_Services_Store_StoreContext_System_Object }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for TypedEventHandler<super::services::store::StorePackageLicense, IInspectable> => [0x6c59d637,0x2970,0x5f64,0x95,0x11,0xd3,0x9a,0xc2,0x45,0xbc,0x94] as IID_TypedEventHandler_2_Windows_Services_Store_StorePackageLicense_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::accesscache::StorageItemMostRecentlyUsedList, super::storage::accesscache::ItemRemovedEventArgs> => [0x029dace8,0x98d1,0x5bf7,0xb7,0x80,0x97,0x17,0xe9,0x50,0x27,0xff] as IID_TypedEventHandler_2_Windows_Storage_AccessCache_StorageItemMostRecentlyUsedList_Windows_Storage_AccessCache_ItemRemovedEventArgs }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::ApplicationData, IInspectable> => [0xb5348b3b,0x5081,0x5ae9,0x8f,0xa3,0x4d,0x22,0xd6,0x8f,0xb0,0xea] as IID_TypedEventHandler_2_Windows_Storage_ApplicationData_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::bulkaccess::IStorageItemInformation, IInspectable> => [0x5b98b352,0xe0cf,0x58de,0xb2,0xec,0x4f,0xd7,0x86,0xbb,0xb5,0xa7] as IID_TypedEventHandler_2_Windows_Storage_BulkAccess_IStorageItemInformation_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::pickers::provider::FileOpenPickerUI, super::storage::pickers::provider::FileRemovedEventArgs> => [0xf1fb2939,0x695b,0x5f56,0x84,0x1a,0xa5,0x2a,0x7d,0x14,0x85,0x72] as IID_TypedEventHandler_2_Windows_Storage_Pickers_Provider_FileOpenPickerUI_Windows_Storage_Pickers_Provider_FileRemovedEventArgs }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::pickers::provider::FileOpenPickerUI, super::storage::pickers::provider::PickerClosingEventArgs> => [0x2b06bdac,0x983b,0x5552,0xb5,0xc9,0xb0,0x99,0x0a,0x2d,0xb3,0xa1] as IID_TypedEventHandler_2_Windows_Storage_Pickers_Provider_FileOpenPickerUI_Windows_Storage_Pickers_Provider_PickerClosingEventArgs }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::pickers::provider::FileSavePickerUI, IInspectable> => [0xf1e6a632,0xf97f,0x54d9,0x9e,0x1b,0xa7,0x14,0xed,0xc3,0xff,0x06] as IID_TypedEventHandler_2_Windows_Storage_Pickers_Provider_FileSavePickerUI_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::pickers::provider::FileSavePickerUI, super::storage::pickers::provider::TargetFileRequestedEventArgs> => [0xd3e1f8c7,0x45c5,0x5249,0xb3,0x36,0xa1,0x11,0xbf,0xaa,0x98,0x5b] as IID_TypedEventHandler_2_Windows_Storage_Pickers_Provider_FileSavePickerUI_Windows_Storage_Pickers_Provider_TargetFileRequestedEventArgs }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::provider::CachedFileUpdaterUI, IInspectable> => [0x45fdd443,0xc0b9,0x57b0,0xa8,0x4f,0x7d,0x87,0x6e,0xdc,0x31,0x49] as IID_TypedEventHandler_2_Windows_Storage_Provider_CachedFileUpdaterUI_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::provider::CachedFileUpdaterUI, super::storage::provider::FileUpdateRequestedEventArgs> => [0xed56ab72,0xebd3,0x52c8,0xb0,0xac,0x98,0x7d,0x30,0x09,0x03,0x51] as IID_TypedEventHandler_2_Windows_Storage_Provider_CachedFileUpdaterUI_Windows_Storage_Provider_FileUpdateRequestedEventArgs }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::search::IStorageQueryResultBase, IInspectable> => [0x4ba22861,0x00c4,0x597f,0xb6,0xbf,0x3a,0xf5,0x16,0xf3,0xb8,0x70] as IID_TypedEventHandler_2_Windows_Storage_Search_IStorageQueryResultBase_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for TypedEventHandler<super::storage::StorageLibrary, IInspectable> => [0xedc09538,0xbbae,0x5b2b,0x9e,0x81,0xb4,0x49,0xea,0x7e,0x48,0xfe] as IID_TypedEventHandler_2_Windows_Storage_StorageLibrary_System_Object }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::remotesystems::RemoteSystemWatcher, super::system::remotesystems::RemoteSystemAddedEventArgs> => [0xa9b98f4a,0xb63d,0x5d07,0x92,0xbb,0xe2,0xac,0xb3,0x94,0x55,0xd1] as IID_TypedEventHandler_2_Windows_System_RemoteSystems_RemoteSystemWatcher_Windows_System_RemoteSystems_RemoteSystemAddedEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::remotesystems::RemoteSystemWatcher, super::system::remotesystems::RemoteSystemRemovedEventArgs> => [0xc290fb5a,0x3ed0,0x5858,0xaf,0x19,0xf8,0x55,0x53,0xcb,0x96,0xb8] as IID_TypedEventHandler_2_Windows_System_RemoteSystems_RemoteSystemWatcher_Windows_System_RemoteSystems_RemoteSystemRemovedEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::remotesystems::RemoteSystemWatcher, super::system::remotesystems::RemoteSystemUpdatedEventArgs> => [0x88f9d23f,0x8946,0x5a1e,0x8d,0xa1,0x82,0xc6,0x69,0x82,0xa6,0xd2] as IID_TypedEventHandler_2_Windows_System_RemoteSystems_RemoteSystemWatcher_Windows_System_RemoteSystems_RemoteSystemUpdatedEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::UserWatcher, IInspectable> => [0xf155e0ff,0xdbb5,0x5c34,0xac,0x0c,0x7e,0x29,0x1e,0x33,0x00,0xab] as IID_TypedEventHandler_2_Windows_System_UserWatcher_System_Object }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::UserWatcher, super::system::UserAuthenticationStatusChangingEventArgs> => [0x9ec3d9d5,0xb413,0x51df,0x8c,0x64,0x64,0x0e,0x33,0x56,0xe3,0x51] as IID_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserAuthenticationStatusChangingEventArgs }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for TypedEventHandler<super::system::UserWatcher, super::system::UserChangedEventArgs> => [0xeb9d0454,0x25db,0x5620,0x98,0xb8,0xbe,0x4c,0x5d,0x0d,0xbc,0x67] as IID_TypedEventHandler_2_Windows_System_UserWatcher_Windows_System_UserChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::applicationsettings::AccountsSettingsPane, super::ui::applicationsettings::AccountsSettingsPaneCommandsRequestedEventArgs> => [0x69b8847e,0x7d72,0x5a15,0xbc,0x1c,0x4c,0xa3,0x9c,0x93,0xb1,0x62] as IID_TypedEventHandler_2_Windows_UI_ApplicationSettings_AccountsSettingsPane_Windows_UI_ApplicationSettings_AccountsSettingsPaneCommandsRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::applicationsettings::SettingsPane, super::ui::applicationsettings::SettingsPaneCommandsRequestedEventArgs> => [0xf39a56a2,0x7db1,0x5c48,0x9e,0x13,0x7d,0xc4,0x85,0xa4,0xa9,0x9e] as IID_TypedEventHandler_2_Windows_UI_ApplicationSettings_SettingsPane_Windows_UI_ApplicationSettings_SettingsPaneCommandsRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::composition::CompositionGraphicsDevice, super::ui::composition::RenderingDeviceReplacedEventArgs> => [0x259b32be,0xbd06,0x53c2,0xbd,0x51,0x89,0xe8,0xe0,0xf9,0xe2,0x39] as IID_TypedEventHandler_2_Windows_UI_Composition_CompositionGraphicsDevice_Windows_UI_Composition_RenderingDeviceReplacedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreComponentInputSource, super::ui::core::ClosestInteractiveBoundsRequestedEventArgs> => [0xe2c62d42,0x0577,0x5112,0x9e,0x59,0xea,0xe1,0x59,0xbf,0x39,0xe9] as IID_TypedEventHandler_2_Windows_UI_Core_CoreComponentInputSource_Windows_UI_Core_ClosestInteractiveBoundsRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreDispatcher, super::ui::core::AcceleratorKeyEventArgs> => [0x136dff0d,0xf7e8,0x5153,0xb3,0x1c,0x86,0x39,0x0c,0x70,0x18,0x80] as IID_TypedEventHandler_2_Windows_UI_Core_CoreDispatcher_Windows_UI_Core_AcceleratorKeyEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::AutomationProviderRequestedEventArgs> => [0x54db5c04,0x81f7,0x5f46,0x9f,0xb8,0xe4,0x9b,0xee,0xc7,0x0a,0x24] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_AutomationProviderRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::CharacterReceivedEventArgs> => [0x73f846a8,0x0af6,0x5872,0x8f,0xb8,0xae,0x2f,0x56,0xd8,0x55,0x3e] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_CharacterReceivedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::ClosestInteractiveBoundsRequestedEventArgs> => [0x21a652d2,0xbfe2,0x5b2e,0xa2,0xab,0xca,0x45,0x25,0x3b,0xe8,0xb0] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_ClosestInteractiveBoundsRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::CoreWindowEventArgs> => [0xd08e4f66,0x3457,0x57f2,0xba,0x0c,0xcb,0x34,0x71,0x33,0xbd,0x15] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_CoreWindowEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::CoreWindowPopupShowingEventArgs> => [0xb32d6422,0x78b2,0x5e00,0x84,0xa8,0x6e,0x31,0x67,0xaa,0xab,0xde] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_CoreWindowPopupShowingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::InputEnabledEventArgs> => [0xe230a64a,0x506a,0x59c3,0xbb,0x61,0x55,0x59,0xff,0x99,0x56,0x63] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_InputEnabledEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::KeyEventArgs> => [0xa3ec0774,0x55ac,0x5d61,0x82,0x32,0xb3,0x5c,0x5d,0x35,0xc9,0x3c] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_KeyEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::PointerEventArgs> => [0x420e1bb6,0xe99d,0x5e64,0x8e,0x25,0x07,0x46,0x7e,0x3c,0xae,0x9e] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::TouchHitTestingEventArgs> => [0x197654c9,0x0c47,0x502b,0x9a,0xa1,0x0d,0xeb,0x03,0xed,0x97,0x02] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_TouchHitTestingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::VisibilityChangedEventArgs> => [0x14b7f692,0x5583,0x52a1,0xaa,0x42,0xfc,0x18,0x43,0xc0,0xf7,0x48] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_VisibilityChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::WindowActivatedEventArgs> => [0x26a73b35,0xa7f9,0x52db,0x88,0xd6,0x15,0x72,0x6d,0xeb,0x25,0x23] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_WindowActivatedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::CoreWindow, super::ui::core::WindowSizeChangedEventArgs> => [0x318dbb67,0x4089,0x5690,0x90,0x40,0x1d,0x45,0x4f,0xb2,0xf6,0x86] as IID_TypedEventHandler_2_Windows_UI_Core_CoreWindow_Windows_UI_Core_WindowSizeChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::core::ICorePointerRedirector, super::ui::core::PointerEventArgs> => [0x29742d27,0x177d,0x54c3,0xb9,0x74,0x61,0x6f,0xc4,0x5a,0x2b,0x0c] as IID_TypedEventHandler_2_Windows_UI_Core_ICorePointerRedirector_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::EdgeGesture, super::ui::input::EdgeGestureEventArgs> => [0xb62d7f11,0xc7b1,0x5bf0,0xa3,0x47,0x33,0x66,0x25,0x2d,0xb4,0xce] as IID_TypedEventHandler_2_Windows_UI_Input_EdgeGesture_Windows_UI_Input_EdgeGestureEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::CrossSlidingEventArgs> => [0x1fc1eb70,0x0c26,0x5cf0,0x9e,0x50,0x84,0x3a,0x34,0x08,0x36,0x13] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_CrossSlidingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::DraggingEventArgs> => [0xbe7cca42,0x98dd,0x5d72,0x9e,0x91,0x97,0x61,0x13,0xd7,0x98,0x5e] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_DraggingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::HoldingEventArgs> => [0x0027bdf5,0x6948,0x53f7,0xaf,0xbe,0xd4,0xd8,0xfe,0x50,0x0f,0xeb] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_HoldingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::ManipulationCompletedEventArgs> => [0xc24f5605,0x3059,0x52cc,0xbd,0xf3,0x70,0x98,0x14,0x6d,0x34,0xd7] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_ManipulationCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::ManipulationInertiaStartingEventArgs> => [0x350a72ab,0x34a5,0x5193,0x91,0x3d,0x3d,0x4c,0x59,0x83,0x84,0x2c] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_ManipulationInertiaStartingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::ManipulationStartedEventArgs> => [0x110d75c8,0xba5e,0x5462,0x8b,0x2d,0x4a,0x15,0x82,0x57,0x4b,0x61] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_ManipulationStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::ManipulationUpdatedEventArgs> => [0xeb5216f5,0x020a,0x5e40,0x9c,0x4b,0x48,0x91,0x2c,0x69,0x0e,0x2d] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_ManipulationUpdatedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::RightTappedEventArgs> => [0x8420d242,0xba34,0x5b17,0x92,0xf3,0x8f,0x76,0x7f,0x1d,0x0d,0xe4] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_RightTappedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::GestureRecognizer, super::ui::input::TappedEventArgs> => [0x27f3ad57,0x8994,0x5712,0x8b,0x83,0xa9,0x3b,0xa1,0x7c,0x03,0xc2] as IID_TypedEventHandler_2_Windows_UI_Input_GestureRecognizer_Windows_UI_Input_TappedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::core::CoreInkIndependentInputSource, super::ui::core::PointerEventArgs> => [0xb83fbe98,0x882a,0x5b69,0xbd,0x1c,0xc6,0x66,0x90,0x70,0x7f,0xef] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_Core_CoreInkIndependentInputSource_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::core::CoreWetStrokeUpdateSource, super::ui::input::inking::core::CoreWetStrokeUpdateEventArgs> => [0x67ff75e8,0x02a4,0x5254,0xa9,0x65,0x0b,0x25,0x4c,0x7d,0x07,0x88] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_Core_CoreWetStrokeUpdateSource_Windows_UI_Input_Inking_Core_CoreWetStrokeUpdateEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::InkPresenter, super::ui::input::inking::InkStrokesCollectedEventArgs> => [0x176bfa8f,0xc0de,0x5b3a,0xb2,0x8c,0x0f,0x39,0x31,0xca,0x52,0xd3] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_InkPresenter_Windows_UI_Input_Inking_InkStrokesCollectedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::InkPresenter, super::ui::input::inking::InkStrokesErasedEventArgs> => [0x30fec929,0x14d0,0x550f,0x84,0xf2,0x13,0x7f,0xc6,0xa9,0xf0,0x8f] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_InkPresenter_Windows_UI_Input_Inking_InkStrokesErasedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::InkStrokeInput, super::ui::core::PointerEventArgs> => [0xbf66b962,0x702d,0x5c07,0xa2,0xd5,0x15,0xf2,0x15,0x83,0xc4,0x3a] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_InkStrokeInput_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::inking::InkUnprocessedInput, super::ui::core::PointerEventArgs> => [0x4a86bd78,0x5bcf,0x5ede,0x8f,0x65,0xa8,0xc6,0x52,0x35,0x05,0x5c] as IID_TypedEventHandler_2_Windows_UI_Input_Inking_InkUnprocessedInput_Windows_UI_Core_PointerEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::KeyboardDeliveryInterceptor, super::ui::core::KeyEventArgs> => [0x2c1caf11,0x9d6f,0x5e0f,0xa9,0xea,0x4c,0x7c,0x73,0x4d,0x73,0xd6] as IID_TypedEventHandler_2_Windows_UI_Input_KeyboardDeliveryInterceptor_Windows_UI_Core_KeyEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, IInspectable> => [0x5e0f93b1,0xc2f2,0x5351,0x82,0xaa,0x6c,0xf5,0xf4,0xc2,0xd0,0x68] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, super::ui::input::RadialControllerButtonClickedEventArgs> => [0xd09d9fcc,0xedb8,0x56c0,0x85,0x6d,0x70,0xe4,0x77,0xa9,0xdd,0xf3] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_Windows_UI_Input_RadialControllerButtonClickedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, super::ui::input::RadialControllerControlAcquiredEventArgs> => [0x4ec5f3fd,0xb217,0x5452,0xa2,0xbd,0x97,0x25,0xce,0x9f,0x66,0x75] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_Windows_UI_Input_RadialControllerControlAcquiredEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, super::ui::input::RadialControllerRotationChangedEventArgs> => [0x8fe73ac9,0x8a36,0x5152,0x81,0x5d,0x03,0x31,0x0e,0xe8,0xbf,0x85] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_Windows_UI_Input_RadialControllerRotationChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, super::ui::input::RadialControllerScreenContactContinuedEventArgs> => [0x30579e67,0xfb4f,0x5d38,0x83,0xb4,0x9c,0xb6,0x10,0x09,0x0d,0xef] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_Windows_UI_Input_RadialControllerScreenContactContinuedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialController, super::ui::input::RadialControllerScreenContactStartedEventArgs> => [0x1f2d584e,0x3ad8,0x5049,0xb4,0x51,0x3a,0x44,0xa1,0x02,0xfa,0x82] as IID_TypedEventHandler_2_Windows_UI_Input_RadialController_Windows_UI_Input_RadialControllerScreenContactStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::RadialControllerMenuItem, IInspectable> => [0x5c90d6fb,0xe4f8,0x5be2,0x85,0x44,0x9d,0xe3,0x3f,0x82,0xc4,0x1a] as IID_TypedEventHandler_2_Windows_UI_Input_RadialControllerMenuItem_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialHoldCanceledEventArgs> => [0x6a715963,0xc49f,0x5f3d,0xbf,0xec,0x95,0x27,0x00,0x30,0x88,0x60] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialHoldCanceledEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialHoldCompletedEventArgs> => [0xe425d80e,0x8c18,0x5375,0xb6,0x00,0x1d,0xd7,0xa1,0x1d,0xba,0x5e] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialHoldCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialHoldStartedEventArgs> => [0x7537dd12,0x02b8,0x5132,0x8f,0xf7,0x90,0xc8,0x0e,0xf4,0x54,0xd1] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialHoldStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialManipulationCanceledEventArgs> => [0xb92a6754,0x3946,0x5353,0xb8,0xf9,0x2a,0x07,0xeb,0x0e,0x88,0x86] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialManipulationCanceledEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialManipulationCompletedEventArgs> => [0x10dac914,0xbea2,0x5d67,0x86,0x07,0xdc,0x47,0x0e,0xa1,0xdc,0xd8] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialManipulationCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialManipulationStartedEventArgs> => [0xa123252b,0xcfe8,0x5cfb,0xb6,0x1c,0xf2,0xdc,0x01,0x1e,0xb1,0x2e] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialManipulationStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialManipulationUpdatedEventArgs> => [0xcecbe023,0x3c49,0x530e,0xa0,0x10,0x8c,0x0c,0x3c,0xbd,0x30,0x88] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialManipulationUpdatedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialNavigationCanceledEventArgs> => [0x9947ea8e,0xeb4d,0x5f93,0x9f,0xd9,0x2a,0xde,0x64,0x70,0xbc,0x5d] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialNavigationCanceledEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialNavigationCompletedEventArgs> => [0xf0d459df,0xebd3,0x5388,0xb0,0xa9,0x5f,0x44,0xbc,0xd6,0xf5,0x8f] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialNavigationCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialNavigationStartedEventArgs> => [0x5419cadc,0x2600,0x527b,0x93,0x98,0x17,0x44,0x31,0x8d,0x06,0x18] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialNavigationStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialNavigationUpdatedEventArgs> => [0xa7216b90,0xc175,0x5a28,0xb5,0x00,0xa4,0x45,0xf0,0x75,0x1c,0x5b] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialNavigationUpdatedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialRecognitionEndedEventArgs> => [0xafa7fad7,0x3fd7,0x5c81,0x88,0x02,0x19,0x5c,0x52,0x3f,0x6e,0x7b] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialRecognitionEndedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialRecognitionStartedEventArgs> => [0xf2bd99d6,0x99fa,0x5599,0xa1,0x4a,0x1f,0x7a,0x7a,0x92,0xe3,0xd7] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialRecognitionStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialGestureRecognizer, super::ui::input::spatial::SpatialTappedEventArgs> => [0x630205a4,0x2f93,0x5022,0xb7,0xb8,0xc4,0x3e,0xd4,0x28,0x49,0x8a] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialGestureRecognizer_Windows_UI_Input_Spatial_SpatialTappedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialInteractionManager, super::ui::input::spatial::SpatialInteractionDetectedEventArgs> => [0x0f223f8f,0xf220,0x5388,0x8f,0xe6,0xb3,0xb7,0xe7,0x93,0x09,0x87] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialInteractionManager_Windows_UI_Input_Spatial_SpatialInteractionDetectedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::input::spatial::SpatialInteractionManager, super::ui::input::spatial::SpatialInteractionSourceEventArgs> => [0xae831d66,0x70f0,0x5371,0x86,0x6f,0xa3,0xfc,0x8b,0x60,0xe2,0xd8] as IID_TypedEventHandler_2_Windows_UI_Input_Spatial_SpatialInteractionManager_Windows_UI_Input_Spatial_SpatialInteractionSourceEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::notifications::management::UserNotificationListener, super::ui::notifications::UserNotificationChangedEventArgs> => [0x10242902,0xb897,0x5507,0x99,0x22,0x2c,0x0a,0x7d,0x34,0x46,0x4d] as IID_TypedEventHandler_2_Windows_UI_Notifications_Management_UserNotificationListener_Windows_UI_Notifications_UserNotificationChangedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::notifications::ToastNotification, IInspectable> => [0xab54de2d,0x97d9,0x5528,0xb6,0xad,0x10,0x5a,0xfe,0x15,0x65,0x30] as IID_TypedEventHandler_2_Windows_UI_Notifications_ToastNotification_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::notifications::ToastNotification, super::ui::notifications::ToastDismissedEventArgs> => [0x61c2402f,0x0ed0,0x5a18,0xab,0x69,0x59,0xf4,0xaa,0x99,0xa3,0x68] as IID_TypedEventHandler_2_Windows_UI_Notifications_ToastNotification_Windows_UI_Notifications_ToastDismissedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::notifications::ToastNotification, super::ui::notifications::ToastFailedEventArgs> => [0x95e3e803,0xc969,0x5e3a,0x97,0x53,0xea,0x2a,0xd2,0x2a,0x9a,0x33] as IID_TypedEventHandler_2_Windows_UI_Notifications_ToastNotification_Windows_UI_Notifications_ToastFailedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::startscreen::SecondaryTile, super::ui::startscreen::VisualElementsRequestedEventArgs> => [0x02d9f968,0xfa76,0x5d77,0x93,0x4b,0x66,0x5e,0x7c,0x3b,0xe7,0xcf] as IID_TypedEventHandler_2_Windows_UI_StartScreen_SecondaryTile_Windows_UI_StartScreen_VisualElementsRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, IInspectable> => [0xef53b467,0xc472,0x5b59,0xa8,0x27,0x38,0xad,0xc3,0xa9,0xd3,0x26] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextCompositionCompletedEventArgs> => [0xa2d7059e,0x68ed,0x5260,0x8d,0x8e,0x1d,0xcf,0x3d,0x25,0xd6,0x63] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextCompositionCompletedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextCompositionStartedEventArgs> => [0xe671d625,0x5b59,0x57e6,0xa9,0x2e,0x40,0x00,0x95,0x07,0x85,0x3a] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextCompositionStartedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextFormatUpdatingEventArgs> => [0x3e4ef599,0x4cc2,0x5248,0xbf,0x2d,0x13,0xf1,0x76,0x13,0xb0,0xa6] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextFormatUpdatingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextLayoutRequestedEventArgs> => [0x1a5f5596,0x561c,0x57f6,0xa4,0xff,0xcb,0x85,0x01,0x3c,0x65,0x44] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextLayoutRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextSelectionRequestedEventArgs> => [0x882e51e1,0xf4a3,0x57e5,0x93,0x92,0x6a,0x8c,0x38,0x57,0x91,0x81] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextSelectionRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextSelectionUpdatingEventArgs> => [0x6b140a40,0xd461,0x555a,0xb6,0xeb,0x5d,0xbb,0x8e,0x21,0x01,0xe5] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextSelectionUpdatingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextTextRequestedEventArgs> => [0xc7e08176,0x4134,0x50b7,0xbc,0x73,0x72,0x9e,0x9f,0x9a,0xd2,0x2a] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextTextRequestedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextEditContext, super::ui::text::core::CoreTextTextUpdatingEventArgs> => [0xfd896a84,0xdf7c,0x50d5,0x91,0x67,0x58,0xf6,0x16,0xbd,0xdb,0x6e] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextEditContext_Windows_UI_Text_Core_CoreTextTextUpdatingEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::text::core::CoreTextServicesManager, IInspectable> => [0x112fb01d,0x260a,0x51c6,0x91,0x98,0x5d,0xb3,0xe6,0xe9,0xef,0x3d] as IID_TypedEventHandler_2_Windows_UI_Text_Core_CoreTextServicesManager_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::viewmanagement::AccessibilitySettings, IInspectable> => [0xf5917e6f,0x5abf,0x5e65,0xb5,0xb4,0x1b,0x9c,0x8d,0x94,0xe7,0x88] as IID_TypedEventHandler_2_Windows_UI_ViewManagement_AccessibilitySettings_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::viewmanagement::ApplicationView, IInspectable> => [0x00c1f983,0xc836,0x565c,0x8b,0xbf,0x70,0x53,0x05,0x5b,0xdb,0x4c] as IID_TypedEventHandler_2_Windows_UI_ViewManagement_ApplicationView_System_Object }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::viewmanagement::ApplicationView, super::ui::viewmanagement::ApplicationViewConsolidatedEventArgs> => [0x463c606a,0x8c82,0x5a29,0xa2,0xbd,0x04,0x07,0x81,0xf2,0x53,0x48] as IID_TypedEventHandler_2_Windows_UI_ViewManagement_ApplicationView_Windows_UI_ViewManagement_ApplicationViewConsolidatedEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::viewmanagement::InputPane, super::ui::viewmanagement::InputPaneVisibilityEventArgs> => [0xb813d684,0xd953,0x5a8a,0x9b,0x30,0x78,0xb7,0x9f,0xb9,0x14,0x7b] as IID_TypedEventHandler_2_Windows_UI_ViewManagement_InputPane_Windows_UI_ViewManagement_InputPaneVisibilityEventArgs }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::viewmanagement::UISettings, IInspectable> => [0x2dbdba9d,0x20da,0x519d,0x90,0x78,0x09,0xf8,0x35,0xbc,0x5b,0xc7] as IID_TypedEventHandler_2_Windows_UI_ViewManagement_UISettings_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::AutoSuggestBox, super::ui::xaml::controls::AutoSuggestBoxQuerySubmittedEventArgs> => [0x1fa5f243,0x7045,0x56cb,0xbf,0x2d,0xf5,0xa4,0x25,0x02,0x5c,0x21] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_AutoSuggestBox_Windows_UI_Xaml_Controls_AutoSuggestBoxQuerySubmittedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::AutoSuggestBox, super::ui::xaml::controls::AutoSuggestBoxSuggestionChosenEventArgs> => [0x7996a97e,0x615e,0x5ff5,0xbe,0x3d,0x0f,0xf9,0xfe,0x43,0x45,0x1c] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_AutoSuggestBox_Windows_UI_Xaml_Controls_AutoSuggestBoxSuggestionChosenEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::AutoSuggestBox, super::ui::xaml::controls::AutoSuggestBoxTextChangedEventArgs> => [0x7e2dc943,0x5f2f,0x54fb,0x81,0x6f,0x8e,0x65,0xe8,0x93,0xf9,0x0a] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_AutoSuggestBox_Windows_UI_Xaml_Controls_AutoSuggestBoxTextChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::CalendarDatePicker, super::ui::xaml::controls::CalendarDatePickerDateChangedEventArgs> => [0x5ff44775,0x026e,0x51db,0xb4,0x62,0x44,0xc1,0x9c,0x45,0xa7,0x77] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_CalendarDatePicker_Windows_UI_Xaml_Controls_CalendarDatePickerDateChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::CalendarView, super::ui::xaml::controls::CalendarViewDayItemChangingEventArgs> => [0x6a74874e,0xf6b3,0x5c39,0x9e,0x5f,0x17,0x51,0xb7,0x82,0xbb,0x32] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_CalendarView_Windows_UI_Xaml_Controls_CalendarViewDayItemChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::CalendarView, super::ui::xaml::controls::CalendarViewSelectedDatesChangedEventArgs> => [0xd22361ee,0x5234,0x5d25,0xa5,0x3b,0x79,0xa5,0xff,0x6a,0x03,0xb8] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_CalendarView_Windows_UI_Xaml_Controls_CalendarViewSelectedDatesChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::CommandBar, super::ui::xaml::controls::DynamicOverflowItemsChangingEventArgs> => [0x758990cd,0xa4a5,0x5c0a,0xac,0xa5,0x64,0xa6,0x29,0xaf,0xdb,0xcc] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_CommandBar_Windows_UI_Xaml_Controls_DynamicOverflowItemsChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ContentDialog, super::ui::xaml::controls::ContentDialogButtonClickEventArgs> => [0x4b00de1a,0xffed,0x57b4,0xbd,0x6e,0x8c,0x7a,0xab,0x2c,0x53,0xff] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ContentDialog_Windows_UI_Xaml_Controls_ContentDialogButtonClickEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ContentDialog, super::ui::xaml::controls::ContentDialogClosedEventArgs> => [0xb040eb41,0xb4f5,0x5d9f,0x83,0xc7,0x9c,0x93,0x9c,0x48,0xc8,0x90] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ContentDialog_Windows_UI_Xaml_Controls_ContentDialogClosedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ContentDialog, super::ui::xaml::controls::ContentDialogClosingEventArgs> => [0x30491cfe,0xfff8,0x5c91,0xb3,0x87,0xce,0x81,0x37,0x71,0x39,0x18] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ContentDialog_Windows_UI_Xaml_Controls_ContentDialogClosingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ContentDialog, super::ui::xaml::controls::ContentDialogOpenedEventArgs> => [0xb79b774b,0x7c7f,0x580c,0x89,0x14,0xe9,0xcb,0x26,0x42,0x43,0x2e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ContentDialog_Windows_UI_Xaml_Controls_ContentDialogOpenedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::Control, super::ui::xaml::controls::FocusDisengagedEventArgs> => [0x38b4535c,0x2785,0x5122,0x96,0xfe,0xd4,0x4f,0x79,0x5b,0x9c,0xb2] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Control_Windows_UI_Xaml_Controls_FocusDisengagedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::Control, super::ui::xaml::controls::FocusEngagedEventArgs> => [0x0c3f6433,0x66b6,0x5544,0x8b,0x9b,0x89,0x04,0xf4,0x05,0x5e,0x92] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Control_Windows_UI_Xaml_Controls_FocusEngagedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::DatePickerFlyout, super::ui::xaml::controls::DatePickedEventArgs> => [0x4d9c196f,0xcdd3,0x54d8,0x98,0xd9,0x4f,0x29,0xab,0xba,0xde,0x76] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_DatePickerFlyout_Windows_UI_Xaml_Controls_DatePickedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::InkToolbar, IInspectable> => [0xeea8b7be,0x9cba,0x5129,0x9b,0x75,0x49,0x30,0xdc,0x0c,0x27,0x05] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_InkToolbar_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ListPickerFlyout, super::ui::xaml::controls::ItemsPickedEventArgs> => [0x46c68740,0x3f79,0x593f,0xa8,0x5f,0x42,0x48,0x12,0x79,0x48,0xc6] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ListPickerFlyout_Windows_UI_Xaml_Controls_ItemsPickedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ListViewBase, super::ui::xaml::controls::ChoosingGroupHeaderContainerEventArgs> => [0x4f5971d1,0xbae9,0x56f4,0xac,0xd6,0x0a,0x82,0x46,0xa6,0xf2,0x55] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ListViewBase_Windows_UI_Xaml_Controls_ChoosingGroupHeaderContainerEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ListViewBase, super::ui::xaml::controls::ChoosingItemContainerEventArgs> => [0xf06fc999,0x61e1,0x5d3f,0xb0,0xac,0x69,0xf2,0xee,0x9e,0x4d,0x64] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ListViewBase_Windows_UI_Xaml_Controls_ChoosingItemContainerEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ListViewBase, super::ui::xaml::controls::ContainerContentChangingEventArgs> => [0xd01fb083,0x5e61,0x5c12,0xa1,0x8f,0x62,0x94,0x71,0x58,0xfa,0xa8] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ListViewBase_Windows_UI_Xaml_Controls_ContainerContentChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::ListViewBase, super::ui::xaml::controls::DragItemsCompletedEventArgs> => [0x586d1c88,0xe27e,0x58ad,0x8e,0x2f,0x7e,0x6e,0x83,0xd8,0x1e,0x40] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_ListViewBase_Windows_UI_Xaml_Controls_DragItemsCompletedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::CustomMapTileDataSource, super::ui::xaml::controls::maps::MapTileBitmapRequestedEventArgs> => [0x8d2d9655,0x2f82,0x5271,0x9e,0x95,0xa2,0xdb,0x39,0xd8,0x72,0xf0] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_CustomMapTileDataSource_Windows_UI_Xaml_Controls_Maps_MapTileBitmapRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::HttpMapTileDataSource, super::ui::xaml::controls::maps::MapTileUriRequestedEventArgs> => [0x4933a19a,0x00cc,0x5c21,0xa3,0xdf,0xb6,0x8f,0x99,0x39,0xf6,0xef] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_HttpMapTileDataSource_Windows_UI_Xaml_Controls_Maps_MapTileUriRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::LocalMapTileDataSource, super::ui::xaml::controls::maps::MapTileUriRequestedEventArgs> => [0x76752fc4,0xb240,0x502c,0x90,0x98,0x62,0x2c,0x6c,0x36,0xe6,0xa3] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_LocalMapTileDataSource_Windows_UI_Xaml_Controls_Maps_MapTileUriRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, IInspectable> => [0xf250dd93,0xe636,0x51ef,0xbc,0x93,0xee,0x78,0xd4,0x31,0xa6,0xbd] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapActualCameraChangedEventArgs> => [0x1b536ae0,0x08b0,0x5c54,0xbb,0x30,0x67,0x9e,0x6a,0x87,0x5d,0x61] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapActualCameraChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapActualCameraChangingEventArgs> => [0x78bfb71b,0x2d80,0x50e1,0xa2,0xe9,0xe5,0x66,0x7f,0xf8,0x9e,0xf2] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapActualCameraChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlBusinessLandmarkClickEventArgs> => [0x3a9d75c2,0xa41b,0x5708,0x8c,0x1b,0x8e,0x7c,0x26,0xe8,0x57,0xd0] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlBusinessLandmarkClickEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlBusinessLandmarkPointerEnteredEventArgs> => [0xfd7dabea,0x0014,0x5a30,0x9a,0x59,0xbd,0x41,0x26,0xa2,0xff,0xb7] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlBusinessLandmarkPointerEnteredEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlBusinessLandmarkPointerExitedEventArgs> => [0xc4574b81,0xa192,0x5810,0xb0,0xd9,0xcc,0x99,0x23,0x0f,0xdc,0xdc] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlBusinessLandmarkPointerExitedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlBusinessLandmarkRightTappedEventArgs> => [0xe3634a54,0x05ed,0x5e39,0x9d,0x8a,0x03,0x85,0x7f,0x0b,0xa0,0xe7] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlBusinessLandmarkRightTappedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlTransitFeatureClickEventArgs> => [0x3ec75af0,0x1679,0x53ff,0xbb,0x0c,0x37,0x6b,0x8c,0x44,0x19,0x80] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlTransitFeatureClickEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlTransitFeaturePointerEnteredEventArgs> => [0x166ea60b,0xab70,0x580c,0xbb,0x70,0x2f,0x79,0xee,0x21,0x4c,0xea] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlTransitFeaturePointerEnteredEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlTransitFeaturePointerExitedEventArgs> => [0x7553fcf8,0xa4c2,0x5cc1,0x9a,0x3c,0xf0,0xb3,0x6b,0x75,0x60,0x68] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlTransitFeaturePointerExitedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapControlTransitFeatureRightTappedEventArgs> => [0xa18b47d7,0x6326,0x5fc1,0x8a,0x40,0x88,0xaf,0x91,0xbb,0x05,0x89] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapControlTransitFeatureRightTappedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapCustomExperienceChangedEventArgs> => [0x272cf26f,0x18da,0x599e,0x89,0x6f,0x3b,0xfb,0xf6,0xfb,0x13,0x26] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapCustomExperienceChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapElementClickEventArgs> => [0x4c7821a1,0xd570,0x597d,0xac,0xc7,0x06,0x88,0x53,0xc4,0xab,0x27] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapElementClickEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapElementPointerEnteredEventArgs> => [0xca2638e5,0x7c33,0x5b90,0x9b,0x66,0x27,0x37,0x31,0xfc,0x70,0x91] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapElementPointerEnteredEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapElementPointerExitedEventArgs> => [0xf6a7bfd1,0x2c79,0x5191,0xb3,0x82,0x75,0xb1,0x41,0xd1,0x88,0x46] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapElementPointerExitedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapInputEventArgs> => [0xb92f6816,0x4d0a,0x52c2,0x98,0x68,0x94,0xb5,0xc9,0x42,0x00,0x7e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapInputEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapRightTappedEventArgs> => [0xefc52f2d,0xad6b,0x59af,0xa0,0xf0,0x22,0x53,0xd4,0x34,0x41,0x4f] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapRightTappedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapControl, super::ui::xaml::controls::maps::MapTargetCameraChangedEventArgs> => [0x2671c2dd,0xe212,0x5e43,0x80,0xe2,0xab,0x6f,0xf3,0xf3,0x08,0x6c] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapControl_Windows_UI_Xaml_Controls_Maps_MapTargetCameraChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::maps::MapScene, super::ui::xaml::controls::maps::MapTargetCameraChangedEventArgs> => [0x766ed4a8,0xe810,0x5f78,0xbc,0x96,0x9a,0xff,0x9f,0x58,0xcf,0xca] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Maps_MapScene_Windows_UI_Xaml_Controls_Maps_MapTargetCameraChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::MediaElement, super::ui::xaml::media::PartialMediaFailureDetectedEventArgs> => [0xb402b0ca,0xbeca,0x5537,0x81,0x92,0x8f,0x30,0xf7,0xcb,0x5d,0x0e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_MediaElement_Windows_UI_Xaml_Media_PartialMediaFailureDetectedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::MediaTransportControls, super::ui::xaml::media::MediaTransportControlsThumbnailRequestedEventArgs> => [0xc2925ff8,0x71f0,0x59d3,0xba,0x13,0x86,0x2b,0x22,0x6e,0xeb,0xa2] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_MediaTransportControls_Windows_UI_Xaml_Media_MediaTransportControlsThumbnailRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::PickerFlyout, super::ui::xaml::controls::PickerConfirmedEventArgs> => [0x22cde5b7,0x4eb7,0x5ee4,0x8d,0x28,0x1f,0x1c,0xbc,0xf6,0x8f,0xb0] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_PickerFlyout_Windows_UI_Xaml_Controls_PickerConfirmedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::Pivot, super::ui::xaml::controls::PivotItemEventArgs> => [0x6b0c4ca2,0x7feb,0x5e4e,0xbf,0x5c,0xde,0x9f,0x3a,0xc4,0x22,0x1c] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Pivot_Windows_UI_Xaml_Controls_PivotItemEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::primitives::FlyoutBase, super::ui::xaml::controls::primitives::FlyoutBaseClosingEventArgs> => [0x96e17fbc,0x78c7,0x5560,0xac,0x3a,0x58,0x7f,0x46,0xdb,0x70,0xd6] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_Primitives_FlyoutBase_Windows_UI_Xaml_Controls_Primitives_FlyoutBaseClosingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::RichEditBox, super::ui::xaml::controls::CandidateWindowBoundsChangedEventArgs> => [0xb0b3c248,0x7604,0x5108,0xae,0xc9,0x6f,0x3a,0xec,0xca,0x27,0x37] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_RichEditBox_Windows_UI_Xaml_Controls_CandidateWindowBoundsChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::RichEditBox, super::ui::xaml::controls::RichEditBoxTextChangingEventArgs> => [0xfad2ffb9,0xd2d9,0x563c,0x88,0xca,0x13,0x23,0xb1,0x33,0xfb,0xf3] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_RichEditBox_Windows_UI_Xaml_Controls_RichEditBoxTextChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::RichEditBox, super::ui::xaml::controls::TextCompositionChangedEventArgs> => [0xc080b01b,0xeec0,0x542c,0xb1,0xf1,0xd0,0x0e,0x20,0x7e,0xe1,0xe0] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_RichEditBox_Windows_UI_Xaml_Controls_TextCompositionChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::RichEditBox, super::ui::xaml::controls::TextCompositionEndedEventArgs> => [0xe6750b95,0x305f,0x52fd,0xbb,0x80,0xcf,0xcf,0x72,0xbc,0x54,0x21] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_RichEditBox_Windows_UI_Xaml_Controls_TextCompositionEndedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::RichEditBox, super::ui::xaml::controls::TextCompositionStartedEventArgs> => [0x297dde84,0xd0c7,0x5d21,0xb1,0xed,0xf9,0x6c,0x4e,0xa4,0x77,0x2f] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_RichEditBox_Windows_UI_Xaml_Controls_TextCompositionStartedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SearchBox, super::ui::xaml::controls::SearchBoxQueryChangedEventArgs> => [0xb15ccc28,0x40f3,0x52da,0x90,0x11,0x87,0x62,0x1e,0x9c,0x60,0xea] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SearchBox_Windows_UI_Xaml_Controls_SearchBoxQueryChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SearchBox, super::ui::xaml::controls::SearchBoxQuerySubmittedEventArgs> => [0x56d6c824,0xa5b2,0x51f4,0x8a,0xf7,0x7b,0x8e,0xe5,0x82,0xc0,0x29] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SearchBox_Windows_UI_Xaml_Controls_SearchBoxQuerySubmittedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SearchBox, super::ui::xaml::controls::SearchBoxResultSuggestionChosenEventArgs> => [0x8d18767b,0xa4b8,0x52fc,0x87,0x67,0xf8,0x7d,0x05,0xb5,0x17,0x2e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SearchBox_Windows_UI_Xaml_Controls_SearchBoxResultSuggestionChosenEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SearchBox, super::ui::xaml::controls::SearchBoxSuggestionsRequestedEventArgs> => [0x287dd4fe,0x12fc,0x5289,0xab,0x8a,0x7c,0x72,0x17,0x02,0x4a,0x6b] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SearchBox_Windows_UI_Xaml_Controls_SearchBoxSuggestionsRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SearchBox, super::ui::xaml::RoutedEventArgs> => [0xa16eff3c,0xcc37,0x554c,0x8f,0x10,0x0f,0x7e,0x6e,0x2b,0xca,0xad] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SearchBox_Windows_UI_Xaml_RoutedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SplitView, IInspectable> => [0xe277bfe5,0x10c1,0x5472,0x9b,0xc6,0x1a,0xe3,0x9a,0xeb,0xfc,0x86] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SplitView_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SplitView, super::ui::xaml::controls::SplitViewPaneClosingEventArgs> => [0xc674a1de,0xc3d9,0x5e39,0xbc,0x39,0x12,0x1f,0xc3,0xcc,0x7d,0x41] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SplitView_Windows_UI_Xaml_Controls_SplitViewPaneClosingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::SwapChainPanel, IInspectable> => [0xa8bbf146,0xb687,0x5c03,0x9a,0x42,0x2a,0xe2,0xd5,0x5b,0xfb,0xb4] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_SwapChainPanel_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TextBox, super::ui::xaml::controls::CandidateWindowBoundsChangedEventArgs> => [0xb6b53bf8,0x1ac8,0x51c4,0xba,0xfc,0x95,0xf8,0xe0,0x16,0x37,0xb0] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TextBox_Windows_UI_Xaml_Controls_CandidateWindowBoundsChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TextBox, super::ui::xaml::controls::TextBoxTextChangingEventArgs> => [0x1e65e112,0xe634,0x55c3,0xbe,0xfb,0xdb,0xf5,0xcf,0xcb,0x30,0xb1] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TextBox_Windows_UI_Xaml_Controls_TextBoxTextChangingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TextBox, super::ui::xaml::controls::TextCompositionChangedEventArgs> => [0x61107067,0x2cfb,0x5de1,0x92,0xb6,0xd3,0x32,0xc1,0x7f,0x75,0x6e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TextBox_Windows_UI_Xaml_Controls_TextCompositionChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TextBox, super::ui::xaml::controls::TextCompositionEndedEventArgs> => [0xb9ac0e9e,0x5b32,0x52b7,0xa8,0xf9,0xb8,0x5e,0x4b,0xe1,0x4b,0x16] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TextBox_Windows_UI_Xaml_Controls_TextCompositionEndedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TextBox, super::ui::xaml::controls::TextCompositionStartedEventArgs> => [0x98fee2a4,0x211d,0x5a3d,0xa8,0x32,0xc5,0xdd,0xeb,0x84,0x44,0xa9] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TextBox_Windows_UI_Xaml_Controls_TextCompositionStartedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::TimePickerFlyout, super::ui::xaml::controls::TimePickedEventArgs> => [0x7d77980b,0xa0df,0x51b1,0x87,0x9b,0xc2,0x3d,0x2d,0xe0,0xab,0xbe] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_TimePickerFlyout_Windows_UI_Xaml_Controls_TimePickedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, IInspectable> => [0xd9f52e0d,0x21fb,0x5a0b,0xb4,0xc6,0x7d,0x16,0x2a,0xf7,0xfb,0x9c] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewContentLoadingEventArgs> => [0xe7b42a9a,0xf140,0x52ad,0xa6,0x58,0xe2,0x37,0xb9,0xa3,0xdc,0xca] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewContentLoadingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewDOMContentLoadedEventArgs> => [0xb9cc891c,0x4745,0x5a25,0x98,0x45,0xe4,0x4d,0x13,0x42,0x5a,0x38] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewDOMContentLoadedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewLongRunningScriptDetectedEventArgs> => [0xecdc76ef,0xa99b,0x5ce7,0xb9,0xa4,0xc8,0x5e,0x66,0xfe,0xd1,0xee] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewLongRunningScriptDetectedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewNavigationCompletedEventArgs> => [0x411136f7,0x770d,0x599c,0x85,0x45,0x6d,0x05,0x3a,0x6a,0x17,0x99] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewNavigationCompletedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewNavigationStartingEventArgs> => [0x98055b5a,0x36bb,0x5962,0x97,0x1f,0x8b,0x87,0x61,0x9e,0xb1,0x7e] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewNavigationStartingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewNewWindowRequestedEventArgs> => [0xa8d0aff5,0x90e1,0x5921,0x87,0xdd,0x57,0x6a,0x4b,0x0a,0x95,0xb6] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewNewWindowRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewPermissionRequestedEventArgs> => [0x718c7a23,0xeb9f,0x50a6,0x8c,0xf7,0xfb,0xac,0x10,0x4e,0x59,0xc3] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewPermissionRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewUnsupportedUriSchemeIdentifiedEventArgs> => [0xd304027c,0x5714,0x502a,0x93,0x12,0x68,0xca,0x86,0x39,0x71,0x24] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewUnsupportedUriSchemeIdentifiedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::controls::WebView, super::ui::xaml::controls::WebViewUnviewableContentIdentifiedEventArgs> => [0xf00e9fbf,0xd30e,0x5854,0x89,0x27,0xc9,0x51,0x2a,0xbd,0x81,0x18] as IID_TypedEventHandler_2_Windows_UI_Xaml_Controls_WebView_Windows_UI_Xaml_Controls_WebViewUnviewableContentIdentifiedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::documents::Hyperlink, super::ui::xaml::documents::HyperlinkClickEventArgs> => [0x5fead0d2,0xe657,0x5aef,0xa9,0x1b,0x7f,0x52,0xea,0xd1,0x7f,0xe3] as IID_TypedEventHandler_2_Windows_UI_Xaml_Documents_Hyperlink_Windows_UI_Xaml_Documents_HyperlinkClickEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::FrameworkElement, IInspectable> => [0xc229f252,0xdede,0x5d42,0xa0,0x1a,0x84,0x79,0xd5,0x6a,0x7d,0x2f] as IID_TypedEventHandler_2_Windows_UI_Xaml_FrameworkElement_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::FrameworkElement, super::ui::xaml::DataContextChangedEventArgs> => [0xb01c8a21,0xde6f,0x5edd,0x87,0x96,0x30,0x0e,0x3f,0xe6,0x63,0x82] as IID_TypedEventHandler_2_Windows_UI_Xaml_FrameworkElement_Windows_UI_Xaml_DataContextChangedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::media::animation::ConnectedAnimation, IInspectable> => [0x44caa9ea,0x7598,0x517a,0xb7,0x8e,0xab,0xd2,0x0d,0x93,0xd5,0x87] as IID_TypedEventHandler_2_Windows_UI_Xaml_Media_Animation_ConnectedAnimation_System_Object }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::DragStartingEventArgs> => [0xecc4b13b,0x146c,0x5963,0xb8,0xb3,0x02,0x4c,0x5b,0x9b,0x95,0xe4] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_DragStartingEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::DropCompletedEventArgs> => [0xffd72e78,0xec1f,0x5bcc,0x9d,0x13,0xff,0x5f,0xbb,0x04,0x05,0x62] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_DropCompletedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::input::AccessKeyDisplayDismissedEventArgs> => [0x2831903f,0x655e,0x5464,0x82,0x8c,0x56,0xa8,0xb4,0xc6,0x5f,0x1e] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_Input_AccessKeyDisplayDismissedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::input::AccessKeyDisplayRequestedEventArgs> => [0x5871821a,0x2491,0x5cec,0xa4,0x57,0x21,0x99,0x6c,0xa4,0xef,0xaf] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_Input_AccessKeyDisplayRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::input::AccessKeyInvokedEventArgs> => [0xa5c9a137,0xf716,0x5d8d,0x92,0xc4,0x02,0xf1,0x71,0x93,0x6f,0xa1] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_Input_AccessKeyInvokedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::input::ContextRequestedEventArgs> => [0x41d66b93,0xd17b,0x59b2,0xb9,0x16,0x8e,0x81,0x3f,0xec,0xb9,0xbd] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_Input_ContextRequestedEventArgs }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for TypedEventHandler<super::ui::xaml::UIElement, super::ui::xaml::RoutedEventArgs> => [0x657f28aa,0x8c76,0x501f,0xb0,0x32,0xd8,0xdc,0x93,0x59,0x5e,0x76] as IID_TypedEventHandler_2_Windows_UI_Xaml_UIElement_Windows_UI_Xaml_RoutedEventArgs }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for TypedEventHandler<super::web::http::diagnostics::HttpDiagnosticProvider, super::web::http::diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs> => [0x2281ad23,0x9c8d,0x5d82,0x9b,0x20,0xbc,0xf1,0x57,0xb0,0x4f,0xd9] as IID_TypedEventHandler_2_Windows_Web_Http_Diagnostics_HttpDiagnosticProvider_Windows_Web_Http_Diagnostics_HttpDiagnosticProviderRequestResponseCompletedEventArgs }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for TypedEventHandler<super::web::http::diagnostics::HttpDiagnosticProvider, super::web::http::diagnostics::HttpDiagnosticProviderRequestSentEventArgs> => [0xf8e10321,0x47bd,0x526a,0xa9,0xb2,0x3b,0xf1,0x2f,0x72,0x5f,0x8b] as IID_TypedEventHandler_2_Windows_Web_Http_Diagnostics_HttpDiagnosticProvider_Windows_Web_Http_Diagnostics_HttpDiagnosticProviderRequestSentEventArgs }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for TypedEventHandler<super::web::http::diagnostics::HttpDiagnosticProvider, super::web::http::diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs> => [0x2eef1846,0x8176,0x52af,0x8d,0x2b,0xe0,0xc9,0x32,0x51,0x2e,0x9f] as IID_TypedEventHandler_2_Windows_Web_Http_Diagnostics_HttpDiagnosticProvider_Windows_Web_Http_Diagnostics_HttpDiagnosticProviderResponseReceivedEventArgs }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for TypedEventHandler<super::web::http::filters::HttpBaseProtocolFilter, super::web::http::filters::HttpServerCustomValidationRequestedEventArgs> => [0xed0260c6,0x41f2,0x5a04,0x9a,0x8b,0x29,0x30,0xd7,0xff,0x8a,0x9e] as IID_TypedEventHandler_2_Windows_Web_Http_Filters_HttpBaseProtocolFilter_Windows_Web_Http_Filters_HttpServerCustomValidationRequestedEventArgs }
pub mod collections { // Windows.Foundation.Collections
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum CollectionChange: i32 {
			Reset (CollectionChange_Reset) = 0, ItemInserted (CollectionChange_ItemInserted) = 1, ItemRemoved (CollectionChange_ItemRemoved) = 2, ItemChanged (CollectionChange_ItemChanged) = 3,
		}}
		DEFINE_IID!(IID_IVectorChangedEventArgs, 1465463775, 13566, 17536, 175, 21, 7, 105, 31, 61, 93, 155);
		RT_INTERFACE!{interface IVectorChangedEventArgs(IVectorChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVectorChangedEventArgs] {
			fn get_CollectionChange(&mut self, out: *mut CollectionChange) -> ::w::HRESULT,
			fn get_Index(&mut self, out: *mut u32) -> ::w::HRESULT
		}}
		impl IVectorChangedEventArgs {
			#[inline] pub unsafe fn get_collection_change(&mut self) -> RtResult<CollectionChange> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CollectionChange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_index(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Index)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IPropertySet, 2319707551, 62694, 17441, 172, 249, 29, 171, 41, 134, 130, 12);
		RT_INTERFACE!{interface IPropertySet(IPropertySetVtbl): IInspectable(IInspectableVtbl) [IID_IPropertySet] {
			
		}}
		RT_CLASS!{class PropertySet: IPropertySet}
		RT_CLASS!{class ValueSet: IPropertySet}
		RT_CLASS!{class StringMap: IMap<HString, HString>}
		DEFINE_IID!(IID_IIterable, 4205151722, 25108, 16919, 175, 218, 127, 70, 222, 88, 105, 179);
		RT_INTERFACE!{interface IIterable<T>(IIterableVtbl): IInspectable(IInspectableVtbl) [IID_IIterable] {
			fn First(&mut self, out: *mut *mut IIterator<T>) -> ::w::HRESULT
		}}
		impl<T: RtType> IIterable<T> {
			#[inline] pub unsafe fn first(&mut self) -> RtResult<ComPtr<IIterator<T>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).First)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IIterator, 1786374243, 17152, 17818, 153, 102, 203, 182, 96, 150, 62, 225);
		RT_INTERFACE!{interface IIterator<T>(IIteratorVtbl): IInspectable(IInspectableVtbl) [IID_IIterator] {
			fn get_Current(&mut self, out: *mut T::Abi) -> ::w::HRESULT,
			fn get_HasCurrent(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn MoveNext(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn GetMany(&mut self, itemsSize: u32, items: *mut T::Abi, out: *mut u32) -> ::w::HRESULT
		}}
		impl<T: RtType> IIterator<T> {
			#[inline] pub unsafe fn get_current(&mut self) -> RtResult<T::Out> {
				let mut out = T::uninitialized();
				let hr = ((*self.lpVtbl).get_Current)(self, &mut out);
				if hr == ::w::S_OK { Ok(T::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_has_current(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_HasCurrent)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn move_next(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).MoveNext)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_many(&mut self, itemsSize: u32, items: *mut T::Abi) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetMany)(self, itemsSize, items, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IVectorView, 3152149068, 45283, 17795, 186, 239, 31, 27, 46, 72, 62, 86);
		RT_INTERFACE!{interface IVectorView<T>(IVectorViewVtbl): IInspectable(IInspectableVtbl) [IID_IVectorView] {
			fn GetAt(&mut self, index: u32, out: *mut T::Abi) -> ::w::HRESULT,
			fn get_Size(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn IndexOf(&mut self, value: T::Abi, index: *mut u32, out: *mut bool) -> ::w::HRESULT,
			fn GetMany(&mut self, startIndex: u32, itemsSize: u32, items: *mut T::Abi, out: *mut u32) -> ::w::HRESULT
		}}
		impl<T: RtType> IVectorView<T> {
			#[inline] pub unsafe fn get_at(&mut self, index: u32) -> RtResult<T::Out> {
				let mut out = T::uninitialized();
				let hr = ((*self.lpVtbl).GetAt)(self, index, &mut out);
				if hr == ::w::S_OK { Ok(T::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Size)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn index_of(&mut self, value: &T::In) -> RtResult<(u32, bool)> {
				let mut index = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IndexOf)(self, T::unwrap(value), &mut index, &mut out);
				if hr == ::w::S_OK { Ok((index, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_many(&mut self, startIndex: u32, itemsSize: u32, items: *mut T::Abi) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetMany)(self, startIndex, itemsSize, items, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IVector, 2436052969, 4513, 17221, 163, 162, 78, 127, 149, 110, 34, 45);
		RT_INTERFACE!{interface IVector<T>(IVectorVtbl): IInspectable(IInspectableVtbl) [IID_IVector] {
			fn GetAt(&mut self, index: u32, out: *mut T::Abi) -> ::w::HRESULT,
			fn get_Size(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn GetView(&mut self, out: *mut *mut IVectorView<T>) -> ::w::HRESULT,
			fn IndexOf(&mut self, value: T::Abi, index: *mut u32, out: *mut bool) -> ::w::HRESULT,
			fn SetAt(&mut self, index: u32, value: T::Abi) -> ::w::HRESULT,
			fn InsertAt(&mut self, index: u32, value: T::Abi) -> ::w::HRESULT,
			fn RemoveAt(&mut self, index: u32) -> ::w::HRESULT,
			fn Append(&mut self, value: T::Abi) -> ::w::HRESULT,
			fn RemoveAtEnd(&mut self) -> ::w::HRESULT,
			fn Clear(&mut self) -> ::w::HRESULT,
			fn GetMany(&mut self, startIndex: u32, itemsSize: u32, items: *mut T::Abi, out: *mut u32) -> ::w::HRESULT,
			fn ReplaceAll(&mut self, itemsSize: u32, items: *mut T::Abi) -> ::w::HRESULT
		}}
		impl<T: RtType> IVector<T> {
			#[inline] pub unsafe fn get_at(&mut self, index: u32) -> RtResult<T::Out> {
				let mut out = T::uninitialized();
				let hr = ((*self.lpVtbl).GetAt)(self, index, &mut out);
				if hr == ::w::S_OK { Ok(T::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Size)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_view(&mut self) -> RtResult<ComPtr<IVectorView<T>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetView)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn index_of(&mut self, value: &T::In) -> RtResult<(u32, bool)> {
				let mut index = ::std::mem::zeroed(); let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IndexOf)(self, T::unwrap(value), &mut index, &mut out);
				if hr == ::w::S_OK { Ok((index, out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_at(&mut self, index: u32, value: &T::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetAt)(self, index, T::unwrap(value));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn insert_at(&mut self, index: u32, value: &T::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).InsertAt)(self, index, T::unwrap(value));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_at(&mut self, index: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RemoveAt)(self, index);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn append(&mut self, value: &T::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Append)(self, T::unwrap(value));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_at_end(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RemoveAtEnd)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Clear)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_many(&mut self, startIndex: u32, itemsSize: u32, items: *mut T::Abi) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetMany)(self, startIndex, itemsSize, items, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn replace_all(&mut self, items: &[&T::In]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).ReplaceAll)(self, items.len() as u32, items.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IKeyValuePair, 45422889, 49604, 19070, 137, 64, 3, 18, 181, 193, 133, 0);
		RT_INTERFACE!{interface IKeyValuePair<K, V>(IKeyValuePairVtbl): IInspectable(IInspectableVtbl) [IID_IKeyValuePair] {
			fn get_Key(&mut self, out: *mut K::Abi) -> ::w::HRESULT,
			fn get_Value(&mut self, out: *mut V::Abi) -> ::w::HRESULT
		}}
		impl<K: RtType, V: RtType> IKeyValuePair<K, V> {
			#[inline] pub unsafe fn get_key(&mut self) -> RtResult<K::Out> {
				let mut out = K::uninitialized();
				let hr = ((*self.lpVtbl).get_Key)(self, &mut out);
				if hr == ::w::S_OK { Ok(K::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_value(&mut self) -> RtResult<V::Out> {
				let mut out = V::uninitialized();
				let hr = ((*self.lpVtbl).get_Value)(self, &mut out);
				if hr == ::w::S_OK { Ok(V::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMap, 1009329662, 34073, 17857, 170, 121, 25, 123, 103, 24, 193, 193);
		RT_INTERFACE!{interface IMap<K, V>(IMapVtbl): IInspectable(IInspectableVtbl) [IID_IMap] {
			fn Lookup(&mut self, key: K::Abi, out: *mut V::Abi) -> ::w::HRESULT,
			fn get_Size(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn HasKey(&mut self, key: K::Abi, out: *mut bool) -> ::w::HRESULT,
			fn GetView(&mut self, out: *mut *mut IMapView<K, V>) -> ::w::HRESULT,
			fn Insert(&mut self, key: K::Abi, value: V::Abi, out: *mut bool) -> ::w::HRESULT,
			fn Remove(&mut self, key: K::Abi) -> ::w::HRESULT,
			fn Clear(&mut self) -> ::w::HRESULT
		}}
		impl<K: RtType, V: RtType> IMap<K, V> {
			#[inline] pub unsafe fn lookup(&mut self, key: &K::In) -> RtResult<V::Out> {
				let mut out = V::uninitialized();
				let hr = ((*self.lpVtbl).Lookup)(self, K::unwrap(key), &mut out);
				if hr == ::w::S_OK { Ok(V::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Size)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn has_key(&mut self, key: &K::In) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).HasKey)(self, K::unwrap(key), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_view(&mut self) -> RtResult<ComPtr<IMapView<K, V>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).GetView)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn insert(&mut self, key: &K::In, value: &V::In) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).Insert)(self, K::unwrap(key), V::unwrap(value), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove(&mut self, key: &K::In) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Remove)(self, K::unwrap(key));
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn clear(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Clear)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMapView, 3833646656, 41784, 19162, 173, 207, 39, 34, 114, 228, 140, 185);
		RT_INTERFACE!{interface IMapView<K, V>(IMapViewVtbl): IInspectable(IInspectableVtbl) [IID_IMapView] {
			fn Lookup(&mut self, key: K::Abi, out: *mut V::Abi) -> ::w::HRESULT,
			fn get_Size(&mut self, out: *mut u32) -> ::w::HRESULT,
			fn HasKey(&mut self, key: K::Abi, out: *mut bool) -> ::w::HRESULT,
			fn Split(&mut self, first: *mut *mut IMapView<K, V>, second: *mut *mut IMapView<K, V>) -> ::w::HRESULT
		}}
		impl<K: RtType, V: RtType> IMapView<K, V> {
			#[inline] pub unsafe fn lookup(&mut self, key: &K::In) -> RtResult<V::Out> {
				let mut out = V::uninitialized();
				let hr = ((*self.lpVtbl).Lookup)(self, K::unwrap(key), &mut out);
				if hr == ::w::S_OK { Ok(V::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_size(&mut self) -> RtResult<u32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Size)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn has_key(&mut self, key: &K::In) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).HasKey)(self, K::unwrap(key), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn split(&mut self) -> RtResult<(ComPtr<IMapView<K, V>>, ComPtr<IMapView<K, V>>)> {
				let mut first = ::std::ptr::null_mut(); let mut second = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Split)(self, &mut first, &mut second);
				if hr == ::w::S_OK { Ok((ComPtr::wrap(first), ComPtr::wrap(second))) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_VectorChangedEventHandler, 201660242, 40895, 19568, 170, 12, 14, 76, 130, 217, 167, 97);
		RT_DELEGATE!{delegate VectorChangedEventHandler<T>(VectorChangedEventHandlerVtbl, VectorChangedEventHandlerImpl) [IID_VectorChangedEventHandler] {
			fn Invoke(&mut self, sender: *mut IObservableVector<T>, event: *mut IVectorChangedEventArgs) -> ::w::HRESULT
		}}
		impl<T: RtType> VectorChangedEventHandler<T> {
			#[inline] pub unsafe fn invoke(&mut self, sender: &IObservableVector<T>, event: &IVectorChangedEventArgs) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, event as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IObservableVector, 1494739795, 20660, 18957, 179, 9, 101, 134, 43, 63, 29, 188);
		RT_INTERFACE!{interface IObservableVector<T>(IObservableVectorVtbl): IInspectable(IInspectableVtbl) [IID_IObservableVector] {
			fn add_VectorChanged(&mut self, vhnd: *mut VectorChangedEventHandler<T>, out: *mut super::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_VectorChanged(&mut self, token: super::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl<T: RtType> IObservableVector<T> {
			#[inline] pub unsafe fn add_vector_changed(&mut self, vhnd: &VectorChangedEventHandler<T>) -> RtResult<super::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_VectorChanged)(self, vhnd as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_vector_changed(&mut self, token: super::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_VectorChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IMapChangedEventArgs, 2570712287, 1290, 19471, 170, 96, 119, 7, 95, 156, 71, 119);
		RT_INTERFACE!{interface IMapChangedEventArgs<K>(IMapChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMapChangedEventArgs] {
			fn get_CollectionChange(&mut self, out: *mut CollectionChange) -> ::w::HRESULT,
			fn get_Key(&mut self, out: *mut K::Abi) -> ::w::HRESULT
		}}
		impl<K: RtType> IMapChangedEventArgs<K> {
			#[inline] pub unsafe fn get_collection_change(&mut self) -> RtResult<CollectionChange> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_CollectionChange)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_key(&mut self) -> RtResult<K::Out> {
				let mut out = K::uninitialized();
				let hr = ((*self.lpVtbl).get_Key)(self, &mut out);
				if hr == ::w::S_OK { Ok(K::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_MapChangedEventHandler, 395646963, 38126, 16888, 189, 220, 118, 138, 137, 85, 68, 243);
		RT_DELEGATE!{delegate MapChangedEventHandler<K, V>(MapChangedEventHandlerVtbl, MapChangedEventHandlerImpl) [IID_MapChangedEventHandler] {
			fn Invoke(&mut self, sender: *mut IObservableMap<K, V>, event: *mut IMapChangedEventArgs<K>) -> ::w::HRESULT
		}}
		impl<K: RtType, V: RtType> MapChangedEventHandler<K, V> {
			#[inline] pub unsafe fn invoke(&mut self, sender: &IObservableMap<K, V>, event: &IMapChangedEventArgs<K>) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Invoke)(self, sender as *const _ as *mut _, event as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IObservableMap, 1709124597, 48953, 16821, 174, 188, 90, 157, 134, 94, 71, 43);
		RT_INTERFACE!{interface IObservableMap<K, V>(IObservableMapVtbl): IInspectable(IInspectableVtbl) [IID_IObservableMap] {
			fn add_MapChanged(&mut self, vhnd: *mut MapChangedEventHandler<K, V>, out: *mut super::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_MapChanged(&mut self, token: super::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl<K: RtType, V: RtType> IObservableMap<K, V> {
			#[inline] pub unsafe fn add_map_changed(&mut self, vhnd: &MapChangedEventHandler<K, V>) -> RtResult<super::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_MapChanged)(self, vhnd as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_map_changed(&mut self, token: super::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_MapChanged)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_PINTERFACE!{ for IIterable<::Guid> => [0xf4ca3045,0x5dd7,0x54be,0x98,0x2e,0xd8,0x8d,0x8c,0xa0,0x87,0x6e] as IID_IIterable_1_System_Guid }
		RT_PINTERFACE!{ for IIterable<f32> => [0xb01bee51,0x063a,0x5fda,0xbd,0x72,0xd7,0x66,0x37,0xbb,0x8c,0xb8] as IID_IIterable_1_System_Single }
		RT_PINTERFACE!{ for IIterable<f64> => [0xc738964e,0x9c64,0x5bce,0xb5,0xce,0x61,0xe9,0xa2,0x82,0xec,0x4a] as IID_IIterable_1_System_Double }
		RT_PINTERFACE!{ for IIterable<HString> => [0xe2fcc7c1,0x3bfc,0x5a0b,0xb2,0xb0,0x72,0xe7,0x69,0xd1,0xcb,0x7e] as IID_IIterable_1_System_String }
		RT_PINTERFACE!{ for IIterable<i32> => [0x81a643fb,0xf51c,0x5565,0x83,0xc4,0xf9,0x64,0x25,0x77,0x7b,0x66] as IID_IIterable_1_System_Int32 }
		RT_PINTERFACE!{ for IIterable<IInspectable> => [0x092b849b,0x60b1,0x52be,0xa4,0x4a,0x6f,0xe8,0xe9,0x33,0xcb,0xe4] as IID_IIterable_1_System_Object }
		RT_PINTERFACE!{ for IIterable<IIterable<super::Point>> => [0xae44597e,0xd411,0x5b7f,0xbb,0xec,0x6a,0x96,0xc9,0x4a,0x10,0x7a] as IID_IIterable_1_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Point }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<::Guid, IInspectable>> => [0xf3b20528,0xe3b3,0x5331,0xb2,0xd0,0x0c,0x26,0x23,0xae,0xe7,0x85] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<::Guid, super::super::applicationmodel::background::IBackgroundTaskRegistration>> => [0x80fb0327,0x5a00,0x55cc,0x85,0xdb,0xa8,0x52,0x71,0x99,0x81,0xb9] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_Windows_ApplicationModel_Background_IBackgroundTaskRegistration }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<::Guid, super::super::perception::spatial::surfaces::SpatialSurfaceInfo>> => [0x868757d1,0xbe21,0x51d9,0x8d,0xee,0xa9,0x58,0xb9,0xde,0xec,0x71] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_Windows_Perception_Spatial_Surfaces_SpatialSurfaceInfo }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, HString>> => [0xe9bdaaf0,0xcbf6,0x5c72,0xbe,0x90,0x29,0xcb,0xf3,0xa1,0x31,0x9b] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_System_String }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, IInspectable>> => [0xfe2f3d47,0x5d47,0x5499,0x83,0x74,0x43,0x0c,0x7c,0xda,0x02,0x04] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_System_Object }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, IVector<HString>>> => [0x4fed2669,0xd0d3,0x59f6,0x91,0xd9,0x95,0x90,0x2d,0x72,0x8d,0x6a] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVector_1_System_String }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, IVectorView<HString>>> => [0xa4cd6151,0x2cc1,0x56f1,0x90,0x14,0xdf,0x6b,0xa3,0x41,0x0b,0xeb] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_System_String }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, IVectorView<super::super::data::text::TextSegment>>> => [0xf819a276,0xb3f5,0x54d4,0xb8,0xfd,0xc9,0xad,0xb7,0xf7,0x00,0xe3] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::chat::ChatMessageStatus>> => [0x57d87c13,0x48e9,0x546f,0x9b,0x4e,0xa3,0x90,0x6e,0x1e,0x7c,0x24] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Chat_ChatMessageStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::resources::core::ResourceMap>> => [0x9895431e,0xa817,0x5509,0x91,0xe6,0xd9,0x0a,0x93,0x3e,0xd8,0x30] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::store::licensemanagement::LicenseSatisfactionInfo>> => [0xac935021,0xe04b,0x5226,0x81,0x19,0x5b,0x73,0xd0,0xb8,0xbe,0x5b] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::store::ProductLicense>> => [0xffe05002,0x6e65,0x5001,0xa7,0x52,0x9b,0x27,0xed,0x3e,0x28,0x39] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductLicense }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::store::ProductListing>> => [0x3a7d9a2f,0x2a82,0x59f8,0xbd,0x7c,0xd6,0x91,0xca,0x16,0x98,0x63] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductListing }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::voicecommands::VoiceCommandDefinition>> => [0x67693dd1,0xac45,0x5ef3,0x9b,0xa6,0x4d,0x78,0x70,0x9d,0x9e,0xe0] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_VoiceCommands_VoiceCommandDefinition }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletItemCustomProperty>> => [0x3f45154c,0x0c0d,0x5df9,0xa5,0x57,0x25,0x9f,0x20,0xc9,0x27,0xae] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletItemCustomProperty }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletRelevantLocation>> => [0xe55e510c,0x4028,0x5df0,0xb7,0x8b,0x27,0xbd,0x06,0x98,0x0b,0x0b] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletRelevantLocation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletTransaction>> => [0x4fd2ca58,0xb7a2,0x5923,0x93,0x80,0x49,0xc1,0x1c,0x69,0xc3,0x9a] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletTransaction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletVerb>> => [0x6d2ef172,0x8ae3,0x572e,0xae,0x44,0x8e,0xe3,0xfd,0x49,0xd1,0x9f] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletVerb }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::graphics::imaging::BitmapTypedValue>> => [0x05f9430c,0x2f22,0x5638,0xaa,0x89,0x8c,0x9a,0xbc,0xd5,0x4f,0xf9] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Graphics_Imaging_BitmapTypedValue }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::graphics::printing::optiondetails::IPrintOptionDetails>> => [0x6770cf39,0x094f,0x59c5,0x8a,0x5d,0xe3,0xb5,0xdc,0x64,0xdb,0x0f] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Graphics_Printing_OptionDetails_IPrintOptionDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::media::capture::frames::MediaFrameSource>> => [0xa038e80f,0x0b3d,0x5cd4,0x84,0x9d,0x13,0x03,0x6e,0x1f,0x50,0x6e] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Media_Capture_Frames_MediaFrameSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::networking::sockets::SocketActivityInformation>> => [0x3e43fa16,0x7af1,0x51df,0xa0,0xd3,0xda,0x81,0xb3,0x21,0x63,0x9d] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Networking_Sockets_SocketActivityInformation }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::perception::spatial::SpatialAnchor>> => [0x55f0fa8a,0xafd4,0x5541,0xa1,0xc3,0x36,0xf1,0x21,0x47,0xd6,0x06] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::services::store::StoreLicense>> => [0xca8ba445,0x6f4d,0x5da9,0x95,0xee,0x42,0xcf,0x11,0x8d,0xef,0x63] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Services_Store_StoreLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::services::store::StoreProduct>> => [0x78a33722,0xabfb,0x57c0,0x85,0x3f,0x56,0x16,0xa3,0xab,0x8d,0x57] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Services_Store_StoreProduct }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::storage::ApplicationDataContainer>> => [0xa785be1d,0x159e,0x53ad,0x95,0x53,0x59,0x8b,0x03,0xdc,0xa0,0x48] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_ApplicationDataContainer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::storage::streams::IBuffer>> => [0x3c9ffa92,0x5123,0x5ac4,0xb1,0x11,0x03,0xc2,0x15,0xf0,0xc5,0x1c] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<HString, super::super::storage::streams::RandomAccessStreamReference>> => [0xc9729ba7,0x5e20,0x569d,0xa3,0xd1,0x97,0xa4,0xe6,0x53,0xe5,0xbb] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		RT_PINTERFACE!{ for IIterable<IKeyValuePair<IInspectable, IInspectable>> => [0x33ac68f0,0x1084,0x529a,0x8a,0x17,0x4e,0x7c,0x8a,0xdb,0x7a,0x0c] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Object_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<super::super::devices::sensors::PedometerStepKind, super::super::devices::sensors::PedometerReading>> => [0x098f29cb,0xbc91,0x5639,0xa5,0x41,0xd5,0xa4,0x81,0x1e,0xc3,0x5b] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_Windows_Devices_Sensors_PedometerStepKind_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<IKeyValuePair<u32, super::super::storage::streams::IBuffer>> => [0x4fe7fe23,0x22b1,0x528c,0x88,0x1d,0xa4,0xec,0xea,0xef,0x0f,0x11] as IID_IIterable_1_Windows_Foundation_Collections_IKeyValuePair_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IIterable<IMapView<HString, IInspectable>> => [0xe1670fae,0x49cd,0x5c47,0xa8,0xc8,0xf6,0xfa,0x2c,0x65,0x0c,0x6c] as IID_IIterable_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for IIterable<super::DateTime> => [0x576a207d,0x977c,0x5b36,0xb5,0x4d,0x62,0x4e,0xc8,0x6c,0x53,0xa3] as IID_IIterable_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IIterable<super::Point> => [0xc192280d,0x3a09,0x5423,0x9d,0xc5,0x67,0xb8,0x3e,0xbd,0xe4,0x1d] as IID_IIterable_1_Windows_Foundation_Point }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appextensions::AppExtension> => [0x3b4fe356,0x1b13,0x59cb,0xab,0x1f,0xc4,0x66,0x7a,0x74,0x75,0x6b] as IID_IIterable_1_Windows_ApplicationModel_AppExtensions_AppExtension }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::AppInfo> => [0x63d0bffe,0x0e34,0x55b3,0x83,0xd5,0x31,0x4c,0xaf,0xf2,0xb1,0x37] as IID_IIterable_1_Windows_ApplicationModel_AppInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appointments::Appointment> => [0xb9802bba,0xff53,0x5d37,0x8c,0xd7,0xe5,0x61,0x62,0xf1,0x21,0x56] as IID_IIterable_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appointments::AppointmentCalendar> => [0xd3fb010b,0xb692,0x5130,0x9d,0x16,0x2c,0xfd,0xab,0xcb,0x6d,0xec] as IID_IIterable_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appointments::AppointmentException> => [0xcaac41d6,0x6c65,0x5fd8,0xb7,0x83,0xeb,0x9d,0x9a,0x42,0x72,0xb8] as IID_IIterable_1_Windows_ApplicationModel_Appointments_AppointmentException }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appointments::AppointmentInvitee> => [0xfb9718a9,0xf059,0x52b0,0xa9,0x04,0x1a,0x65,0xe4,0x28,0x1e,0x40] as IID_IIterable_1_Windows_ApplicationModel_Appointments_AppointmentInvitee }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::appointments::AppointmentStoreChange> => [0x7b657ca2,0xe02e,0x5026,0xa0,0x32,0x99,0x05,0xe4,0x96,0x82,0xfd] as IID_IIterable_1_Windows_ApplicationModel_Appointments_AppointmentStoreChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::calls::PhoneCallHistoryEntry> => [0xa3f93eea,0xc846,0x52c7,0xaa,0x5a,0x33,0x06,0x70,0x7f,0x63,0x69] as IID_IIterable_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatConversation> => [0xaf43c676,0xa512,0x5388,0x9f,0x69,0x03,0x08,0x95,0x3d,0x71,0x9b] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatMessage> => [0x647bf12c,0xf621,0x5fd8,0xaf,0x39,0xc7,0x2b,0x16,0xba,0xf0,0x7e] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatMessageAttachment> => [0x8a1e36ac,0x13b6,0x577c,0x9b,0x43,0x3d,0x24,0xa4,0x53,0xf8,0x66] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatMessageAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatMessageChange> => [0x0df896df,0x354c,0x5d35,0xb7,0xac,0x6b,0x2e,0x1d,0x70,0xc8,0xeb] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatMessageChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatMessageTransport> => [0xaae32f12,0xed85,0x528c,0x8b,0xad,0x63,0x62,0xd8,0x76,0xef,0x8b] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::ChatRecipientDeliveryInfo> => [0xe3d7b44c,0x4829,0x561b,0xa1,0x5e,0xa7,0x45,0xe5,0xad,0xf6,0xd1] as IID_IIterable_1_Windows_ApplicationModel_Chat_ChatRecipientDeliveryInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::IChatItem> => [0xea8e3309,0x099a,0x592e,0x9e,0x28,0x44,0x1b,0x15,0x1f,0xe0,0x61] as IID_IIterable_1_Windows_ApplicationModel_Chat_IChatItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::RcsEndUserMessageAction> => [0xb6d21a55,0x471e,0x5a25,0xac,0xdd,0x77,0x84,0xf7,0xb4,0xd7,0xba] as IID_IIterable_1_Windows_ApplicationModel_Chat_RcsEndUserMessageAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::chat::RcsTransport> => [0x184c2264,0x65fd,0x5ad4,0xb2,0x2f,0xcb,0x34,0xe8,0xea,0xec,0x63] as IID_IIterable_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::Contact> => [0x63319996,0x7e0f,0x552e,0x87,0x2b,0x7b,0x9a,0xdb,0x1f,0x49,0x97] as IID_IIterable_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactAddress> => [0xe783287c,0xe920,0x5540,0x91,0x82,0xc1,0xa6,0xa5,0xf2,0xad,0x36] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactAddress }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactAnnotation> => [0xea7fc05e,0xfe09,0x5690,0xa7,0x0b,0xa1,0x48,0x67,0x04,0x0f,0xa5] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactAnnotationList> => [0xae095a89,0x8b8b,0x5b8a,0x8f,0x28,0x55,0x5a,0xa4,0x90,0xad,0x87] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactChange> => [0xf761174c,0x1f89,0x5796,0x9d,0x09,0x7f,0xee,0x08,0x13,0x70,0x4d] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactConnectedServiceAccount> => [0x35e203b2,0x5138,0x5967,0x80,0xfa,0xa4,0x77,0xed,0x4c,0x7d,0xdc] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactConnectedServiceAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactDate> => [0x96045d0b,0xb38b,0x5d91,0x83,0x11,0x4f,0xbc,0x7a,0xd4,0x33,0x7d] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactDate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactEmail> => [0x37d0d55f,0xe136,0x5b07,0x8a,0x3a,0x81,0x10,0xbd,0xe3,0x39,0x17] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactEmail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactField> => [0x3b012111,0xc82b,0x541e,0xa0,0xc1,0x37,0x71,0x3e,0xd8,0x35,0x41] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactFieldType> => [0x384b8b1b,0xce8e,0x5781,0xb3,0xdc,0x07,0x76,0xd6,0x84,0xf6,0x58] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactFieldType }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactInformation> => [0x352762af,0x17e3,0x55e0,0x8b,0xe1,0x6a,0x59,0x8a,0x44,0xb5,0xb4] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactInstantMessageField> => [0x810533b2,0x28bb,0x5ed3,0xac,0x19,0xfe,0xc8,0x05,0x9d,0x7b,0x3c] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactInstantMessageField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactJobInfo> => [0x17c1cead,0x56a3,0x5d93,0xab,0xf2,0x14,0xd3,0x4d,0x4b,0x93,0x56] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactJobInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactList> => [0xf9b0782c,0xbfe9,0x564e,0xbc,0xa2,0x97,0x23,0x5f,0xd6,0x44,0x63] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactLocationField> => [0x2a0a41a6,0xda96,0x50a5,0xb8,0xdf,0xe4,0xa8,0xc4,0xfc,0xf8,0x6b] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactLocationField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactMatchReason> => [0x0a8c1bd9,0x2402,0x5c98,0xbe,0x6e,0x63,0xa4,0x80,0x80,0x47,0xba] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactMatchReason }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactPhone> => [0x4abd089c,0x49a1,0x5ba9,0x80,0xdf,0x53,0xb7,0x2d,0xd6,0x91,0xce] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactPhone }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactSignificantOther> => [0xae12bd35,0x93d6,0x53d8,0x87,0xc0,0x49,0xd8,0x4c,0x5c,0x6a,0x83] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactSignificantOther }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::ContactWebsite> => [0x4b03c203,0x989e,0x5b97,0x8f,0xcb,0x67,0xd6,0x61,0xde,0xfe,0x76] as IID_IIterable_1_Windows_ApplicationModel_Contacts_ContactWebsite }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::contacts::IContactField> => [0xe065edc5,0x1d23,0x5be5,0x99,0x98,0x27,0x36,0xcd,0x4d,0x52,0x97] as IID_IIterable_1_Windows_ApplicationModel_Contacts_IContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::core::AppListEntry> => [0x86f4d4ef,0xd8fd,0x5fb5,0x80,0x7c,0x72,0xda,0x8f,0xc9,0xe5,0x44] as IID_IIterable_1_Windows_ApplicationModel_Core_AppListEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::core::CoreApplicationView> => [0x32bc12d1,0x2653,0x5a41,0xa5,0x5e,0x88,0xa1,0x2a,0xf2,0x02,0x6a] as IID_IIterable_1_Windows_ApplicationModel_Core_CoreApplicationView }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailAttachment> => [0xa5ab00e4,0x0ed7,0x52ee,0xaa,0xcb,0x83,0xd8,0x40,0xd6,0xf8,0xfa] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailCertificateValidationStatus> => [0x7e326530,0x7449,0x51a7,0xb1,0xbc,0xc4,0x35,0x33,0xa7,0x8e,0x06] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailCertificateValidationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailConversation> => [0xd495f8dc,0x4327,0x5bca,0xa5,0x06,0x44,0xb1,0x72,0xd6,0xd4,0x35] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailFolder> => [0x6dcb53eb,0x8a35,0x54bf,0x8c,0x8e,0x44,0x9b,0xce,0x9b,0x39,0x20] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailMailbox> => [0x8fc76b2e,0xf800,0x5f1d,0xa0,0x23,0xde,0x47,0xe5,0xf3,0x06,0xe0] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailMailboxAction> => [0x26419311,0x1cd7,0x5bab,0x9c,0x4a,0xe9,0x58,0x84,0xd5,0x53,0x9c] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailMailboxAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailMailboxChange> => [0x4630ccb6,0xdfce,0x57dc,0xa5,0xd1,0x28,0xb8,0x89,0xc2,0xc2,0xb7] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailMailboxChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailMessage> => [0xa5fac823,0x8e6d,0x5bbe,0xad,0x16,0x83,0x50,0xae,0xa4,0x46,0xe0] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailRecipient> => [0x5f18cab2,0x236d,0x5ec5,0xbc,0x64,0xe3,0xe6,0x3d,0x29,0xe7,0x74] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailRecipient }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::email::EmailRecipientResolutionResult> => [0xcae3c1c4,0xc689,0x5787,0x97,0x6f,0x1a,0x15,0x8f,0xfd,0xd1,0x6b] as IID_IIterable_1_Windows_ApplicationModel_Email_EmailRecipientResolutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::lockscreen::LockScreenBadge> => [0x6e82dedc,0xb74e,0x503a,0xb0,0x0b,0x9c,0x6f,0x47,0xf1,0x2a,0x0f] as IID_IIterable_1_Windows_ApplicationModel_LockScreen_LockScreenBadge }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::Package> => [0x69ad6aa7,0x0c49,0x5f27,0xa5,0xeb,0xef,0x4d,0x59,0x46,0x7b,0x6d] as IID_IIterable_1_Windows_ApplicationModel_Package }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::core::NamedResource> => [0xe80d3d9d,0x96c9,0x579e,0x8e,0x42,0xd5,0x50,0x70,0x0d,0xe9,0x25] as IID_IIterable_1_Windows_ApplicationModel_Resources_Core_NamedResource }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::core::ResourceCandidate> => [0xd89c9498,0x8869,0x57f8,0xa8,0x83,0x9c,0x2d,0xfe,0xec,0xb6,0xc6] as IID_IIterable_1_Windows_ApplicationModel_Resources_Core_ResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::core::ResourceMap> => [0x8bbe1154,0x19aa,0x53e7,0x9d,0x6e,0xdc,0x7d,0x35,0x85,0x80,0xf4] as IID_IIterable_1_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::core::ResourceQualifier> => [0x2eee68e2,0x687c,0x5f7a,0xa1,0x4e,0x58,0x8c,0x4d,0x30,0x89,0xe1] as IID_IIterable_1_Windows_ApplicationModel_Resources_Core_ResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::management::IndexedResourceCandidate> => [0x0fcb4184,0x1489,0x5774,0x99,0x10,0xba,0xb3,0x26,0xbb,0x50,0xf6] as IID_IIterable_1_Windows_ApplicationModel_Resources_Management_IndexedResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::resources::management::IndexedResourceQualifier> => [0xe16e0455,0x7341,0x55c0,0xa0,0x24,0x26,0xd9,0xad,0x43,0xc8,0xcc] as IID_IIterable_1_Windows_ApplicationModel_Resources_Management_IndexedResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::search::core::SearchSuggestion> => [0xdf956160,0xf155,0x5816,0xb3,0x8b,0xa2,0xff,0x06,0x29,0xba,0x0e] as IID_IIterable_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::socialinfo::SocialFeedItem> => [0xad33d864,0x9569,0x5e2d,0xbd,0x72,0x18,0x2a,0x8f,0xf5,0x0c,0xf6] as IID_IIterable_1_Windows_ApplicationModel_SocialInfo_SocialFeedItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::socialinfo::SocialItemThumbnail> => [0x5d102c6d,0x92c3,0x59f3,0xb1,0xdc,0x59,0x86,0xc5,0x64,0x45,0xa5] as IID_IIterable_1_Windows_ApplicationModel_SocialInfo_SocialItemThumbnail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::StartupTask> => [0x61885ead,0xbf9e,0x5e9f,0xaf,0x04,0x62,0x96,0xb3,0x36,0x93,0x0b] as IID_IIterable_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::store::preview::installcontrol::AppInstallItem> => [0x93e1cdc8,0x503f,0x55b1,0x91,0x5b,0xc0,0xdc,0x78,0x88,0xce,0x31] as IID_IIterable_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::store::preview::StorePreviewProductInfo> => [0xa9cb4860,0x67d1,0x53c2,0xa6,0x21,0x30,0x74,0xb0,0x34,0x4d,0x49] as IID_IIterable_1_Windows_ApplicationModel_Store_Preview_StorePreviewProductInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::store::preview::StorePreviewSkuInfo> => [0x2c0d85d9,0x0df7,0x5de6,0x96,0x2e,0xbc,0x8f,0x14,0x9f,0xaf,0x19] as IID_IIterable_1_Windows_ApplicationModel_Store_Preview_StorePreviewSkuInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::store::preview::StoreSystemFeature> => [0x98a8577a,0xb128,0x5400,0x8d,0x3d,0x58,0x65,0x4e,0xaa,0xf9,0x57] as IID_IIterable_1_Windows_ApplicationModel_Store_Preview_StoreSystemFeature }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::store::UnfulfilledConsumable> => [0x2f4d1483,0xdd86,0x5fdb,0x8c,0x44,0x06,0xc9,0x88,0x44,0xbf,0x3d] as IID_IIterable_1_Windows_ApplicationModel_Store_UnfulfilledConsumable }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::userdataaccounts::provider::UserDataAccountPartnerAccountInfo> => [0x5cdb425e,0xda5a,0x55fa,0xb3,0x49,0x54,0x67,0x99,0x6c,0xab,0x32] as IID_IIterable_1_Windows_ApplicationModel_UserDataAccounts_Provider_UserDataAccountPartnerAccountInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::userdataaccounts::systemaccess::DeviceAccountConfiguration> => [0xa9c3ea6e,0x9dd9,0x52fe,0x9d,0x27,0xf9,0xe4,0xde,0xdd,0x4d,0x3f] as IID_IIterable_1_Windows_ApplicationModel_UserDataAccounts_SystemAccess_DeviceAccountConfiguration }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::userdataaccounts::UserDataAccount> => [0x1bc7f1ff,0x26b4,0x5440,0x96,0x29,0xcb,0x4c,0xd8,0xc8,0x79,0x87] as IID_IIterable_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::voicecommands::VoiceCommandContentTile> => [0xbd13249b,0x8099,0x5573,0xbf,0x74,0x74,0x57,0x79,0x6e,0x92,0xe5] as IID_IIterable_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandContentTile }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterable<super::super::applicationmodel::wallet::WalletItem> => [0xac174c8c,0x0fdd,0x5cff,0xa2,0x9f,0x4e,0x8c,0xe1,0xc8,0xbc,0x81] as IID_IIterable_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<super::super::data::text::AlternateWordForm> => [0xae838c29,0x60c1,0x5093,0xae,0x61,0x0e,0xd2,0x28,0x57,0xdb,0x05] as IID_IIterable_1_Windows_Data_Text_AlternateWordForm }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<super::super::data::text::SelectableWordSegment> => [0x784b0cec,0x1348,0x5334,0x91,0xe5,0x2e,0x01,0x32,0x94,0xe2,0x11] as IID_IIterable_1_Windows_Data_Text_SelectableWordSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<super::super::data::text::TextPhoneme> => [0x2017f561,0x8162,0x55f8,0xb0,0x56,0x65,0x66,0x36,0x93,0x58,0x15] as IID_IIterable_1_Windows_Data_Text_TextPhoneme }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<super::super::data::text::TextSegment> => [0x5498f4f3,0xcee4,0x5b72,0x97,0x29,0x81,0x5c,0x4a,0xd7,0xb9,0xdc] as IID_IIterable_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterable<super::super::data::text::WordSegment> => [0xd14dc94a,0xa311,0x5ddc,0xbf,0x8b,0xd5,0x87,0x95,0xd8,0x7d,0x6d] as IID_IIterable_1_Windows_Data_Text_WordSegment }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::adc::AdcController> => [0x4e478aad,0x4861,0x5758,0xb6,0x4b,0x5b,0x4f,0x28,0xd8,0xf8,0x6e] as IID_IIterable_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::adc::provider::IAdcControllerProvider> => [0x30047155,0x1f71,0x5223,0x84,0x82,0xe5,0x15,0x9d,0x01,0x37,0xd0] as IID_IIterable_1_Windows_Devices_Adc_Provider_IAdcControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::alljoyn::AllJoynAuthenticationMechanism> => [0xd307c7af,0x4106,0x5d1c,0xb0,0x6c,0x5e,0xb5,0x93,0xd9,0xbe,0x34] as IID_IIterable_1_Windows_Devices_AllJoyn_AllJoynAuthenticationMechanism }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementBytePattern> => [0x1e3fadee,0x54ac,0x538b,0x87,0x77,0x35,0x1a,0xfb,0x78,0xcb,0x74] as IID_IIterable_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementBytePattern }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementDataSection> => [0xdb98b5d1,0x897e,0x59cc,0xb8,0x6a,0x7b,0x88,0x55,0xac,0x98,0xaf] as IID_IIterable_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementDataSection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementReceivedEventArgs> => [0x34f6412f,0x8314,0x5205,0x96,0x7c,0xdb,0x35,0x7c,0x9a,0x42,0xa7] as IID_IIterable_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::advertisement::BluetoothLEManufacturerData> => [0x834a4cac,0xbb8b,0x5f0f,0x9f,0x28,0x4d,0xbc,0x98,0xc1,0x79,0x07] as IID_IIterable_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEManufacturerData }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic> => [0xe3c56728,0x7f2d,0x5a0d,0xad,0x38,0x03,0x0d,0x39,0xc6,0x0f,0x9f] as IID_IIterable_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCharacteristic }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::genericattributeprofile::GattDescriptor> => [0x30e2ffc4,0x3aa3,0x5219,0x9a,0x18,0xca,0x2d,0x0b,0x65,0x62,0xe8] as IID_IIterable_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::genericattributeprofile::GattDeviceService> => [0x4b192e23,0x4893,0x56b2,0x8e,0xff,0x43,0x9c,0x3a,0xb7,0xfd,0x1f] as IID_IIterable_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::genericattributeprofile::GattPresentationFormat> => [0xd75fcef1,0xc10e,0x5b7b,0xb1,0x30,0xf5,0xa0,0x03,0x14,0xd3,0x5d] as IID_IIterable_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattPresentationFormat }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::bluetooth::rfcomm::RfcommDeviceService> => [0x3378e9a6,0xf6e2,0x50ea,0xbf,0xee,0xb8,0x10,0x96,0x31,0xfe,0xca] as IID_IIterable_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::enumeration::DeviceClass> => [0x47d4be05,0x58f1,0x522e,0x81,0xc6,0x97,0x5e,0xb4,0x13,0x1b,0xb9] as IID_IIterable_1_Windows_Devices_Enumeration_DeviceClass }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::enumeration::DeviceInformation> => [0xdd9f8a5d,0xec98,0x5f4b,0xa3,0xea,0x9c,0x8b,0x5a,0xd5,0x3c,0x4b] as IID_IIterable_1_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::enumeration::DeviceWatcherEvent> => [0xb48fd051,0xeafa,0x523f,0xa6,0x6e,0x9d,0x41,0x51,0xc5,0xd5,0x22] as IID_IIterable_1_Windows_Devices_Enumeration_DeviceWatcherEvent }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::enumeration::DeviceWatcherEventKind> => [0xf04365ab,0xd3f3,0x5f85,0xa7,0xda,0xdc,0x19,0xcf,0xf7,0x3d,0x86] as IID_IIterable_1_Windows_Devices_Enumeration_DeviceWatcherEventKind }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::enumeration::pnp::PnpObject> => [0x30b50092,0x36ee,0x53ff,0x94,0x50,0x02,0x90,0x04,0x43,0x6c,0x60] as IID_IIterable_1_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::BasicGeoposition> => [0x922399a8,0x0093,0x5009,0xa8,0xd2,0xf8,0x7b,0x0e,0xae,0x75,0xf5] as IID_IIterable_1_Windows_Devices_Geolocation_BasicGeoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::geofencing::Geofence> => [0xce697733,0x595c,0x51c0,0xad,0x5f,0x32,0x4a,0xf5,0xcd,0xf2,0xdd] as IID_IIterable_1_Windows_Devices_Geolocation_Geofencing_Geofence }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::geofencing::GeofenceStateChangeReport> => [0x76f50b4e,0x7aa7,0x565b,0xaa,0xda,0xb0,0xc1,0xcc,0x14,0x4e,0xd0] as IID_IIterable_1_Windows_Devices_Geolocation_Geofencing_GeofenceStateChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::Geopath> => [0x246fcfbd,0xa881,0x5e8e,0x99,0x08,0xc1,0xb9,0xeb,0xdf,0xec,0x78] as IID_IIterable_1_Windows_Devices_Geolocation_Geopath }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::Geopoint> => [0xe7617fc9,0x2cc7,0x5bd1,0xbc,0x5a,0xf4,0x72,0x60,0x83,0x4e,0xd8] as IID_IIterable_1_Windows_Devices_Geolocation_Geopoint }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::geolocation::Geoposition> => [0x135ed72d,0x75b1,0x5881,0xbe,0x41,0x6f,0xfe,0xaa,0x20,0x20,0x44] as IID_IIterable_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::gpio::GpioController> => [0x415c3794,0xb2b6,0x5f5c,0x9a,0x05,0xae,0x92,0x68,0x51,0x47,0x26] as IID_IIterable_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::gpio::provider::IGpioControllerProvider> => [0x09212bd4,0x851b,0x52bd,0xb8,0x2c,0x42,0x1b,0xf3,0xd6,0xf5,0x11] as IID_IIterable_1_Windows_Devices_Gpio_Provider_IGpioControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::humaninterfacedevice::HidBooleanControl> => [0x1111e585,0x5ab0,0x5d2b,0x8a,0xed,0xb6,0xd6,0x18,0x6d,0x1c,0x3f] as IID_IIterable_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControl }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::humaninterfacedevice::HidBooleanControlDescription> => [0xd0ff0fed,0xa156,0x58bf,0x94,0x11,0x57,0x77,0xdf,0x9d,0x57,0xbf] as IID_IIterable_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::humaninterfacedevice::HidCollection> => [0xbbeada0f,0x708f,0x5b5e,0xa0,0x17,0x5c,0x64,0xff,0xb9,0x6b,0x69] as IID_IIterable_1_Windows_Devices_HumanInterfaceDevice_HidCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::humaninterfacedevice::HidNumericControlDescription> => [0x868f060d,0xe0d4,0x571b,0xb2,0xf7,0x43,0x1d,0x69,0x84,0xa5,0x13] as IID_IIterable_1_Windows_Devices_HumanInterfaceDevice_HidNumericControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::i2c::I2cController> => [0xa5ee8233,0x2429,0x5b26,0x9a,0x02,0x99,0x3e,0x4e,0x7e,0xdf,0xa9] as IID_IIterable_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::i2c::provider::II2cControllerProvider> => [0x11341a6c,0x3a02,0x5f73,0x9d,0xb8,0xc3,0xec,0x58,0x23,0xe3,0x5d] as IID_IIterable_1_Windows_Devices_I2c_Provider_II2cControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::input::PointerDevice> => [0xad26662c,0x845b,0x5c6d,0xae,0xaa,0x40,0x6f,0x48,0xc2,0x1a,0xe9] as IID_IIterable_1_Windows_Devices_Input_PointerDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::input::PointerDeviceUsage> => [0x592d6618,0xeaab,0x5a79,0xa4,0x7a,0xc7,0xfc,0x0b,0x74,0x9a,0x4e] as IID_IIterable_1_Windows_Devices_Input_PointerDeviceUsage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::perception::PerceptionColorFrameSource> => [0xdb18069e,0x7b5a,0x54c3,0xa6,0x27,0xd5,0x6f,0x95,0x17,0xfd,0xf5] as IID_IIterable_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::perception::PerceptionDepthFrameSource> => [0x8a07e1e8,0x5a02,0x585b,0xa2,0x6e,0xad,0x79,0xbe,0xaa,0x94,0xcf] as IID_IIterable_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::perception::PerceptionInfraredFrameSource> => [0x9309d0db,0x338d,0x5adf,0x8b,0x3e,0x50,0x9b,0xfd,0xfc,0xce,0xf3] as IID_IIterable_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::perception::PerceptionVideoProfile> => [0xf6aea351,0xeb9b,0x564d,0xb1,0x0a,0x06,0x67,0x30,0x94,0xac,0xc8] as IID_IIterable_1_Windows_Devices_Perception_PerceptionVideoProfile }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::perception::provider::PerceptionCorrelation> => [0xca6bf87e,0x1745,0x5cd0,0xae,0xe2,0x59,0x73,0x6f,0x5a,0x20,0x6d] as IID_IIterable_1_Windows_Devices_Perception_Provider_PerceptionCorrelation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::pointofservice::PosPrinterRotation> => [0x1b1e4d8d,0x15f5,0x5802,0x9b,0x23,0x8b,0x75,0xce,0x2a,0x58,0xc5] as IID_IIterable_1_Windows_Devices_PointOfService_PosPrinterRotation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::pwm::provider::IPwmControllerProvider> => [0x4936ed59,0xb494,0x5128,0xbc,0x7e,0x03,0xe6,0x30,0x34,0x64,0x75] as IID_IIterable_1_Windows_Devices_Pwm_Provider_IPwmControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::pwm::PwmController> => [0x1403a6ab,0x73cb,0x5805,0x9b,0xbc,0xa0,0xdd,0x39,0xd4,0x76,0xb0] as IID_IIterable_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::radios::Radio> => [0xe82500af,0x1f53,0x504e,0xb8,0xbe,0xda,0xc4,0xfb,0xb6,0x90,0x84] as IID_IIterable_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sensors::ActivitySensorReading> => [0x9a34ce03,0x8c6d,0x5994,0x90,0x7f,0xd5,0xc2,0xd1,0x91,0x48,0xcb] as IID_IIterable_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sensors::ActivitySensorReadingChangeReport> => [0x551a4962,0x9e96,0x5e6b,0x8b,0x8a,0x65,0xee,0x3d,0x00,0x46,0xf3] as IID_IIterable_1_Windows_Devices_Sensors_ActivitySensorReadingChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sensors::ActivityType> => [0x2a04cdfa,0x5dfd,0x5178,0x87,0x31,0xad,0xe9,0x98,0xe4,0xa7,0xf6] as IID_IIterable_1_Windows_Devices_Sensors_ActivityType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sensors::PedometerReading> => [0xbbb61a5c,0x98c3,0x5718,0x88,0xfe,0x53,0x92,0xa7,0x45,0x1e,0x2d] as IID_IIterable_1_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sensors::ProximitySensorReading> => [0x301ebccf,0x11ab,0x5e90,0x98,0xee,0xbd,0x99,0xc0,0xe3,0xbb,0x76] as IID_IIterable_1_Windows_Devices_Sensors_ProximitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::smartcards::SmartCard> => [0xa32c5202,0xd113,0x535f,0x88,0x0e,0x50,0xf3,0xe5,0x12,0x1e,0xf8] as IID_IIterable_1_Windows_Devices_SmartCards_SmartCard }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sms::ISmsBinaryMessage> => [0x5678a6a5,0x4d5a,0x51c2,0xa1,0x33,0x4b,0x83,0xbf,0x25,0xd9,0x87] as IID_IIterable_1_Windows_Devices_Sms_ISmsBinaryMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sms::ISmsMessage> => [0xecabfd70,0x9601,0x5e38,0x83,0xcf,0xb1,0x04,0x60,0x22,0xa2,0x44] as IID_IIterable_1_Windows_Devices_Sms_ISmsMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sms::SmsBroadcastType> => [0x12276b75,0x173e,0x514b,0x98,0xf0,0x8a,0x79,0x27,0xa9,0x20,0x6c] as IID_IIterable_1_Windows_Devices_Sms_SmsBroadcastType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sms::SmsFilterRule> => [0x03ed8267,0x9c90,0x5260,0x8b,0xc0,0x6c,0x3e,0x33,0x06,0xc9,0x64] as IID_IIterable_1_Windows_Devices_Sms_SmsFilterRule }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::sms::SmsMessageRegistration> => [0xf836fa0a,0x770d,0x5e8f,0x86,0x64,0x01,0xc4,0x3f,0x95,0x9e,0xea] as IID_IIterable_1_Windows_Devices_Sms_SmsMessageRegistration }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::spi::provider::ISpiControllerProvider> => [0x71ba027d,0x8c84,0x58b1,0x8d,0x66,0x91,0x77,0xc1,0x16,0x98,0xeb] as IID_IIterable_1_Windows_Devices_Spi_Provider_ISpiControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::spi::SpiController> => [0x7b076938,0xdc1b,0x5368,0x90,0x03,0x05,0x92,0x91,0xd3,0x7f,0x35] as IID_IIterable_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbBulkInEndpointDescriptor> => [0x101b1fd9,0xf1c9,0x5dda,0x9a,0xd4,0x71,0x17,0x6f,0xa8,0x39,0xb2] as IID_IIterable_1_Windows_Devices_Usb_UsbBulkInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbBulkInPipe> => [0x2201a671,0x42d2,0x508d,0xa8,0x48,0x64,0xb5,0x44,0x70,0x83,0xc8] as IID_IIterable_1_Windows_Devices_Usb_UsbBulkInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbBulkOutEndpointDescriptor> => [0xb80beb39,0x62b3,0x5f59,0xb3,0xe7,0x88,0x2c,0xc9,0xc5,0xb0,0xc0] as IID_IIterable_1_Windows_Devices_Usb_UsbBulkOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbBulkOutPipe> => [0x9824caba,0x5ca6,0x5c2d,0x80,0xcf,0x19,0x49,0x02,0x6d,0x78,0x57] as IID_IIterable_1_Windows_Devices_Usb_UsbBulkOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbDescriptor> => [0x989909a5,0x5a03,0x51fb,0xbd,0x94,0x84,0xda,0x7b,0xda,0x88,0x19] as IID_IIterable_1_Windows_Devices_Usb_UsbDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterface> => [0xf54037ed,0x92e9,0x590d,0xb9,0x04,0x3a,0xd7,0xbf,0xa9,0xa6,0x21] as IID_IIterable_1_Windows_Devices_Usb_UsbInterface }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterfaceSetting> => [0x1aaf5739,0x9c2c,0x533e,0xa0,0xe9,0xd5,0x3f,0xdb,0x45,0xd1,0x5d] as IID_IIterable_1_Windows_Devices_Usb_UsbInterfaceSetting }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterruptInEndpointDescriptor> => [0x8a7bac69,0x1f10,0x59c7,0x98,0x37,0x72,0xcf,0xed,0x71,0x54,0xa4] as IID_IIterable_1_Windows_Devices_Usb_UsbInterruptInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterruptInPipe> => [0x39aef336,0x18aa,0x5be4,0x86,0xd9,0xe3,0x32,0xfe,0x26,0x32,0xf3] as IID_IIterable_1_Windows_Devices_Usb_UsbInterruptInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterruptOutEndpointDescriptor> => [0x09393d62,0x2316,0x536b,0x8a,0x10,0x70,0x38,0x88,0x4a,0xb2,0xa7] as IID_IIterable_1_Windows_Devices_Usb_UsbInterruptOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::usb::UsbInterruptOutPipe> => [0xe61a011e,0x4abe,0x53f2,0x83,0xb3,0xed,0x4a,0x94,0x9d,0x2e,0x3f] as IID_IIterable_1_Windows_Devices_Usb_UsbInterruptOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::wifi::WiFiAdapter> => [0xe0bc76c4,0x8d0c,0x53fc,0xbc,0xd4,0x22,0x8f,0x47,0x21,0x0a,0xce] as IID_IIterable_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::wifi::WiFiAvailableNetwork> => [0xf17484ea,0xc71e,0x5d3e,0xb7,0x4c,0x3a,0x0e,0x61,0xdd,0x9c,0x20] as IID_IIterable_1_Windows_Devices_WiFi_WiFiAvailableNetwork }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::wifidirect::services::WiFiDirectServiceConfigurationMethod> => [0xd9773b1a,0xa148,0x58bf,0x9c,0x4b,0xaf,0xea,0xc9,0xbe,0x3a,0xb4] as IID_IIterable_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::wifidirect::WiFiDirectConfigurationMethod> => [0x794f12da,0x2dc6,0x5277,0x82,0xdc,0xb0,0x78,0x16,0x10,0x53,0x7b] as IID_IIterable_1_Windows_Devices_WiFiDirect_WiFiDirectConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterable<super::super::devices::wifidirect::WiFiDirectInformationElement> => [0x19c1ca4e,0x9561,0x5253,0x96,0xd9,0xdb,0xaf,0x28,0xd4,0x7d,0x89] as IID_IIterable_1_Windows_Devices_WiFiDirect_WiFiDirectInformationElement }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::input::ArcadeStick> => [0x9376f457,0x2da5,0x544a,0xa4,0x09,0xc6,0x36,0xf5,0xd8,0x1c,0x35] as IID_IIterable_1_Windows_Gaming_Input_ArcadeStick }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::input::Gamepad> => [0x47132ba0,0x6b17,0x5cd2,0xa8,0xbd,0xb5,0xd3,0x44,0x3c,0xcb,0x13] as IID_IIterable_1_Windows_Gaming_Input_Gamepad }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::input::RacingWheel> => [0x9a7c3830,0x9a87,0x5287,0xa1,0xe2,0x8a,0x2a,0xf2,0x9c,0xf6,0x8c] as IID_IIterable_1_Windows_Gaming_Input_RacingWheel }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::input::UINavigationController> => [0x8dea85a0,0x0204,0x57dd,0xab,0xad,0x90,0xe3,0x7c,0x0e,0xf2,0x40] as IID_IIterable_1_Windows_Gaming_Input_UINavigationController }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::preview::gamesenumeration::GameListEntry> => [0x42b8c8a0,0x3d03,0x5d5f,0x81,0x7e,0x44,0x05,0xc8,0x50,0xf6,0x46] as IID_IIterable_1_Windows_Gaming_Preview_GamesEnumeration_GameListEntry }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::xboxlive::storage::GameSaveBlobInfo> => [0xa7c456d7,0xfa9f,0x536f,0x8e,0xd2,0x45,0x95,0x45,0x81,0x1e,0xd4] as IID_IIterable_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobInfo }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterable<super::super::gaming::xboxlive::storage::GameSaveContainerInfo> => [0x55e4d98f,0x0889,0x5c06,0xa8,0x57,0x7d,0xd1,0x68,0xc2,0xd8,0x52] as IID_IIterable_1_Windows_Gaming_XboxLive_Storage_GameSaveContainerInfo }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IIterable<super::super::globalization::JapanesePhoneme> => [0x1aad17cb,0x1829,0x5236,0x8a,0xef,0x0b,0x75,0xf8,0xdf,0xd7,0xa6] as IID_IIterable_1_Windows_Globalization_JapanesePhoneme }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IIterable<super::super::globalization::Language> => [0x48409a10,0x61b6,0x5db1,0xa6,0x9d,0x8a,0xbc,0x46,0xac,0x60,0x8a] as IID_IIterable_1_Windows_Globalization_Language }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::directx::direct3d11::IDirect3DSurface> => [0xcc63bf9c,0xe16a,0x5a75,0xa5,0xaa,0x2b,0x53,0xf9,0x75,0xb0,0xb0] as IID_IIterable_1_Windows_Graphics_DirectX_Direct3D11_IDirect3DSurface }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::directx::DirectXPixelFormat> => [0x3908f2c6,0x1aee,0x5129,0xb9,0xa6,0x2a,0x6e,0x01,0xd9,0x50,0x7e] as IID_IIterable_1_Windows_Graphics_DirectX_DirectXPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::holographic::HolographicCamera> => [0xb2afd154,0x8db0,0x5bb2,0xad,0x7a,0x68,0x4a,0xfd,0x47,0x92,0x64] as IID_IIterable_1_Windows_Graphics_Holographic_HolographicCamera }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::holographic::HolographicCameraPose> => [0x92111aff,0x8dcc,0x538e,0xae,0x3d,0x31,0xfd,0x25,0x2a,0x0a,0xd5] as IID_IIterable_1_Windows_Graphics_Holographic_HolographicCameraPose }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::imaging::BitmapCodecInformation> => [0x2b6bdb90,0xa4eb,0x5142,0xb5,0x82,0x3c,0xcb,0x1e,0xdc,0x57,0x89] as IID_IIterable_1_Windows_Graphics_Imaging_BitmapCodecInformation }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::imaging::BitmapPixelFormat> => [0xe924d9ed,0xa13e,0x5bdb,0x9e,0xd8,0x65,0xa1,0x47,0x4d,0xc2,0x74] as IID_IIterable_1_Windows_Graphics_Imaging_BitmapPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::imaging::ImageStream> => [0x034ea0c4,0xc20e,0x5c0c,0xba,0x31,0x64,0x21,0x2f,0x28,0xe6,0x50] as IID_IIterable_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DBaseMaterial> => [0x9a6bd130,0x6f22,0x559c,0xb9,0x2c,0x14,0xf9,0xf8,0xdd,0xda,0x47] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DBaseMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DBaseMaterialGroup> => [0xc08f8e70,0xf6ef,0x5469,0x80,0x6a,0x7c,0xb6,0x01,0xdd,0xdb,0x67] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DBaseMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DColorMaterial> => [0xc77d4f28,0x7882,0x52b4,0xb3,0xc9,0x7d,0x58,0xc8,0x83,0x65,0x73] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DColorMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DColorMaterialGroup> => [0x1bf32a86,0x26ab,0x5750,0xb5,0x4c,0x3b,0xda,0x67,0x86,0x7f,0x8a] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DColorMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DComponent> => [0x516556ca,0xf862,0x59f8,0x82,0x41,0xe0,0xf0,0xc1,0x77,0xda,0xdd] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DComponent }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DComponentWithMatrix> => [0x8a213648,0x0b81,0x5e23,0xa4,0x8e,0xaf,0xe9,0xf6,0x69,0x1c,0xc1] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DComponentWithMatrix }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DCompositeMaterial> => [0xa0af2623,0x1b11,0x53cf,0x97,0x5d,0x64,0x95,0x93,0x86,0xcd,0xd3] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DCompositeMaterialGroup> => [0xf2ffef61,0xc254,0x58c0,0x82,0x06,0xb3,0xb3,0x09,0x6b,0xe9,0xcb] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DMesh> => [0xa8018fda,0xde4d,0x56fa,0x86,0x09,0xfd,0x22,0x98,0xbf,0xb5,0x58] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DMesh }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DModelTexture> => [0x94790870,0x6041,0x5d04,0x86,0x99,0x17,0x41,0x71,0x17,0xbb,0x85] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DModelTexture }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterial> => [0x0dfc274e,0xae4d,0x5bbb,0x93,0xa8,0x7d,0xc9,0xf8,0x4d,0xda,0xc3] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterialGroup> => [0x23f7518e,0x2439,0x5573,0xa6,0x83,0xef,0xca,0x0c,0x61,0xa8,0xd6] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DTexture2CoordMaterial> => [0x28373276,0x483c,0x5bd0,0x99,0xc7,0x01,0xbf,0xa0,0x4a,0x57,0xd4] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DTexture2CoordMaterialGroup> => [0x00017a1d,0x96bc,0x5c0e,0xb7,0x86,0x59,0x4f,0xb4,0xd0,0x77,0xb6] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterable<super::super::graphics::printing3d::Printing3DTextureResource> => [0x54e3a71d,0xeae0,0x5199,0x97,0x28,0xfa,0xc9,0x64,0x85,0x0e,0xbb] as IID_IIterable_1_Windows_Graphics_Printing3D_Printing3DTextureResource }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IIterable<super::super::management::deployment::PackageUserInformation> => [0x341348b9,0x52c8,0x5b57,0x9e,0x91,0xf1,0x9f,0x2a,0x05,0xb1,0x88] as IID_IIterable_1_Windows_Management_Deployment_PackageUserInformation }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IIterable<super::super::management::deployment::PackageVolume> => [0xa6199162,0xb163,0x56a1,0x99,0x80,0xdb,0x0c,0x3f,0x4e,0x92,0x84] as IID_IIterable_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::audio::AudioGraphConnection> => [0x96168d06,0xa51a,0x5480,0x94,0x03,0xfb,0xd7,0x63,0x1e,0x3b,0x3c] as IID_IIterable_1_Windows_Media_Audio_AudioGraphConnection }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::audio::EqualizerBand> => [0x6f76d148,0x023e,0x565a,0x9f,0x09,0x4a,0xd4,0xa3,0x2a,0xd7,0x4f] as IID_IIterable_1_Windows_Media_Audio_EqualizerBand }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::capture::frames::MediaFrameFormat> => [0x1f029a27,0x1123,0x538a,0x92,0x61,0x8a,0x38,0x0e,0x12,0xba,0xc6] as IID_IIterable_1_Windows_Media_Capture_Frames_MediaFrameFormat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::capture::frames::MediaFrameSourceGroup> => [0xd0b71deb,0x76e8,0x5833,0x96,0x23,0x2b,0x1e,0x1a,0x8e,0x1b,0x72] as IID_IIterable_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::capture::frames::MediaFrameSourceInfo> => [0x2e29c5b0,0x6aa9,0x50f2,0x91,0xa4,0x5b,0x67,0xa5,0x59,0x8f,0x2e] as IID_IIterable_1_Windows_Media_Capture_Frames_MediaFrameSourceInfo }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::capture::MediaCaptureVideoProfile> => [0xdbd49d71,0xe07b,0x5e11,0x82,0x4a,0x62,0xac,0xe8,0xbd,0xfc,0x3e] as IID_IIterable_1_Windows_Media_Capture_MediaCaptureVideoProfile }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::capture::MediaCaptureVideoProfileMediaDescription> => [0x0895e56d,0xfe1f,0x5364,0xab,0x67,0xc5,0x97,0xd8,0x97,0x0b,0x89] as IID_IIterable_1_Windows_Media_Capture_MediaCaptureVideoProfileMediaDescription }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::casting::CastingSource> => [0x1abb2cc9,0x46a2,0x58b1,0x91,0xaa,0x28,0x69,0x9d,0x66,0xd1,0xab] as IID_IIterable_1_Windows_Media_Casting_CastingSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::AudioStreamDescriptor> => [0xa3e2c972,0xa171,0x5b94,0x83,0x89,0xe9,0x83,0xeb,0xc3,0xf3,0xb9] as IID_IIterable_1_Windows_Media_Core_AudioStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::AudioTrack> => [0xb3be50a8,0x9856,0x5656,0xab,0x6d,0xcd,0x58,0xf9,0xde,0x0a,0x4f] as IID_IIterable_1_Windows_Media_Core_AudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::IMediaCue> => [0x737a2098,0x41bf,0x5d9f,0xa1,0xd2,0x2f,0x17,0x1c,0x57,0x8b,0x3c] as IID_IIterable_1_Windows_Media_Core_IMediaCue }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::MseSourceBuffer> => [0x5ca0da86,0x6307,0x558a,0x86,0x5f,0x3a,0x1e,0xf9,0xfe,0x56,0xb3] as IID_IIterable_1_Windows_Media_Core_MseSourceBuffer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::MseTimeRange> => [0xed0c6e08,0xe22f,0x5ac2,0xba,0x14,0xe0,0xff,0x1d,0xf3,0x46,0x7f] as IID_IIterable_1_Windows_Media_Core_MseTimeRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::TimedMetadataTrack> => [0x150a4454,0x03bb,0x5dd1,0x81,0x53,0x6a,0x60,0x0e,0x85,0x1f,0x71] as IID_IIterable_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::TimedTextLine> => [0xaec710ad,0x3bd8,0x5a59,0xae,0x77,0xe7,0xfc,0x46,0xfb,0x10,0x5b] as IID_IIterable_1_Windows_Media_Core_TimedTextLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::TimedTextSource> => [0x4fc57282,0x0edf,0x5d85,0x9d,0x89,0xdd,0xc2,0xa5,0x69,0x2c,0x13] as IID_IIterable_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::TimedTextSubformat> => [0xcee3ae43,0xc93c,0x56f7,0x8c,0x55,0x90,0x24,0xde,0xd7,0x2c,0x76] as IID_IIterable_1_Windows_Media_Core_TimedTextSubformat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::VideoStreamDescriptor> => [0x3acbf03c,0x0a79,0x5823,0xaa,0xa9,0xd8,0x8b,0xc3,0xf8,0xf5,0x94] as IID_IIterable_1_Windows_Media_Core_VideoStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::core::VideoTrack> => [0x84413442,0xa2e3,0x5e0f,0x93,0x6d,0xbc,0x40,0xb0,0xfb,0x2d,0xcd] as IID_IIterable_1_Windows_Media_Core_VideoTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::AdvancedPhotoMode> => [0x7d090784,0x70a9,0x570c,0xbe,0x82,0x0d,0x08,0x90,0x31,0x89,0x75] as IID_IIterable_1_Windows_Media_Devices_AdvancedPhotoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::AutoFocusRange> => [0x751664c6,0xf8d6,0x50a3,0xab,0x80,0x13,0x7c,0x6d,0x90,0x8c,0x55] as IID_IIterable_1_Windows_Media_Devices_AutoFocusRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::CaptureSceneMode> => [0x16d26b98,0x2cbc,0x52f0,0xab,0x64,0x17,0x23,0x71,0x44,0x18,0xe9] as IID_IIterable_1_Windows_Media_Devices_CaptureSceneMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::core::FrameController> => [0xbd8eeadc,0x2dd9,0x5ad8,0xac,0x5d,0xf3,0xb1,0x3b,0x94,0xb9,0xc2] as IID_IIterable_1_Windows_Media_Devices_Core_FrameController }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::FocusMode> => [0x561bc21f,0x4ae2,0x580a,0xa2,0x16,0x0a,0xd4,0x8f,0x37,0x3a,0x4c] as IID_IIterable_1_Windows_Media_Devices_FocusMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::FocusPreset> => [0x26ba711b,0x3a32,0x5216,0xbc,0x34,0x61,0xec,0xaf,0xbe,0xbd,0xc1] as IID_IIterable_1_Windows_Media_Devices_FocusPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::HdrVideoMode> => [0x1d9679a7,0x2d06,0x5294,0xac,0x67,0xf9,0xcd,0x35,0x61,0xdc,0xb8] as IID_IIterable_1_Windows_Media_Devices_HdrVideoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::IsoSpeedPreset> => [0x94839abe,0x9712,0x545a,0xa9,0x4d,0xa5,0x67,0xa3,0xe8,0xdf,0xb7] as IID_IIterable_1_Windows_Media_Devices_IsoSpeedPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::ManualFocusDistance> => [0xcf8cbeb1,0x2a4c,0x522d,0x96,0x2f,0x84,0xc3,0x1a,0x59,0x8d,0x68] as IID_IIterable_1_Windows_Media_Devices_ManualFocusDistance }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::OpticalImageStabilizationMode> => [0x323d7734,0x94c2,0x544d,0xa5,0x60,0x56,0x56,0x0f,0xe6,0x88,0x19] as IID_IIterable_1_Windows_Media_Devices_OpticalImageStabilizationMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::RegionOfInterest> => [0xd73144c7,0x9d75,0x5dfb,0x80,0x40,0x62,0x62,0x02,0xdc,0xf4,0x54] as IID_IIterable_1_Windows_Media_Devices_RegionOfInterest }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::devices::ZoomTransitionMode> => [0xdb656915,0x8fac,0x5fb2,0x98,0xe0,0x0e,0x97,0x42,0x16,0x56,0xc5] as IID_IIterable_1_Windows_Media_Devices_ZoomTransitionMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::editing::BackgroundAudioTrack> => [0x3fc05ba2,0x30f6,0x5219,0x90,0x47,0x11,0x97,0xff,0xae,0x8d,0xba] as IID_IIterable_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::editing::EmbeddedAudioTrack> => [0x32fabed0,0xe1e6,0x578e,0x86,0xe5,0xb4,0xe6,0xab,0xeb,0x22,0xd6] as IID_IIterable_1_Windows_Media_Editing_EmbeddedAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::editing::MediaClip> => [0xff2e9b5c,0x26d0,0x575d,0xa3,0xeb,0x7d,0x93,0x8b,0xd1,0x6f,0x17] as IID_IIterable_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::editing::MediaOverlay> => [0xefcda247,0xa1fb,0x51dc,0xa7,0x76,0xe3,0xe0,0x66,0x95,0xfb,0x36] as IID_IIterable_1_Windows_Media_Editing_MediaOverlay }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::editing::MediaOverlayLayer> => [0x7d2312d0,0xf3a2,0x5091,0x8a,0x5e,0x41,0x83,0x2e,0x63,0x2c,0x08] as IID_IIterable_1_Windows_Media_Editing_MediaOverlayLayer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::effects::AudioEffect> => [0x07af9afd,0x25b8,0x579d,0xbe,0x7e,0x8a,0xcc,0x03,0x41,0x8d,0x0b] as IID_IIterable_1_Windows_Media_Effects_AudioEffect }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::effects::IAudioEffectDefinition> => [0x607a20bf,0x32b4,0x5b8e,0xa7,0x93,0x30,0x24,0xf8,0xd3,0x58,0x2a] as IID_IIterable_1_Windows_Media_Effects_IAudioEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::effects::IVideoEffectDefinition> => [0xeb567f6f,0xb014,0x513d,0x99,0xcd,0xf1,0x6c,0x22,0x6c,0x3c,0x41] as IID_IIterable_1_Windows_Media_Effects_IVideoEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::faceanalysis::DetectedFace> => [0x25347323,0x3556,0x5cbb,0x98,0x55,0x2b,0x58,0x56,0x43,0x7f,0x4d] as IID_IIterable_1_Windows_Media_FaceAnalysis_DetectedFace }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::IMediaMarker> => [0xa1c0a397,0x0364,0x5e4c,0x9d,0xca,0x7c,0xd7,0x01,0x1b,0xd1,0x14] as IID_IIterable_1_Windows_Media_IMediaMarker }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportItem> => [0x82347483,0x3b75,0x5e95,0xbb,0xa4,0xab,0xc0,0xb8,0xa3,0x20,0xaa] as IID_IIterable_1_Windows_Media_Import_PhotoImportItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportOperation> => [0x94f33a8f,0x115a,0x50cb,0xb5,0x9d,0xab,0x84,0x83,0xa8,0x48,0x42] as IID_IIterable_1_Windows_Media_Import_PhotoImportOperation }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportSidecar> => [0x2b7f92ad,0xe596,0x5669,0xb6,0x22,0xfb,0xfb,0xc7,0x04,0x0e,0x89] as IID_IIterable_1_Windows_Media_Import_PhotoImportSidecar }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportSource> => [0x40e01d62,0xb413,0x5b43,0xab,0x07,0xab,0x28,0xb2,0x3f,0xc8,0x86] as IID_IIterable_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportStorageMedium> => [0x3233cbfe,0xf9ee,0x560f,0xbd,0x0f,0xe3,0x6a,0xbe,0x6c,0xda,0x7f] as IID_IIterable_1_Windows_Media_Import_PhotoImportStorageMedium }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::import::PhotoImportVideoSegment> => [0x94dd3b44,0xda03,0x5d79,0xbb,0xfb,0x1b,0xea,0xf2,0xed,0xe4,0x82] as IID_IIterable_1_Windows_Media_Import_PhotoImportVideoSegment }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::mediaproperties::AudioEncodingProperties> => [0x00939468,0x25d8,0x533f,0x85,0x4e,0x4f,0x20,0xf3,0x6c,0x51,0xdc] as IID_IIterable_1_Windows_Media_MediaProperties_AudioEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::mediaproperties::IMediaEncodingProperties> => [0xd7fc75d5,0x3492,0x5bbb,0x9b,0x34,0xda,0xc3,0xe2,0x4e,0x79,0xd0] as IID_IIterable_1_Windows_Media_MediaProperties_IMediaEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::mediaproperties::VideoEncodingProperties> => [0x73c7317c,0x8682,0x5f81,0x84,0xa2,0x30,0xc4,0x25,0xfa,0x2d,0x24] as IID_IIterable_1_Windows_Media_MediaProperties_VideoEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::ocr::OcrLine> => [0x6afa94a2,0x60d7,0x5dbe,0x94,0x2d,0x81,0xaa,0x39,0x29,0xc8,0x5e] as IID_IIterable_1_Windows_Media_Ocr_OcrLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::ocr::OcrWord> => [0xa0ce663a,0x46d0,0x55e5,0x92,0x8e,0x25,0x1e,0xb6,0x7a,0x1e,0x99] as IID_IIterable_1_Windows_Media_Ocr_OcrWord }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::playback::MediaBreak> => [0x04f000ec,0xc727,0x5dc0,0x9f,0x7c,0x24,0x5c,0x75,0xc9,0x2f,0x2f] as IID_IIterable_1_Windows_Media_Playback_MediaBreak }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::playback::MediaPlaybackItem> => [0x8b8ab4a4,0x0253,0x56e9,0xa2,0x32,0x94,0xe3,0x35,0xae,0xfa,0x8f] as IID_IIterable_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::protection::playready::IPlayReadyDomain> => [0x84e98f86,0x4bee,0x5f41,0x93,0xa1,0x25,0x58,0x87,0x12,0x2d,0x9f] as IID_IIterable_1_Windows_Media_Protection_PlayReady_IPlayReadyDomain }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::protection::playready::IPlayReadyLicense> => [0x9f28f6b7,0xb5ea,0x5073,0xba,0x3d,0x8c,0xb2,0xf0,0x72,0x91,0xa1] as IID_IIterable_1_Windows_Media_Protection_PlayReady_IPlayReadyLicense }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::protection::playready::IPlayReadySecureStopServiceRequest> => [0x8d8ac279,0xb07d,0x5308,0x9c,0x78,0x1c,0x5c,0x99,0x6c,0xa0,0x3c] as IID_IIterable_1_Windows_Media_Protection_PlayReady_IPlayReadySecureStopServiceRequest }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::protection::RevocationAndRenewalItem> => [0x07015868,0x578c,0x556b,0x8a,0x35,0x40,0x39,0xa3,0x5d,0x1d,0x92] as IID_IIterable_1_Windows_Media_Protection_RevocationAndRenewalItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::speechrecognition::ISpeechRecognitionConstraint> => [0x88e6436c,0x3253,0x520b,0x9e,0xd8,0xa6,0x3b,0x17,0x8c,0x44,0xa2] as IID_IIterable_1_Windows_Media_SpeechRecognition_ISpeechRecognitionConstraint }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::speechrecognition::SpeechRecognitionResult> => [0x0d9b7b48,0x98a1,0x5b22,0x9a,0x66,0x6f,0x81,0x2f,0x59,0x47,0xaa] as IID_IIterable_1_Windows_Media_SpeechRecognition_SpeechRecognitionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterable<super::super::media::speechsynthesis::VoiceInformation> => [0x3c33bb52,0xbd98,0x5c8c,0xad,0xee,0xee,0x8d,0xa0,0x62,0x8e,0xfc] as IID_IIterable_1_Windows_Media_SpeechSynthesis_VoiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::backgroundtransfer::BackgroundTransferContentPart> => [0xcf303199,0xde3b,0x5dac,0xa7,0x03,0x6c,0x57,0xd8,0x08,0x21,0xc4] as IID_IIterable_1_Windows_Networking_BackgroundTransfer_BackgroundTransferContentPart }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::backgroundtransfer::DownloadOperation> => [0xf6fd69cb,0xe6e7,0x56d5,0x9b,0xe6,0xe0,0xdc,0x46,0x83,0xfa,0x80] as IID_IIterable_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::backgroundtransfer::UploadOperation> => [0x79778799,0x38cc,0x5b67,0x9c,0xd0,0x04,0x3f,0xc4,0x7a,0x9e,0xf7] as IID_IIterable_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::connectivity::AttributedNetworkUsage> => [0xd061dcb9,0x6854,0x5ef9,0x8e,0x03,0x00,0x8a,0x7a,0x70,0x4c,0x48] as IID_IIterable_1_Windows_Networking_Connectivity_AttributedNetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::connectivity::ConnectionProfile> => [0x34dabef9,0x87d0,0x5b1c,0xa7,0xac,0x9d,0x29,0x0a,0xde,0xb0,0xc8] as IID_IIterable_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::connectivity::ConnectivityInterval> => [0x58051a8b,0xb259,0x5414,0x9b,0x9a,0xca,0xa0,0x78,0x9e,0x83,0x3e] as IID_IIterable_1_Windows_Networking_Connectivity_ConnectivityInterval }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::connectivity::LanIdentifier> => [0xaccef3cd,0x5d92,0x5c01,0x8a,0xc4,0x79,0xfe,0x74,0xcd,0x73,0x3e] as IID_IIterable_1_Windows_Networking_Connectivity_LanIdentifier }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::connectivity::NetworkUsage> => [0xdd2656b1,0x8360,0x5772,0xb2,0x72,0xc4,0x7f,0x7f,0x0f,0xc7,0xa6] as IID_IIterable_1_Windows_Networking_Connectivity_NetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::EndpointPair> => [0xd7ec83c4,0xa17b,0x51bf,0x89,0x97,0xaa,0x33,0xb9,0x10,0x2d,0xc9] as IID_IIterable_1_Windows_Networking_EndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::HostName> => [0x9e5f3ed0,0xcf1c,0x5d38,0x83,0x2c,0xac,0xea,0x61,0x64,0xbf,0x5c] as IID_IIterable_1_Windows_Networking_HostName }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandDeviceServiceInformation> => [0x88511855,0x6fe6,0x5694,0x83,0xa7,0x99,0x1e,0x29,0x03,0x3d,0xe5] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandNetworkRegistrationStateChange> => [0x0b90bb30,0x660c,0x51c6,0x9b,0x8c,0x31,0xdd,0x84,0x86,0xe1,0x0e] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandNetworkRegistrationStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandPinLockStateChange> => [0xaa4a8700,0x9943,0x59a3,0x86,0x47,0xd3,0x73,0xfd,0x5e,0x0e,0x2b] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandPinLockStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandPinType> => [0x9d55726d,0x813e,0x50fb,0x94,0x98,0x87,0xaa,0x87,0x2d,0xd6,0xca] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandPinType }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandRadioStateChange> => [0xc385adaa,0x574c,0x5ad8,0x98,0xc2,0x61,0x30,0x95,0x25,0x13,0x2d] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandRadioStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::MobileBroadbandUiccApp> => [0xaf538114,0xbd14,0x53b0,0xb1,0xd1,0x84,0x1d,0xca,0xa4,0x51,0xad] as IID_IIterable_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccApp }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::networkoperators::NetworkOperatorTetheringClient> => [0x4762ecb3,0xaf48,0x5b63,0x89,0xb7,0x78,0xa4,0x20,0x56,0x54,0x9f] as IID_IIterable_1_Windows_Networking_NetworkOperators_NetworkOperatorTetheringClient }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::proximity::PeerInformation> => [0x917e1105,0x0647,0x5793,0x9d,0x50,0xbe,0xfe,0x22,0x5f,0x0f,0x2f] as IID_IIterable_1_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::servicediscovery::dnssd::DnssdServiceInstance> => [0x1de3a3e5,0x387e,0x5328,0xb8,0x64,0x3f,0x0e,0x34,0x75,0xd3,0x43] as IID_IIterable_1_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceInstance }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::IVpnCustomPrompt> => [0x8bac695c,0x70cb,0x54d6,0x86,0x06,0xaf,0x6e,0x3a,0x25,0xe3,0xa1] as IID_IIterable_1_Windows_Networking_Vpn_IVpnCustomPrompt }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::IVpnCustomPromptElement> => [0x437d3693,0x00c4,0x50b4,0x98,0x9a,0x93,0x8f,0x10,0x16,0xa2,0x30] as IID_IIterable_1_Windows_Networking_Vpn_IVpnCustomPromptElement }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::IVpnProfile> => [0xdb35f6b1,0xf266,0x5c87,0x88,0x62,0x9d,0xd8,0x7d,0x9d,0xf1,0x8f] as IID_IIterable_1_Windows_Networking_Vpn_IVpnProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::VpnAppId> => [0x0e1e00aa,0xf93d,0x5dc7,0x99,0x12,0xe0,0x7d,0x1f,0xa6,0xbd,0x67] as IID_IIterable_1_Windows_Networking_Vpn_VpnAppId }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::VpnDomainNameInfo> => [0x33abe488,0xbe1a,0x558a,0xa9,0xcf,0xb5,0x33,0x0a,0xb4,0x9f,0x50] as IID_IIterable_1_Windows_Networking_Vpn_VpnDomainNameInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::VpnNamespaceInfo> => [0x17781d03,0xddcf,0x553f,0xab,0xa8,0xd2,0xe8,0x15,0x5c,0xb6,0xb8] as IID_IIterable_1_Windows_Networking_Vpn_VpnNamespaceInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::VpnRoute> => [0xbbf498d5,0xb9ef,0x55f1,0x97,0xb1,0x77,0xa0,0x66,0x39,0xe4,0xe2] as IID_IIterable_1_Windows_Networking_Vpn_VpnRoute }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::vpn::VpnTrafficFilter> => [0xb6d4c853,0x77c9,0x52ca,0x9c,0xe9,0x85,0x3a,0xdd,0x45,0x54,0xcf] as IID_IIterable_1_Windows_Networking_Vpn_VpnTrafficFilter }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveDeviceAddress> => [0x44df817c,0xb475,0x5fdb,0x86,0x2a,0x4a,0x96,0xed,0x1d,0xad,0x5c] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveDeviceAddress }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveEndpointPair> => [0x7fcaf666,0xddc0,0x50dc,0xa7,0x6f,0x9b,0xb6,0x05,0x8b,0xe3,0xc9] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveEndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveEndpointPairTemplate> => [0x9fce55c3,0x5580,0x581a,0x85,0xb5,0x88,0xdd,0x5e,0x9d,0x4f,0xf7] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveEndpointPairTemplate }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetric> => [0xe202eef6,0x93bd,0x5fa2,0x91,0xfc,0x7c,0xa6,0xa4,0xed,0xc3,0x8a] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetric }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetricResult> => [0x65cc99ec,0x9779,0x568a,0x89,0x82,0xae,0xe4,0x39,0xfa,0x24,0xce] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetricResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterable<super::super::networking::xboxlive::XboxLiveQualityOfServicePrivatePayloadResult> => [0x3a061dd4,0x03dd,0x52fb,0x9a,0x83,0x06,0x7d,0xe2,0x7c,0x2b,0xb1] as IID_IIterable_1_Windows_Networking_XboxLive_XboxLiveQualityOfServicePrivatePayloadResult }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterable<super::super::perception::spatial::SpatialBoundingVolume> => [0x89e8f1ee,0x3a2a,0x5b69,0xa7,0x86,0xcd,0xdc,0xf7,0x45,0x6a,0x3a] as IID_IIterable_1_Windows_Perception_Spatial_SpatialBoundingVolume }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::identity::core::MicrosoftAccountMultiFactorSessionInfo> => [0x85a662c8,0x8a5d,0x59a8,0x9f,0x73,0xee,0x23,0x73,0x93,0xc5,0x5c] as IID_IIterable_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorSessionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::identity::EnterpriseKeyCredentialRegistrationInfo> => [0xe7eea796,0x77f9,0x5473,0xa9,0x13,0x73,0x4e,0xa0,0xe3,0xff,0x46] as IID_IIterable_1_Windows_Security_Authentication_Identity_EnterpriseKeyCredentialRegistrationInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::identity::provider::SecondaryAuthenticationFactorInfo> => [0x43b7bbe4,0xf096,0x53dd,0x8c,0x16,0x1f,0xaa,0x4b,0x46,0x8c,0x86] as IID_IIterable_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::onlineid::OnlineIdServiceTicket> => [0x809d1314,0x97ab,0x5544,0x98,0x91,0xdd,0xcd,0xfa,0xdd,0x1d,0xbb] as IID_IIterable_1_Windows_Security_Authentication_OnlineId_OnlineIdServiceTicket }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::onlineid::OnlineIdServiceTicketRequest> => [0xcb72d686,0x9516,0x520d,0xa2,0x74,0xfa,0x4c,0xd1,0x76,0x2c,0xb2] as IID_IIterable_1_Windows_Security_Authentication_OnlineId_OnlineIdServiceTicketRequest }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::web::core::WebTokenResponse> => [0x7e5bb7ec,0xbbd7,0x5575,0x9a,0x61,0xf5,0x81,0x5f,0xa2,0x2a,0x0e] as IID_IIterable_1_Windows_Security_Authentication_Web_Core_WebTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::web::provider::WebAccountClientView> => [0x610e0f9d,0xaae4,0x54e1,0xbb,0x0b,0x1a,0xca,0x14,0x11,0x0a,0xbf] as IID_IIterable_1_Windows_Security_Authentication_Web_Provider_WebAccountClientView }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::authentication::web::provider::WebProviderTokenResponse> => [0xe9bac236,0xc077,0x553a,0xb4,0xae,0xb5,0x8f,0xb0,0xb8,0x99,0x18] as IID_IIterable_1_Windows_Security_Authentication_Web_Provider_WebProviderTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::credentials::PasswordCredential> => [0x0d224a66,0xbad5,0x5ad5,0x9a,0xde,0x1e,0x9f,0x5a,0x60,0xfe,0x73] as IID_IIterable_1_Windows_Security_Credentials_PasswordCredential }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::credentials::WebAccount> => [0xcb15d439,0xa910,0x542a,0x89,0xed,0x7c,0xfe,0x67,0x84,0x8a,0x83] as IID_IIterable_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::cryptography::certificates::Certificate> => [0x0c7d1423,0xe8fd,0x5a91,0xb5,0x5c,0x8b,0xfb,0xe7,0xac,0x2d,0x40] as IID_IIterable_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::cryptography::certificates::ChainValidationResult> => [0x2628f58f,0x3f02,0x54f2,0x80,0x8f,0xe1,0x11,0x77,0x09,0xd6,0xd0] as IID_IIterable_1_Windows_Security_Cryptography_Certificates_ChainValidationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterable<super::super::security::cryptography::certificates::CmsSignerInfo> => [0x6af24174,0x2dda,0x5a54,0xa0,0xb9,0x4d,0x66,0x90,0x05,0x94,0x27] as IID_IIterable_1_Windows_Security_Cryptography_Certificates_CmsSignerInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::guidance::GuidanceLaneInfo> => [0x45960d72,0x1bf6,0x5a1d,0xa1,0x7f,0xe8,0x3f,0x56,0xf1,0xab,0x57] as IID_IIterable_1_Windows_Services_Maps_Guidance_GuidanceLaneInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::guidance::GuidanceManeuver> => [0xb5780d67,0x8a8b,0x558f,0xa4,0xb6,0xc4,0x53,0x1e,0xf3,0x2e,0xc8] as IID_IIterable_1_Windows_Services_Maps_Guidance_GuidanceManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::guidance::GuidanceRoadSegment> => [0xf7c614c4,0x0fca,0x5eda,0x80,0x4c,0x85,0xc8,0x29,0x95,0x63,0x34] as IID_IIterable_1_Windows_Services_Maps_Guidance_GuidanceRoadSegment }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::localsearch::LocalLocation> => [0x5474eefb,0x60f4,0x58ac,0x89,0xe2,0x6e,0x83,0xf7,0x9f,0xa7,0x6c] as IID_IIterable_1_Windows_Services_Maps_LocalSearch_LocalLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::localsearch::LocalLocationHoursOfOperationItem> => [0xf298f515,0xb9bd,0x5297,0xb8,0xbd,0x1c,0x00,0x40,0xda,0xac,0x76] as IID_IIterable_1_Windows_Services_Maps_LocalSearch_LocalLocationHoursOfOperationItem }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::MapLocation> => [0x77da6151,0x0763,0x508a,0x90,0x41,0x33,0x10,0xba,0xac,0xe5,0x75] as IID_IIterable_1_Windows_Services_Maps_MapLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::MapRoute> => [0xd88a62a2,0x0edf,0x5312,0x97,0xa8,0x10,0xae,0xae,0xa8,0x0b,0x99] as IID_IIterable_1_Windows_Services_Maps_MapRoute }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::MapRouteLeg> => [0x8ff98759,0x78cd,0x56e8,0x87,0x7b,0x83,0xce,0x84,0x6d,0x6f,0x8b] as IID_IIterable_1_Windows_Services_Maps_MapRouteLeg }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::maps::MapRouteManeuver> => [0xde9015fb,0x91d7,0x556e,0xbb,0x4d,0x20,0x0b,0x6f,0x58,0xfa,0xd4] as IID_IIterable_1_Windows_Services_Maps_MapRouteManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StoreAvailability> => [0xc58de1a0,0x25de,0x578b,0xbb,0x69,0xe0,0xa2,0x6d,0x67,0xb2,0x03] as IID_IIterable_1_Windows_Services_Store_StoreAvailability }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StoreImage> => [0xb2da6de8,0xad55,0x56ce,0x87,0x54,0x2c,0x96,0xf4,0xfe,0x1c,0x2e] as IID_IIterable_1_Windows_Services_Store_StoreImage }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StorePackageUpdate> => [0x6b076c51,0x849e,0x5ec5,0xae,0xd5,0x9b,0x05,0x85,0x59,0x19,0x02] as IID_IIterable_1_Windows_Services_Store_StorePackageUpdate }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StorePackageUpdateStatus> => [0x60832223,0x7eb4,0x5cd7,0x83,0x40,0xf5,0x07,0x71,0x73,0xd3,0x64] as IID_IIterable_1_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StoreSku> => [0x522d34ef,0x4b5a,0x5b44,0xa0,0x46,0x7a,0x16,0x05,0x1d,0x01,0x1e] as IID_IIterable_1_Windows_Services_Store_StoreSku }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterable<super::super::services::store::StoreVideo> => [0x46be61e4,0x7173,0x565e,0xae,0xd5,0x4a,0x21,0x52,0xf1,0xce,0x69] as IID_IIterable_1_Windows_Services_Store_StoreVideo }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::accesscache::AccessListEntry> => [0x4995c2b0,0x736b,0x588d,0xae,0x42,0x6f,0x69,0xb0,0x25,0xb3,0x88] as IID_IIterable_1_Windows_Storage_AccessCache_AccessListEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::bulkaccess::FileInformation> => [0xdd96d7e9,0x892b,0x5932,0xb6,0x77,0x5b,0xc3,0x25,0x88,0x00,0x8f] as IID_IIterable_1_Windows_Storage_BulkAccess_FileInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::bulkaccess::FolderInformation> => [0x5c720bf5,0x7636,0x51fd,0x9e,0xf7,0xd5,0xf5,0x7f,0x07,0x1a,0x9b] as IID_IIterable_1_Windows_Storage_BulkAccess_FolderInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::bulkaccess::IStorageItemInformation> => [0x43bc252e,0xa3d6,0x5f00,0xa1,0x2c,0xb0,0x88,0xd3,0xb9,0x12,0xd4] as IID_IIterable_1_Windows_Storage_BulkAccess_IStorageItemInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::IStorageFile> => [0x76d43c7e,0xfd09,0x5908,0xa2,0xb9,0xa4,0x9b,0x48,0x48,0x29,0x4b] as IID_IIterable_1_Windows_Storage_IStorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::IStorageItem> => [0xbb8b8418,0x65d1,0x544b,0xb0,0x83,0x6d,0x17,0x2f,0x56,0x8c,0x73] as IID_IIterable_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::search::IIndexableContent> => [0x4a6edbfe,0x0c41,0x5042,0xac,0x58,0xa8,0x85,0xa8,0xfc,0x79,0x28] as IID_IIterable_1_Windows_Storage_Search_IIndexableContent }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::search::SortEntry> => [0x35aff6f9,0xef75,0x5280,0xbb,0x84,0xa2,0xbf,0x83,0x17,0xcf,0x35] as IID_IIterable_1_Windows_Storage_Search_SortEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::StorageFile> => [0x9ac00304,0x83ea,0x5688,0x87,0xb6,0xae,0x38,0xaa,0xb6,0x5d,0x0b] as IID_IIterable_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::StorageFolder> => [0x4669befc,0xae5c,0x52b1,0x8a,0x97,0x54,0x66,0xce,0x61,0xe9,0x4e] as IID_IIterable_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::StorageLibrary> => [0x851e3cfd,0x306b,0x5c8e,0xae,0x3c,0xa8,0xd8,0x3c,0x62,0x36,0x04] as IID_IIterable_1_Windows_Storage_StorageLibrary }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::StorageLibraryChange> => [0x87c15dfc,0x0c5e,0x518b,0x92,0x06,0x97,0xd3,0xd9,0x82,0x3c,0x61] as IID_IIterable_1_Windows_Storage_StorageLibraryChange }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::streams::IBuffer> => [0x902972bf,0xa984,0x5443,0xb1,0xc5,0x2f,0x04,0xa9,0x9e,0x1f,0xca] as IID_IIterable_1_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterable<super::super::storage::streams::IRandomAccessStream> => [0xba666a00,0x1555,0x5df4,0x81,0xa5,0x07,0xd2,0x3f,0x7f,0xfc,0xeb] as IID_IIterable_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterable<super::super::system::diagnostics::ProcessDiagnosticInfo> => [0x97b73627,0xb296,0x5076,0xb8,0xcd,0x6b,0xd8,0xa2,0x40,0xe9,0x66] as IID_IIterable_1_Windows_System_Diagnostics_ProcessDiagnosticInfo }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterable<super::super::system::remotesystems::IRemoteSystemFilter> => [0x13966c92,0xa8de,0x50c0,0xb1,0x6b,0x00,0xc2,0xc4,0x8f,0x5f,0x37] as IID_IIterable_1_Windows_System_RemoteSystems_IRemoteSystemFilter }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterable<super::super::system::User> => [0xd1bacd1f,0x0376,0x5823,0x8c,0x29,0x1d,0x45,0xb9,0xf4,0xc1,0x91] as IID_IIterable_1_Windows_System_User }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::applicationsettings::CredentialCommand> => [0x883ed18d,0x4dbb,0x58f2,0x8f,0xd2,0xe4,0xb0,0x18,0x50,0x95,0x53] as IID_IIterable_1_Windows_UI_ApplicationSettings_CredentialCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::applicationsettings::SettingsCommand> => [0x6308e7e8,0xcb85,0x5339,0xa3,0xe9,0x9a,0x75,0x00,0xd1,0x9c,0x68] as IID_IIterable_1_Windows_UI_ApplicationSettings_SettingsCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::applicationsettings::WebAccountCommand> => [0xbd0d999c,0xb2ba,0x51b2,0xbc,0xc0,0xd4,0xa5,0xcd,0x82,0x15,0x55] as IID_IIterable_1_Windows_UI_ApplicationSettings_WebAccountCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::applicationsettings::WebAccountProviderCommand> => [0x15165367,0x2e93,0x59a6,0xb5,0xc7,0x16,0xd3,0xb5,0x8f,0xd2,0xe7] as IID_IIterable_1_Windows_UI_ApplicationSettings_WebAccountProviderCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::Color> => [0x932eef5e,0x2c2f,0x5eae,0x92,0x9a,0x74,0xe9,0x73,0xb5,0x7c,0x27] as IID_IIterable_1_Windows_UI_Color }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::composition::interactions::InteractionTrackerInertiaModifier> => [0x9a245c40,0xaae6,0x59fb,0x87,0xf5,0x4b,0xb0,0x55,0x99,0xf0,0xb1] as IID_IIterable_1_Windows_UI_Composition_Interactions_InteractionTrackerInertiaModifier }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::core::animationmetrics::IPropertyAnimation> => [0xc75f1bd1,0xa3c1,0x5881,0x9d,0xa0,0x1e,0xcd,0xb8,0xe5,0x1b,0xc3] as IID_IIterable_1_Windows_UI_Core_AnimationMetrics_IPropertyAnimation }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::inking::InkPoint> => [0x0630c0ef,0xa4e2,0x5af6,0xb2,0xe9,0x8e,0x04,0x2e,0x29,0x4e,0x17] as IID_IIterable_1_Windows_UI_Input_Inking_InkPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::inking::InkRecognitionResult> => [0xe29b658b,0x7cc1,0x561c,0x99,0x12,0x00,0x1d,0xbc,0xa8,0x66,0x51] as IID_IIterable_1_Windows_UI_Input_Inking_InkRecognitionResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::inking::InkRecognizer> => [0x611b7e84,0xa803,0x5071,0xaa,0xea,0x4f,0x2c,0xe0,0x15,0x10,0x52] as IID_IIterable_1_Windows_UI_Input_Inking_InkRecognizer }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::inking::InkStroke> => [0xbbc11401,0x89d0,0x5305,0xa3,0xb3,0x36,0xc8,0x87,0x71,0x4b,0x9b] as IID_IIterable_1_Windows_UI_Input_Inking_InkStroke }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::inking::InkStrokeRenderingSegment> => [0x27000f47,0x2885,0x5da9,0x89,0x23,0x16,0xa3,0xa5,0x8b,0x7a,0x55] as IID_IIterable_1_Windows_UI_Input_Inking_InkStrokeRenderingSegment }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::PointerPoint> => [0xf6f2cba6,0x7076,0x5b59,0x96,0x31,0xf6,0xac,0x32,0xb5,0x76,0x95] as IID_IIterable_1_Windows_UI_Input_PointerPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::preview::injection::InjectedInputKeyboardInfo> => [0x15d6330f,0x9c97,0x5705,0xb6,0x77,0x87,0x25,0x85,0x66,0x4f,0xb5] as IID_IIterable_1_Windows_UI_Input_Preview_Injection_InjectedInputKeyboardInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::preview::injection::InjectedInputMouseInfo> => [0x6c34e5bd,0x0fa4,0x5244,0x89,0xfb,0x04,0xbf,0xd4,0x80,0xec,0xd8] as IID_IIterable_1_Windows_UI_Input_Preview_Injection_InjectedInputMouseInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::preview::injection::InjectedInputTouchInfo> => [0xac5fac0b,0x82a0,0x5436,0x92,0x84,0xe7,0xdb,0x0b,0xf4,0xe6,0x15] as IID_IIterable_1_Windows_UI_Input_Preview_Injection_InjectedInputTouchInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::RadialControllerMenuItem> => [0x1aa752b3,0xdc11,0x5bce,0xb2,0xb9,0xcd,0x1b,0xf8,0xf2,0x35,0xbe] as IID_IIterable_1_Windows_UI_Input_RadialControllerMenuItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::RadialControllerSystemMenuItemKind> => [0x4516010f,0xfd98,0x5e1d,0xbf,0x3f,0xae,0xaf,0x79,0xf1,0xf3,0xda] as IID_IIterable_1_Windows_UI_Input_RadialControllerSystemMenuItemKind }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::input::spatial::SpatialInteractionSourceState> => [0x7ecce0f5,0x0874,0x506f,0x8d,0x42,0x4c,0x95,0x19,0x15,0x64,0x07] as IID_IIterable_1_Windows_UI_Input_Spatial_SpatialInteractionSourceState }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::AdaptiveNotificationText> => [0x0343e8f2,0xca4c,0x5f40,0xb8,0xd1,0x3f,0xf4,0x70,0x47,0xce,0x43] as IID_IIterable_1_Windows_UI_Notifications_AdaptiveNotificationText }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::NotificationBinding> => [0xe8d9489c,0x635e,0x5153,0x8a,0xb7,0x38,0x9f,0x2e,0xe9,0xfa,0xca] as IID_IIterable_1_Windows_UI_Notifications_NotificationBinding }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::ScheduledTileNotification> => [0x4b60d1e5,0x52ae,0x5766,0x97,0x20,0xbe,0x4a,0xd0,0x86,0xf9,0x52] as IID_IIterable_1_Windows_UI_Notifications_ScheduledTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::ScheduledToastNotification> => [0x7a7b2a51,0xc182,0x5846,0xa8,0x61,0x4f,0x9c,0x03,0x6f,0x24,0xad] as IID_IIterable_1_Windows_UI_Notifications_ScheduledToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::ShownTileNotification> => [0x1863baee,0x44f1,0x5e51,0xbc,0xdf,0xa3,0xcd,0xab,0x82,0x6a,0x15] as IID_IIterable_1_Windows_UI_Notifications_ShownTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::ToastNotification> => [0x52c9428b,0xd37a,0x554d,0xbf,0x55,0xb8,0x68,0x5d,0x5f,0x55,0x2d] as IID_IIterable_1_Windows_UI_Notifications_ToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::notifications::UserNotification> => [0x18170480,0x1bd8,0x5cd0,0xbb,0x32,0x67,0xe7,0x1d,0x5b,0x4d,0x7c] as IID_IIterable_1_Windows_UI_Notifications_UserNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::popups::IUICommand> => [0xe63de42b,0x53c3,0x5e07,0x90,0xd3,0x98,0x17,0x2d,0x54,0x54,0x12] as IID_IIterable_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::startscreen::JumpListItem> => [0x130a7274,0x1afb,0x5c10,0xab,0xea,0x61,0xd8,0x16,0x92,0xa4,0x96] as IID_IIterable_1_Windows_UI_StartScreen_JumpListItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::startscreen::SecondaryTile> => [0x75651af0,0x014a,0x5593,0xbc,0x48,0x83,0x6b,0xa3,0xd1,0xd5,0xd4] as IID_IIterable_1_Windows_UI_StartScreen_SecondaryTile }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::startscreen::SecondaryTileVisualElements> => [0x6ef7c354,0xf153,0x5b53,0x99,0xc2,0xe0,0x45,0xc7,0x8c,0xce,0x08] as IID_IIterable_1_Windows_UI_StartScreen_SecondaryTileVisualElements }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterable<super::super::ui::text::core::CoreTextCompositionSegment> => [0x38372bd2,0xd3fe,0x5ad2,0x9d,0x39,0xd1,0x66,0xb6,0x8e,0x78,0xe7] as IID_IIterable_1_Windows_UI_Text_Core_CoreTextCompositionSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::automation::AutomationAnnotation> => [0xc6e210cb,0x1c7b,0x5e6a,0x93,0x6b,0x61,0xd4,0xe5,0x36,0xa2,0x91] as IID_IIterable_1_Windows_UI_Xaml_Automation_AutomationAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::automation::peers::AutomationPeer> => [0x7f67a4e2,0x96e0,0x522b,0x87,0x10,0x14,0xc4,0x2d,0x83,0x4f,0x1e] as IID_IIterable_1_Windows_UI_Xaml_Automation_Peers_AutomationPeer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::automation::peers::AutomationPeerAnnotation> => [0xdd28ff94,0xd11e,0x5ae7,0xb8,0x19,0x61,0x77,0xc1,0x59,0x93,0x13] as IID_IIterable_1_Windows_UI_Xaml_Automation_Peers_AutomationPeerAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::ColumnDefinition> => [0xa99329f3,0x4130,0x55cc,0xa4,0xf0,0xc2,0xba,0x43,0xca,0x07,0x35] as IID_IIterable_1_Windows_UI_Xaml_Controls_ColumnDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::GroupStyle> => [0x89be2766,0x2a52,0x5790,0xad,0x0e,0xd5,0xca,0xe3,0x05,0xb0,0x7c] as IID_IIterable_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::HubSection> => [0x558c4082,0x463a,0x5c3d,0xb5,0x1e,0x10,0x92,0x1b,0x4a,0x4d,0x6c] as IID_IIterable_1_Windows_UI_Xaml_Controls_HubSection }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::ICommandBarElement> => [0xd4c5a8e7,0x0d5e,0x5922,0xa7,0xb4,0x59,0xb5,0xe6,0x34,0xd3,0x35] as IID_IIterable_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::maps::MapElement> => [0x81d25c25,0xa4b3,0x5d0d,0x92,0xab,0x26,0x36,0x0c,0x2a,0x7f,0xac] as IID_IIterable_1_Windows_UI_Xaml_Controls_Maps_MapElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::maps::MapRouteView> => [0x090ad4b3,0x8fce,0x502d,0x86,0x65,0x18,0x65,0x0c,0x51,0xbe,0xa9] as IID_IIterable_1_Windows_UI_Xaml_Controls_Maps_MapRouteView }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::maps::MapTileSource> => [0x6d8a73f7,0xabd7,0x56c4,0x99,0xa7,0x06,0xc1,0xfa,0x77,0xdc,0xd2] as IID_IIterable_1_Windows_UI_Xaml_Controls_Maps_MapTileSource }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::MenuFlyoutItemBase> => [0x0bb14d64,0xcc9a,0x58ae,0xb8,0x81,0x73,0xfe,0x0e,0xcb,0x99,0xeb] as IID_IIterable_1_Windows_UI_Xaml_Controls_MenuFlyoutItemBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::primitives::Popup> => [0x0af05ce9,0x3b0f,0x5a6d,0xa0,0x53,0xd0,0x1a,0x1a,0x55,0x4f,0x8c] as IID_IIterable_1_Windows_UI_Xaml_Controls_Primitives_Popup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::RowDefinition> => [0xabef522a,0x7378,0x504f,0x94,0x06,0x97,0xd9,0xf4,0x26,0x43,0xa7] as IID_IIterable_1_Windows_UI_Xaml_Controls_RowDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::controls::WebViewDeferredPermissionRequest> => [0x3981a977,0xda6c,0x5450,0x82,0x3e,0x7d,0xd2,0x3b,0x91,0xf2,0xbc] as IID_IIterable_1_Windows_UI_Xaml_Controls_WebViewDeferredPermissionRequest }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::data::ItemIndexRange> => [0x273b8073,0x8c16,0x59c2,0xa6,0x16,0x0a,0x53,0x44,0x83,0xc6,0x12] as IID_IIterable_1_Windows_UI_Xaml_Data_ItemIndexRange }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::DependencyObject> => [0xf66c6bd3,0x55b4,0x5bbb,0xb8,0x2a,0x6d,0x9c,0xe3,0x83,0x09,0x1a] as IID_IIterable_1_Windows_UI_Xaml_DependencyObject }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::documents::Block> => [0xf7023b9a,0xe6d1,0x5e2d,0x8f,0x41,0xb2,0x8c,0x33,0x32,0x3e,0x04] as IID_IIterable_1_Windows_UI_Xaml_Documents_Block }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::documents::Inline> => [0xe1d2b910,0x18c2,0x5906,0x8f,0x8a,0xd6,0x2a,0x63,0xf9,0x3f,0x18] as IID_IIterable_1_Windows_UI_Xaml_Documents_Inline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::input::InputScopeName> => [0x81416296,0x95d0,0x5100,0xb5,0x9b,0xbe,0xa1,0xc2,0x7d,0x20,0x02] as IID_IIterable_1_Windows_UI_Xaml_Input_InputScopeName }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::input::Pointer> => [0x6cf9f859,0x2234,0x510d,0x86,0x0a,0xdb,0x32,0x80,0x30,0xcb,0xcc] as IID_IIterable_1_Windows_UI_Xaml_Input_Pointer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::ColorKeyFrame> => [0x1859dd08,0x582d,0x51dc,0x82,0xa1,0x46,0x61,0x11,0xca,0xf9,0x44] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_ColorKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::DoubleKeyFrame> => [0x5f1676da,0xa405,0x5b7a,0xba,0xf1,0x96,0x8d,0xe4,0x39,0x1f,0xb7] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_DoubleKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::ObjectKeyFrame> => [0x9084a8e1,0x8f4d,0x5de3,0xb1,0xc6,0xe5,0xf0,0x57,0x24,0xca,0xed] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_ObjectKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::PointKeyFrame> => [0xb8de4dc9,0x8c69,0x55f3,0xaf,0x58,0x04,0x0f,0x13,0x19,0x64,0x9c] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_PointKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::Timeline> => [0xa122a346,0xe6d5,0x5c54,0x85,0x7d,0x03,0x8e,0x60,0xf5,0xd9,0xc1] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_Timeline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::animation::Transition> => [0xfeb51398,0x4fdb,0x5112,0x8a,0x9b,0x6a,0x87,0x86,0xca,0x01,0xce] as IID_IIterable_1_Windows_UI_Xaml_Media_Animation_Transition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::Brush> => [0xb07e92d5,0x06b3,0x5dd2,0x8d,0x49,0x34,0x9f,0xfb,0xd8,0x46,0x34] as IID_IIterable_1_Windows_UI_Xaml_Media_Brush }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::Geometry> => [0x35340039,0x0dfc,0x52b4,0x87,0x48,0x0d,0x9a,0x75,0x5d,0xb8,0xa8] as IID_IIterable_1_Windows_UI_Xaml_Media_Geometry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::GradientStop> => [0x9105bb93,0xac26,0x5bae,0x8c,0x1e,0xdf,0x8e,0xcf,0x00,0xde,0xe6] as IID_IIterable_1_Windows_UI_Xaml_Media_GradientStop }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::PathFigure> => [0xcd1dc421,0xd6e5,0x5b3f,0xa8,0xc7,0x99,0x38,0xf2,0x8b,0x29,0x95] as IID_IIterable_1_Windows_UI_Xaml_Media_PathFigure }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::PathSegment> => [0x37e2cb21,0xb9c9,0x5006,0xbe,0xd7,0x4c,0x32,0x89,0x81,0xb5,0x51] as IID_IIterable_1_Windows_UI_Xaml_Media_PathSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::TimelineMarker> => [0x946c5af5,0x4c09,0x5784,0x9c,0xf2,0x50,0x69,0x47,0x37,0x8e,0x8e] as IID_IIterable_1_Windows_UI_Xaml_Media_TimelineMarker }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::media::Transform> => [0xfb8cacbc,0xd3ec,0x51b8,0x97,0x78,0x99,0xed,0xe8,0x46,0x36,0x11] as IID_IIterable_1_Windows_UI_Xaml_Media_Transform }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::navigation::PageStackEntry> => [0xdd2278a5,0x4c14,0x5967,0x8a,0x41,0x9a,0x47,0xc3,0xc5,0xc4,0xa7] as IID_IIterable_1_Windows_UI_Xaml_Navigation_PageStackEntry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::ResourceDictionary> => [0xeaf20635,0xa462,0x5397,0xbe,0xe1,0xf7,0xa0,0x95,0x04,0x65,0x3b] as IID_IIterable_1_Windows_UI_Xaml_ResourceDictionary }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::StateTriggerBase> => [0x073325bc,0x8f0f,0x56d8,0xb5,0x21,0x6b,0xe4,0x76,0x44,0xc5,0x54] as IID_IIterable_1_Windows_UI_Xaml_StateTriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::TriggerAction> => [0xa9d34579,0x8a6a,0x58bf,0x85,0xfd,0x0f,0x37,0x32,0x4e,0x23,0x97] as IID_IIterable_1_Windows_UI_Xaml_TriggerAction }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::TriggerBase> => [0xd697764f,0x4e15,0x5888,0xa2,0xa5,0x7b,0x4c,0xf0,0xeb,0x07,0xa5] as IID_IIterable_1_Windows_UI_Xaml_TriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::UIElement> => [0x42e26ae1,0xd357,0x57e8,0xbb,0x48,0xf7,0x5c,0x9f,0xf6,0x9d,0x91] as IID_IIterable_1_Windows_UI_Xaml_UIElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::VisualState> => [0x1fb071a3,0xa064,0x5619,0xa9,0x4e,0x23,0xc0,0x1a,0x4c,0xbf,0x3a] as IID_IIterable_1_Windows_UI_Xaml_VisualState }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::VisualStateGroup> => [0x5d9ab411,0xe991,0x55b0,0xb1,0x6c,0xa4,0x00,0xa5,0x0a,0x93,0xdf] as IID_IIterable_1_Windows_UI_Xaml_VisualStateGroup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterable<super::super::ui::xaml::VisualTransition> => [0x017a8eb0,0xe942,0x5f25,0xa9,0x45,0x20,0x5a,0x94,0x70,0xb9,0xfc] as IID_IIterable_1_Windows_UI_Xaml_VisualTransition }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::atompub::ResourceCollection> => [0xd4372a2d,0x7ab0,0x5d8e,0xbd,0x5c,0x6e,0x9c,0x0a,0x67,0xa8,0xd8] as IID_IIterable_1_Windows_Web_AtomPub_ResourceCollection }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::atompub::Workspace> => [0xf02d0ebe,0xeac2,0x502f,0x98,0x36,0x1c,0x54,0x82,0x33,0x3b,0xfe] as IID_IIterable_1_Windows_Web_AtomPub_Workspace }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::http::diagnostics::HttpDiagnosticSourceLocation> => [0x4286ca1a,0xa4c5,0x5ae8,0x9d,0xa9,0x5b,0xfa,0x24,0x76,0x8e,0x22] as IID_IIterable_1_Windows_Web_Http_Diagnostics_HttpDiagnosticSourceLocation }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::http::headers::HttpNameValueHeaderValue> => [0x5838a126,0xb617,0x5417,0xb3,0x2e,0xde,0xd2,0xd2,0x7d,0x40,0xa3] as IID_IIterable_1_Windows_Web_Http_Headers_HttpNameValueHeaderValue }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::http::HttpCookie> => [0x0eb9fa36,0x88de,0x590d,0x8e,0xa0,0xb6,0x13,0xd0,0xab,0x01,0x5f] as IID_IIterable_1_Windows_Web_Http_HttpCookie }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::ISyndicationNode> => [0xb486569a,0x72b3,0x57aa,0x99,0x50,0xce,0xa0,0xb3,0xe4,0xfc,0x58] as IID_IIterable_1_Windows_Web_Syndication_ISyndicationNode }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::SyndicationAttribute> => [0x329eabe1,0xefcc,0x539e,0x96,0xba,0xf6,0xa4,0x4f,0x22,0x1d,0xbd] as IID_IIterable_1_Windows_Web_Syndication_SyndicationAttribute }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::SyndicationCategory> => [0xd151f7d1,0xeabd,0x5300,0xb5,0x5c,0x14,0x9e,0xb2,0x89,0xcc,0x71] as IID_IIterable_1_Windows_Web_Syndication_SyndicationCategory }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::SyndicationItem> => [0x55463eef,0xecb8,0x59cd,0x8d,0x6b,0x74,0xda,0xac,0xbe,0x7d,0x19] as IID_IIterable_1_Windows_Web_Syndication_SyndicationItem }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::SyndicationLink> => [0xc6919f6a,0x66d9,0x556a,0x96,0x32,0x87,0xd3,0x9a,0xf1,0x46,0x38] as IID_IIterable_1_Windows_Web_Syndication_SyndicationLink }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterable<super::super::web::syndication::SyndicationPerson> => [0xe58e7844,0xeb34,0x5284,0xb0,0x9e,0xde,0x67,0x62,0xd5,0x48,0xca] as IID_IIterable_1_Windows_Web_Syndication_SyndicationPerson }
		RT_PINTERFACE!{ for IIterable<super::TimeSpan> => [0xe9f78726,0x829a,0x5f67,0x8d,0x19,0x95,0xef,0x15,0x4b,0x77,0x42] as IID_IIterable_1_Windows_Foundation_TimeSpan }
		RT_PINTERFACE!{ for IIterable<super::Uri> => [0xb0d63b78,0x78ad,0x5e31,0xb6,0xd8,0xe3,0x2a,0x0e,0x16,0xc4,0x47] as IID_IIterable_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for IIterable<u32> => [0x421d4b91,0xb13b,0x5f37,0xae,0x54,0xb5,0x24,0x9b,0xd8,0x05,0x39] as IID_IIterable_1_System_UInt32 }
		RT_PINTERFACE!{ for IIterable<u8> => [0x88318266,0xf3fd,0x50fc,0x8f,0x08,0xb8,0x23,0xa4,0x1b,0x60,0xc1] as IID_IIterable_1_System_Byte }
		RT_PINTERFACE!{ for IIterator<::Guid> => [0xd3d64048,0x82b3,0x53c7,0x92,0x85,0xb0,0xbe,0x18,0x36,0x84,0x82] as IID_IIterator_1_System_Guid }
		RT_PINTERFACE!{ for IIterator<f32> => [0x42614e61,0xb0aa,0x5e72,0x93,0x54,0x27,0x71,0xdb,0x20,0xb7,0xa8] as IID_IIterator_1_System_Single }
		RT_PINTERFACE!{ for IIterator<f64> => [0x638a2cf4,0xf474,0x5318,0x90,0x55,0x14,0x1c,0xb9,0x09,0xac,0x4b] as IID_IIterator_1_System_Double }
		RT_PINTERFACE!{ for IIterator<HString> => [0x8c304ebb,0x6615,0x50a4,0x88,0x29,0x87,0x9e,0xcd,0x44,0x32,0x36] as IID_IIterator_1_System_String }
		RT_PINTERFACE!{ for IIterator<i32> => [0xbfea7f78,0x50c2,0x5f1d,0xa6,0xea,0x9e,0x97,0x8d,0x26,0x99,0xff] as IID_IIterator_1_System_Int32 }
		RT_PINTERFACE!{ for IIterator<IInspectable> => [0x44a94f2d,0x04f8,0x5091,0xb3,0x36,0xbe,0x78,0x92,0xdd,0x10,0xbe] as IID_IIterator_1_System_Object }
		RT_PINTERFACE!{ for IIterator<IIterable<super::Point>> => [0x377f6162,0x6e4d,0x574e,0xbf,0x01,0x77,0xf4,0xfd,0x02,0x1d,0x0e] as IID_IIterator_1_Windows_Foundation_Collections_IIterable_1_Windows_Foundation_Point }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<::Guid, IInspectable>> => [0x4f25059a,0x0b9a,0x5f25,0x9b,0x9e,0x4b,0x9f,0x1d,0x22,0xff,0x65] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<::Guid, super::super::applicationmodel::background::IBackgroundTaskRegistration>> => [0x2001aea5,0x1a86,0x517e,0x8b,0xe5,0x11,0xd7,0xfb,0x59,0x35,0xb2] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_Windows_ApplicationModel_Background_IBackgroundTaskRegistration }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<::Guid, super::super::perception::spatial::surfaces::SpatialSurfaceInfo>> => [0x6d328390,0xf279,0x5f39,0x96,0x82,0xbb,0xa0,0xcd,0x81,0x48,0x9b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Guid_Windows_Perception_Spatial_Surfaces_SpatialSurfaceInfo }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, HString>> => [0x05eb86f1,0x7140,0x5517,0xb8,0x8d,0xcb,0xae,0xbe,0x57,0xe6,0xb1] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_System_String }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, IInspectable>> => [0x5db5fa32,0x707c,0x5849,0xa0,0x6b,0x91,0xc8,0xeb,0x9d,0x10,0xe8] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_System_Object }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, IVector<HString>>> => [0xa11824c9,0xe458,0x502a,0xaf,0xd8,0xce,0x3c,0xe0,0xab,0xd6,0xfe] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVector_1_System_String }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, IVectorView<HString>>> => [0x643b6d83,0x457e,0x5a43,0x80,0x0f,0xb0,0x44,0x9f,0x91,0xd9,0x6b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_System_String }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, IVectorView<super::super::data::text::TextSegment>>> => [0x00078aa3,0x8676,0x5f06,0xad,0xf5,0xff,0xe5,0xd6,0x61,0xd6,0x70] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::chat::ChatMessageStatus>> => [0x5b099e05,0x07e2,0x5346,0xb0,0x75,0xf4,0x29,0x7b,0x3e,0x30,0x8b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Chat_ChatMessageStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::resources::core::NamedResource>> => [0x7fdcc3d7,0xe13e,0x5f76,0xaf,0xc6,0x07,0x69,0xc4,0x08,0x63,0x99] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Resources_Core_NamedResource }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::resources::core::ResourceMap>> => [0x28cf8d5e,0x69f6,0x59f6,0x98,0x65,0xbc,0xa9,0x7d,0x59,0xf7,0x4f] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::store::licensemanagement::LicenseSatisfactionInfo>> => [0x168d4306,0xe80a,0x5e37,0xae,0x46,0x2c,0xee,0xcd,0xd7,0xfc,0x9a] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::store::ProductLicense>> => [0x3f3c06e6,0x593f,0x557a,0x8e,0x3c,0x45,0x51,0x3a,0xc0,0x1f,0x7c] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductLicense }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::store::ProductListing>> => [0x142a6937,0x1ae1,0x5aad,0x8a,0xda,0x9a,0x8e,0xe0,0x34,0xe4,0xeb] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductListing }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::voicecommands::VoiceCommandDefinition>> => [0x91fbb58b,0xfb9c,0x5165,0xa1,0xbf,0x81,0x5d,0x27,0x67,0x30,0x0d] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_VoiceCommands_VoiceCommandDefinition }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletItemCustomProperty>> => [0xc66d71b4,0x4336,0x5693,0x83,0x6e,0x49,0x15,0x30,0x3c,0x18,0x3b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletItemCustomProperty }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletRelevantLocation>> => [0xb5d9a611,0x5f2c,0x542c,0xae,0x58,0x27,0x67,0x53,0xbb,0xf8,0xc7] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletRelevantLocation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletTransaction>> => [0x75f5591e,0x31a9,0x50e9,0xb9,0xd0,0x37,0x3b,0x1e,0xb0,0xd6,0xb6] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletTransaction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletVerb>> => [0x93b2ca58,0xf717,0x56e6,0xa9,0x45,0x85,0x13,0xc4,0x8f,0x91,0x5c] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletVerb }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::graphics::imaging::BitmapTypedValue>> => [0x2ad3fb0c,0x0656,0x5302,0xb5,0x04,0x31,0x53,0xbe,0x84,0x51,0x61] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Graphics_Imaging_BitmapTypedValue }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::graphics::printing::optiondetails::IPrintOptionDetails>> => [0x7bef6011,0x58a1,0x5523,0x8e,0x2a,0x30,0x9f,0x8c,0xb1,0xbd,0x39] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Graphics_Printing_OptionDetails_IPrintOptionDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::media::capture::frames::MediaFrameSource>> => [0xd8ec36b7,0x64eb,0x5675,0xad,0x81,0x62,0x23,0x3e,0x48,0x3e,0x17] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Media_Capture_Frames_MediaFrameSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::networking::sockets::SocketActivityInformation>> => [0xf656f7a2,0x264b,0x5cfd,0x82,0x88,0x64,0xeb,0x89,0x45,0x51,0x57] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Networking_Sockets_SocketActivityInformation }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::perception::spatial::SpatialAnchor>> => [0x67a5f318,0x0232,0x5900,0xac,0x7e,0x5c,0x64,0x7d,0x73,0x1c,0xbc] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::services::store::StoreLicense>> => [0xa1509348,0x6522,0x5062,0xae,0x86,0xcf,0x59,0x54,0x75,0x92,0x6d] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Services_Store_StoreLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::services::store::StoreProduct>> => [0x0edb142c,0x9d04,0x532b,0x81,0xe9,0x4c,0x84,0xab,0x09,0xb3,0x4b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Services_Store_StoreProduct }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::storage::ApplicationDataContainer>> => [0xaf3c131d,0x67aa,0x5c8d,0xae,0x0e,0x27,0x2b,0xa2,0x4a,0xe7,0x4f] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_ApplicationDataContainer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::storage::streams::IBuffer>> => [0x790acb62,0xc4b3,0x57ea,0xa1,0x52,0x9e,0x21,0x93,0x71,0xc6,0xdc] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<HString, super::super::storage::streams::RandomAccessStreamReference>> => [0x9419af53,0xacb8,0x5328,0x88,0x53,0x70,0xba,0x87,0xeb,0x6a,0xd5] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		RT_PINTERFACE!{ for IIterator<IKeyValuePair<IInspectable, IInspectable>> => [0x31e55e8a,0x0f05,0x52fd,0x90,0xd3,0xb0,0x4a,0xa3,0x31,0xaa,0xa4] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_Object_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<super::super::devices::sensors::PedometerStepKind, super::super::devices::sensors::PedometerReading>> => [0x3e88fe66,0xd4a7,0x5658,0xb5,0xcf,0x1a,0x39,0xe1,0xfc,0x41,0x65] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_Windows_Devices_Sensors_PedometerStepKind_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<IKeyValuePair<u32, super::super::storage::streams::IBuffer>> => [0xa295fa0c,0xc99f,0x5109,0x8a,0xb9,0x91,0x53,0x4b,0xb4,0x8c,0x9b] as IID_IIterator_1_Windows_Foundation_Collections_IKeyValuePair_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IIterator<IMapView<HString, IInspectable>> => [0x53a2e825,0x9bf1,0x5083,0x8a,0x7b,0x9d,0x94,0xf3,0x12,0xda,0xde] as IID_IIterator_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for IIterator<super::DateTime> => [0xf56158df,0x8947,0x5480,0x96,0xed,0x36,0xc1,0x05,0x78,0x77,0xea] as IID_IIterator_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IIterator<super::Point> => [0xc602b59e,0x0a8e,0x5e99,0xb4,0x78,0x2b,0x56,0x45,0x85,0x27,0x8d] as IID_IIterator_1_Windows_Foundation_Point }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appextensions::AppExtension> => [0x8e80ca83,0x3cd3,0x5f9c,0x83,0xe4,0x84,0x34,0x7c,0xa5,0x49,0x8c] as IID_IIterator_1_Windows_ApplicationModel_AppExtensions_AppExtension }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::AppInfo> => [0x69cec62c,0x41eb,0x5d69,0xa4,0x75,0x29,0xee,0x22,0x32,0x3d,0xd8] as IID_IIterator_1_Windows_ApplicationModel_AppInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appointments::Appointment> => [0x386a5922,0x49fc,0x53b6,0x8b,0xed,0x4c,0x9f,0xf9,0xfe,0x6e,0x01] as IID_IIterator_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appointments::AppointmentCalendar> => [0xf40a879d,0xb6b7,0x5f92,0xbe,0xb1,0x6a,0x8e,0x7c,0xe5,0x41,0x20] as IID_IIterator_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appointments::AppointmentException> => [0xe58c63db,0xd9d5,0x5fa5,0x87,0x90,0x29,0x84,0x6d,0xe5,0x4f,0xa4] as IID_IIterator_1_Windows_ApplicationModel_Appointments_AppointmentException }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appointments::AppointmentInvitee> => [0x57e35198,0x1b41,0x54da,0xad,0xaf,0x50,0xef,0x1e,0x93,0xfd,0xed] as IID_IIterator_1_Windows_ApplicationModel_Appointments_AppointmentInvitee }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::appointments::AppointmentStoreChange> => [0x16a427bf,0xe5b0,0x5662,0x92,0x79,0xca,0xa8,0xed,0x84,0x81,0xa6] as IID_IIterator_1_Windows_ApplicationModel_Appointments_AppointmentStoreChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::calls::PhoneCallHistoryEntry> => [0xc1cf3870,0x064a,0x54d5,0xaf,0xab,0xd1,0xdc,0x4e,0xe2,0x6c,0xcb] as IID_IIterator_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatConversation> => [0x7007a155,0x47ca,0x59c8,0xbf,0x1e,0x96,0x0b,0x82,0x15,0x99,0x07] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatMessage> => [0xcd3c8682,0x2366,0x5646,0x9a,0xf5,0xbc,0xb9,0xc3,0xbe,0x9e,0xbe] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatMessageAttachment> => [0xbc37f8a5,0xcd61,0x5054,0xa8,0x97,0x6d,0x40,0x2b,0x56,0xb5,0x8b] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatMessageAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatMessageChange> => [0xdf6e6b4f,0x3e45,0x52cd,0xaa,0xde,0x33,0x16,0x89,0x6a,0xba,0xd0] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatMessageChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatMessageTransport> => [0x98ebffc3,0xef5f,0x58ac,0x96,0x95,0x04,0x7a,0x96,0xc3,0xf0,0xb0] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::ChatRecipientDeliveryInfo> => [0x3a7b0f38,0xecd7,0x55f8,0xa5,0xc5,0xe0,0x3d,0x43,0xa3,0x97,0x8e] as IID_IIterator_1_Windows_ApplicationModel_Chat_ChatRecipientDeliveryInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::IChatItem> => [0x5d2c1b3f,0x9bc7,0x5126,0x93,0xcd,0xf5,0x23,0x26,0x49,0x4d,0xe1] as IID_IIterator_1_Windows_ApplicationModel_Chat_IChatItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::RcsEndUserMessageAction> => [0x75a37f34,0xd87d,0x555c,0x8e,0x64,0xa1,0xea,0x48,0xa3,0xdd,0x20] as IID_IIterator_1_Windows_ApplicationModel_Chat_RcsEndUserMessageAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::chat::RcsTransport> => [0xa4eda5fb,0xfb99,0x56a7,0x89,0x48,0x95,0xc6,0x68,0xa3,0xed,0x3c] as IID_IIterator_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::Contact> => [0xa572c173,0x800a,0x58bb,0xab,0x24,0x17,0x99,0x59,0xdf,0x28,0x13] as IID_IIterator_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactAddress> => [0xd9003f84,0x63df,0x5c0c,0xbd,0x1e,0x2c,0xcd,0xea,0x55,0xe7,0x17] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactAddress }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactAnnotation> => [0x77bc5ee1,0x7130,0x5876,0x9d,0x30,0x1f,0x93,0x06,0xcc,0x22,0x6a] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactAnnotationList> => [0x3d7b4ad2,0xbb54,0x5e21,0xa9,0x2e,0x6b,0x80,0x26,0x4c,0xcc,0x50] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactChange> => [0xcd1a34ad,0x16df,0x572c,0xb5,0xcd,0x52,0x6e,0xb3,0x04,0x4f,0xce] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactConnectedServiceAccount> => [0x3ef1863f,0xc859,0x5b9d,0x8e,0x35,0x20,0xad,0xf1,0x02,0xa4,0x0d] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactConnectedServiceAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactDate> => [0x5004bf96,0x5349,0x5b10,0x87,0xc6,0xc7,0x6f,0x21,0xf2,0xa1,0xd5] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactDate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactEmail> => [0xd64ce66d,0x2936,0x5a1e,0xb8,0xf5,0x08,0x0b,0xb1,0x35,0x60,0x22] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactEmail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactField> => [0xaa226af5,0xfaa5,0x5353,0x87,0x1c,0x53,0x80,0x99,0xb7,0xc8,0x36] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactFieldType> => [0x2f6d856a,0x50d4,0x5173,0xab,0xea,0xdb,0x6c,0x6b,0x8f,0xc5,0x30] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactFieldType }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactInformation> => [0x7b77b895,0xabee,0x5501,0x94,0xdb,0xce,0x4e,0x48,0xa9,0xa3,0x4f] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactInstantMessageField> => [0x65e069e6,0x28d1,0x5d57,0x9f,0xe1,0x80,0xff,0x64,0x85,0x0e,0x67] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactInstantMessageField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactJobInfo> => [0x0873df73,0xac99,0x50ef,0x86,0x73,0xe7,0x8f,0x8a,0x54,0x0e,0x2e] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactJobInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactList> => [0xee69382d,0x887d,0x5964,0x83,0xb4,0x47,0xee,0x9d,0xed,0x6f,0x05] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactLocationField> => [0xa20407d7,0x6980,0x5c4f,0xb9,0x93,0xf1,0xda,0x03,0x99,0x41,0x05] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactLocationField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactMatchReason> => [0x4ae36741,0xbbde,0x5bd6,0x9d,0x4f,0x0d,0x57,0xb1,0x41,0x0e,0x4e] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactMatchReason }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactPhone> => [0x603b190e,0x1fb6,0x5762,0xbd,0x8a,0xf5,0x9e,0x95,0x27,0x26,0xf7] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactPhone }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactSignificantOther> => [0x2051d4fa,0xbd46,0x52eb,0xb2,0xd0,0x4e,0xb5,0xda,0xc1,0x21,0x57] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactSignificantOther }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::ContactWebsite> => [0x91a59fa2,0x5cc1,0x564d,0xbb,0x1d,0xf5,0x2d,0xae,0xc1,0x36,0xad] as IID_IIterator_1_Windows_ApplicationModel_Contacts_ContactWebsite }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::contacts::IContactField> => [0xc501c1b3,0x171b,0x5320,0x8d,0x84,0xc3,0xa8,0x9a,0x3d,0x40,0x34] as IID_IIterator_1_Windows_ApplicationModel_Contacts_IContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::core::AppListEntry> => [0xb93e2028,0x50bc,0x599e,0xb3,0xd9,0x42,0x7b,0x61,0xd2,0x6c,0x01] as IID_IIterator_1_Windows_ApplicationModel_Core_AppListEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::core::CoreApplicationView> => [0x4f5f6944,0x264b,0x5868,0x80,0x9e,0xc7,0xac,0x1a,0xc5,0xed,0xad] as IID_IIterator_1_Windows_ApplicationModel_Core_CoreApplicationView }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailAttachment> => [0x44655b88,0x9a99,0x5994,0x8e,0x0f,0x5b,0x96,0x40,0x92,0x41,0x20] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailCertificateValidationStatus> => [0x1cfe3d41,0x16a5,0x5026,0xa6,0xfe,0x2c,0xb0,0xa3,0x03,0xa6,0x05] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailCertificateValidationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailConversation> => [0xfadada27,0xe629,0x5a34,0xb2,0xe9,0x1d,0x25,0xc9,0x35,0x44,0xb5] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailFolder> => [0x95ae5494,0x43bc,0x5f6b,0xa0,0x2b,0xb6,0x95,0x6d,0x0c,0x70,0x69] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailMailbox> => [0x312f8d4a,0x0e85,0x566e,0xb7,0xaa,0xdb,0xd4,0x0a,0x03,0x43,0xff] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailMailboxAction> => [0xb9d8eec0,0xf0e0,0x5a4d,0x88,0xd0,0x75,0x8a,0xcb,0xc6,0x38,0x0f] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailMailboxAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailMailboxChange> => [0xb2b91198,0x5f8b,0x5e4a,0x85,0xf8,0xdd,0xca,0x82,0xba,0x0b,0x7f] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailMailboxChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailMessage> => [0xca569bf8,0xd6d7,0x5411,0x96,0x00,0xab,0x95,0xec,0x06,0x5c,0x72] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailRecipient> => [0x12238d88,0x1a2f,0x5e7a,0x89,0xb1,0x8d,0xc1,0x40,0x53,0x6b,0xac] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailRecipient }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::email::EmailRecipientResolutionResult> => [0x5c040cd6,0x9593,0x5e74,0x9a,0x5e,0x72,0x84,0xcd,0x1b,0x72,0x00] as IID_IIterator_1_Windows_ApplicationModel_Email_EmailRecipientResolutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::lockscreen::LockScreenBadge> => [0x8d38f924,0x154d,0x5705,0x8f,0x0b,0xed,0x61,0x35,0x3f,0x6c,0xe2] as IID_IIterator_1_Windows_ApplicationModel_LockScreen_LockScreenBadge }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::Package> => [0x0217f069,0x025c,0x5ee6,0xa8,0x7f,0xe7,0x82,0xe3,0xb6,0x23,0xae] as IID_IIterator_1_Windows_ApplicationModel_Package }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::core::NamedResource> => [0x0c5a605f,0xa7f1,0x5030,0xa1,0x79,0x9f,0xd3,0x63,0xca,0xf3,0xb5] as IID_IIterator_1_Windows_ApplicationModel_Resources_Core_NamedResource }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::core::ResourceCandidate> => [0xe151bd8c,0xa286,0x57ab,0xbc,0xea,0x79,0xb7,0xbc,0x26,0x87,0xa1] as IID_IIterator_1_Windows_ApplicationModel_Resources_Core_ResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::core::ResourceMap> => [0x3dedcae6,0xd048,0x5eaa,0xaf,0xa2,0xfb,0x4a,0x79,0x70,0xef,0x68] as IID_IIterator_1_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::core::ResourceQualifier> => [0xfedb74db,0xe74f,0x597a,0xb9,0xbf,0x70,0x4b,0x0d,0xad,0xca,0x38] as IID_IIterator_1_Windows_ApplicationModel_Resources_Core_ResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::management::IndexedResourceCandidate> => [0x6b6f3ab9,0x1593,0x5852,0xb6,0xbb,0x17,0xa2,0x17,0xe1,0x2f,0x9f] as IID_IIterator_1_Windows_ApplicationModel_Resources_Management_IndexedResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::resources::management::IndexedResourceQualifier> => [0x1a22ebee,0x7992,0x5198,0x97,0x2b,0x05,0x45,0x80,0x94,0x57,0x41] as IID_IIterator_1_Windows_ApplicationModel_Resources_Management_IndexedResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::search::core::SearchSuggestion> => [0xc3157582,0xf72f,0x513a,0xb0,0x89,0x62,0x08,0x18,0x8e,0xc2,0xb6] as IID_IIterator_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::socialinfo::SocialFeedItem> => [0xe7c8cd1f,0x3907,0x5da8,0x9d,0x72,0x90,0x42,0x6d,0xc3,0x70,0x72] as IID_IIterator_1_Windows_ApplicationModel_SocialInfo_SocialFeedItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::socialinfo::SocialItemThumbnail> => [0xfabcf39f,0xfd48,0x5550,0x8f,0x47,0xa0,0xf1,0x57,0x3e,0x1f,0x53] as IID_IIterator_1_Windows_ApplicationModel_SocialInfo_SocialItemThumbnail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::StartupTask> => [0x14653598,0x9065,0x508e,0xb3,0x7b,0x44,0xeb,0x28,0xd5,0x1c,0xb7] as IID_IIterator_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::store::preview::installcontrol::AppInstallItem> => [0xccaca81b,0x6cf7,0x56f0,0xb7,0xff,0x8a,0xc5,0x19,0x1e,0x79,0xbf] as IID_IIterator_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::store::preview::StorePreviewProductInfo> => [0x3fb16dec,0x73f1,0x5cfa,0x80,0xe6,0x67,0xfa,0x23,0x2d,0x1b,0xef] as IID_IIterator_1_Windows_ApplicationModel_Store_Preview_StorePreviewProductInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::store::preview::StorePreviewSkuInfo> => [0xb6f9b421,0x7f54,0x5d26,0x9c,0x37,0x9f,0x9d,0x7a,0xc8,0x93,0xeb] as IID_IIterator_1_Windows_ApplicationModel_Store_Preview_StorePreviewSkuInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::store::preview::StoreSystemFeature> => [0xd0455b2d,0xd8aa,0x557e,0x89,0xa3,0x63,0xc3,0x3e,0x8c,0xee,0x99] as IID_IIterator_1_Windows_ApplicationModel_Store_Preview_StoreSystemFeature }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::store::UnfulfilledConsumable> => [0xcb77cf2e,0xef57,0x5256,0x97,0x53,0x21,0x4b,0xaa,0xda,0x23,0x01] as IID_IIterator_1_Windows_ApplicationModel_Store_UnfulfilledConsumable }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::userdataaccounts::provider::UserDataAccountPartnerAccountInfo> => [0xac401b26,0x3ebf,0x5cbf,0x96,0x43,0xc9,0x6a,0x40,0xab,0x40,0xa2] as IID_IIterator_1_Windows_ApplicationModel_UserDataAccounts_Provider_UserDataAccountPartnerAccountInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::userdataaccounts::systemaccess::DeviceAccountConfiguration> => [0x51705a87,0x8dcb,0x5971,0x8d,0x6b,0xca,0x8a,0xe6,0xa9,0x55,0xad] as IID_IIterator_1_Windows_ApplicationModel_UserDataAccounts_SystemAccess_DeviceAccountConfiguration }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::userdataaccounts::UserDataAccount> => [0xe38246ab,0xdf01,0x5d16,0x92,0x3a,0x17,0xc8,0x8c,0xdb,0xac,0x29] as IID_IIterator_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::voicecommands::VoiceCommandContentTile> => [0x968d589c,0x0710,0x52f0,0x85,0xed,0x11,0x2f,0xac,0x4c,0xff,0x35] as IID_IIterator_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandContentTile }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IIterator<super::super::applicationmodel::wallet::WalletItem> => [0xe3ceb002,0xc2dd,0x5e63,0x91,0x3c,0xd7,0xd5,0x77,0x56,0x1e,0x73] as IID_IIterator_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<super::super::data::text::AlternateWordForm> => [0x7f463f8a,0xe08f,0x516e,0xb4,0xb8,0x81,0xb5,0x41,0x7b,0xfb,0x58] as IID_IIterator_1_Windows_Data_Text_AlternateWordForm }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<super::super::data::text::SelectableWordSegment> => [0xa5842459,0x147d,0x5a88,0x8f,0x23,0xa3,0x39,0x8a,0xfd,0x8a,0x85] as IID_IIterator_1_Windows_Data_Text_SelectableWordSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<super::super::data::text::TextPhoneme> => [0x36426c36,0xb5c4,0x5d1b,0xa4,0x68,0xaf,0xf3,0xb4,0x8b,0x7c,0x3a] as IID_IIterator_1_Windows_Data_Text_TextPhoneme }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<super::super::data::text::TextSegment> => [0x645a39b4,0xf001,0x5272,0x90,0x15,0xfb,0x4a,0x32,0x71,0x79,0xae] as IID_IIterator_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IIterator<super::super::data::text::WordSegment> => [0xaeb846b3,0x664b,0x545e,0xab,0x93,0xf5,0xfc,0x66,0xd2,0x4e,0x32] as IID_IIterator_1_Windows_Data_Text_WordSegment }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::adc::AdcController> => [0xa10b62c1,0xa014,0x5335,0x88,0x67,0x74,0x7f,0xca,0xb1,0x60,0x05] as IID_IIterator_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::adc::provider::IAdcControllerProvider> => [0xb43acf15,0xa24a,0x5b00,0xb7,0x10,0x17,0x37,0xba,0x55,0x0a,0x18] as IID_IIterator_1_Windows_Devices_Adc_Provider_IAdcControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::alljoyn::AllJoynAuthenticationMechanism> => [0x0fbc36d2,0xf46e,0x5a4d,0xaa,0x10,0x4c,0x80,0x6b,0x49,0x45,0xd6] as IID_IIterator_1_Windows_Devices_AllJoyn_AllJoynAuthenticationMechanism }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementBytePattern> => [0xb33e103a,0x1a61,0x5107,0x88,0x13,0xc0,0xe9,0x05,0xc0,0x54,0x86] as IID_IIterator_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementBytePattern }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementDataSection> => [0xaf5c0e81,0x788b,0x52d4,0x82,0xa2,0x1e,0xd2,0x8c,0x66,0xa0,0x5e] as IID_IIterator_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementDataSection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementReceivedEventArgs> => [0x096edbb8,0xecef,0x5724,0xbe,0x62,0x24,0x0d,0xcf,0xf6,0xac,0xa9] as IID_IIterator_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::advertisement::BluetoothLEManufacturerData> => [0x12f158dd,0x7016,0x5338,0xac,0x5c,0x7d,0x55,0x03,0xd7,0x32,0x74] as IID_IIterator_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEManufacturerData }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic> => [0x1ffc4777,0x4346,0x5564,0xb7,0xa5,0x59,0xea,0xe3,0x85,0xf4,0xf6] as IID_IIterator_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCharacteristic }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::genericattributeprofile::GattDescriptor> => [0x3d8df436,0xcefb,0x5ffb,0x85,0x8c,0x48,0x82,0xce,0x1d,0xa0,0x79] as IID_IIterator_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::genericattributeprofile::GattDeviceService> => [0x8beb3a26,0x73ca,0x50f3,0xa1,0xd3,0x41,0x8c,0x60,0xa9,0xf3,0xb2] as IID_IIterator_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::genericattributeprofile::GattPresentationFormat> => [0x20006c53,0x5dda,0x5319,0x91,0xb1,0xc6,0xf2,0x8f,0xe6,0x59,0x33] as IID_IIterator_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattPresentationFormat }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::bluetooth::rfcomm::RfcommDeviceService> => [0x64ab0132,0xc64c,0x5a87,0x81,0x13,0x61,0x3e,0xf3,0x56,0x92,0x4c] as IID_IIterator_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::enumeration::DeviceClass> => [0xc3807283,0x1416,0x593c,0x95,0x5c,0x0b,0x4a,0x28,0x6f,0xf7,0xbb] as IID_IIterator_1_Windows_Devices_Enumeration_DeviceClass }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::enumeration::DeviceInformation> => [0x6f85d843,0xe8ab,0x5b46,0x85,0xd7,0x32,0x7c,0x58,0xd1,0x87,0x12] as IID_IIterator_1_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::enumeration::DeviceWatcherEvent> => [0x74f7d6cc,0x9c20,0x5bb9,0xba,0xce,0xb2,0xff,0xa3,0x86,0x87,0xf9] as IID_IIterator_1_Windows_Devices_Enumeration_DeviceWatcherEvent }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::enumeration::DeviceWatcherEventKind> => [0xcb5ca9db,0xccd6,0x5103,0xa9,0x3d,0xc9,0x25,0xc9,0x08,0x83,0x8d] as IID_IIterator_1_Windows_Devices_Enumeration_DeviceWatcherEventKind }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::enumeration::pnp::PnpObject> => [0x6bb6d2f1,0xb5fb,0x57f0,0x82,0x51,0xf2,0x0c,0xde,0x5a,0x68,0x71] as IID_IIterator_1_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::BasicGeoposition> => [0x1b4e26a1,0x88e4,0x5872,0xbb,0x2d,0x4f,0x31,0x70,0x08,0x28,0xb2] as IID_IIterator_1_Windows_Devices_Geolocation_BasicGeoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::geofencing::Geofence> => [0xe7a9e144,0x202d,0x5708,0xa9,0xbd,0xe3,0xdc,0x0e,0x14,0xdf,0x46] as IID_IIterator_1_Windows_Devices_Geolocation_Geofencing_Geofence }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::geofencing::GeofenceStateChangeReport> => [0xeaff2de4,0x6650,0x544a,0xb7,0xac,0x6d,0x5b,0x81,0x9d,0x46,0x98] as IID_IIterator_1_Windows_Devices_Geolocation_Geofencing_GeofenceStateChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::Geopath> => [0xcf1d4402,0x4754,0x57e7,0xaa,0xe0,0x69,0xca,0x42,0xcb,0xd8,0xf2] as IID_IIterator_1_Windows_Devices_Geolocation_Geopath }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::Geopoint> => [0x88225b39,0x8be9,0x5c03,0x97,0x14,0x8f,0x16,0x42,0xd8,0xa4,0x3f] as IID_IIterator_1_Windows_Devices_Geolocation_Geopoint }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::geolocation::Geoposition> => [0xa99b4206,0x263e,0x5308,0x82,0xf2,0x31,0x31,0x5c,0x65,0x13,0x5c] as IID_IIterator_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::gpio::GpioController> => [0x67944db0,0x6c56,0x5a2f,0x9e,0x7b,0x63,0xca,0x1a,0xa8,0xc4,0x11] as IID_IIterator_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::gpio::provider::IGpioControllerProvider> => [0x6ac0edb9,0xe3c9,0x5840,0x8a,0xa8,0x1b,0xc4,0x53,0x66,0xf6,0xca] as IID_IIterator_1_Windows_Devices_Gpio_Provider_IGpioControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::humaninterfacedevice::HidBooleanControl> => [0x5cde3c23,0xd054,0x53d6,0xab,0xf1,0x41,0xe7,0x33,0x79,0xb4,0x72] as IID_IIterator_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControl }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::humaninterfacedevice::HidBooleanControlDescription> => [0x203203b0,0xb7f4,0x542d,0xb0,0xd0,0x9c,0xaa,0x1f,0xb5,0x5d,0x7f] as IID_IIterator_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::humaninterfacedevice::HidCollection> => [0xcefcee70,0xc7ff,0x57c1,0xa6,0x75,0xa0,0xdf,0x89,0x76,0xa9,0x88] as IID_IIterator_1_Windows_Devices_HumanInterfaceDevice_HidCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::humaninterfacedevice::HidNumericControlDescription> => [0x52b9c36e,0x7d95,0x5d1c,0xac,0xab,0x23,0xc1,0x9e,0xa7,0x6f,0x01] as IID_IIterator_1_Windows_Devices_HumanInterfaceDevice_HidNumericControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::i2c::I2cController> => [0x8f6822fc,0xe4ea,0x5b35,0x93,0x9a,0x27,0xf3,0xb3,0xd5,0x50,0xd2] as IID_IIterator_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::i2c::provider::II2cControllerProvider> => [0xf6232961,0xc660,0x50a1,0x82,0xe8,0x12,0x89,0x2f,0xcd,0x91,0xf7] as IID_IIterator_1_Windows_Devices_I2c_Provider_II2cControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::input::PointerDevice> => [0xde94641c,0x7960,0x5fcd,0xab,0xe8,0xd6,0xba,0x60,0x9e,0xf7,0xd3] as IID_IIterator_1_Windows_Devices_Input_PointerDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::input::PointerDeviceUsage> => [0x9ab2160d,0x11ef,0x5eca,0x8d,0xd9,0x3e,0x13,0xaa,0x4e,0x5f,0x99] as IID_IIterator_1_Windows_Devices_Input_PointerDeviceUsage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::perception::PerceptionColorFrameSource> => [0x24089f00,0xba6d,0x50d4,0xac,0x46,0xf2,0x88,0x75,0x5e,0x41,0x81] as IID_IIterator_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::perception::PerceptionDepthFrameSource> => [0x20cff8c2,0x7844,0x54e5,0xae,0x4f,0x57,0xe7,0x76,0x8f,0x9b,0x69] as IID_IIterator_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::perception::PerceptionInfraredFrameSource> => [0xb22b294f,0xa4d2,0x5726,0xa7,0xfc,0x5e,0x33,0x14,0x32,0xd9,0xb4] as IID_IIterator_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::perception::PerceptionVideoProfile> => [0x38ce8062,0x7079,0x5d7b,0x84,0x1f,0x9a,0xa4,0x58,0x0f,0xd5,0xf1] as IID_IIterator_1_Windows_Devices_Perception_PerceptionVideoProfile }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::perception::provider::PerceptionCorrelation> => [0xc4db1093,0xd705,0x5503,0x8b,0xce,0x68,0x53,0x5c,0xd4,0x2f,0xfa] as IID_IIterator_1_Windows_Devices_Perception_Provider_PerceptionCorrelation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::pointofservice::PosPrinterRotation> => [0xf687ef7c,0xb11e,0x56c3,0x91,0x58,0xe6,0xba,0x15,0xbd,0x52,0x1b] as IID_IIterator_1_Windows_Devices_PointOfService_PosPrinterRotation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::pwm::provider::IPwmControllerProvider> => [0x90389702,0xf036,0x56e1,0xa9,0x4f,0x6d,0x99,0xd5,0x2b,0x95,0x78] as IID_IIterator_1_Windows_Devices_Pwm_Provider_IPwmControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::pwm::PwmController> => [0x599330bd,0xb0ca,0x533e,0x93,0x8f,0x5d,0xd4,0x24,0x2b,0xf5,0x13] as IID_IIterator_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::radios::Radio> => [0xcf37ede7,0xeaec,0x5b8f,0xad,0x31,0x4d,0x51,0xab,0xd9,0xdb,0x05] as IID_IIterator_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sensors::ActivitySensorReading> => [0xd2dab535,0x0c94,0x547e,0xaf,0xe3,0x55,0x27,0xbc,0xbe,0xb9,0xcc] as IID_IIterator_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sensors::ActivitySensorReadingChangeReport> => [0x9c07034e,0x8333,0x59d5,0x8d,0x60,0x0e,0x3f,0x04,0x38,0xac,0x12] as IID_IIterator_1_Windows_Devices_Sensors_ActivitySensorReadingChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sensors::ActivityType> => [0x40524281,0xa7c6,0x50b1,0xb6,0xf5,0x0b,0xaa,0x95,0xd9,0x02,0xc2] as IID_IIterator_1_Windows_Devices_Sensors_ActivityType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sensors::PedometerReading> => [0x0ac70ed3,0x8553,0x5ef3,0x92,0xf8,0x43,0x86,0x09,0x62,0x30,0x87] as IID_IIterator_1_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sensors::ProximitySensorReading> => [0x1d4f08df,0x7f49,0x573b,0x93,0x6a,0x6d,0x4d,0x4e,0x61,0x09,0x30] as IID_IIterator_1_Windows_Devices_Sensors_ProximitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::smartcards::SmartCard> => [0x86b29903,0x916e,0x5817,0xbc,0x96,0xdf,0x32,0x44,0x75,0xe3,0x1a] as IID_IIterator_1_Windows_Devices_SmartCards_SmartCard }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sms::ISmsBinaryMessage> => [0x13e60d89,0xea0a,0x5b01,0x9c,0x2f,0x0e,0x5b,0x43,0x50,0x58,0xe0] as IID_IIterator_1_Windows_Devices_Sms_ISmsBinaryMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sms::ISmsMessage> => [0xeed04f5c,0xb2b2,0x5c83,0x8b,0x13,0xc7,0x8a,0xf6,0xca,0x3a,0x18] as IID_IIterator_1_Windows_Devices_Sms_ISmsMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sms::SmsBroadcastType> => [0x6448ddea,0xc1cd,0x5143,0xa4,0x22,0x5f,0xe4,0xf0,0x08,0xcc,0x92] as IID_IIterator_1_Windows_Devices_Sms_SmsBroadcastType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sms::SmsFilterRule> => [0xfec7cae6,0x97f5,0x5a19,0xb3,0x2a,0xd8,0xf0,0xba,0x27,0x6f,0x34] as IID_IIterator_1_Windows_Devices_Sms_SmsFilterRule }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::sms::SmsMessageRegistration> => [0xee1a0675,0xf3c9,0x5c12,0x93,0xe0,0xf2,0xb0,0x1b,0xdc,0xe6,0x11] as IID_IIterator_1_Windows_Devices_Sms_SmsMessageRegistration }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::spi::provider::ISpiControllerProvider> => [0xcf1d15d3,0xa6c8,0x56dd,0x80,0xc8,0xe8,0xd9,0x60,0x26,0x22,0x77] as IID_IIterator_1_Windows_Devices_Spi_Provider_ISpiControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::spi::SpiController> => [0xfd7d5997,0x544c,0x5be9,0xb0,0xfa,0x1d,0x0e,0xfb,0xfc,0x4a,0x03] as IID_IIterator_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbBulkInEndpointDescriptor> => [0xea511030,0x89c4,0x503d,0x8c,0xaf,0x66,0x7f,0x42,0x30,0xd2,0xa9] as IID_IIterator_1_Windows_Devices_Usb_UsbBulkInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbBulkInPipe> => [0xd7af2c5b,0x528d,0x5cbb,0xa9,0x97,0xd8,0x30,0xad,0xe7,0x04,0xc7] as IID_IIterator_1_Windows_Devices_Usb_UsbBulkInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbBulkOutEndpointDescriptor> => [0xa8b89ab3,0x883d,0x5361,0x99,0x03,0xf4,0x89,0xcc,0x62,0xbe,0xa5] as IID_IIterator_1_Windows_Devices_Usb_UsbBulkOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbBulkOutPipe> => [0x46dd2f6a,0x573b,0x5c45,0xb1,0x68,0x92,0x23,0x03,0x84,0x91,0xdd] as IID_IIterator_1_Windows_Devices_Usb_UsbBulkOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbDescriptor> => [0x521598ed,0x0167,0x528e,0x99,0x0d,0x52,0xab,0xb7,0x12,0xf0,0x72] as IID_IIterator_1_Windows_Devices_Usb_UsbDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterface> => [0x216b5a5f,0x63e3,0x5a9b,0x9c,0x99,0xb0,0x9c,0xbc,0x0f,0xf3,0xb1] as IID_IIterator_1_Windows_Devices_Usb_UsbInterface }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterfaceSetting> => [0x71267ec7,0x5697,0x5dea,0xb2,0xf8,0x14,0xcf,0x69,0x8e,0xc0,0xad] as IID_IIterator_1_Windows_Devices_Usb_UsbInterfaceSetting }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterruptInEndpointDescriptor> => [0x6717500f,0xec1c,0x5b12,0xbf,0x33,0x0e,0x3e,0x3d,0x24,0x45,0x87] as IID_IIterator_1_Windows_Devices_Usb_UsbInterruptInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterruptInPipe> => [0xe3a7b1c0,0x74f6,0x5292,0xa2,0x2a,0x67,0x2a,0xa2,0xb4,0x99,0x85] as IID_IIterator_1_Windows_Devices_Usb_UsbInterruptInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterruptOutEndpointDescriptor> => [0x4b6426db,0xdb32,0x5b51,0xad,0xad,0x04,0x53,0x2e,0xa9,0x4a,0xcd] as IID_IIterator_1_Windows_Devices_Usb_UsbInterruptOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::usb::UsbInterruptOutPipe> => [0xcbd8d8a8,0x2286,0x5cbd,0xa6,0xe4,0x96,0x27,0x42,0xff,0xd9,0x1a] as IID_IIterator_1_Windows_Devices_Usb_UsbInterruptOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::wifi::WiFiAdapter> => [0x144136c6,0xb502,0x5a52,0x90,0xfc,0x22,0xa0,0x93,0x18,0xf9,0x32] as IID_IIterator_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::wifi::WiFiAvailableNetwork> => [0x468677c4,0xebb9,0x5196,0x83,0x6d,0x72,0xfa,0xa9,0xfe,0x67,0x3e] as IID_IIterator_1_Windows_Devices_WiFi_WiFiAvailableNetwork }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::wifidirect::services::WiFiDirectServiceConfigurationMethod> => [0x19889f5e,0x49ae,0x5e31,0xb0,0x59,0x08,0x3f,0x9f,0x15,0x32,0xc3] as IID_IIterator_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::wifidirect::WiFiDirectConfigurationMethod> => [0x201940f9,0xa368,0x57f4,0x9e,0xf2,0x3f,0x64,0xe2,0x43,0xe0,0xa4] as IID_IIterator_1_Windows_Devices_WiFiDirect_WiFiDirectConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IIterator<super::super::devices::wifidirect::WiFiDirectInformationElement> => [0xcf806026,0xc915,0x553e,0xaf,0x3c,0x8d,0xa4,0x38,0x71,0xb6,0x93] as IID_IIterator_1_Windows_Devices_WiFiDirect_WiFiDirectInformationElement }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::input::ArcadeStick> => [0xd30629af,0xcc9d,0x52e1,0x8b,0x1f,0x0f,0xfa,0x96,0x29,0xaf,0xee] as IID_IIterator_1_Windows_Gaming_Input_ArcadeStick }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::input::Gamepad> => [0x246737e8,0x12bc,0x5c64,0xaf,0x52,0x06,0xdb,0x4b,0x13,0xfa,0x2f] as IID_IIterator_1_Windows_Gaming_Input_Gamepad }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::input::RacingWheel> => [0x23d735b8,0x4d36,0x5377,0xa2,0x45,0x69,0xdf,0x97,0xc9,0xfc,0xd9] as IID_IIterator_1_Windows_Gaming_Input_RacingWheel }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::input::UINavigationController> => [0xc10b2696,0x64a3,0x5262,0xbc,0x4f,0xb7,0x41,0xe5,0xd5,0xaf,0xab] as IID_IIterator_1_Windows_Gaming_Input_UINavigationController }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::preview::gamesenumeration::GameListEntry> => [0xed5b903e,0x5aeb,0x5d8c,0x95,0x38,0x83,0x06,0xf0,0x29,0x26,0xc3] as IID_IIterator_1_Windows_Gaming_Preview_GamesEnumeration_GameListEntry }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::xboxlive::storage::GameSaveBlobInfo> => [0xaaaf545b,0xf5e9,0x5da6,0xaf,0x70,0x9d,0x90,0x4c,0x7a,0x4d,0x37] as IID_IIterator_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobInfo }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IIterator<super::super::gaming::xboxlive::storage::GameSaveContainerInfo> => [0x0ecd9756,0x3e0d,0x523f,0xa5,0x49,0x2b,0x65,0x04,0xdb,0x52,0x02] as IID_IIterator_1_Windows_Gaming_XboxLive_Storage_GameSaveContainerInfo }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IIterator<super::super::globalization::JapanesePhoneme> => [0xf15ca7e7,0x69a8,0x564d,0x9c,0x20,0x4d,0xa7,0x5a,0x77,0x34,0x32] as IID_IIterator_1_Windows_Globalization_JapanesePhoneme }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IIterator<super::super::globalization::Language> => [0x30e99ae6,0xf414,0x5243,0x8d,0xb2,0xaa,0xb3,0x8e,0xa3,0xf1,0xf1] as IID_IIterator_1_Windows_Globalization_Language }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::directx::direct3d11::IDirect3DSurface> => [0xbdfb6d0b,0xe785,0x5d5a,0xab,0xd2,0xfe,0x1b,0x18,0xc4,0x32,0x57] as IID_IIterator_1_Windows_Graphics_DirectX_Direct3D11_IDirect3DSurface }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::directx::DirectXPixelFormat> => [0xea016190,0xac80,0x5840,0x8f,0x58,0xff,0x43,0x4c,0x7b,0x29,0x07] as IID_IIterator_1_Windows_Graphics_DirectX_DirectXPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::holographic::HolographicCamera> => [0x6acc8576,0x2fea,0x561d,0x84,0xdd,0x4a,0x1a,0xb0,0x5f,0xc7,0xed] as IID_IIterator_1_Windows_Graphics_Holographic_HolographicCamera }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::holographic::HolographicCameraPose> => [0x93e27fb4,0x332b,0x591e,0xae,0x6b,0x61,0x92,0xfa,0x0a,0x10,0x09] as IID_IIterator_1_Windows_Graphics_Holographic_HolographicCameraPose }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::imaging::BitmapCodecInformation> => [0x4ff2b2db,0x9326,0x537f,0xb8,0xdc,0x4c,0x93,0xd7,0x7f,0xbb,0x84] as IID_IIterator_1_Windows_Graphics_Imaging_BitmapCodecInformation }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::imaging::BitmapPixelFormat> => [0x7fc2e293,0x1084,0x5d45,0xb8,0xb8,0x93,0xe1,0x06,0x92,0xbc,0xc8] as IID_IIterator_1_Windows_Graphics_Imaging_BitmapPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::imaging::ImageStream> => [0x4a10752d,0x6b1a,0x5fec,0xa5,0x9c,0x70,0x38,0x9b,0xf1,0x62,0xa2] as IID_IIterator_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DBaseMaterial> => [0xdad4dd0d,0x59ab,0x501f,0x9d,0x6b,0xa2,0x09,0xc7,0xd5,0x46,0x49] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DBaseMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DBaseMaterialGroup> => [0xa34dc709,0xe2a7,0x5254,0x9d,0xc1,0xcd,0x47,0xe8,0x5e,0x25,0x04] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DBaseMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DColorMaterial> => [0x5a54a4a1,0x4d97,0x58d3,0xbd,0xcc,0x1b,0xf3,0x8b,0x43,0x8d,0x6d] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DColorMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DColorMaterialGroup> => [0x498467be,0xde0e,0x552b,0xb2,0x4e,0x8e,0xe2,0x5e,0xc9,0xa4,0x86] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DColorMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DComponent> => [0x2e9eabba,0x184b,0x5c14,0xae,0x5f,0xeb,0x63,0x4a,0xa7,0x17,0xe0] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DComponent }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DComponentWithMatrix> => [0x01d2ce44,0x8b63,0x571f,0xb9,0x2e,0xbf,0x2c,0xf7,0xcc,0x6d,0x53] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DComponentWithMatrix }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DCompositeMaterial> => [0xb7e6b17a,0xa885,0x5c97,0xb2,0x9e,0xbf,0x26,0x1e,0xb5,0xda,0xd4] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DCompositeMaterialGroup> => [0xaf86eea4,0xdd9d,0x5aa9,0xae,0xe5,0xbe,0x38,0x92,0x12,0x47,0x42] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DMesh> => [0x16ddf132,0xf80d,0x53b2,0xb0,0x9f,0xa4,0x2e,0xd9,0x68,0x9f,0xc4] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DMesh }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DModelTexture> => [0x3d473ca2,0x4a8c,0x5cbd,0x80,0x7f,0x49,0xaf,0x15,0x80,0xd2,0xba] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DModelTexture }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterial> => [0x614c0a0a,0xbf75,0x56ad,0xa3,0x04,0xb7,0x9f,0x60,0x01,0x7b,0x83] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterialGroup> => [0xa24bab9a,0xd946,0x5036,0xb1,0xc9,0x1c,0x09,0xb7,0x93,0xf3,0x6c] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DTexture2CoordMaterial> => [0x72d80d63,0x3626,0x5a2f,0xa5,0x79,0x78,0xe7,0x0a,0xa8,0x6d,0x46] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DTexture2CoordMaterialGroup> => [0x11eaecc4,0x6ac1,0x5697,0x9b,0xf5,0x1e,0xf6,0x17,0xe1,0xdf,0xeb] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IIterator<super::super::graphics::printing3d::Printing3DTextureResource> => [0x0678d5db,0x8fca,0x5084,0xa8,0x51,0x73,0x12,0xfe,0x53,0xf7,0x35] as IID_IIterator_1_Windows_Graphics_Printing3D_Printing3DTextureResource }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IIterator<super::super::management::deployment::PackageUserInformation> => [0x75660566,0xae43,0x5858,0xad,0xa6,0xd5,0x7d,0xda,0xe9,0x02,0x77] as IID_IIterator_1_Windows_Management_Deployment_PackageUserInformation }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IIterator<super::super::management::deployment::PackageVolume> => [0xa8d5b736,0x4e68,0x5ef1,0x9f,0x07,0xf0,0x68,0x37,0x98,0x8c,0x73] as IID_IIterator_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::audio::AudioGraphConnection> => [0x4af6a8fc,0xe7fb,0x5957,0x91,0xc1,0x2d,0xf9,0x60,0x0b,0x22,0xeb] as IID_IIterator_1_Windows_Media_Audio_AudioGraphConnection }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::audio::EqualizerBand> => [0xeb4f8b6a,0x7928,0x5f2f,0xb7,0xf2,0x7b,0x90,0xc0,0x84,0x35,0x6f] as IID_IIterator_1_Windows_Media_Audio_EqualizerBand }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::capture::frames::MediaFrameFormat> => [0x83a0cfaa,0x6546,0x5a63,0x8c,0xd7,0xf6,0x21,0x52,0xa7,0x5d,0x27] as IID_IIterator_1_Windows_Media_Capture_Frames_MediaFrameFormat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::capture::frames::MediaFrameSourceGroup> => [0xdc0c1f9a,0xb748,0x5cfa,0x9b,0x42,0xa3,0xa8,0xfe,0x37,0x28,0x1a] as IID_IIterator_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::capture::frames::MediaFrameSourceInfo> => [0x443c60d8,0x208e,0x5399,0xbc,0x44,0xed,0xc6,0xfe,0xf0,0x22,0x93] as IID_IIterator_1_Windows_Media_Capture_Frames_MediaFrameSourceInfo }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::capture::MediaCaptureVideoProfile> => [0xa9bc95f8,0xb5c0,0x5108,0xb9,0xed,0xa9,0x02,0x33,0x93,0x66,0xe9] as IID_IIterator_1_Windows_Media_Capture_MediaCaptureVideoProfile }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::capture::MediaCaptureVideoProfileMediaDescription> => [0xb3e8378f,0x710c,0x5126,0xa6,0xc9,0x8f,0x48,0x9f,0x63,0xe1,0x5e] as IID_IIterator_1_Windows_Media_Capture_MediaCaptureVideoProfileMediaDescription }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::casting::CastingSource> => [0x3f6c93e9,0xcc77,0x5ef4,0xb2,0xb7,0x25,0xcf,0xcf,0xc0,0x97,0x20] as IID_IIterator_1_Windows_Media_Casting_CastingSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::AudioStreamDescriptor> => [0xa61a11cd,0xb32e,0x518b,0xa6,0xa7,0x54,0x72,0xcb,0xe0,0x0e,0x83] as IID_IIterator_1_Windows_Media_Core_AudioStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::AudioTrack> => [0x138064ef,0x8693,0x5303,0x8a,0x75,0xeb,0xa4,0x94,0xd0,0x63,0x42] as IID_IIterator_1_Windows_Media_Core_AudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::IMediaCue> => [0x1a594dc8,0xa64b,0x55ed,0x9b,0x34,0x7b,0x27,0x4e,0x1d,0x5c,0x70] as IID_IIterator_1_Windows_Media_Core_IMediaCue }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::MseSourceBuffer> => [0x53076581,0x01a9,0x51b9,0x98,0xcc,0x52,0x65,0x50,0x4c,0xd3,0x52] as IID_IIterator_1_Windows_Media_Core_MseSourceBuffer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::MseTimeRange> => [0x92a36852,0xfbb3,0x5b48,0xb4,0xec,0x01,0xdd,0xa0,0x97,0x2a,0x5c] as IID_IIterator_1_Windows_Media_Core_MseTimeRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::TimedMetadataTrack> => [0x859354e5,0x077b,0x5d53,0xb2,0x97,0x1a,0x07,0xb9,0x7f,0x09,0xc3] as IID_IIterator_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::TimedTextLine> => [0x84c4fcac,0x86d8,0x5c74,0xa1,0x38,0xd9,0xbf,0x37,0xb7,0x49,0xec] as IID_IIterator_1_Windows_Media_Core_TimedTextLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::TimedTextSource> => [0xbdded7c0,0x5c73,0x57f5,0x9b,0x08,0x65,0x29,0x33,0x58,0x6d,0xd5] as IID_IIterator_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::TimedTextSubformat> => [0x65105e50,0x865c,0x591d,0x9b,0xf4,0x96,0x23,0x7d,0xe2,0x53,0x3f] as IID_IIterator_1_Windows_Media_Core_TimedTextSubformat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::VideoStreamDescriptor> => [0xda51ab3c,0x3c64,0x545c,0xa3,0xf4,0xf9,0xb0,0x55,0xaa,0xf7,0xd9] as IID_IIterator_1_Windows_Media_Core_VideoStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::core::VideoTrack> => [0xa7c8d22c,0xb59d,0x5d7a,0x8d,0x70,0x67,0xf8,0x98,0xa0,0xb8,0x77] as IID_IIterator_1_Windows_Media_Core_VideoTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::AdvancedPhotoMode> => [0xe6d0bc9d,0xe1cb,0x5ed0,0x8e,0xde,0x7d,0x03,0x7b,0xcc,0x2e,0x07] as IID_IIterator_1_Windows_Media_Devices_AdvancedPhotoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::AutoFocusRange> => [0x07489ac5,0x3c71,0x59c6,0xb7,0xdc,0x7f,0x21,0x34,0x1c,0x2f,0x71] as IID_IIterator_1_Windows_Media_Devices_AutoFocusRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::CaptureSceneMode> => [0xaafa6d7a,0x2f7f,0x5dd7,0xaa,0x0a,0x26,0x57,0x31,0xa2,0xb3,0xb3] as IID_IIterator_1_Windows_Media_Devices_CaptureSceneMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::core::FrameController> => [0x1440dc88,0x63ff,0x5a01,0xbb,0x93,0x39,0x0c,0x76,0x74,0x24,0x88] as IID_IIterator_1_Windows_Media_Devices_Core_FrameController }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::FocusMode> => [0xf9a43cd4,0xb300,0x541f,0xaf,0x79,0x3d,0xe3,0x40,0x0e,0x16,0xaf] as IID_IIterator_1_Windows_Media_Devices_FocusMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::FocusPreset> => [0xd3ebc8e9,0xf0c5,0x51c0,0xbb,0x86,0xbd,0xea,0x0a,0x69,0x46,0xfb] as IID_IIterator_1_Windows_Media_Devices_FocusPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::HdrVideoMode> => [0x3db61d13,0x0f30,0x5d2d,0x99,0xcb,0x30,0xc7,0xb9,0x00,0x98,0x78] as IID_IIterator_1_Windows_Media_Devices_HdrVideoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::IsoSpeedPreset> => [0x1b33af76,0x980b,0x5348,0x91,0x6a,0x79,0x3f,0x61,0xb5,0x55,0xa0] as IID_IIterator_1_Windows_Media_Devices_IsoSpeedPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::ManualFocusDistance> => [0xb02944e1,0xf649,0x511e,0x80,0xdd,0x2e,0x2b,0x20,0x37,0x9d,0xeb] as IID_IIterator_1_Windows_Media_Devices_ManualFocusDistance }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::OpticalImageStabilizationMode> => [0x4a165d46,0xcf19,0x5a03,0xbb,0x54,0x63,0xfc,0x2b,0x4e,0xd3,0x9b] as IID_IIterator_1_Windows_Media_Devices_OpticalImageStabilizationMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::RegionOfInterest> => [0x8eb80e4e,0x9691,0x594f,0x8b,0x3d,0xf5,0x2e,0xcc,0x0f,0x78,0x37] as IID_IIterator_1_Windows_Media_Devices_RegionOfInterest }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::devices::ZoomTransitionMode> => [0x80eb468a,0xfdc4,0x5c89,0x99,0xb8,0x8d,0x47,0x62,0x64,0xe2,0x11] as IID_IIterator_1_Windows_Media_Devices_ZoomTransitionMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::editing::BackgroundAudioTrack> => [0x18b0f692,0x8635,0x577a,0x9e,0xfa,0xcb,0x90,0x47,0x70,0xd6,0xe5] as IID_IIterator_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::editing::EmbeddedAudioTrack> => [0xc9fa7f51,0xb52c,0x578e,0x99,0xf9,0x01,0x2c,0xd5,0x64,0x12,0x47] as IID_IIterator_1_Windows_Media_Editing_EmbeddedAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::editing::MediaClip> => [0x2dfd20b2,0x06d8,0x577d,0xab,0x06,0x77,0x1e,0x04,0x14,0xfc,0x00] as IID_IIterator_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::editing::MediaOverlay> => [0x351f6f24,0x4a92,0x56d6,0xa1,0x87,0xfa,0xea,0xe7,0x48,0xe0,0xc7] as IID_IIterator_1_Windows_Media_Editing_MediaOverlay }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::editing::MediaOverlayLayer> => [0xca401ed8,0x63d2,0x525a,0x80,0xbb,0xe4,0x94,0x90,0x0c,0x4c,0xe6] as IID_IIterator_1_Windows_Media_Editing_MediaOverlayLayer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::effects::AudioEffect> => [0x673ce717,0xa3cf,0x5d68,0xa8,0x0b,0x5e,0xd3,0xe7,0xb9,0x3f,0xed] as IID_IIterator_1_Windows_Media_Effects_AudioEffect }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::effects::IAudioEffectDefinition> => [0xec0f39fc,0x6959,0x5423,0x9e,0x1a,0xf7,0xcb,0x8e,0x84,0x5c,0xa1] as IID_IIterator_1_Windows_Media_Effects_IAudioEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::effects::IVideoEffectDefinition> => [0x9d82379d,0x4958,0x558e,0xa1,0x55,0x3a,0x80,0x9b,0xb1,0x6c,0x04] as IID_IIterator_1_Windows_Media_Effects_IVideoEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::faceanalysis::DetectedFace> => [0xa0cf090e,0x0340,0x531f,0x89,0x8b,0xc2,0x1e,0xaf,0xb9,0xf4,0xae] as IID_IIterator_1_Windows_Media_FaceAnalysis_DetectedFace }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::IMediaMarker> => [0xf464661e,0x88bc,0x5cea,0x93,0xcd,0x0c,0x12,0x3f,0x17,0xd2,0x58] as IID_IIterator_1_Windows_Media_IMediaMarker }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportItem> => [0xd04d6068,0xb5a3,0x508e,0xbc,0x6b,0x1d,0xcd,0xfc,0xfb,0x0d,0x08] as IID_IIterator_1_Windows_Media_Import_PhotoImportItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportOperation> => [0x7c9dde1a,0xa8a1,0x5957,0x8e,0x0d,0xc4,0x01,0xd1,0x9c,0x92,0x37] as IID_IIterator_1_Windows_Media_Import_PhotoImportOperation }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportSidecar> => [0xaef5ebf0,0x1363,0x593a,0x86,0xd5,0xf9,0x2b,0xc2,0x30,0xbf,0xd6] as IID_IIterator_1_Windows_Media_Import_PhotoImportSidecar }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportSource> => [0x7d70f831,0x6ee4,0x5130,0xa7,0xb8,0x25,0x3a,0x21,0x15,0x4e,0x82] as IID_IIterator_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportStorageMedium> => [0x985cb948,0x9769,0x55dc,0x85,0xd9,0x12,0x5a,0x5d,0x03,0xd6,0xbb] as IID_IIterator_1_Windows_Media_Import_PhotoImportStorageMedium }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::import::PhotoImportVideoSegment> => [0xc4c16a75,0x3310,0x5ab9,0x93,0x07,0x78,0x75,0x5a,0xb1,0x09,0x4d] as IID_IIterator_1_Windows_Media_Import_PhotoImportVideoSegment }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::mediaproperties::AudioEncodingProperties> => [0x064b6aef,0x3bd0,0x5463,0x84,0x50,0x72,0xc6,0x16,0x9a,0xf5,0xd4] as IID_IIterator_1_Windows_Media_MediaProperties_AudioEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::mediaproperties::IMediaEncodingProperties> => [0x7c094aec,0xc8f3,0x5f49,0x99,0xc7,0xb6,0x6d,0x84,0x14,0x20,0x0e] as IID_IIterator_1_Windows_Media_MediaProperties_IMediaEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::mediaproperties::VideoEncodingProperties> => [0x094166ef,0xae5f,0x5315,0xa3,0xbf,0xfe,0x54,0xe8,0xc3,0x5f,0xcd] as IID_IIterator_1_Windows_Media_MediaProperties_VideoEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::ocr::OcrLine> => [0x52ca0f8a,0x5788,0x5695,0xb9,0x05,0x46,0xb8,0xd8,0x17,0x1d,0x88] as IID_IIterator_1_Windows_Media_Ocr_OcrLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::ocr::OcrWord> => [0x0ed4317a,0x9964,0x51c6,0xac,0xbe,0x02,0x51,0x2a,0x06,0x90,0x82] as IID_IIterator_1_Windows_Media_Ocr_OcrWord }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::playback::MediaBreak> => [0x9efd8746,0xf93c,0x524f,0x9f,0x95,0x4b,0x59,0x8a,0xcf,0x8d,0x25] as IID_IIterator_1_Windows_Media_Playback_MediaBreak }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::playback::MediaPlaybackItem> => [0xab074059,0x8c08,0x53e7,0x96,0x54,0x02,0xd2,0x59,0x8f,0xff,0x55] as IID_IIterator_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::protection::playready::IPlayReadyDomain> => [0x5c35e8a5,0x4ad7,0x5e70,0xbe,0xdf,0x91,0xf5,0xd5,0x88,0x8d,0x35] as IID_IIterator_1_Windows_Media_Protection_PlayReady_IPlayReadyDomain }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::protection::playready::IPlayReadyLicense> => [0x6a6d000a,0xce26,0x541b,0xa1,0x58,0x84,0x57,0x40,0x9b,0x26,0x04] as IID_IIterator_1_Windows_Media_Protection_PlayReady_IPlayReadyLicense }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::protection::playready::IPlayReadySecureStopServiceRequest> => [0x77b0419b,0x3f4b,0x5ef9,0xae,0x0b,0x88,0x11,0x43,0xb1,0x72,0xc9] as IID_IIterator_1_Windows_Media_Protection_PlayReady_IPlayReadySecureStopServiceRequest }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::protection::RevocationAndRenewalItem> => [0xdfb9655c,0x8b22,0x511f,0x8e,0xaf,0x3a,0xea,0x75,0x21,0x80,0x2b] as IID_IIterator_1_Windows_Media_Protection_RevocationAndRenewalItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::speechrecognition::ISpeechRecognitionConstraint> => [0x738f00b1,0xe18c,0x5140,0xa5,0x3a,0xf1,0x78,0x8d,0x10,0xc9,0x3d] as IID_IIterator_1_Windows_Media_SpeechRecognition_ISpeechRecognitionConstraint }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::speechrecognition::SpeechRecognitionResult> => [0x20756dd2,0x6d3f,0x5409,0x84,0x6a,0x0f,0x0f,0x01,0xd7,0xbf,0x9a] as IID_IIterator_1_Windows_Media_SpeechRecognition_SpeechRecognitionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IIterator<super::super::media::speechsynthesis::VoiceInformation> => [0x12d40a27,0xae8d,0x5fb0,0x8f,0xed,0x00,0x16,0x5d,0x59,0xc6,0xab] as IID_IIterator_1_Windows_Media_SpeechSynthesis_VoiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::backgroundtransfer::BackgroundTransferContentPart> => [0x07fbc351,0x781d,0x52c7,0x95,0x58,0xa4,0x53,0xe5,0x70,0x3f,0x29] as IID_IIterator_1_Windows_Networking_BackgroundTransfer_BackgroundTransferContentPart }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::backgroundtransfer::DownloadOperation> => [0x2ab61055,0x2d0a,0x59cb,0x8c,0xbd,0x05,0x6f,0x2d,0x7f,0xb4,0x54] as IID_IIterator_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::backgroundtransfer::UploadOperation> => [0xcaa85133,0x73d7,0x5f96,0xab,0x2d,0xfb,0xb4,0xfa,0x00,0xf7,0x15] as IID_IIterator_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::connectivity::AttributedNetworkUsage> => [0x4070c40f,0xab2f,0x56f2,0xb5,0x4c,0x82,0x32,0xae,0x86,0xaa,0xcd] as IID_IIterator_1_Windows_Networking_Connectivity_AttributedNetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::connectivity::ConnectionProfile> => [0x89913732,0xa08b,0x5cb2,0xaf,0x16,0xbb,0xbb,0x22,0x23,0x83,0x9e] as IID_IIterator_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::connectivity::ConnectivityInterval> => [0x741cea48,0x651c,0x5fd9,0x93,0x1e,0x4f,0x91,0xb5,0x21,0xe1,0x82] as IID_IIterator_1_Windows_Networking_Connectivity_ConnectivityInterval }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::connectivity::LanIdentifier> => [0x2c5d2f7e,0xce9c,0x5253,0xa0,0xf4,0x01,0xe5,0xbd,0xc1,0x19,0x88] as IID_IIterator_1_Windows_Networking_Connectivity_LanIdentifier }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::connectivity::NetworkUsage> => [0x5fafb57b,0x9c82,0x50a1,0x99,0x70,0x69,0xf9,0xcb,0x06,0x96,0x95] as IID_IIterator_1_Windows_Networking_Connectivity_NetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::EndpointPair> => [0xc899ff9f,0xe6f5,0x5673,0x81,0x0c,0x04,0xe2,0xff,0x98,0x70,0x4f] as IID_IIterator_1_Windows_Networking_EndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::HostName> => [0x557bf83c,0xa428,0x5dbd,0xa0,0xfe,0x05,0xf6,0xee,0x54,0x3d,0x45] as IID_IIterator_1_Windows_Networking_HostName }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandDeviceServiceInformation> => [0xd8d776f6,0x4692,0x5461,0x91,0x55,0x81,0x6e,0x63,0xba,0xc8,0x74] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandNetworkRegistrationStateChange> => [0x9cb0f858,0xe589,0x57a7,0x9d,0x01,0x2c,0x62,0x91,0x56,0x7c,0xc7] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandNetworkRegistrationStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandPinLockStateChange> => [0xe61b479f,0x7bd9,0x5550,0xbc,0x69,0xf9,0xc2,0xf7,0x1c,0x6a,0x05] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandPinLockStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandPinType> => [0x23efcf0c,0x1f8e,0x5bd9,0x8b,0x57,0xf0,0x85,0x01,0x21,0x20,0x1c] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandPinType }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandRadioStateChange> => [0xc088cec3,0x08e5,0x5f35,0xa2,0xb9,0x09,0x00,0xd0,0x28,0xc8,0x3b] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandRadioStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::MobileBroadbandUiccApp> => [0x4bb2066f,0x1b75,0x57cf,0xa7,0x22,0x1e,0x58,0xbf,0xc5,0xae,0x50] as IID_IIterator_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccApp }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::networkoperators::NetworkOperatorTetheringClient> => [0x5653d065,0xc708,0x5341,0xbc,0x05,0xd3,0xb9,0xce,0xcd,0x2a,0xc7] as IID_IIterator_1_Windows_Networking_NetworkOperators_NetworkOperatorTetheringClient }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::proximity::PeerInformation> => [0xeb6fe2c2,0xd6cd,0x5df0,0xa2,0x95,0x74,0xc5,0x6e,0xc5,0x8a,0xab] as IID_IIterator_1_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::servicediscovery::dnssd::DnssdServiceInstance> => [0xbc0cca83,0x44e5,0x5544,0xab,0x5b,0xe0,0x9d,0x66,0xf5,0xfd,0x5f] as IID_IIterator_1_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceInstance }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::IVpnCustomPrompt> => [0x6fc7cfe8,0x1882,0x5ba1,0x8e,0x5e,0x4c,0x5e,0x3a,0x4f,0xa8,0x6d] as IID_IIterator_1_Windows_Networking_Vpn_IVpnCustomPrompt }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::IVpnCustomPromptElement> => [0xee23ff21,0x51ba,0x5cc4,0x98,0x56,0x62,0x5c,0x79,0xc2,0x80,0x80] as IID_IIterator_1_Windows_Networking_Vpn_IVpnCustomPromptElement }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::IVpnProfile> => [0x91ccb492,0xec28,0x530b,0xb4,0x5e,0xc4,0x31,0x74,0x4c,0xa9,0xb5] as IID_IIterator_1_Windows_Networking_Vpn_IVpnProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::VpnAppId> => [0xec9298b0,0x8ca2,0x549c,0xbb,0xe2,0x25,0x28,0x23,0xe7,0x0e,0xef] as IID_IIterator_1_Windows_Networking_Vpn_VpnAppId }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::VpnDomainNameInfo> => [0x29f9008e,0x3e81,0x5c58,0x8a,0x78,0x6b,0xe9,0x1a,0xbc,0xc1,0x7d] as IID_IIterator_1_Windows_Networking_Vpn_VpnDomainNameInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::VpnNamespaceInfo> => [0x91e28244,0x7555,0x594d,0xb5,0x4d,0x9c,0x87,0x09,0x5e,0x79,0xa2] as IID_IIterator_1_Windows_Networking_Vpn_VpnNamespaceInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::VpnRoute> => [0x44f813ac,0x052f,0x514b,0xa7,0x76,0xaa,0xd3,0x7a,0x64,0xfd,0xc6] as IID_IIterator_1_Windows_Networking_Vpn_VpnRoute }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::vpn::VpnTrafficFilter> => [0x8f37d5a0,0x5905,0x55bf,0x9c,0x18,0xb9,0xb3,0xb5,0x44,0x64,0x8b] as IID_IIterator_1_Windows_Networking_Vpn_VpnTrafficFilter }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveDeviceAddress> => [0x85fb7103,0xef5e,0x5746,0x93,0x41,0x1d,0xfb,0xb2,0x1d,0x72,0x0d] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveDeviceAddress }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveEndpointPair> => [0xe796a96b,0x98a0,0x52a2,0xbb,0x54,0x9d,0xba,0x5b,0xb6,0x4f,0xc4] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveEndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveEndpointPairTemplate> => [0x515331c6,0x39e1,0x5cc7,0x84,0x54,0x7f,0x1c,0x8b,0xcb,0xa1,0x8e] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveEndpointPairTemplate }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetric> => [0xb281ef1a,0x56bc,0x5daa,0xbb,0xe2,0x65,0xe6,0x17,0xb4,0x99,0x25] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetric }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetricResult> => [0xe0696826,0x0069,0x57d6,0x9a,0xd8,0xd0,0xb3,0x68,0x62,0x9e,0x2e] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetricResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IIterator<super::super::networking::xboxlive::XboxLiveQualityOfServicePrivatePayloadResult> => [0xeb5bfdf4,0x7897,0x5cbf,0xaa,0xa5,0x35,0x82,0xfa,0xfb,0x4d,0x78] as IID_IIterator_1_Windows_Networking_XboxLive_XboxLiveQualityOfServicePrivatePayloadResult }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IIterator<super::super::perception::spatial::SpatialBoundingVolume> => [0xeb8385c5,0x0775,0x5415,0x8f,0x76,0x32,0x7e,0x6e,0x38,0x8a,0xc5] as IID_IIterator_1_Windows_Perception_Spatial_SpatialBoundingVolume }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::identity::core::MicrosoftAccountMultiFactorSessionInfo> => [0xfd6d2ade,0x0fd3,0x5cd0,0xb8,0x6e,0xd2,0x4a,0xd9,0xa2,0x09,0x2c] as IID_IIterator_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorSessionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::identity::EnterpriseKeyCredentialRegistrationInfo> => [0xe3497259,0x1737,0x5fad,0x80,0x3b,0x9d,0x2d,0x29,0x27,0x3e,0x3b] as IID_IIterator_1_Windows_Security_Authentication_Identity_EnterpriseKeyCredentialRegistrationInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::identity::provider::SecondaryAuthenticationFactorInfo> => [0x0eedbda6,0x2de0,0x50af,0xab,0xc4,0x46,0x07,0x32,0x45,0xfb,0x2d] as IID_IIterator_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::onlineid::OnlineIdServiceTicket> => [0x039feee7,0x0882,0x50e2,0xbc,0x3f,0x4f,0xac,0x7e,0x8c,0x27,0x69] as IID_IIterator_1_Windows_Security_Authentication_OnlineId_OnlineIdServiceTicket }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::onlineid::OnlineIdServiceTicketRequest> => [0xb6a5c8e4,0x6e3c,0x5c37,0x92,0xcf,0xcf,0x9f,0x1c,0x38,0x33,0x35] as IID_IIterator_1_Windows_Security_Authentication_OnlineId_OnlineIdServiceTicketRequest }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::web::core::WebTokenResponse> => [0xf080b0c9,0xa095,0x5b3a,0xa1,0xdc,0xd1,0x7e,0x7d,0x29,0x82,0xc7] as IID_IIterator_1_Windows_Security_Authentication_Web_Core_WebTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::web::provider::WebAccountClientView> => [0xa5984607,0x661d,0x5e9c,0xa0,0xba,0x5c,0x7d,0x5f,0x41,0xaf,0x1c] as IID_IIterator_1_Windows_Security_Authentication_Web_Provider_WebAccountClientView }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::authentication::web::provider::WebProviderTokenResponse> => [0xeb57825d,0x5ad6,0x5ee0,0x8d,0xc6,0xa5,0x3c,0x1e,0x82,0xe3,0xab] as IID_IIterator_1_Windows_Security_Authentication_Web_Provider_WebProviderTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::credentials::PasswordCredential> => [0xb01093d8,0x4f52,0x50f0,0x9a,0xa4,0xe2,0x26,0x39,0x11,0x11,0x62] as IID_IIterator_1_Windows_Security_Credentials_PasswordCredential }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::credentials::WebAccount> => [0xbfb82cca,0xaebc,0x567c,0x95,0xd9,0xeb,0xa2,0x5c,0x36,0x5f,0xaa] as IID_IIterator_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::cryptography::certificates::Certificate> => [0x676fc159,0xf15c,0x58bd,0x91,0xa7,0x28,0xf7,0xe7,0x95,0xc7,0x56] as IID_IIterator_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::cryptography::certificates::ChainValidationResult> => [0x8bcad2b7,0x0e3b,0x5eae,0xbf,0x69,0xe1,0xf6,0xd9,0xc8,0x88,0xf8] as IID_IIterator_1_Windows_Security_Cryptography_Certificates_ChainValidationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IIterator<super::super::security::cryptography::certificates::CmsSignerInfo> => [0xba691628,0xd419,0x5e0a,0xb9,0x24,0x03,0xeb,0xc2,0x36,0xb1,0x1e] as IID_IIterator_1_Windows_Security_Cryptography_Certificates_CmsSignerInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::guidance::GuidanceLaneInfo> => [0x4d4ce4d8,0x7ce0,0x5168,0xab,0x29,0x6b,0xcf,0x7f,0x19,0x8a,0x58] as IID_IIterator_1_Windows_Services_Maps_Guidance_GuidanceLaneInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::guidance::GuidanceManeuver> => [0x74a37092,0x2641,0x5c3d,0xb3,0xcb,0x68,0x9d,0xc8,0xab,0xa2,0x2e] as IID_IIterator_1_Windows_Services_Maps_Guidance_GuidanceManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::guidance::GuidanceRoadSegment> => [0x148cb8ff,0x3ab9,0x53ab,0x88,0x24,0x25,0x6a,0x62,0x04,0x7b,0x43] as IID_IIterator_1_Windows_Services_Maps_Guidance_GuidanceRoadSegment }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::localsearch::LocalLocation> => [0xa23c2e87,0xa8e7,0x568f,0x96,0xa1,0x69,0xe9,0x8f,0x86,0xb9,0xd3] as IID_IIterator_1_Windows_Services_Maps_LocalSearch_LocalLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::localsearch::LocalLocationHoursOfOperationItem> => [0x3f9ba5c0,0xb2dc,0x5777,0xa8,0x1e,0xb0,0xa2,0x83,0x9b,0x15,0x2b] as IID_IIterator_1_Windows_Services_Maps_LocalSearch_LocalLocationHoursOfOperationItem }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::MapLocation> => [0x2a704d9a,0x3997,0x5f1e,0x86,0x41,0x88,0x3e,0xba,0x40,0x87,0x26] as IID_IIterator_1_Windows_Services_Maps_MapLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::MapRoute> => [0x97e8485a,0x79c0,0x5343,0x93,0xd1,0x47,0xcd,0xfb,0x55,0x24,0x6b] as IID_IIterator_1_Windows_Services_Maps_MapRoute }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::MapRouteLeg> => [0xdd1be7d2,0xde62,0x5752,0xb2,0xe0,0xa2,0xb0,0x87,0x23,0xb7,0x87] as IID_IIterator_1_Windows_Services_Maps_MapRouteLeg }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::maps::MapRouteManeuver> => [0xa7ab048b,0xa6dc,0x5e4c,0x93,0x21,0x71,0xb0,0xe4,0x65,0xdf,0xe8] as IID_IIterator_1_Windows_Services_Maps_MapRouteManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StoreAvailability> => [0x50511ccb,0x089e,0x5b73,0xbb,0x4a,0x4d,0x1e,0xf7,0x7b,0x8f,0x0f] as IID_IIterator_1_Windows_Services_Store_StoreAvailability }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StoreImage> => [0xfbe076f6,0xc3d2,0x5df7,0x83,0x9f,0x01,0x2a,0xc0,0xf9,0x51,0xc5] as IID_IIterator_1_Windows_Services_Store_StoreImage }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StorePackageUpdate> => [0xb75dd77b,0x87ca,0x5956,0x89,0x02,0x84,0xe9,0xff,0xc9,0x7d,0x83] as IID_IIterator_1_Windows_Services_Store_StorePackageUpdate }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StorePackageUpdateStatus> => [0x6181d84f,0xf731,0x57b8,0x9a,0x6b,0x8a,0x12,0xfc,0xd5,0x8d,0x04] as IID_IIterator_1_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StoreSku> => [0x365cde92,0x7fe3,0x59d5,0xb8,0xf8,0x8f,0x05,0xac,0xf5,0x09,0x47] as IID_IIterator_1_Windows_Services_Store_StoreSku }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IIterator<super::super::services::store::StoreVideo> => [0x91b0b554,0xa537,0x5e22,0xb3,0x9f,0x6a,0x93,0x5d,0x0b,0xef,0x45] as IID_IIterator_1_Windows_Services_Store_StoreVideo }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::accesscache::AccessListEntry> => [0xd1a0a6c4,0x889d,0x519b,0x85,0x08,0x26,0x24,0x1b,0x32,0x9b,0x7e] as IID_IIterator_1_Windows_Storage_AccessCache_AccessListEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::bulkaccess::FileInformation> => [0xbf2f6543,0x230e,0x50bf,0x9c,0x57,0x9e,0x4b,0xa8,0x63,0x59,0x03] as IID_IIterator_1_Windows_Storage_BulkAccess_FileInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::bulkaccess::FolderInformation> => [0xff68b5b6,0xcaad,0x553a,0x98,0x08,0x95,0xee,0xa7,0x00,0xc9,0xde] as IID_IIterator_1_Windows_Storage_BulkAccess_FolderInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::bulkaccess::IStorageItemInformation> => [0x3da6401d,0x1279,0x55a1,0x96,0x2c,0x25,0xcd,0x23,0xb9,0x9b,0x27] as IID_IIterator_1_Windows_Storage_BulkAccess_IStorageItemInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::IStorageFile> => [0x314d2318,0x74ee,0x535c,0xb3,0x61,0x21,0x44,0xdb,0xc5,0x73,0xa0] as IID_IIterator_1_Windows_Storage_IStorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::IStorageItem> => [0x05b487c2,0x3830,0x5d3c,0x98,0xda,0x25,0xfa,0x11,0x54,0x2d,0xbd] as IID_IIterator_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::search::IIndexableContent> => [0x6cdb32ba,0x2361,0x57a8,0xa3,0x9d,0xbe,0x1d,0xf0,0x41,0xbd,0xb8] as IID_IIterator_1_Windows_Storage_Search_IIndexableContent }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::search::SortEntry> => [0x520434a2,0xacf7,0x58c9,0xb4,0x7a,0x27,0x41,0xf2,0xfa,0xc2,0xc2] as IID_IIterator_1_Windows_Storage_Search_SortEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::StorageFile> => [0x43e29f53,0x0298,0x55aa,0xa6,0xc8,0x4e,0xdd,0x32,0x3d,0x95,0x98] as IID_IIterator_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::StorageFolder> => [0x5aac96fb,0xb3b9,0x5a7f,0xa9,0x20,0x4b,0x5a,0x8d,0xf8,0x11,0x68] as IID_IIterator_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::StorageLibrary> => [0x0a1c6409,0xfbd3,0x58c8,0x9a,0xf3,0x62,0x62,0xcc,0x56,0xe5,0xb3] as IID_IIterator_1_Windows_Storage_StorageLibrary }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::StorageLibraryChange> => [0xc48a1103,0x56e6,0x5398,0x84,0xfe,0x92,0xed,0xad,0x7f,0xc1,0x11] as IID_IIterator_1_Windows_Storage_StorageLibraryChange }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::streams::IBuffer> => [0xafee38e0,0xf882,0x5f10,0x96,0x55,0x1f,0xc9,0x8c,0xc8,0xcc,0xe5] as IID_IIterator_1_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IIterator<super::super::storage::streams::IRandomAccessStream> => [0xc875446a,0x587f,0x58da,0x89,0x7e,0x3b,0xbe,0x5e,0xc7,0xc3,0x0b] as IID_IIterator_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterator<super::super::system::diagnostics::ProcessDiagnosticInfo> => [0xa89b4418,0x4c3b,0x5f49,0xb9,0x57,0x78,0x56,0x97,0xc9,0x9a,0xbf] as IID_IIterator_1_Windows_System_Diagnostics_ProcessDiagnosticInfo }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterator<super::super::system::remotesystems::IRemoteSystemFilter> => [0x6a2c5aef,0x9f30,0x58ae,0xa6,0xcb,0x9a,0xc9,0xc8,0x09,0x2a,0x41] as IID_IIterator_1_Windows_System_RemoteSystems_IRemoteSystemFilter }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IIterator<super::super::system::User> => [0x326fe162,0x582b,0x5659,0xb8,0xa4,0x68,0xff,0x0f,0x52,0x57,0x45] as IID_IIterator_1_Windows_System_User }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::applicationsettings::CredentialCommand> => [0x9f1177f1,0x85bb,0x5cd0,0x9b,0x08,0xa0,0xb4,0x7a,0x76,0x4c,0x75] as IID_IIterator_1_Windows_UI_ApplicationSettings_CredentialCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::applicationsettings::SettingsCommand> => [0x2f071c24,0x4a58,0x5a00,0xa2,0x94,0xc7,0x16,0x2e,0x98,0xc2,0xa0] as IID_IIterator_1_Windows_UI_ApplicationSettings_SettingsCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::applicationsettings::WebAccountCommand> => [0x8cbb62b6,0xbd9c,0x5486,0x9d,0x14,0x9c,0xc4,0x62,0x7b,0x32,0xd4] as IID_IIterator_1_Windows_UI_ApplicationSettings_WebAccountCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::applicationsettings::WebAccountProviderCommand> => [0x82d7cd74,0x8e33,0x5f06,0x92,0xfc,0x91,0x51,0x38,0xaa,0xcb,0xde] as IID_IIterator_1_Windows_UI_ApplicationSettings_WebAccountProviderCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::Color> => [0xc4310b12,0x7ac2,0x5e5b,0xb5,0x11,0xe5,0x46,0xee,0xa4,0x73,0xb4] as IID_IIterator_1_Windows_UI_Color }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::composition::interactions::InteractionTrackerInertiaModifier> => [0x46617d87,0x2cd2,0x5e31,0x9a,0x30,0xea,0x86,0xf8,0xaa,0x7c,0xa1] as IID_IIterator_1_Windows_UI_Composition_Interactions_InteractionTrackerInertiaModifier }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::core::animationmetrics::IPropertyAnimation> => [0xbb6799d3,0x9f1a,0x5a4e,0xa9,0x40,0x94,0x5f,0x1a,0xb8,0xc4,0xfe] as IID_IIterator_1_Windows_UI_Core_AnimationMetrics_IPropertyAnimation }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::inking::InkPoint> => [0x47415452,0xdb79,0x567e,0x84,0xd5,0xe9,0x91,0x23,0x30,0xf9,0x44] as IID_IIterator_1_Windows_UI_Input_Inking_InkPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::inking::InkRecognitionResult> => [0x9abc247f,0x0223,0x5f44,0x8f,0xa1,0x0d,0x6d,0x69,0x1b,0xf9,0xaf] as IID_IIterator_1_Windows_UI_Input_Inking_InkRecognitionResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::inking::InkRecognizer> => [0xf8bd3097,0x5262,0x5e7a,0xa1,0x9d,0x13,0xc0,0x29,0xd2,0xd7,0xe5] as IID_IIterator_1_Windows_UI_Input_Inking_InkRecognizer }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::inking::InkStroke> => [0x5608d5a9,0xe7e4,0x5a0b,0x94,0x1f,0xb7,0xfe,0xd7,0x6b,0x35,0xbf] as IID_IIterator_1_Windows_UI_Input_Inking_InkStroke }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::inking::InkStrokeRenderingSegment> => [0xd7d8c317,0x6f3f,0x5192,0x92,0x10,0x65,0xa2,0x63,0xba,0xf8,0xd1] as IID_IIterator_1_Windows_UI_Input_Inking_InkStrokeRenderingSegment }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::PointerPoint> => [0x721fe01c,0x5ad4,0x5262,0xb0,0x78,0x3a,0xb3,0x45,0x10,0x5d,0xb8] as IID_IIterator_1_Windows_UI_Input_PointerPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::preview::injection::InjectedInputKeyboardInfo> => [0x500e5efe,0x3bc1,0x5d9b,0xbc,0xfc,0xc1,0xf4,0x39,0x50,0x5f,0x12] as IID_IIterator_1_Windows_UI_Input_Preview_Injection_InjectedInputKeyboardInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::preview::injection::InjectedInputMouseInfo> => [0x9604d1d9,0x1744,0x5bd3,0xb5,0xb9,0xd4,0x7b,0x94,0x34,0xfa,0xcb] as IID_IIterator_1_Windows_UI_Input_Preview_Injection_InjectedInputMouseInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::preview::injection::InjectedInputTouchInfo> => [0x4bc92e92,0xd32e,0x597a,0xae,0x24,0xb3,0x88,0x61,0xc5,0xfb,0x08] as IID_IIterator_1_Windows_UI_Input_Preview_Injection_InjectedInputTouchInfo }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::RadialControllerMenuItem> => [0x5a773e24,0xd968,0x535e,0x96,0x9a,0x76,0xce,0x36,0x02,0xa6,0x37] as IID_IIterator_1_Windows_UI_Input_RadialControllerMenuItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::RadialControllerSystemMenuItemKind> => [0x3fbc1858,0xa43e,0x54dc,0xb0,0xe2,0x8b,0x09,0x8b,0xdd,0xac,0xf6] as IID_IIterator_1_Windows_UI_Input_RadialControllerSystemMenuItemKind }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::input::spatial::SpatialInteractionSourceState> => [0x23f50032,0x907e,0x5d73,0xbb,0xdc,0xf7,0x56,0x3d,0xe6,0x55,0xc4] as IID_IIterator_1_Windows_UI_Input_Spatial_SpatialInteractionSourceState }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::AdaptiveNotificationText> => [0x18015daa,0xcbc3,0x5a51,0x9f,0x4b,0x3c,0x06,0x91,0x35,0xb0,0xe0] as IID_IIterator_1_Windows_UI_Notifications_AdaptiveNotificationText }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::NotificationBinding> => [0x66187f56,0x9ee1,0x5c48,0x82,0xda,0x6c,0xb9,0xdd,0xf8,0x79,0xe7] as IID_IIterator_1_Windows_UI_Notifications_NotificationBinding }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::ScheduledTileNotification> => [0x5665e491,0x6543,0x5036,0x93,0x5f,0xb5,0x15,0x79,0x50,0xb3,0x59] as IID_IIterator_1_Windows_UI_Notifications_ScheduledTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::ScheduledToastNotification> => [0x304238b6,0x888a,0x5dd2,0x96,0xcd,0xbf,0xca,0x89,0x27,0x48,0x3b] as IID_IIterator_1_Windows_UI_Notifications_ScheduledToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::ShownTileNotification> => [0x04d8d70b,0x7c15,0x5f60,0x98,0x94,0xb2,0x13,0x66,0xb4,0x27,0xc2] as IID_IIterator_1_Windows_UI_Notifications_ShownTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::ToastNotification> => [0xfe1e726a,0x3aa9,0x5d98,0xb1,0x9b,0x97,0xe3,0xe1,0x7e,0xec,0x7b] as IID_IIterator_1_Windows_UI_Notifications_ToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::notifications::UserNotification> => [0x6ee1200d,0xdd13,0x5050,0x88,0xcb,0x53,0x52,0xaf,0x11,0x3f,0xd1] as IID_IIterator_1_Windows_UI_Notifications_UserNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::popups::IUICommand> => [0xf45db3d3,0x7299,0x57ce,0xa7,0x3e,0x29,0x7c,0xf0,0xaf,0x30,0x83] as IID_IIterator_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::startscreen::JumpListItem> => [0xf69f5cc4,0x004f,0x53eb,0x89,0xe6,0x78,0x6e,0x46,0x05,0x88,0xa4] as IID_IIterator_1_Windows_UI_StartScreen_JumpListItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::startscreen::SecondaryTile> => [0x391f7579,0xa90e,0x5352,0x9d,0x01,0xfd,0xa9,0x95,0xd7,0x91,0x2f] as IID_IIterator_1_Windows_UI_StartScreen_SecondaryTile }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::startscreen::SecondaryTileVisualElements> => [0xbbc6e16c,0xcace,0x5230,0x88,0x04,0x22,0x98,0x37,0x51,0x68,0xac] as IID_IIterator_1_Windows_UI_StartScreen_SecondaryTileVisualElements }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IIterator<super::super::ui::text::core::CoreTextCompositionSegment> => [0x39b4528d,0x2370,0x57fa,0xb5,0xd4,0xb5,0xa2,0x07,0x9a,0x7c,0xea] as IID_IIterator_1_Windows_UI_Text_Core_CoreTextCompositionSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::automation::AutomationAnnotation> => [0x7ed32ba3,0xdb0c,0x5a54,0xab,0x43,0x30,0x62,0x8a,0xfb,0xc2,0xd8] as IID_IIterator_1_Windows_UI_Xaml_Automation_AutomationAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::automation::peers::AutomationPeer> => [0x1f93cd7a,0x8075,0x5ba9,0xbc,0x3e,0xb0,0x4a,0x94,0xe1,0x4b,0xc0] as IID_IIterator_1_Windows_UI_Xaml_Automation_Peers_AutomationPeer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::automation::peers::AutomationPeerAnnotation> => [0x3b415733,0x48f2,0x58b0,0x98,0x84,0x6f,0x0d,0x0e,0x35,0xdc,0x1a] as IID_IIterator_1_Windows_UI_Xaml_Automation_Peers_AutomationPeerAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::ColumnDefinition> => [0x264ebc1f,0xed90,0x528e,0xbf,0x80,0xe9,0xf7,0xe0,0x2c,0x0e,0xe4] as IID_IIterator_1_Windows_UI_Xaml_Controls_ColumnDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::GroupStyle> => [0x4b1bfdea,0x343f,0x5b34,0x96,0xf4,0x75,0x3d,0x57,0x22,0x7e,0xb9] as IID_IIterator_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::HubSection> => [0x4f845272,0xf53e,0x5652,0xb0,0x08,0xa8,0xfb,0xf1,0xe0,0x91,0xef] as IID_IIterator_1_Windows_UI_Xaml_Controls_HubSection }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::ICommandBarElement> => [0xcddb0380,0xe9d7,0x5264,0xab,0x5c,0xd7,0x2b,0x64,0x28,0x74,0xc9] as IID_IIterator_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::maps::MapElement> => [0xf916b428,0x3b74,0x5ad4,0x9d,0x97,0x1b,0x0a,0x38,0x7a,0xec,0xb5] as IID_IIterator_1_Windows_UI_Xaml_Controls_Maps_MapElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::maps::MapRouteView> => [0xaf256095,0x4144,0x55a7,0x91,0x39,0x89,0x84,0x3b,0x57,0x2d,0xb7] as IID_IIterator_1_Windows_UI_Xaml_Controls_Maps_MapRouteView }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::maps::MapTileSource> => [0xe5c7eba6,0x7c75,0x50bc,0x8b,0x36,0x2d,0x8c,0xa1,0xfa,0x53,0x8b] as IID_IIterator_1_Windows_UI_Xaml_Controls_Maps_MapTileSource }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::MenuFlyoutItemBase> => [0x2a8a81ef,0xf351,0x50a7,0xbc,0xdc,0x83,0x68,0xdf,0x21,0x52,0x80] as IID_IIterator_1_Windows_UI_Xaml_Controls_MenuFlyoutItemBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::primitives::Popup> => [0x5bcb0970,0x5472,0x56e8,0xb1,0x84,0xd0,0x1f,0xb8,0x1e,0x40,0x8a] as IID_IIterator_1_Windows_UI_Xaml_Controls_Primitives_Popup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::RowDefinition> => [0x2655d45d,0x38c6,0x53f0,0x87,0x19,0xf3,0xc3,0xa7,0x39,0xc1,0xf9] as IID_IIterator_1_Windows_UI_Xaml_Controls_RowDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::controls::WebViewDeferredPermissionRequest> => [0xa6ed0a56,0x801b,0x5301,0x95,0xba,0xdf,0x84,0xd0,0x27,0xa9,0x77] as IID_IIterator_1_Windows_UI_Xaml_Controls_WebViewDeferredPermissionRequest }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::data::ItemIndexRange> => [0x9c223a26,0x0c81,0x59f6,0xa9,0x09,0xba,0x49,0x66,0xb4,0xcf,0x24] as IID_IIterator_1_Windows_UI_Xaml_Data_ItemIndexRange }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::DependencyObject> => [0x29f8d454,0x905d,0x587e,0xb9,0xd8,0xbf,0xd4,0x18,0x80,0x5a,0x65] as IID_IIterator_1_Windows_UI_Xaml_DependencyObject }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::documents::Block> => [0x798d518e,0xa9f8,0x5fc7,0x8c,0xcc,0x2a,0x49,0x06,0x9a,0xba,0x05] as IID_IIterator_1_Windows_UI_Xaml_Documents_Block }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::documents::Inline> => [0xf80dc964,0x2542,0x5c6a,0xba,0x65,0xb0,0x48,0x24,0xb5,0xed,0x75] as IID_IIterator_1_Windows_UI_Xaml_Documents_Inline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::input::InputScopeName> => [0x7ac16ff4,0x5857,0x5001,0xb8,0x7f,0x32,0x70,0x93,0xf6,0x83,0x92] as IID_IIterator_1_Windows_UI_Xaml_Input_InputScopeName }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::input::Pointer> => [0x8cb1347d,0x8888,0x5fb3,0xbf,0xfd,0xe6,0xca,0xf6,0x1b,0x4f,0x03] as IID_IIterator_1_Windows_UI_Xaml_Input_Pointer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::ColorKeyFrame> => [0x36a6440d,0xaa86,0x5bce,0x8d,0xf2,0x5d,0xe9,0x92,0x06,0xf1,0x51] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_ColorKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::DoubleKeyFrame> => [0xca007bbd,0x84a1,0x512f,0x97,0x7f,0x9b,0xd7,0x28,0xe1,0xe7,0x3f] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_DoubleKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::ObjectKeyFrame> => [0x69c69834,0x8951,0x54a7,0xa2,0xca,0x92,0x2b,0xac,0xf9,0xfc,0x70] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_ObjectKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::PointKeyFrame> => [0xe55a65ad,0xe742,0x5f78,0x87,0x6b,0x64,0xd1,0x68,0x1f,0xc9,0xe2] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_PointKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::Timeline> => [0xb0c22c25,0xae1a,0x5326,0xbf,0x81,0x39,0x42,0x46,0xcc,0x30,0x76] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_Timeline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::animation::Transition> => [0x0f149913,0xd622,0x5dde,0xb6,0xe3,0x78,0x35,0xc2,0xab,0x54,0xb7] as IID_IIterator_1_Windows_UI_Xaml_Media_Animation_Transition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::Brush> => [0x5d4853d4,0x3f43,0x5aba,0xa0,0x74,0xf2,0x1b,0x30,0x92,0x7b,0xf6] as IID_IIterator_1_Windows_UI_Xaml_Media_Brush }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::Geometry> => [0x8726dcbf,0x961d,0x527a,0xa7,0xcb,0x2d,0xb4,0x7e,0x1c,0x90,0x92] as IID_IIterator_1_Windows_UI_Xaml_Media_Geometry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::GradientStop> => [0x01dca32b,0x0938,0x5e4a,0x94,0xad,0xbb,0x49,0x06,0xf6,0x51,0xed] as IID_IIterator_1_Windows_UI_Xaml_Media_GradientStop }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::PathFigure> => [0x71bd579b,0x088e,0x5e59,0x88,0x76,0x80,0x61,0x3d,0xcf,0xf8,0x3e] as IID_IIterator_1_Windows_UI_Xaml_Media_PathFigure }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::PathSegment> => [0x3cfedcfb,0x7a75,0x5bc7,0xa7,0xe2,0x95,0xee,0x9b,0xc6,0xdd,0x32] as IID_IIterator_1_Windows_UI_Xaml_Media_PathSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::TimelineMarker> => [0x63e1e513,0xfca3,0x51c0,0x8c,0x2b,0x09,0xdb,0x5f,0x8f,0x4c,0x40] as IID_IIterator_1_Windows_UI_Xaml_Media_TimelineMarker }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::media::Transform> => [0x2cdbd536,0x4598,0x5f0f,0xa2,0x36,0x11,0xec,0x05,0x3c,0x8e,0x4b] as IID_IIterator_1_Windows_UI_Xaml_Media_Transform }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::navigation::PageStackEntry> => [0xb89ca96c,0xded1,0x53bd,0x87,0x44,0xca,0xa8,0x4e,0x87,0xba,0x87] as IID_IIterator_1_Windows_UI_Xaml_Navigation_PageStackEntry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::ResourceDictionary> => [0x849a2f3a,0x2e5e,0x58a8,0xb7,0x6e,0x73,0x45,0x0e,0xa6,0x80,0xc0] as IID_IIterator_1_Windows_UI_Xaml_ResourceDictionary }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::StateTriggerBase> => [0xd78b9c25,0x3214,0x54c6,0x84,0x05,0x47,0x93,0x44,0x30,0x92,0x77] as IID_IIterator_1_Windows_UI_Xaml_StateTriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::TriggerAction> => [0xfa0c6c2e,0xf81a,0x543c,0xb8,0xb6,0x5c,0x18,0xd3,0x67,0x11,0xb0] as IID_IIterator_1_Windows_UI_Xaml_TriggerAction }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::TriggerBase> => [0xd317c81a,0x5dda,0x59f6,0x8c,0xe9,0x44,0xf2,0x87,0x7b,0xfa,0xe8] as IID_IIterator_1_Windows_UI_Xaml_TriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::UIElement> => [0x1d1f9d60,0xd53b,0x57f7,0xb1,0x44,0x8f,0x7c,0x48,0x78,0x46,0xe8] as IID_IIterator_1_Windows_UI_Xaml_UIElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::VisualState> => [0xf20bd8bc,0x6dda,0x5c71,0xbd,0x39,0xc5,0x71,0x37,0xc5,0xa4,0xed] as IID_IIterator_1_Windows_UI_Xaml_VisualState }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::VisualStateGroup> => [0x09e95afc,0x3096,0x50c1,0xb0,0x5a,0xac,0xae,0x1a,0x8c,0xb9,0x2e] as IID_IIterator_1_Windows_UI_Xaml_VisualStateGroup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IIterator<super::super::ui::xaml::VisualTransition> => [0x5ae4cb71,0xa8b8,0x506b,0xb3,0x1b,0x62,0xdb,0x11,0xf6,0x62,0x57] as IID_IIterator_1_Windows_UI_Xaml_VisualTransition }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::atompub::ResourceCollection> => [0x2b175876,0x0920,0x52f0,0x80,0xbf,0xdf,0xe7,0x97,0x44,0x12,0x8d] as IID_IIterator_1_Windows_Web_AtomPub_ResourceCollection }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::atompub::Workspace> => [0x0cc8c426,0xd68a,0x5136,0x97,0x41,0xde,0x32,0x67,0x64,0xca,0x32] as IID_IIterator_1_Windows_Web_AtomPub_Workspace }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::http::diagnostics::HttpDiagnosticSourceLocation> => [0x807b6ed4,0x5f42,0x5199,0xb2,0x31,0x60,0xcc,0xe2,0xc7,0x69,0x40] as IID_IIterator_1_Windows_Web_Http_Diagnostics_HttpDiagnosticSourceLocation }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::http::headers::HttpNameValueHeaderValue> => [0x3bb0c8fa,0x5f1f,0x5c70,0x99,0x50,0x5d,0x1d,0x1a,0x70,0x3d,0xd4] as IID_IIterator_1_Windows_Web_Http_Headers_HttpNameValueHeaderValue }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::http::HttpCookie> => [0x626bc177,0x8403,0x5030,0xa8,0x8c,0x74,0x85,0xcc,0x89,0xd7,0x30] as IID_IIterator_1_Windows_Web_Http_HttpCookie }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::ISyndicationNode> => [0x2dc8d9d6,0x0f44,0x5692,0x93,0x3e,0xf8,0x90,0x2a,0xb7,0xfb,0x94] as IID_IIterator_1_Windows_Web_Syndication_ISyndicationNode }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::SyndicationAttribute> => [0xa76fcde8,0xf86f,0x5b75,0xaa,0x7d,0x57,0x87,0x46,0x7a,0x31,0x9d] as IID_IIterator_1_Windows_Web_Syndication_SyndicationAttribute }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::SyndicationCategory> => [0x2a9228fa,0xb088,0x5690,0xbb,0x38,0xb7,0x04,0x4e,0x0b,0x50,0x2b] as IID_IIterator_1_Windows_Web_Syndication_SyndicationCategory }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::SyndicationItem> => [0xd5692aa3,0xd785,0x5db4,0xac,0x5c,0xb3,0x83,0x20,0x82,0xe6,0x29] as IID_IIterator_1_Windows_Web_Syndication_SyndicationItem }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::SyndicationLink> => [0x901642b7,0x6ca4,0x5b57,0xb8,0xf1,0x73,0x20,0x83,0x42,0xba,0x4a] as IID_IIterator_1_Windows_Web_Syndication_SyndicationLink }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IIterator<super::super::web::syndication::SyndicationPerson> => [0x1745e807,0xf209,0x5da6,0x88,0x55,0x7f,0x99,0xe2,0x5e,0xb1,0xfc] as IID_IIterator_1_Windows_Web_Syndication_SyndicationPerson }
		RT_PINTERFACE!{ for IIterator<super::TimeSpan> => [0x67e9eadb,0x324b,0x5661,0xa4,0x05,0xde,0xd8,0x44,0x5b,0x1e,0xea] as IID_IIterator_1_Windows_Foundation_TimeSpan }
		RT_PINTERFACE!{ for IIterator<super::Uri> => [0x1c157d0f,0x5efe,0x5cec,0xbb,0xd6,0x0c,0x6c,0xe9,0xaf,0x07,0xa5] as IID_IIterator_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for IIterator<u32> => [0xf06a2739,0x9443,0x5ef0,0xb2,0x84,0xdc,0x5a,0xff,0x3e,0x7d,0x10] as IID_IIterator_1_System_UInt32 }
		RT_PINTERFACE!{ for IIterator<u8> => [0x40556131,0xa2a1,0x5fab,0xaa,0xee,0x5f,0x35,0x26,0x8c,0xa2,0x6b] as IID_IIterator_1_System_Byte }
		RT_PINTERFACE!{ for IKeyValuePair<::Guid, IInspectable> => [0x3bda1540,0xd089,0x5a1a,0x8f,0x0d,0x94,0xeb,0xa8,0x06,0x8e,0x58] as IID_IKeyValuePair_2_System_Guid_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<::Guid, super::super::applicationmodel::background::IBackgroundTaskRegistration> => [0x5a1f6d75,0x8678,0x547c,0x8f,0xd7,0xfb,0xce,0xb6,0xeb,0xf9,0x68] as IID_IKeyValuePair_2_System_Guid_Windows_ApplicationModel_Background_IBackgroundTaskRegistration }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IKeyValuePair<::Guid, super::super::perception::spatial::surfaces::SpatialSurfaceInfo> => [0xa6bdf94a,0x2697,0x5ff2,0x89,0xdc,0xa1,0x7c,0xec,0xdc,0xda,0x6c] as IID_IKeyValuePair_2_System_Guid_Windows_Perception_Spatial_Surfaces_SpatialSurfaceInfo }
		RT_PINTERFACE!{ for IKeyValuePair<HString, HString> => [0x60310303,0x49c5,0x52e6,0xab,0xc6,0xa9,0xb3,0x6e,0xcc,0xc7,0x16] as IID_IKeyValuePair_2_System_String_System_String }
		RT_PINTERFACE!{ for IKeyValuePair<HString, IInspectable> => [0x09335560,0x6c6b,0x5a26,0x93,0x48,0x97,0xb7,0x81,0x13,0x2b,0x20] as IID_IKeyValuePair_2_System_String_System_Object }
		RT_PINTERFACE!{ for IKeyValuePair<HString, IVector<HString>> => [0x174f26c7,0x79ea,0x5f7c,0xbd,0x70,0xac,0x44,0x57,0xf2,0xca,0xc8] as IID_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVector_1_System_String }
		RT_PINTERFACE!{ for IKeyValuePair<HString, IVectorView<HString>> => [0xbcde03ad,0xea71,0x5077,0xa9,0x61,0x1c,0x0e,0xcf,0xf5,0x72,0x02] as IID_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_System_String }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IKeyValuePair<HString, IVectorView<super::super::data::text::TextSegment>> => [0x77b4daf4,0x4f4f,0x5568,0x90,0xee,0x1a,0x32,0xcf,0x0c,0xaa,0xea] as IID_IKeyValuePair_2_System_String_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::chat::ChatMessageStatus> => [0x4f426a27,0x6d23,0x58b6,0x9f,0x29,0x4f,0x88,0xed,0x27,0x4b,0xcd] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Chat_ChatMessageStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::resources::core::NamedResource> => [0xbd4b0143,0x3a22,0x5ee2,0x92,0xed,0x7b,0xc3,0xc1,0x29,0xe5,0x2b] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Resources_Core_NamedResource }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::resources::core::ResourceMap> => [0x159782ba,0x798d,0x5ae6,0x85,0xc7,0xc7,0xbb,0x55,0x1a,0xae,0x61] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::store::licensemanagement::LicenseSatisfactionInfo> => [0x69426b8f,0x88d8,0x5546,0x92,0xee,0x53,0xf7,0x53,0x07,0x84,0x5b] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::store::ProductLicense> => [0xff71c38c,0x3e6e,0x5e60,0x99,0x4b,0x92,0x01,0x43,0x6d,0xee,0xd1] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductLicense }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::store::ProductListing> => [0x61a02c5d,0x4007,0x573e,0x8a,0x01,0x02,0x59,0x71,0x49,0x27,0xdf] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Store_ProductListing }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::voicecommands::VoiceCommandDefinition> => [0xa932bfda,0x2ce5,0x5012,0xae,0x83,0xf3,0x97,0x97,0x6e,0x4a,0x86] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_VoiceCommands_VoiceCommandDefinition }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletItemCustomProperty> => [0x1aa9cd86,0x9376,0x5ebb,0xb4,0x5c,0x8d,0xad,0x7e,0x66,0xf9,0xf7] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletItemCustomProperty }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletRelevantLocation> => [0x031812fc,0xa4f7,0x5127,0x9e,0xc4,0xd9,0x26,0x21,0xcb,0x3f,0x90] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletRelevantLocation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletTransaction> => [0xf50232e9,0x7ce3,0x559b,0xba,0xad,0x67,0x26,0xff,0xa4,0xe7,0x9b] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletTransaction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::applicationmodel::wallet::WalletVerb> => [0x1fe3a179,0xffa8,0x5f52,0x98,0x23,0x9c,0x3d,0xff,0x73,0xc5,0x6a] as IID_IKeyValuePair_2_System_String_Windows_ApplicationModel_Wallet_WalletVerb }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::graphics::imaging::BitmapTypedValue> => [0x93621bf0,0xdae9,0x5f00,0x94,0xac,0x79,0x5a,0xa9,0x43,0xdc,0xa6] as IID_IKeyValuePair_2_System_String_Windows_Graphics_Imaging_BitmapTypedValue }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::graphics::printing::optiondetails::IPrintOptionDetails> => [0xf5d9c723,0xa4b1,0x5fc8,0x9f,0x78,0x0b,0x95,0xb7,0x16,0x72,0x0b] as IID_IKeyValuePair_2_System_String_Windows_Graphics_Printing_OptionDetails_IPrintOptionDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::media::capture::frames::MediaFrameSource> => [0x29f35a95,0x7eae,0x55a7,0xbc,0x19,0xed,0x87,0xba,0xed,0x48,0x69] as IID_IKeyValuePair_2_System_String_Windows_Media_Capture_Frames_MediaFrameSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::networking::sockets::SocketActivityInformation> => [0x7e4bda2c,0x0125,0x587d,0x88,0x06,0x12,0x85,0x06,0x0f,0x3b,0x2d] as IID_IKeyValuePair_2_System_String_Windows_Networking_Sockets_SocketActivityInformation }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::perception::spatial::SpatialAnchor> => [0x627298e7,0x068d,0x53f6,0x91,0x54,0xd7,0xd8,0xd8,0x09,0x14,0x63] as IID_IKeyValuePair_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::services::store::StoreLicense> => [0x33eefc64,0xef0c,0x5c8d,0xb6,0x20,0x47,0x6e,0xdf,0x7d,0xf7,0x99] as IID_IKeyValuePair_2_System_String_Windows_Services_Store_StoreLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::services::store::StoreProduct> => [0x0e89a311,0x437a,0x5957,0x95,0x93,0x8e,0xd6,0x45,0x11,0x54,0x5b] as IID_IKeyValuePair_2_System_String_Windows_Services_Store_StoreProduct }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::storage::ApplicationDataContainer> => [0x5adbc543,0x2170,0x5ad9,0xb3,0x5e,0x96,0x8c,0xdb,0x78,0xfb,0x30] as IID_IKeyValuePair_2_System_String_Windows_Storage_ApplicationDataContainer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::storage::streams::IBuffer> => [0x9114f794,0x2ceb,0x5b03,0x9b,0x22,0x36,0x88,0x4e,0x1f,0x58,0xb3] as IID_IKeyValuePair_2_System_String_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IKeyValuePair<HString, super::super::storage::streams::RandomAccessStreamReference> => [0xe5195792,0xaeab,0x56e8,0xbd,0x30,0x13,0x72,0xc4,0x34,0x0b,0xf6] as IID_IKeyValuePair_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		RT_PINTERFACE!{ for IKeyValuePair<IInspectable, IInspectable> => [0x59e7ae0c,0xc29d,0x5ad6,0xbe,0xf5,0xde,0xdb,0x52,0xa1,0x98,0xe1] as IID_IKeyValuePair_2_System_Object_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IKeyValuePair<super::super::devices::sensors::PedometerStepKind, super::super::devices::sensors::PedometerReading> => [0xb270d3b8,0x3dd2,0x599f,0xa6,0x71,0x2d,0xe5,0x03,0x55,0x03,0xda] as IID_IKeyValuePair_2_Windows_Devices_Sensors_PedometerStepKind_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IKeyValuePair<u32, super::super::storage::streams::IBuffer> => [0x82a3a3b7,0xe04a,0x5395,0x84,0x87,0x7f,0x94,0xf1,0x50,0x8c,0xe7] as IID_IKeyValuePair_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IMap<::Guid, IInspectable> => [0x5ee3189c,0x7dbf,0x5998,0xad,0x07,0x54,0x14,0xfb,0x82,0x56,0x7c] as IID_IMap_2_System_Guid_System_Object }
		RT_PINTERFACE!{ for IMap<HString, HString> => [0xf6d1f700,0x49c2,0x52ae,0x81,0x54,0x82,0x6f,0x99,0x08,0x77,0x3c] as IID_IMap_2_System_String_System_String }
		RT_PINTERFACE!{ for IMap<HString, IInspectable> => [0x1b0d3570,0x0877,0x5ec2,0x8a,0x2c,0x3b,0x95,0x39,0x50,0x6a,0xca] as IID_IMap_2_System_String_System_Object }
		RT_PINTERFACE!{ for IMap<HString, IVector<HString>> => [0xe475ca9d,0x6afb,0x5992,0x99,0x3e,0x53,0xe6,0xef,0x7a,0x9e,0xcd] as IID_IMap_2_System_String_Windows_Foundation_Collections_IVector_1_System_String }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IMap<HString, IVectorView<super::super::data::text::TextSegment>> => [0xa31b6540,0xb2b1,0x536d,0x81,0x8f,0x8a,0xde,0x70,0x51,0xc3,0xb3] as IID_IMap_2_System_String_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMap<HString, super::super::applicationmodel::wallet::WalletItemCustomProperty> => [0x5cc135b0,0x29f3,0x5113,0xa0,0x97,0x25,0xe4,0x1a,0x32,0xe4,0x73] as IID_IMap_2_System_String_Windows_ApplicationModel_Wallet_WalletItemCustomProperty }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMap<HString, super::super::applicationmodel::wallet::WalletRelevantLocation> => [0x9378c55a,0x852d,0x5ddf,0xb0,0x1b,0x9c,0xc3,0xd4,0x7e,0xc5,0x2d] as IID_IMap_2_System_String_Windows_ApplicationModel_Wallet_WalletRelevantLocation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMap<HString, super::super::applicationmodel::wallet::WalletTransaction> => [0x3ef47bcf,0x8328,0x5245,0x8c,0x91,0xf0,0xab,0x4c,0x39,0x90,0x27] as IID_IMap_2_System_String_Windows_ApplicationModel_Wallet_WalletTransaction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMap<HString, super::super::applicationmodel::wallet::WalletVerb> => [0xbda656b0,0x1139,0x5fd3,0x9d,0xfd,0xd2,0x4d,0xbb,0x91,0x05,0x09] as IID_IMap_2_System_String_Windows_ApplicationModel_Wallet_WalletVerb }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IMap<HString, super::super::graphics::imaging::BitmapTypedValue> => [0x2c70ef8d,0x5d4c,0x5185,0x8d,0xb7,0xfe,0xd8,0x77,0x28,0x16,0x5d] as IID_IMap_2_System_String_Windows_Graphics_Imaging_BitmapTypedValue }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMap<HString, super::super::storage::streams::RandomAccessStreamReference> => [0xe5d2ccfc,0x825a,0x5a8e,0x82,0xaa,0x09,0x5e,0xd5,0xdb,0xd5,0xd1] as IID_IMap_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		RT_PINTERFACE!{ for IMap<IInspectable, IInspectable> => [0xf5f69427,0x55ed,0x5512,0x84,0x29,0xd4,0xf6,0x62,0x6d,0xfc,0xdd] as IID_IMap_2_System_Object_System_Object }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMap<u32, super::super::storage::streams::IBuffer> => [0x5d2591df,0x48c5,0x5734,0x9e,0xf1,0xbd,0x63,0x9b,0x03,0x20,0x07] as IID_IMap_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IMapChangedEventArgs<HString> => [0x60141efb,0xf2f9,0x5377,0x96,0xfd,0xf8,0xc6,0x0d,0x95,0x58,0xb5] as IID_IMapChangedEventArgs_1_System_String }
		RT_PINTERFACE!{ for IMapView<::Guid, IInspectable> => [0xe4d2c732,0xbbc1,0x5ef4,0x86,0x9f,0x50,0x07,0xce,0xb5,0x5f,0x6e] as IID_IMapView_2_System_Guid_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<::Guid, super::super::applicationmodel::background::IBackgroundTaskRegistration> => [0x78c880f6,0xa7dc,0x5172,0x89,0xda,0x77,0x49,0xfc,0x82,0xaa,0x82] as IID_IMapView_2_System_Guid_Windows_ApplicationModel_Background_IBackgroundTaskRegistration }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IMapView<::Guid, super::super::perception::spatial::surfaces::SpatialSurfaceInfo> => [0xeaa722b9,0x2859,0x593d,0xbb,0x66,0x0c,0x53,0x8e,0x41,0x5e,0x71] as IID_IMapView_2_System_Guid_Windows_Perception_Spatial_Surfaces_SpatialSurfaceInfo }
		RT_PINTERFACE!{ for IMapView<HString, HString> => [0xac7f26f2,0xfeb7,0x5b2a,0x8a,0xc4,0x34,0x5b,0xc6,0x2c,0xae,0xde] as IID_IMapView_2_System_String_System_String }
		RT_PINTERFACE!{ for IMapView<HString, IInspectable> => [0xbb78502a,0xf79d,0x54fa,0x92,0xc9,0x90,0xc5,0x03,0x9f,0xdf,0x7e] as IID_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for IMapView<HString, IVector<HString>> => [0x153f9c9c,0xd22a,0x5c9e,0x9c,0x74,0x8b,0x85,0xc9,0x08,0xb0,0x00] as IID_IMapView_2_System_String_Windows_Foundation_Collections_IVector_1_System_String }
		RT_PINTERFACE!{ for IMapView<HString, IVectorView<HString>> => [0x2843d34f,0xd3e5,0x5fca,0x9f,0xdc,0xb5,0x68,0xdd,0x5c,0x1e,0x64] as IID_IMapView_2_System_String_Windows_Foundation_Collections_IVectorView_1_System_String }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IMapView<HString, IVectorView<super::super::data::text::TextSegment>> => [0x91d443d6,0x3777,0x5102,0xb0,0xbc,0x3d,0x41,0x83,0xa2,0x6f,0xf9] as IID_IMapView_2_System_String_Windows_Foundation_Collections_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::chat::ChatMessageStatus> => [0x6a44ff0f,0xa172,0x5285,0x9b,0xa5,0xb9,0xfd,0xd6,0x99,0xa0,0xfe] as IID_IMapView_2_System_String_Windows_ApplicationModel_Chat_ChatMessageStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::resources::core::ResourceMap> => [0xd4349ade,0x93b1,0x5325,0xba,0x5c,0x05,0xf3,0x5e,0xef,0xfc,0x55] as IID_IMapView_2_System_String_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::store::licensemanagement::LicenseSatisfactionInfo> => [0x19df5e64,0xc2b2,0x5bfd,0xa2,0x59,0xf0,0x2c,0x23,0x57,0x4c,0xd3] as IID_IMapView_2_System_String_Windows_ApplicationModel_Store_LicenseManagement_LicenseSatisfactionInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::store::ProductLicense> => [0xd6434f65,0xdd84,0x534c,0xb5,0x79,0xcc,0x10,0xd6,0x9e,0xc3,0x0a] as IID_IMapView_2_System_String_Windows_ApplicationModel_Store_ProductLicense }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::store::ProductListing> => [0x3206de83,0xefbe,0x5791,0xa4,0x87,0x2a,0xc9,0x74,0x20,0x6e,0xc6] as IID_IMapView_2_System_String_Windows_ApplicationModel_Store_ProductListing }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::voicecommands::VoiceCommandDefinition> => [0x4c1168f0,0xa0b2,0x5312,0xb9,0x9a,0x47,0x1a,0xbd,0x33,0x4e,0x85] as IID_IMapView_2_System_String_Windows_ApplicationModel_VoiceCommands_VoiceCommandDefinition }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::wallet::WalletItemCustomProperty> => [0x338f0d64,0xdd4e,0x5614,0xb1,0x6f,0x0b,0xd0,0x8d,0x19,0xfe,0x02] as IID_IMapView_2_System_String_Windows_ApplicationModel_Wallet_WalletItemCustomProperty }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::wallet::WalletRelevantLocation> => [0xb5622af3,0x7c67,0x5158,0xb3,0x9a,0x43,0x23,0x48,0x8e,0x6f,0x87] as IID_IMapView_2_System_String_Windows_ApplicationModel_Wallet_WalletRelevantLocation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::wallet::WalletTransaction> => [0x05b768c4,0x0c95,0x5305,0x9b,0x44,0xef,0x00,0x6b,0x53,0x30,0x0f] as IID_IMapView_2_System_String_Windows_ApplicationModel_Wallet_WalletTransaction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IMapView<HString, super::super::applicationmodel::wallet::WalletVerb> => [0x93ca6ab8,0xa827,0x5e28,0xb2,0x1e,0x01,0xa5,0x97,0x45,0x7c,0x3e] as IID_IMapView_2_System_String_Windows_ApplicationModel_Wallet_WalletVerb }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IMapView<HString, super::super::graphics::imaging::BitmapTypedValue> => [0x9cda5a9a,0x8924,0x5b3b,0x8b,0x19,0x89,0x4d,0x8d,0xa9,0x9d,0xde] as IID_IMapView_2_System_String_Windows_Graphics_Imaging_BitmapTypedValue }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IMapView<HString, super::super::graphics::printing::optiondetails::IPrintOptionDetails> => [0x79e5168f,0x702a,0x5030,0xbd,0x44,0xef,0x23,0xd8,0x88,0x7a,0xed] as IID_IMapView_2_System_String_Windows_Graphics_Printing_OptionDetails_IPrintOptionDetails }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IMapView<HString, super::super::media::capture::frames::MediaFrameSource> => [0x534ea61f,0x8be7,0x5e93,0xb0,0x1b,0xae,0x1f,0x9d,0xd2,0x42,0xa4] as IID_IMapView_2_System_String_Windows_Media_Capture_Frames_MediaFrameSource }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IMapView<HString, super::super::networking::sockets::SocketActivityInformation> => [0xe6ac8bee,0xa31c,0x5af2,0x92,0x27,0x5b,0xe2,0xf9,0xe8,0x07,0x63] as IID_IMapView_2_System_String_Windows_Networking_Sockets_SocketActivityInformation }
		#[cfg(feature="windows.perception")] RT_PINTERFACE!{ for IMapView<HString, super::super::perception::spatial::SpatialAnchor> => [0x2d344564,0x21b1,0x5470,0xb0,0x13,0x48,0x8c,0xdd,0xe4,0x5c,0x48] as IID_IMapView_2_System_String_Windows_Perception_Spatial_SpatialAnchor }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IMapView<HString, super::super::services::store::StoreLicense> => [0x7d0d74f5,0x4020,0x54aa,0x9f,0x3d,0x0f,0x17,0x12,0x7a,0xcd,0xdf] as IID_IMapView_2_System_String_Windows_Services_Store_StoreLicense }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IMapView<HString, super::super::services::store::StoreProduct> => [0xdbaac6e5,0x61a4,0x5c88,0xb5,0xd8,0x3a,0x3e,0x16,0x1c,0x3e,0x4a] as IID_IMapView_2_System_String_Windows_Services_Store_StoreProduct }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMapView<HString, super::super::storage::ApplicationDataContainer> => [0x13624f8d,0x85cc,0x5780,0xa7,0x8d,0x64,0xdb,0xa5,0x8f,0x2c,0x3c] as IID_IMapView_2_System_String_Windows_Storage_ApplicationDataContainer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMapView<HString, super::super::storage::streams::IBuffer> => [0x2cfeec4f,0xe261,0x5f4c,0xae,0xe1,0xc7,0x85,0x18,0xe9,0xd5,0xb9] as IID_IMapView_2_System_String_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMapView<HString, super::super::storage::streams::RandomAccessStreamReference> => [0x0a4ce7a5,0xdfe0,0x5796,0xa4,0x38,0xef,0xfd,0xfa,0xa3,0x1f,0x1b] as IID_IMapView_2_System_String_Windows_Storage_Streams_RandomAccessStreamReference }
		RT_PINTERFACE!{ for IMapView<IInspectable, IInspectable> => [0xefe76d10,0xcb60,0x50ad,0x8a,0x4f,0x68,0x85,0xcd,0x62,0x12,0xa1] as IID_IMapView_2_System_Object_System_Object }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IMapView<super::super::devices::sensors::PedometerStepKind, super::super::devices::sensors::PedometerReading> => [0x64f0c54c,0x4865,0x56bd,0xac,0x98,0x64,0xa9,0x84,0x51,0xe3,0x62] as IID_IMapView_2_Windows_Devices_Sensors_PedometerStepKind_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IMapView<u32, super::super::storage::streams::IBuffer> => [0x57dc41e6,0x8b4d,0x5910,0x97,0x03,0xd7,0xc6,0x68,0x43,0x68,0x52] as IID_IMapView_2_System_UInt32_Windows_Storage_Streams_IBuffer }
		RT_PINTERFACE!{ for IObservableMap<HString, HString> => [0x1e036276,0x2f60,0x55f6,0xb7,0xf3,0xf8,0x60,0x79,0xe6,0x90,0x0b] as IID_IObservableMap_2_System_String_System_String }
		RT_PINTERFACE!{ for IObservableVector<IInspectable> => [0x7b81c56a,0x0985,0x518d,0xba,0xa9,0x0d,0xa9,0xae,0x00,0x9f,0x65] as IID_IObservableVector_1_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IObservableVector<super::super::applicationmodel::search::core::SearchSuggestion> => [0xe885956c,0x72c1,0x514f,0xad,0x9a,0x29,0x43,0xb8,0x80,0xae,0x13] as IID_IObservableVector_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IObservableVector<super::super::media::core::TimedMetadataTrack> => [0x98ebeba8,0x6659,0x5af2,0xbe,0x4f,0x32,0xfd,0xee,0xde,0x3b,0x77] as IID_IObservableVector_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IObservableVector<super::super::media::core::TimedTextSource> => [0x95e6c852,0x6e9c,0x50a9,0x89,0x35,0x05,0x43,0x20,0x24,0x29,0x45] as IID_IObservableVector_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IObservableVector<super::super::media::playback::MediaPlaybackItem> => [0xfabf4843,0x39eb,0x5c3d,0xa1,0x2b,0xfc,0xa1,0x89,0xb4,0x6e,0x8e] as IID_IObservableVector_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IObservableVector<super::super::storage::StorageFolder> => [0x358f44df,0x2a45,0x5cb8,0x93,0x85,0x1f,0xf6,0x68,0x08,0xcd,0xe0] as IID_IObservableVector_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IObservableVector<super::super::ui::xaml::controls::GroupStyle> => [0x8144f56c,0x1f13,0x5a8d,0x83,0x5f,0x5e,0x0c,0x93,0x25,0xbf,0xf1] as IID_IObservableVector_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IObservableVector<super::super::ui::xaml::controls::ICommandBarElement> => [0xd5644006,0x717d,0x512d,0x87,0x85,0xb4,0x8c,0x17,0xe7,0x34,0x68] as IID_IObservableVector_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IObservableVector<super::super::ui::xaml::DependencyObject> => [0xfac6f4d2,0x96fd,0x5ceb,0x80,0xbf,0x46,0xac,0x65,0x29,0xfc,0x65] as IID_IObservableVector_1_Windows_UI_Xaml_DependencyObject }
		RT_PINTERFACE!{ for IVector<::Guid> => [0x482e676d,0xb913,0x5ec1,0xaf,0xa8,0x5f,0x96,0x92,0x2e,0x94,0xae] as IID_IVector_1_System_Guid }
		RT_PINTERFACE!{ for IVector<f32> => [0x61cf693f,0xdb4c,0x579f,0xb9,0x05,0x5d,0xd3,0xd2,0x3c,0xfd,0x4d] as IID_IVector_1_System_Single }
		RT_PINTERFACE!{ for IVector<f64> => [0xf452d23c,0xbf05,0x5f3e,0x88,0xe7,0xd1,0x7a,0x67,0x16,0xb9,0x11] as IID_IVector_1_System_Double }
		RT_PINTERFACE!{ for IVector<HString> => [0x98b9acc1,0x4b56,0x532e,0xac,0x73,0x03,0xd5,0x29,0x1c,0xca,0x90] as IID_IVector_1_System_String }
		RT_PINTERFACE!{ for IVector<i32> => [0xb939af5b,0xb45d,0x5489,0x91,0x49,0x61,0x44,0x2c,0x19,0x05,0xfe] as IID_IVector_1_System_Int32 }
		RT_PINTERFACE!{ for IVector<IInspectable> => [0xb32bdca4,0x5e52,0x5b27,0xbc,0x5d,0xd6,0x6a,0x1a,0x26,0x8c,0x2a] as IID_IVector_1_System_Object }
		RT_PINTERFACE!{ for IVector<super::DateTime> => [0x94390dc5,0xe442,0x5870,0x88,0xb6,0x00,0x7e,0x23,0x2f,0x90,0x2c] as IID_IVector_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IVector<super::Point> => [0xc0d513a9,0xec4a,0x5a5d,0xb6,0xd5,0xb7,0x07,0xde,0xfd,0xb9,0xf7] as IID_IVector_1_Windows_Foundation_Point }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::appointments::AppointmentInvitee> => [0x70f4b32e,0xf91e,0x55bb,0x9a,0x92,0x02,0x46,0xda,0x73,0x4b,0xb0] as IID_IVector_1_Windows_ApplicationModel_Appointments_AppointmentInvitee }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::chat::ChatMessageAttachment> => [0xad2127f1,0x3216,0x58fb,0x81,0x54,0xb2,0x41,0xa6,0x0b,0x42,0x52] as IID_IVector_1_Windows_ApplicationModel_Chat_ChatMessageAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::chat::ChatRecipientDeliveryInfo> => [0x14640361,0x3f8d,0x5606,0x8f,0xcb,0x97,0x32,0x08,0xb7,0x6d,0x72] as IID_IVector_1_Windows_ApplicationModel_Chat_ChatRecipientDeliveryInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::Contact> => [0x945779db,0x01d2,0x5839,0x8a,0x92,0x79,0x05,0xec,0x92,0xb2,0x8f] as IID_IVector_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactAddress> => [0xd0c298ee,0x1520,0x539e,0x84,0xb3,0xa2,0x59,0x09,0x71,0x7d,0x20] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactAddress }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactConnectedServiceAccount> => [0x2c55fb80,0xa759,0x5fae,0xbc,0x29,0x99,0x07,0xe0,0x97,0x60,0x48] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactConnectedServiceAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactDate> => [0x3135d944,0xd914,0x5a4f,0x84,0x3e,0xa6,0xd6,0xcb,0x69,0xbc,0xb1] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactDate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactEmail> => [0x4ce06787,0xdea1,0x559f,0xa7,0x0a,0xfc,0xbe,0x59,0xdb,0xd3,0xa4] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactEmail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactFieldType> => [0x6fdc2115,0x1649,0x54a4,0x8f,0xaa,0x30,0x49,0xce,0xfb,0x05,0xa4] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactFieldType }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactJobInfo> => [0xea148f90,0xbb89,0x5604,0x97,0x57,0xec,0xd1,0xe7,0xce,0x53,0x11] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactJobInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactPhone> => [0x6d1f883a,0x1f30,0x5a87,0xb5,0x4a,0x8e,0x22,0x45,0xed,0x10,0x01] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactPhone }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactSignificantOther> => [0xcec34450,0x8143,0x56e3,0x93,0x3a,0xd3,0x30,0x51,0xb7,0x44,0x37] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactSignificantOther }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::ContactWebsite> => [0x1931848e,0xe794,0x5775,0xb3,0x93,0x4a,0x45,0x18,0xd6,0x3b,0x09] as IID_IVector_1_Windows_ApplicationModel_Contacts_ContactWebsite }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::contacts::IContactField> => [0xf9dd472b,0x4f50,0x583a,0xa3,0xaa,0xb7,0x3a,0xf5,0x48,0x06,0xbe] as IID_IVector_1_Windows_ApplicationModel_Contacts_IContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::email::EmailAttachment> => [0x07b0ebc8,0x70af,0x5deb,0x98,0x61,0xdc,0x93,0xe2,0xb0,0x38,0xe9] as IID_IVector_1_Windows_ApplicationModel_Email_EmailAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::email::EmailMailboxAction> => [0x4c954eb2,0xf15c,0x5869,0xab,0xd7,0x2e,0x32,0x8d,0xe4,0xa4,0xaf] as IID_IVector_1_Windows_ApplicationModel_Email_EmailMailboxAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::email::EmailRecipient> => [0x1151f664,0x39c5,0x5aaa,0x8a,0x2e,0x33,0x50,0xe6,0x11,0x62,0x4b] as IID_IVector_1_Windows_ApplicationModel_Email_EmailRecipient }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::Package> => [0xd1bb509e,0x6989,0x5c69,0xb1,0xff,0xd1,0x70,0x2f,0xe8,0xac,0xa3] as IID_IVector_1_Windows_ApplicationModel_Package }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::search::core::SearchSuggestion> => [0x1cc36c46,0x19be,0x5d6b,0xa5,0x6d,0x04,0x74,0x13,0x25,0x2c,0x69] as IID_IVector_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::socialinfo::SocialFeedItem> => [0x36cd5297,0x36c3,0x56a7,0x96,0x56,0xec,0x9d,0x5b,0xde,0x7a,0xba] as IID_IVector_1_Windows_ApplicationModel_SocialInfo_SocialFeedItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::socialinfo::SocialItemThumbnail> => [0xc210bbd7,0x2f56,0x5076,0xbb,0x0e,0xb7,0x49,0x77,0x26,0xcf,0x95] as IID_IVector_1_Windows_ApplicationModel_SocialInfo_SocialItemThumbnail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVector<super::super::applicationmodel::voicecommands::VoiceCommandContentTile> => [0xe45fe700,0xea08,0x5172,0xb8,0x8c,0xc4,0xb3,0xe0,0x48,0xc3,0xe8] as IID_IVector_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandContentTile }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::alljoyn::AllJoynAuthenticationMechanism> => [0x19c16b93,0xf9ca,0x5c05,0xbf,0x73,0xe7,0x4c,0xd0,0x54,0xc5,0x87] as IID_IVector_1_Windows_Devices_AllJoyn_AllJoynAuthenticationMechanism }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementBytePattern> => [0x8dd461b7,0x9775,0x5e82,0xa0,0xa6,0x66,0x27,0xab,0xd0,0xd0,0x10] as IID_IVector_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementBytePattern }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementDataSection> => [0xb6f71ad2,0xe2cf,0x5d54,0xb6,0xf1,0x90,0x96,0x4e,0xe5,0xd4,0xda] as IID_IVector_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementDataSection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::bluetooth::advertisement::BluetoothLEManufacturerData> => [0x52d75b45,0x1d24,0x5eeb,0xba,0xbb,0x65,0xef,0xfa,0xe4,0x5e,0x46] as IID_IVector_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEManufacturerData }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::enumeration::DeviceClass> => [0xee662d37,0xb0eb,0x5729,0x98,0x32,0x15,0x6f,0xd2,0x88,0x9d,0x48] as IID_IVector_1_Windows_Devices_Enumeration_DeviceClass }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::geolocation::geofencing::Geofence> => [0x096dc936,0x5f66,0x5c6e,0x95,0xce,0xef,0x55,0x41,0xfb,0xf4,0xc4] as IID_IVector_1_Windows_Devices_Geolocation_Geofencing_Geofence }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::geolocation::Geopath> => [0x7ca97e6d,0x6893,0x5672,0xa0,0xc7,0x62,0x5c,0x50,0x90,0x38,0x1e] as IID_IVector_1_Windows_Devices_Geolocation_Geopath }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::sensors::ActivityType> => [0xe3e660d6,0xd041,0x5ecd,0xb1,0x8b,0xfa,0x25,0x4e,0x4a,0x86,0x0f] as IID_IVector_1_Windows_Devices_Sensors_ActivityType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::sms::SmsBroadcastType> => [0xd76bef0b,0x1358,0x5895,0xbd,0x42,0xf1,0x7f,0x6f,0x33,0xee,0xd1] as IID_IVector_1_Windows_Devices_Sms_SmsBroadcastType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::sms::SmsFilterRule> => [0x8e72fa52,0x4867,0x5696,0xb4,0xd9,0x4c,0xa2,0x3f,0x19,0xe1,0x77] as IID_IVector_1_Windows_Devices_Sms_SmsFilterRule }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::wifidirect::services::WiFiDirectServiceConfigurationMethod> => [0xf6a6f91c,0x0579,0x565d,0xbe,0x07,0x45,0x38,0xa5,0x56,0x90,0xbe] as IID_IVector_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::wifidirect::WiFiDirectConfigurationMethod> => [0x9b498bc0,0xb474,0x5587,0xb6,0x5c,0xe6,0x00,0x96,0x5f,0x8f,0xd0] as IID_IVector_1_Windows_Devices_WiFiDirect_WiFiDirectConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVector<super::super::devices::wifidirect::WiFiDirectInformationElement> => [0xb8c55492,0xe4de,0x5ba7,0x84,0x76,0xd3,0xba,0xb5,0x57,0xcd,0xd6] as IID_IVector_1_Windows_Devices_WiFiDirect_WiFiDirectInformationElement }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DBaseMaterial> => [0x6a5aa59f,0xfe10,0x517b,0xb1,0xa9,0xc6,0x85,0xec,0xce,0x16,0x44] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DBaseMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DBaseMaterialGroup> => [0x2b80d2cf,0x5449,0x5c81,0x82,0x26,0xeb,0xfc,0x7d,0x72,0xf5,0x79] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DBaseMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DColorMaterial> => [0x606166fd,0x6bf5,0x53a1,0xb1,0xae,0xc3,0x48,0x92,0xef,0x16,0x63] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DColorMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DColorMaterialGroup> => [0x7c8017f3,0x8365,0x5aa8,0x9f,0xd0,0xa7,0x69,0xf2,0x6e,0x3f,0xef] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DColorMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DComponent> => [0x49e654c2,0xf372,0x582e,0x97,0xcc,0xcb,0x6b,0x0f,0xa3,0xba,0x62] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DComponent }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DComponentWithMatrix> => [0xf09f3dd7,0x61e6,0x5a8d,0x9d,0xdf,0x57,0x00,0x1f,0x70,0x5d,0xe7] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DComponentWithMatrix }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DCompositeMaterial> => [0xc3b27a95,0x5efc,0x52c7,0xb5,0xde,0xe8,0x2e,0x05,0x9a,0x72,0x2e] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DCompositeMaterialGroup> => [0x1e4ccd78,0xb6c0,0x51b1,0xab,0x2b,0xc3,0x42,0x2f,0x02,0xc2,0x4e] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DMesh> => [0xbb11be6e,0xb592,0x5bc2,0x9a,0x53,0x01,0x27,0xa9,0xb3,0x21,0x72] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DMesh }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DModelTexture> => [0x4e72578f,0x9bea,0x5663,0x86,0x99,0xe7,0xfc,0xad,0x35,0x47,0xa7] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DModelTexture }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterial> => [0xe2196da6,0x6a29,0x59a2,0x9d,0xd6,0x93,0x06,0x2f,0x44,0xba,0xad] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterialGroup> => [0x22585b94,0x34a1,0x5b6a,0xba,0xe3,0xbf,0x44,0x65,0x98,0x12,0xf3] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DTexture2CoordMaterial> => [0xf16fbf2c,0xc783,0x5edf,0xad,0x7b,0x7f,0xb7,0xea,0xcf,0x15,0x01] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DTexture2CoordMaterialGroup> => [0x7dc68e96,0x2a62,0x5e7a,0x85,0xd5,0x48,0x64,0xd0,0x35,0x91,0xeb] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVector<super::super::graphics::printing3d::Printing3DTextureResource> => [0x120948c9,0xaaa5,0x5ee5,0xa1,0x33,0x32,0x15,0xd0,0x56,0x14,0x04] as IID_IVector_1_Windows_Graphics_Printing3D_Printing3DTextureResource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::casting::CastingSource> => [0xc2e3dea8,0x92e0,0x50af,0x9c,0x93,0x83,0xb3,0xe8,0x6b,0x73,0xb4] as IID_IVector_1_Windows_Media_Casting_CastingSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::AudioStreamDescriptor> => [0x45afc129,0x988c,0x5f1e,0x9c,0x17,0x6e,0x34,0xb9,0x17,0xcd,0x1b] as IID_IVector_1_Windows_Media_Core_AudioStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::TimedMetadataTrack> => [0xc46d9e34,0xea11,0x5bb2,0x97,0x44,0x16,0x17,0x41,0x7e,0xf0,0x16] as IID_IVector_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::TimedTextLine> => [0x284f0441,0xe96d,0x58ad,0x91,0x88,0x7b,0xf4,0x65,0x14,0xdf,0xcc] as IID_IVector_1_Windows_Media_Core_TimedTextLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::TimedTextSource> => [0xd0a72378,0x5432,0x50bf,0x93,0xc3,0xc5,0xf3,0x5f,0xc9,0x35,0x17] as IID_IVector_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::TimedTextSubformat> => [0x8786f392,0xf369,0x57ea,0xa1,0x6e,0x75,0x87,0x02,0x46,0xa8,0xc9] as IID_IVector_1_Windows_Media_Core_TimedTextSubformat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::core::VideoStreamDescriptor> => [0x1fb064b3,0x636c,0x5988,0x9c,0x97,0x02,0xa9,0xb7,0x61,0x50,0xf6] as IID_IVector_1_Windows_Media_Core_VideoStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::devices::core::FrameController> => [0x1c8f8276,0xb89a,0x5093,0xa1,0xed,0xaf,0x49,0xdf,0xb7,0x2a,0x89] as IID_IVector_1_Windows_Media_Devices_Core_FrameController }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::editing::BackgroundAudioTrack> => [0x56d62145,0x6978,0x5eba,0x83,0xc9,0xfc,0x4a,0xd6,0xd4,0x43,0xbf] as IID_IVector_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::editing::MediaClip> => [0xe805688e,0x3508,0x57f3,0xbf,0x95,0x61,0x7f,0x2d,0x7a,0x6f,0x1a] as IID_IVector_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::editing::MediaOverlay> => [0x5b913ec8,0xed52,0x5b2c,0xa7,0x10,0x52,0xc6,0xe7,0xab,0x3c,0xb2] as IID_IVector_1_Windows_Media_Editing_MediaOverlay }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::editing::MediaOverlayLayer> => [0x6564eb2c,0x2210,0x5dfc,0xa8,0x4c,0x26,0x6c,0x43,0x49,0xc2,0xc6] as IID_IVector_1_Windows_Media_Editing_MediaOverlayLayer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::effects::IAudioEffectDefinition> => [0x2828a982,0xd849,0x5fc9,0x84,0xce,0xf9,0xa4,0xb3,0xb4,0xd3,0x41] as IID_IVector_1_Windows_Media_Effects_IAudioEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::effects::IVideoEffectDefinition> => [0x7ca161ed,0xe201,0x5615,0xaa,0xcc,0x25,0x34,0x85,0x64,0xf0,0xb3] as IID_IVector_1_Windows_Media_Effects_IVideoEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::faceanalysis::DetectedFace> => [0x0dfd8e09,0x73f2,0x505c,0xa7,0x96,0xa8,0xf0,0x31,0xb4,0xed,0xe0] as IID_IVector_1_Windows_Media_FaceAnalysis_DetectedFace }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::playback::MediaPlaybackItem> => [0xe1504f46,0xc4a6,0x5a29,0x8f,0xc9,0xa9,0x34,0xd1,0x2d,0x72,0x42] as IID_IVector_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::protection::RevocationAndRenewalItem> => [0x3623cc0c,0xc765,0x57fb,0x96,0x7d,0xc7,0xcb,0x60,0x97,0xbd,0x78] as IID_IVector_1_Windows_Media_Protection_RevocationAndRenewalItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVector<super::super::media::speechrecognition::ISpeechRecognitionConstraint> => [0x2691d763,0x561e,0x5060,0xbb,0xc9,0x7b,0x07,0x36,0x1a,0xcc,0x95] as IID_IVector_1_Windows_Media_SpeechRecognition_ISpeechRecognitionConstraint }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::HostName> => [0x90c71c29,0xa9b5,0x5267,0xa5,0xad,0x8b,0x75,0x67,0x36,0x31,0x7c] as IID_IVector_1_Windows_Networking_HostName }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::vpn::VpnAppId> => [0x89097d58,0xedb8,0x5ad4,0xab,0xc5,0x60,0x3f,0x21,0xdd,0x4b,0x15] as IID_IVector_1_Windows_Networking_Vpn_VpnAppId }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::vpn::VpnDomainNameInfo> => [0x8179b6f2,0x7273,0x5ca3,0xa8,0x1b,0x53,0xe9,0x02,0xca,0x20,0x9b] as IID_IVector_1_Windows_Networking_Vpn_VpnDomainNameInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::vpn::VpnNamespaceInfo> => [0x056bddf2,0x135d,0x542e,0xa3,0x22,0x36,0xaa,0x4c,0xa0,0xe6,0x0d] as IID_IVector_1_Windows_Networking_Vpn_VpnNamespaceInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::vpn::VpnRoute> => [0x5b026bd8,0x2cc5,0x5570,0xbd,0xe5,0x0d,0xb7,0xc4,0x33,0x12,0x79] as IID_IVector_1_Windows_Networking_Vpn_VpnRoute }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::vpn::VpnTrafficFilter> => [0x2a5b9ad8,0xf005,0x5f69,0xad,0x81,0x30,0x06,0x42,0xe7,0xc6,0x67] as IID_IVector_1_Windows_Networking_Vpn_VpnTrafficFilter }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::xboxlive::XboxLiveDeviceAddress> => [0x8aacb2da,0xc37e,0x5be0,0xab,0x46,0xba,0x44,0x59,0x10,0xb9,0xcb] as IID_IVector_1_Windows_Networking_XboxLive_XboxLiveDeviceAddress }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVector<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetric> => [0x8f3109d5,0xdc6b,0x58d1,0x9f,0x70,0x60,0xcc,0x47,0xbf,0x1c,0xed] as IID_IVector_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetric }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVector<super::super::security::authentication::web::provider::WebProviderTokenResponse> => [0x4e7ad5cf,0x390f,0x5ecd,0xb7,0x14,0x3c,0x65,0x4b,0x84,0xcb,0xba] as IID_IVector_1_Windows_Security_Authentication_Web_Provider_WebProviderTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVector<super::super::security::cryptography::certificates::Certificate> => [0x36282c0f,0x2f1f,0x57f4,0xb2,0xb1,0x86,0x7a,0xf9,0x0c,0x3d,0x13] as IID_IVector_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVector<super::super::security::cryptography::certificates::ChainValidationResult> => [0xd7828cf7,0x4301,0x58d3,0xaa,0xb5,0x06,0xe5,0xee,0xfc,0xf7,0x9f] as IID_IVector_1_Windows_Security_Cryptography_Certificates_ChainValidationResult }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVector<super::super::storage::IStorageItem> => [0x802508e2,0x9c2c,0x5b91,0x89,0xa8,0x39,0xbc,0xf7,0x22,0x33,0x44] as IID_IVector_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVector<super::super::storage::search::SortEntry> => [0xd8ea401b,0x47b3,0x5254,0x84,0xf4,0xee,0xa1,0x0c,0x4c,0xf0,0x68] as IID_IVector_1_Windows_Storage_Search_SortEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVector<super::super::storage::StorageFile> => [0xfcbc8b8b,0x6103,0x5b4e,0xba,0x00,0x4b,0xc2,0xce,0xdb,0x6a,0x35] as IID_IVector_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVector<super::super::storage::StorageFolder> => [0x6c26b7be,0x5f01,0x5a60,0x9d,0xd7,0xfd,0x17,0xbe,0x3a,0x9d,0xd6] as IID_IVector_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVector<super::super::storage::streams::IRandomAccessStream> => [0x2736b66b,0xdaa3,0x5e0c,0x98,0x42,0x6a,0x0f,0x44,0xb5,0x44,0x0b] as IID_IVector_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::applicationsettings::CredentialCommand> => [0xb6af1cb5,0xf60e,0x5b08,0xb3,0x12,0x2e,0xb5,0x11,0x35,0xcf,0xc6] as IID_IVector_1_Windows_UI_ApplicationSettings_CredentialCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::applicationsettings::SettingsCommand> => [0x10bd9cdd,0x3767,0x5e96,0x90,0x22,0xf0,0x0f,0x9c,0xbd,0x62,0x41] as IID_IVector_1_Windows_UI_ApplicationSettings_SettingsCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::applicationsettings::WebAccountCommand> => [0x64e864c8,0x7fef,0x5df5,0xa6,0x24,0x50,0xb5,0x77,0xf4,0x85,0x54] as IID_IVector_1_Windows_UI_ApplicationSettings_WebAccountCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::applicationsettings::WebAccountProviderCommand> => [0xd376abf3,0xf0c1,0x5233,0x9f,0x42,0xde,0x53,0x18,0x84,0x96,0x3e] as IID_IVector_1_Windows_UI_ApplicationSettings_WebAccountProviderCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::input::inking::InkPoint> => [0x10c47202,0x47ab,0x58bc,0x91,0xde,0xd5,0x00,0x0f,0x1a,0x74,0xc0] as IID_IVector_1_Windows_UI_Input_Inking_InkPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::input::PointerPoint> => [0xdfa655cf,0xfde7,0x5048,0xb4,0xbf,0xc9,0x09,0x23,0x1b,0x7e,0xdb] as IID_IVector_1_Windows_UI_Input_PointerPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::input::RadialControllerMenuItem> => [0xbfde94e7,0x70f8,0x5cc0,0x98,0xe2,0x8c,0x0f,0x8c,0xe5,0x24,0xab] as IID_IVector_1_Windows_UI_Input_RadialControllerMenuItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::notifications::NotificationBinding> => [0x7f7d8ad7,0xb4d2,0x5a03,0xbe,0x6f,0x2b,0x89,0x87,0x5f,0xb3,0x2d] as IID_IVector_1_Windows_UI_Notifications_NotificationBinding }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::popups::IUICommand> => [0x105139a1,0xdcb8,0x5f65,0x97,0xef,0xcb,0x1b,0xf0,0xb7,0x5f,0x9d] as IID_IVector_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVector<super::super::ui::startscreen::JumpListItem> => [0xaf8f3fb2,0xf179,0x5f0a,0xaa,0x09,0x28,0x94,0x2e,0xed,0xf6,0x25] as IID_IVector_1_Windows_UI_StartScreen_JumpListItem }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::automation::AutomationAnnotation> => [0x73596c82,0xf6e5,0x5b57,0x8d,0xc5,0x55,0x6c,0xb7,0xa8,0xfb,0xe6] as IID_IVector_1_Windows_UI_Xaml_Automation_AutomationAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::automation::peers::AutomationPeer> => [0xa8d8a409,0x9130,0x5e14,0x84,0x26,0x07,0x82,0xaa,0xf0,0x16,0x08] as IID_IVector_1_Windows_UI_Xaml_Automation_Peers_AutomationPeer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::automation::peers::AutomationPeerAnnotation> => [0xd353f885,0x4bf0,0x5dc2,0x87,0x8e,0xec,0x7a,0x39,0x4e,0xe8,0x80] as IID_IVector_1_Windows_UI_Xaml_Automation_Peers_AutomationPeerAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::ColumnDefinition> => [0x6e137874,0xdd39,0x5b4f,0xa7,0xec,0x2e,0xa6,0x9e,0x4c,0x22,0x29] as IID_IVector_1_Windows_UI_Xaml_Controls_ColumnDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::GroupStyle> => [0xbfb6a4c1,0x12bb,0x5f22,0xa0,0x8a,0x8e,0xba,0xb3,0x86,0x43,0x96] as IID_IVector_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::HubSection> => [0x8e47087a,0x3ce3,0x57dc,0xa5,0x83,0x7d,0xb9,0xbf,0x18,0x8f,0xc4] as IID_IVector_1_Windows_UI_Xaml_Controls_HubSection }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::ICommandBarElement> => [0x18ad7c66,0xa127,0x550f,0x83,0x25,0x8c,0xf1,0x78,0x91,0x76,0xc1] as IID_IVector_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::maps::MapElement> => [0x02773f2d,0xbb17,0x56fd,0x96,0xcc,0x89,0xf1,0xc4,0x7f,0x9e,0x11] as IID_IVector_1_Windows_UI_Xaml_Controls_Maps_MapElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::maps::MapRouteView> => [0x8ce513b4,0x0a7d,0x5553,0xb7,0x35,0x79,0xcd,0x5a,0x7f,0xee,0x3f] as IID_IVector_1_Windows_UI_Xaml_Controls_Maps_MapRouteView }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::maps::MapTileSource> => [0x19f78a46,0x2c65,0x5f94,0xbf,0x5b,0x96,0x33,0x47,0xa0,0xa3,0x18] as IID_IVector_1_Windows_UI_Xaml_Controls_Maps_MapTileSource }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::MenuFlyoutItemBase> => [0xf7f1c37b,0xb4df,0x5128,0xa4,0x76,0xfc,0x83,0x99,0xbc,0x10,0xaf] as IID_IVector_1_Windows_UI_Xaml_Controls_MenuFlyoutItemBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::RowDefinition> => [0x62225981,0x7a0d,0x5d38,0x80,0x88,0x7c,0x6b,0xb6,0xd9,0x59,0xbe] as IID_IVector_1_Windows_UI_Xaml_Controls_RowDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::controls::WebViewDeferredPermissionRequest> => [0xee0e5bc7,0x4440,0x5970,0xa8,0x78,0x2d,0x35,0x1e,0x00,0x93,0x1a] as IID_IVector_1_Windows_UI_Xaml_Controls_WebViewDeferredPermissionRequest }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::DependencyObject> => [0x771b857e,0xab5c,0x5db8,0xa0,0x21,0x39,0x7c,0x92,0xcd,0xc4,0x4c] as IID_IVector_1_Windows_UI_Xaml_DependencyObject }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::documents::Block> => [0x3ee78a34,0x160e,0x50ff,0xb5,0xaa,0x09,0xf2,0x63,0xa6,0x69,0xf8] as IID_IVector_1_Windows_UI_Xaml_Documents_Block }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::documents::Inline> => [0x92ec9252,0x8ee3,0x55d6,0x84,0xb4,0x30,0xb6,0x35,0x07,0x77,0x78] as IID_IVector_1_Windows_UI_Xaml_Documents_Inline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::input::InputScopeName> => [0x703fe123,0xd766,0x562f,0xb2,0x10,0x19,0x80,0xbb,0x2a,0x0d,0x33] as IID_IVector_1_Windows_UI_Xaml_Input_InputScopeName }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::ColorKeyFrame> => [0x92d24fb8,0xaf54,0x5180,0x98,0x88,0x57,0x56,0x56,0x6a,0x13,0xff] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_ColorKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::DoubleKeyFrame> => [0xd7cbde22,0x86bf,0x572f,0x84,0x73,0x07,0x9d,0x15,0x07,0x6c,0x3e] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_DoubleKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::ObjectKeyFrame> => [0x5f733d3f,0x72a6,0x5303,0x97,0x27,0x2b,0x03,0xea,0xe7,0xdd,0x4c] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_ObjectKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::PointKeyFrame> => [0xb17e26de,0x9cd7,0x5456,0xbe,0xe0,0x49,0x88,0x2a,0x87,0xf9,0x45] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_PointKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::Timeline> => [0x2005c7f9,0xc7d7,0x521b,0xa8,0x1c,0x2c,0x9d,0xad,0x77,0xa9,0xe8] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_Timeline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::animation::Transition> => [0xe798571f,0x7e3e,0x5e1a,0xaa,0x55,0xcb,0xc9,0x3b,0x83,0xf8,0x21] as IID_IVector_1_Windows_UI_Xaml_Media_Animation_Transition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::Brush> => [0xa8cd84e4,0x3edf,0x5172,0x8f,0x77,0x10,0xe9,0x10,0xe5,0xdc,0x5d] as IID_IVector_1_Windows_UI_Xaml_Media_Brush }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::Geometry> => [0x84c6ac3a,0x8207,0x5599,0x95,0x83,0x60,0x6a,0xc2,0x13,0x9d,0xdd] as IID_IVector_1_Windows_UI_Xaml_Media_Geometry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::GradientStop> => [0x33422da4,0x24f3,0x5b52,0x9e,0x8d,0x11,0xdd,0x71,0xf0,0x8b,0xb1] as IID_IVector_1_Windows_UI_Xaml_Media_GradientStop }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::PathFigure> => [0xde29d405,0x26dd,0x5e72,0x8b,0xcb,0x49,0x51,0x99,0xd4,0xe5,0xb5] as IID_IVector_1_Windows_UI_Xaml_Media_PathFigure }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::PathSegment> => [0x11fdd506,0xb21d,0x564d,0xb6,0xa8,0xff,0x99,0x10,0x57,0xb8,0xf3] as IID_IVector_1_Windows_UI_Xaml_Media_PathSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::TimelineMarker> => [0xb2d8ddb4,0xd2b8,0x5930,0x94,0x2d,0x26,0x11,0x87,0x56,0xbd,0x46] as IID_IVector_1_Windows_UI_Xaml_Media_TimelineMarker }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::media::Transform> => [0x62d7bbc1,0x71f5,0x5611,0xa9,0x84,0xe5,0x71,0xc2,0xde,0x7b,0xaa] as IID_IVector_1_Windows_UI_Xaml_Media_Transform }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::navigation::PageStackEntry> => [0xe561a13f,0x89a1,0x5ef2,0xa3,0xfe,0xeb,0xa1,0xb4,0x53,0x9b,0x46] as IID_IVector_1_Windows_UI_Xaml_Navigation_PageStackEntry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::ResourceDictionary> => [0xfe820a0c,0x694d,0x518b,0x8e,0xc5,0x37,0x29,0x93,0xf6,0xce,0xaf] as IID_IVector_1_Windows_UI_Xaml_ResourceDictionary }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::StateTriggerBase> => [0x72dbaa30,0x9016,0x51d9,0x85,0x00,0x4b,0x21,0x5b,0x5c,0xb4,0x68] as IID_IVector_1_Windows_UI_Xaml_StateTriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::TriggerAction> => [0xa488f35d,0x9ffc,0x5250,0xac,0x19,0x94,0x16,0x77,0x7b,0x17,0x5a] as IID_IVector_1_Windows_UI_Xaml_TriggerAction }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::TriggerBase> => [0x9149863b,0xb78b,0x5fb6,0xa0,0xa1,0x9e,0xbf,0x6b,0xbc,0x34,0x07] as IID_IVector_1_Windows_UI_Xaml_TriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::UIElement> => [0xb4c1e3ac,0x8768,0x5b9d,0xa6,0x61,0xf6,0x33,0x30,0xb8,0x50,0x7b] as IID_IVector_1_Windows_UI_Xaml_UIElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::VisualState> => [0x5b6d19b8,0xbc0c,0x5a77,0xa4,0x06,0xc0,0x1c,0x12,0xfd,0x46,0xc3] as IID_IVector_1_Windows_UI_Xaml_VisualState }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::VisualStateGroup> => [0x729a0392,0x675e,0x58e4,0xb6,0xa3,0x04,0x57,0xbb,0x9e,0xa9,0x68] as IID_IVector_1_Windows_UI_Xaml_VisualStateGroup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVector<super::super::ui::xaml::VisualTransition> => [0x5aebeb8c,0x7ef7,0x5975,0xba,0x0a,0x6c,0x19,0xa5,0x29,0xbb,0x72] as IID_IVector_1_Windows_UI_Xaml_VisualTransition }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::http::headers::HttpNameValueHeaderValue> => [0x2cf800d4,0x35d0,0x545c,0xab,0x82,0xf6,0x79,0x3b,0xe7,0x4c,0xba] as IID_IVector_1_Windows_Web_Http_Headers_HttpNameValueHeaderValue }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::http::HttpCookie> => [0x98a6c2fe,0x469b,0x5bdd,0xa1,0x6d,0x70,0x02,0xc3,0xa0,0x85,0x3d] as IID_IVector_1_Windows_Web_Http_HttpCookie }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::ISyndicationNode> => [0xf4508afa,0x9f02,0x5eb8,0xa3,0x89,0x14,0xbb,0xe5,0x19,0x3a,0xc0] as IID_IVector_1_Windows_Web_Syndication_ISyndicationNode }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::SyndicationAttribute> => [0x2fe84e7b,0x2350,0x5941,0x94,0xb5,0xa6,0x46,0x77,0xb5,0x85,0xd1] as IID_IVector_1_Windows_Web_Syndication_SyndicationAttribute }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::SyndicationCategory> => [0x72e456e4,0x0e52,0x52cb,0xb3,0x63,0xf3,0x58,0x13,0x27,0xf0,0x33] as IID_IVector_1_Windows_Web_Syndication_SyndicationCategory }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::SyndicationItem> => [0xaa01130b,0x4631,0x5117,0x8c,0x48,0xdc,0x21,0xb0,0x29,0x50,0x96] as IID_IVector_1_Windows_Web_Syndication_SyndicationItem }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::SyndicationLink> => [0xb8fb25a5,0x01c3,0x5207,0x81,0x4e,0x89,0x2b,0x2b,0x53,0x43,0xf7] as IID_IVector_1_Windows_Web_Syndication_SyndicationLink }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVector<super::super::web::syndication::SyndicationPerson> => [0xab772cd6,0x8ce7,0x5db9,0x83,0xac,0x0d,0xb9,0xe4,0x4a,0x1b,0x0c] as IID_IVector_1_Windows_Web_Syndication_SyndicationPerson }
		RT_PINTERFACE!{ for IVector<super::Uri> => [0x0d82bd8d,0xfe62,0x5d67,0xa7,0xb9,0x78,0x86,0xdd,0x75,0xbc,0x4e] as IID_IVector_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for IVector<u32> => [0x534832ed,0x2a03,0x5604,0x89,0x0d,0x5a,0x92,0x8c,0xd4,0x27,0xb9] as IID_IVector_1_System_UInt32 }
		RT_PINTERFACE!{ for IVectorView<::Guid> => [0x9520e64b,0x15b2,0x52a6,0x98,0xed,0x31,0x91,0xfa,0x6c,0xf6,0x8a] as IID_IVectorView_1_System_Guid }
		RT_PINTERFACE!{ for IVectorView<f32> => [0x7bca64fd,0x150c,0x5d50,0xb5,0x6b,0x9f,0x4f,0x47,0x4c,0x59,0x30] as IID_IVectorView_1_System_Single }
		RT_PINTERFACE!{ for IVectorView<f64> => [0xaf7586a8,0x6b21,0x5f61,0xbf,0xf1,0x1b,0x68,0x22,0x93,0xad,0x96] as IID_IVectorView_1_System_Double }
		RT_PINTERFACE!{ for IVectorView<HString> => [0x2f13c006,0xa03a,0x5f69,0xb0,0x90,0x75,0xa4,0x3e,0x33,0x42,0x3e] as IID_IVectorView_1_System_String }
		RT_PINTERFACE!{ for IVectorView<i32> => [0x8d720cdf,0x3934,0x5d3f,0x9a,0x55,0x40,0xe8,0x06,0x3b,0x08,0x6a] as IID_IVectorView_1_System_Int32 }
		RT_PINTERFACE!{ for IVectorView<IInspectable> => [0xa6487363,0xb074,0x5c60,0xab,0x16,0x86,0x6d,0xce,0x4e,0xe5,0x4d] as IID_IVectorView_1_System_Object }
		RT_PINTERFACE!{ for IVectorView<IMapView<HString, IInspectable>> => [0x172a655b,0xb3b8,0x5eae,0xbc,0x2e,0xa6,0xa1,0xf1,0x70,0x8b,0x4b] as IID_IVectorView_1_Windows_Foundation_Collections_IMapView_2_System_String_System_Object }
		RT_PINTERFACE!{ for IVectorView<super::DateTime> => [0x135a5f72,0xa818,0x54a8,0xb9,0x55,0xdf,0xf2,0x59,0x3a,0x3b,0xf5] as IID_IVectorView_1_Windows_Foundation_DateTime }
		RT_PINTERFACE!{ for IVectorView<super::Point> => [0x0b7b4c9d,0x182f,0x582a,0xbd,0xdb,0x42,0xb1,0xaa,0xc3,0x0c,0xad] as IID_IVectorView_1_Windows_Foundation_Point }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appextensions::AppExtension> => [0x94520810,0x7e9b,0x5efd,0xb7,0x4d,0xe9,0xd4,0x17,0x5f,0xd9,0x4a] as IID_IVectorView_1_Windows_ApplicationModel_AppExtensions_AppExtension }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::AppInfo> => [0x8246ed12,0x33e8,0x52b3,0xa5,0xc5,0x19,0x77,0x9d,0xe9,0x99,0x9e] as IID_IVectorView_1_Windows_ApplicationModel_AppInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appointments::Appointment> => [0x61021758,0x9e37,0x5a86,0xa8,0x32,0xaa,0xb3,0x1f,0x32,0x69,0x2b] as IID_IVectorView_1_Windows_ApplicationModel_Appointments_Appointment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appointments::AppointmentCalendar> => [0x774512d3,0xa564,0x5f8d,0xb1,0x04,0x3e,0xc8,0xf2,0xa1,0x10,0x4f] as IID_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentCalendar }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appointments::AppointmentException> => [0xe5030866,0x08d8,0x56be,0xa2,0x1b,0xc5,0xbf,0x80,0xd7,0x03,0x60] as IID_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentException }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appointments::AppointmentInvitee> => [0xba2f633a,0x5182,0x5eda,0x8e,0x2e,0xa6,0x6e,0x55,0xb3,0x20,0xce] as IID_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentInvitee }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::appointments::AppointmentStoreChange> => [0x4f9dd4e5,0xc3ae,0x5269,0xaf,0xf5,0xfe,0x35,0xcd,0x50,0xc3,0xbb] as IID_IVectorView_1_Windows_ApplicationModel_Appointments_AppointmentStoreChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::calls::PhoneCallHistoryEntry> => [0x452ce6ed,0xa06d,0x58fb,0xbe,0x06,0xcb,0x43,0x30,0xb7,0xf5,0xc7] as IID_IVectorView_1_Windows_ApplicationModel_Calls_PhoneCallHistoryEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatConversation> => [0x8d4e5cf4,0x610b,0x5a29,0xb6,0x6a,0x26,0x49,0x70,0x0f,0x52,0x45] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatMessage> => [0xac612e87,0x63fd,0x5c05,0x99,0x9a,0x0d,0xae,0x0d,0x8e,0xc7,0xa3] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatMessageAttachment> => [0x50f5c38b,0x749f,0x5bf6,0x95,0x60,0x11,0xa9,0x87,0x6f,0x20,0xd1] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatMessageChange> => [0x447a59fc,0xe729,0x5846,0x91,0xda,0xb6,0x50,0xfd,0xec,0xa7,0x85] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatMessageTransport> => [0xc7b1733f,0x6e87,0x5a65,0x85,0x42,0xcf,0x36,0xa4,0x52,0x16,0x95] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatMessageTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::ChatRecipientDeliveryInfo> => [0x7897ffd3,0x7d86,0x5c89,0xbb,0xe2,0xca,0x70,0x8d,0x1a,0x33,0x98] as IID_IVectorView_1_Windows_ApplicationModel_Chat_ChatRecipientDeliveryInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::IChatItem> => [0x4e46b3db,0xf003,0x5bfc,0x9e,0xeb,0xf7,0x02,0xf0,0x80,0x19,0x49] as IID_IVectorView_1_Windows_ApplicationModel_Chat_IChatItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::RcsEndUserMessageAction> => [0x9607e377,0xe873,0x5091,0x9e,0x32,0x86,0x95,0xe8,0xf5,0x0e,0x7a] as IID_IVectorView_1_Windows_ApplicationModel_Chat_RcsEndUserMessageAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::chat::RcsTransport> => [0x0627ce33,0x6cf1,0x5bc9,0x95,0x08,0x93,0x8d,0x67,0xa4,0x94,0xed] as IID_IVectorView_1_Windows_ApplicationModel_Chat_RcsTransport }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::Contact> => [0x9bca75b8,0xb0fa,0x5761,0xb9,0x59,0x38,0x19,0x27,0xa5,0xf9,0xd0] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_Contact }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactAddress> => [0xe7fabc7d,0x79c2,0x5862,0x85,0x9e,0x95,0x90,0x02,0xd7,0xb9,0x55] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAddress }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactAnnotation> => [0xb79bca82,0x9ddb,0x51df,0x94,0xec,0x2f,0x33,0x9c,0xd9,0x06,0xe9] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactAnnotationList> => [0x3bf71d9d,0x2037,0x5e08,0xa7,0xe1,0xb9,0x37,0xcf,0x74,0xbb,0xd9] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactAnnotationList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactChange> => [0xe97bb481,0xb86d,0x504f,0xb3,0x09,0x44,0xc9,0xb0,0x98,0xe9,0x2d] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactConnectedServiceAccount> => [0x2687a6f4,0x5f99,0x50a1,0x88,0xd1,0x5d,0x7c,0xc7,0xc7,0xf2,0x36] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactConnectedServiceAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactDate> => [0x2743425d,0xb197,0x598d,0xbb,0x80,0x14,0xfd,0xf0,0xea,0xa8,0x23] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactDate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactEmail> => [0x8c3e5f9e,0x825a,0x5164,0x90,0xd3,0xf9,0x7f,0x7f,0x88,0xec,0xb0] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactEmail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactField> => [0x9c1b3046,0xf16a,0x57d7,0x87,0xa7,0xea,0xa2,0xe8,0x80,0xd9,0xa9] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactFieldType> => [0x39d6abda,0xa00a,0x5777,0x86,0x11,0x82,0xd7,0xc3,0x26,0xc1,0x8d] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactFieldType }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactInformation> => [0xb9e80b52,0x02cb,0x5824,0x95,0xab,0x5c,0xca,0x3d,0xe3,0x94,0xd3] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactInformation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactInstantMessageField> => [0xb65efa04,0xcda8,0x597a,0x8a,0xbb,0xa6,0xe1,0xfe,0x34,0xc0,0x0f] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactInstantMessageField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactJobInfo> => [0xf1f1bdc5,0x7ffe,0x5254,0x89,0xfc,0xc0,0x15,0x59,0x02,0x0f,0x9d] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactJobInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactList> => [0xa55c7dcf,0xe3c9,0x5afa,0x86,0x67,0xca,0x68,0x23,0x0d,0x77,0x24] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactList }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactLocationField> => [0x1febf4ca,0x48dd,0x5faf,0xa2,0xd3,0x74,0x77,0x0d,0x8a,0xa3,0x30] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactLocationField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactMatchReason> => [0xc82c0b6d,0x28d6,0x5c27,0x92,0x6d,0x96,0xd0,0x27,0x50,0x88,0x71] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactMatchReason }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactPhone> => [0x145e78a9,0xe7f9,0x5998,0x80,0x2a,0xdb,0xfc,0x91,0x4c,0xcf,0x36] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactPhone }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactSignificantOther> => [0x33c5edf9,0xc1de,0x528b,0xaa,0x48,0xce,0xb6,0xa1,0x90,0x5c,0xc0] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactSignificantOther }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::ContactWebsite> => [0xf677e62f,0x39c5,0x57c0,0xb6,0x42,0x26,0xb1,0x43,0x30,0x98,0x71] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_ContactWebsite }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::contacts::IContactField> => [0x1a4c5b35,0x7ef5,0x5eea,0x94,0xc7,0xfd,0xf1,0xf6,0x17,0xaa,0x7e] as IID_IVectorView_1_Windows_ApplicationModel_Contacts_IContactField }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::core::AppListEntry> => [0x920c8b92,0xd5ef,0x5899,0x87,0x76,0x2a,0xd9,0x7a,0xca,0x6e,0x1d] as IID_IVectorView_1_Windows_ApplicationModel_Core_AppListEntry }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::core::CoreApplicationView> => [0xde9e16c4,0x1b7c,0x5126,0xb1,0xd8,0x7c,0xd0,0x4f,0x13,0xbd,0x08] as IID_IVectorView_1_Windows_ApplicationModel_Core_CoreApplicationView }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailAttachment> => [0x1d71b8e6,0x3f41,0x51cc,0x89,0x4b,0xdb,0xc1,0x0e,0xbc,0x9d,0x52] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailAttachment }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailCertificateValidationStatus> => [0xa5665ff7,0xb44e,0x57e3,0xbd,0x7a,0xef,0x19,0x1a,0xa5,0x51,0x9c] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailCertificateValidationStatus }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailConversation> => [0x0a7c62d7,0xfc19,0x5bd7,0xb3,0x7a,0x0d,0x62,0x42,0xdf,0x48,0xc0] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailConversation }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailFolder> => [0x4e35d275,0xabdf,0x5e2c,0xb3,0xe8,0x75,0x46,0xed,0x5a,0xd5,0x73] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailFolder }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailMailbox> => [0xd4816e16,0x43c9,0x5b63,0xa4,0x44,0x61,0x89,0xac,0xb5,0x6f,0x6e] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailMailbox }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailMailboxAction> => [0xf7bdef91,0xbeff,0x5be2,0x8e,0xf9,0x2f,0x81,0x12,0xe5,0x9a,0x6f] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailMailboxAction }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailMailboxChange> => [0x9ea98fb4,0x9e7e,0x5caa,0xa3,0x20,0xcc,0x7a,0xb5,0x33,0x80,0x84] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailMailboxChange }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailMessage> => [0x51b8edf2,0x6ca6,0x55de,0xbe,0x45,0x1d,0x1f,0xc5,0x1d,0xf0,0x76] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailMessage }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailRecipient> => [0xf6d6af60,0xf11a,0x5c03,0x80,0xcc,0x47,0x34,0x07,0xa5,0xaa,0xbf] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailRecipient }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::email::EmailRecipientResolutionResult> => [0x9307eb24,0x38f6,0x525e,0xba,0x0d,0x3b,0x4e,0x86,0x3f,0xe0,0xf8] as IID_IVectorView_1_Windows_ApplicationModel_Email_EmailRecipientResolutionResult }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::lockscreen::LockScreenBadge> => [0xa0734995,0x94c2,0x50c2,0x88,0xa2,0xd0,0x70,0xfc,0xd1,0xd3,0x38] as IID_IVectorView_1_Windows_ApplicationModel_LockScreen_LockScreenBadge }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::Package> => [0x0263c4d4,0x195c,0x5dc5,0xa7,0xca,0x68,0x06,0xce,0xca,0x42,0x0b] as IID_IVectorView_1_Windows_ApplicationModel_Package }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::core::NamedResource> => [0x66c9da16,0xd345,0x5bdb,0xb9,0x53,0xd8,0x6d,0xd9,0xea,0x84,0x09] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Core_NamedResource }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::core::ResourceCandidate> => [0xe28e92f0,0x9ffb,0x5ea7,0x9f,0xc9,0xa7,0x3b,0xda,0x47,0x18,0x86] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Core_ResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::core::ResourceMap> => [0xf2656ef5,0xfc27,0x5c24,0xa8,0xc2,0x16,0x97,0xe0,0xbe,0x73,0x6f] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Core_ResourceMap }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::core::ResourceQualifier> => [0xb82c58dc,0x1cc0,0x53f0,0xb0,0xf4,0x66,0xef,0x39,0xa8,0x1c,0xd6] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Core_ResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::management::IndexedResourceCandidate> => [0x1da243f1,0xbb95,0x543e,0x95,0xc6,0x5f,0xd1,0x96,0xb3,0x4b,0x6f] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Management_IndexedResourceCandidate }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::resources::management::IndexedResourceQualifier> => [0x239ded48,0xce04,0x51f2,0xb2,0xc9,0xa5,0xe5,0xab,0x67,0x1b,0x8d] as IID_IVectorView_1_Windows_ApplicationModel_Resources_Management_IndexedResourceQualifier }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::search::core::SearchSuggestion> => [0x05ac2ec0,0xf0c8,0x5cad,0xb4,0xf9,0xf9,0x85,0xe0,0xf7,0x9f,0xe9] as IID_IVectorView_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::socialinfo::SocialFeedItem> => [0xe6be2bb8,0xfc75,0x585c,0x83,0x6c,0x34,0xf3,0xff,0x87,0x68,0x0f] as IID_IVectorView_1_Windows_ApplicationModel_SocialInfo_SocialFeedItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::socialinfo::SocialItemThumbnail> => [0x9a3e6d46,0xe880,0x5deb,0x90,0x06,0x92,0xfe,0x5c,0x43,0xac,0xe1] as IID_IVectorView_1_Windows_ApplicationModel_SocialInfo_SocialItemThumbnail }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::StartupTask> => [0xea3b1b7a,0x5071,0x5986,0x88,0xfc,0x91,0x2d,0xbb,0xf8,0x45,0xfb] as IID_IVectorView_1_Windows_ApplicationModel_StartupTask }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::store::preview::installcontrol::AppInstallItem> => [0x48d7f874,0xa83c,0x55db,0xb2,0xe6,0x94,0x0b,0xe9,0x56,0x98,0x69] as IID_IVectorView_1_Windows_ApplicationModel_Store_Preview_InstallControl_AppInstallItem }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::store::preview::StorePreviewProductInfo> => [0xfcc6add5,0xdc28,0x500f,0x8e,0x24,0xb2,0x2d,0x1a,0xb5,0x6a,0xad] as IID_IVectorView_1_Windows_ApplicationModel_Store_Preview_StorePreviewProductInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::store::preview::StorePreviewSkuInfo> => [0x47418723,0xa671,0x5fdc,0x86,0x47,0x68,0xf7,0xd8,0xc3,0x14,0x16] as IID_IVectorView_1_Windows_ApplicationModel_Store_Preview_StorePreviewSkuInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::store::preview::StoreSystemFeature> => [0xc8f90757,0xebcf,0x5f2c,0xb9,0x18,0x64,0x87,0x10,0x5b,0x0c,0xa1] as IID_IVectorView_1_Windows_ApplicationModel_Store_Preview_StoreSystemFeature }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::store::UnfulfilledConsumable> => [0xf0ae5962,0xe039,0x5105,0xbc,0xc5,0x9b,0x55,0x2f,0x13,0xb1,0x02] as IID_IVectorView_1_Windows_ApplicationModel_Store_UnfulfilledConsumable }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::userdataaccounts::provider::UserDataAccountPartnerAccountInfo> => [0xb730f093,0xe2fb,0x5b20,0x9d,0x9e,0x4f,0x9d,0xef,0xe6,0x47,0xb0] as IID_IVectorView_1_Windows_ApplicationModel_UserDataAccounts_Provider_UserDataAccountPartnerAccountInfo }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::userdataaccounts::UserDataAccount> => [0x65f4f73e,0x3271,0x5999,0x93,0xd8,0x5a,0x3d,0x78,0xbe,0x13,0xa6] as IID_IVectorView_1_Windows_ApplicationModel_UserDataAccounts_UserDataAccount }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::voicecommands::VoiceCommandContentTile> => [0xcb2c6693,0x1fc9,0x5b95,0x99,0xb5,0x72,0x39,0x67,0x96,0x19,0xb9] as IID_IVectorView_1_Windows_ApplicationModel_VoiceCommands_VoiceCommandContentTile }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for IVectorView<super::super::applicationmodel::wallet::WalletItem> => [0x2dc89188,0x2b5b,0x591a,0xbb,0x3d,0xd7,0xd5,0x7f,0xf7,0x31,0x2c] as IID_IVectorView_1_Windows_ApplicationModel_Wallet_WalletItem }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IVectorView<super::super::data::text::AlternateWordForm> => [0x6b742ff2,0x746a,0x5545,0xa6,0xed,0x3b,0xba,0x45,0x3c,0xf5,0xd9] as IID_IVectorView_1_Windows_Data_Text_AlternateWordForm }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IVectorView<super::super::data::text::SelectableWordSegment> => [0x33f90a72,0x86f4,0x5027,0xb5,0x0a,0x69,0x39,0xa1,0xf9,0xd5,0x60] as IID_IVectorView_1_Windows_Data_Text_SelectableWordSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IVectorView<super::super::data::text::TextPhoneme> => [0xcfc6e66d,0x5e2a,0x582d,0x8b,0x6d,0xfb,0xf7,0x1c,0xf3,0xd0,0xeb] as IID_IVectorView_1_Windows_Data_Text_TextPhoneme }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IVectorView<super::super::data::text::TextSegment> => [0x2f245f9d,0xeb5f,0x5641,0x9d,0xcc,0x6a,0xb1,0x94,0x6c,0xc7,0xe6] as IID_IVectorView_1_Windows_Data_Text_TextSegment }
		#[cfg(feature="windows.data")] RT_PINTERFACE!{ for IVectorView<super::super::data::text::WordSegment> => [0xc706749a,0xe11d,0x5e07,0x85,0x34,0x2b,0xd2,0x3e,0xc2,0x10,0xf9] as IID_IVectorView_1_Windows_Data_Text_WordSegment }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::adc::AdcController> => [0x27547dc1,0x376e,0x5ce4,0xa2,0x46,0x34,0xf2,0x10,0xc8,0x44,0x3c] as IID_IVectorView_1_Windows_Devices_Adc_AdcController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::adc::provider::IAdcControllerProvider> => [0x7c4789c0,0x8445,0x5757,0xaa,0xb7,0x65,0x9c,0xbf,0x50,0xaa,0xa7] as IID_IVectorView_1_Windows_Devices_Adc_Provider_IAdcControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::alljoyn::AllJoynAuthenticationMechanism> => [0xeaf57f86,0xb059,0x5ac2,0x9c,0x1f,0xd3,0xc6,0x5e,0xac,0x67,0xa3] as IID_IVectorView_1_Windows_Devices_AllJoyn_AllJoynAuthenticationMechanism }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementBytePattern> => [0xa7d9983a,0xa11f,0x572e,0x89,0xfb,0x68,0x3e,0xa4,0x29,0xbc,0xbc] as IID_IVectorView_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementBytePattern }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementDataSection> => [0xc4f2b8ea,0x11a8,0x5109,0x90,0x13,0x40,0x47,0xe1,0x2c,0x72,0xe8] as IID_IVectorView_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementDataSection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementReceivedEventArgs> => [0x8aef9bca,0xfe7d,0x5966,0x97,0x89,0xfe,0xde,0x24,0xcb,0x41,0xc4] as IID_IVectorView_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementReceivedEventArgs }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::advertisement::BluetoothLEManufacturerData> => [0x78ab070e,0xad7e,0x5912,0xa4,0xf1,0x7b,0xe3,0x3e,0x45,0x60,0xaf] as IID_IVectorView_1_Windows_Devices_Bluetooth_Advertisement_BluetoothLEManufacturerData }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic> => [0xcb3ab3ae,0xb561,0x504f,0xa8,0x08,0x59,0x9d,0xec,0xeb,0x2d,0xf4] as IID_IVectorView_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattCharacteristic }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::genericattributeprofile::GattDescriptor> => [0x19605ea8,0x73d6,0x5760,0x84,0x9b,0xfe,0x5f,0x8a,0x2b,0xd0,0x5c] as IID_IVectorView_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::genericattributeprofile::GattDeviceService> => [0x7c8e7fdd,0xa1a1,0x528a,0x81,0xd1,0x29,0x67,0x69,0x22,0x7a,0x08] as IID_IVectorView_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::genericattributeprofile::GattPresentationFormat> => [0x0ea2c154,0x22b8,0x5c8e,0x92,0x5d,0xd4,0x7e,0x1a,0xad,0x31,0xbb] as IID_IVectorView_1_Windows_Devices_Bluetooth_GenericAttributeProfile_GattPresentationFormat }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::bluetooth::rfcomm::RfcommDeviceService> => [0x97df6b82,0xd15c,0x597e,0xba,0x69,0x49,0x22,0x07,0xa1,0xc1,0x08] as IID_IVectorView_1_Windows_Devices_Bluetooth_Rfcomm_RfcommDeviceService }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::enumeration::DeviceClass> => [0x01a80a97,0xbd87,0x5c8a,0x97,0xfd,0xd4,0x49,0xc9,0x8b,0xda,0xc6] as IID_IVectorView_1_Windows_Devices_Enumeration_DeviceClass }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::enumeration::DeviceInformation> => [0xe170688f,0x3495,0x5bf6,0xaa,0xb5,0x9c,0xac,0x17,0xe0,0xf1,0x0f] as IID_IVectorView_1_Windows_Devices_Enumeration_DeviceInformation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::enumeration::DeviceWatcherEvent> => [0x8f994d37,0x8fab,0x51c6,0xa1,0xe0,0xc9,0x3f,0x68,0xa2,0x0e,0xf0] as IID_IVectorView_1_Windows_Devices_Enumeration_DeviceWatcherEvent }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::enumeration::pnp::PnpObject> => [0xcce5a798,0xd269,0x5fce,0x99,0xce,0xef,0x0a,0xe3,0xcd,0x05,0x69] as IID_IVectorView_1_Windows_Devices_Enumeration_Pnp_PnpObject }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::geolocation::BasicGeoposition> => [0x177f5719,0xe234,0x59db,0x99,0xba,0xf7,0xfd,0xdd,0xf3,0x14,0x30] as IID_IVectorView_1_Windows_Devices_Geolocation_BasicGeoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::geolocation::geofencing::Geofence> => [0xd8039aca,0x1a45,0x5d13,0x8c,0xfd,0x49,0x00,0xc2,0x2b,0x8e,0xf1] as IID_IVectorView_1_Windows_Devices_Geolocation_Geofencing_Geofence }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::geolocation::geofencing::GeofenceStateChangeReport> => [0xea91593d,0xecf4,0x5041,0x86,0xf2,0x83,0x7a,0x28,0x2c,0x4d,0x94] as IID_IVectorView_1_Windows_Devices_Geolocation_Geofencing_GeofenceStateChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::geolocation::Geopath> => [0xa83321cb,0x1b54,0x5f68,0x92,0x34,0x4a,0x82,0x4d,0x33,0xe3,0x71] as IID_IVectorView_1_Windows_Devices_Geolocation_Geopath }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::geolocation::Geoposition> => [0xd572ccf3,0x0c60,0x553f,0xa6,0x24,0xc7,0x16,0x48,0xaf,0x8e,0x7a] as IID_IVectorView_1_Windows_Devices_Geolocation_Geoposition }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::gpio::GpioController> => [0x7fc72a82,0x2c57,0x5c01,0xa6,0x52,0xa8,0xbd,0xac,0x68,0x5d,0x30] as IID_IVectorView_1_Windows_Devices_Gpio_GpioController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::gpio::provider::IGpioControllerProvider> => [0xf429355f,0x7a16,0x5dcf,0xa5,0x75,0xdb,0x7d,0x2a,0x20,0xec,0xed] as IID_IVectorView_1_Windows_Devices_Gpio_Provider_IGpioControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::humaninterfacedevice::HidBooleanControl> => [0x0e417dac,0x591a,0x5de0,0xaf,0xd6,0x0b,0x2c,0x04,0xc3,0x04,0xe7] as IID_IVectorView_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControl }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::humaninterfacedevice::HidBooleanControlDescription> => [0xaab72786,0xec34,0x536f,0xa7,0xc5,0x27,0x39,0x47,0x53,0xdf,0x2c] as IID_IVectorView_1_Windows_Devices_HumanInterfaceDevice_HidBooleanControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::humaninterfacedevice::HidCollection> => [0x96f1faac,0x348f,0x5b8f,0xa7,0x1d,0x2d,0x65,0x0e,0x0b,0x11,0xf2] as IID_IVectorView_1_Windows_Devices_HumanInterfaceDevice_HidCollection }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::humaninterfacedevice::HidNumericControlDescription> => [0xe02ca66c,0x610a,0x51b4,0xae,0xf9,0x37,0x07,0xb6,0x97,0xb9,0x85] as IID_IVectorView_1_Windows_Devices_HumanInterfaceDevice_HidNumericControlDescription }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::i2c::I2cController> => [0xc5dd481d,0xa441,0x5a8c,0x86,0x5f,0x08,0xfa,0x31,0x49,0x0d,0xe5] as IID_IVectorView_1_Windows_Devices_I2c_I2cController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::i2c::provider::II2cControllerProvider> => [0x511f8a39,0x98ca,0x550d,0xaf,0x25,0x1d,0xf2,0xc1,0x19,0x3c,0x01] as IID_IVectorView_1_Windows_Devices_I2c_Provider_II2cControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::input::PointerDevice> => [0xcf5674f1,0x9808,0x5a2b,0x80,0xb8,0x56,0x84,0xed,0x0e,0xa8,0x16] as IID_IVectorView_1_Windows_Devices_Input_PointerDevice }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::input::PointerDeviceUsage> => [0x8e5a2c7e,0x3830,0x50d5,0x92,0xba,0x31,0x63,0xc8,0x9c,0xbb,0xd0] as IID_IVectorView_1_Windows_Devices_Input_PointerDeviceUsage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::perception::PerceptionColorFrameSource> => [0xcbf2f698,0x31a0,0x53c7,0x92,0x7b,0x8e,0x16,0x75,0xf7,0x43,0xbc] as IID_IVectorView_1_Windows_Devices_Perception_PerceptionColorFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::perception::PerceptionDepthFrameSource> => [0x574d3642,0x9f78,0x5125,0x85,0x1f,0x8b,0x67,0xe0,0x31,0x3e,0x2f] as IID_IVectorView_1_Windows_Devices_Perception_PerceptionDepthFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::perception::PerceptionInfraredFrameSource> => [0xf272ae7a,0xc5c4,0x5712,0x85,0x52,0x01,0xde,0xb8,0xb7,0x0e,0x07] as IID_IVectorView_1_Windows_Devices_Perception_PerceptionInfraredFrameSource }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::perception::PerceptionVideoProfile> => [0x8dcb30e8,0x4ec1,0x51b7,0x99,0x97,0x10,0xf3,0x25,0xf0,0x3d,0x47] as IID_IVectorView_1_Windows_Devices_Perception_PerceptionVideoProfile }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::perception::provider::PerceptionCorrelation> => [0x244cad66,0xafbe,0x5394,0xb7,0xb7,0x43,0xa6,0x1f,0xcb,0xfc,0x6d] as IID_IVectorView_1_Windows_Devices_Perception_Provider_PerceptionCorrelation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::pointofservice::PosPrinterRotation> => [0x6f694309,0x1082,0x5d84,0xa5,0xea,0x2f,0xae,0xd6,0xb6,0x59,0x0e] as IID_IVectorView_1_Windows_Devices_PointOfService_PosPrinterRotation }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::pwm::provider::IPwmControllerProvider> => [0x1a166093,0x1a7a,0x5e12,0x9d,0x38,0xf8,0x92,0xfe,0xc3,0xec,0x66] as IID_IVectorView_1_Windows_Devices_Pwm_Provider_IPwmControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::pwm::PwmController> => [0x07cb8bac,0x3bac,0x5ea0,0x91,0x9a,0x9e,0xaf,0x62,0x02,0x70,0xae] as IID_IVectorView_1_Windows_Devices_Pwm_PwmController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::radios::Radio> => [0x65066c36,0x090b,0x5466,0xb8,0xe5,0xe7,0x56,0x5d,0xc3,0x41,0x75] as IID_IVectorView_1_Windows_Devices_Radios_Radio }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sensors::ActivitySensorReading> => [0x726234a9,0x7137,0x55c4,0xa4,0x44,0x35,0x2d,0xcd,0xc3,0x0d,0x77] as IID_IVectorView_1_Windows_Devices_Sensors_ActivitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sensors::ActivitySensorReadingChangeReport> => [0x10e48a80,0xdd6a,0x5704,0x8f,0x3d,0x3d,0x46,0x11,0x1f,0x39,0x1e] as IID_IVectorView_1_Windows_Devices_Sensors_ActivitySensorReadingChangeReport }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sensors::ActivityType> => [0xfc7a0488,0x2803,0x505c,0x9e,0x62,0x92,0x00,0xaf,0xe4,0x16,0xc6] as IID_IVectorView_1_Windows_Devices_Sensors_ActivityType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sensors::PedometerReading> => [0x52076f5c,0x7838,0x54d9,0x95,0x17,0x55,0x11,0xeb,0x62,0x79,0x52] as IID_IVectorView_1_Windows_Devices_Sensors_PedometerReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sensors::ProximitySensorReading> => [0x7a09d76c,0x8ced,0x5e30,0xb7,0xfe,0x1f,0xf7,0x4d,0x4d,0x98,0x14] as IID_IVectorView_1_Windows_Devices_Sensors_ProximitySensorReading }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::smartcards::SmartCard> => [0x4bee6991,0x3508,0x5f03,0xa2,0xf4,0x90,0xa5,0xdd,0xb2,0x6b,0xd8] as IID_IVectorView_1_Windows_Devices_SmartCards_SmartCard }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sms::ISmsBinaryMessage> => [0x6ea176ea,0x99ea,0x5c79,0x87,0x6a,0xf4,0xc4,0x37,0xb8,0x3d,0xf6] as IID_IVectorView_1_Windows_Devices_Sms_ISmsBinaryMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sms::ISmsMessage> => [0xd3acc5b1,0x6f85,0x507e,0xb4,0x0a,0x69,0x50,0x74,0x9b,0x42,0x6f] as IID_IVectorView_1_Windows_Devices_Sms_ISmsMessage }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sms::SmsBroadcastType> => [0x4063e791,0xda2d,0x5e4c,0x91,0x13,0x5b,0x6b,0xa0,0xa7,0xc5,0x95] as IID_IVectorView_1_Windows_Devices_Sms_SmsBroadcastType }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sms::SmsFilterRule> => [0xf3ed4299,0xde36,0x5d82,0x99,0x3f,0x35,0xfc,0x67,0x7d,0x8b,0x72] as IID_IVectorView_1_Windows_Devices_Sms_SmsFilterRule }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::sms::SmsMessageRegistration> => [0x23aaa815,0x24ef,0x57c4,0xb1,0xbc,0x94,0xd6,0x2c,0x0a,0x59,0xa3] as IID_IVectorView_1_Windows_Devices_Sms_SmsMessageRegistration }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::spi::provider::ISpiControllerProvider> => [0x96a4919b,0x3229,0x5e41,0x8b,0x10,0xc8,0x19,0x8c,0x44,0xf1,0x0c] as IID_IVectorView_1_Windows_Devices_Spi_Provider_ISpiControllerProvider }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::spi::SpiController> => [0x35fec489,0x44a2,0x5543,0x8a,0x0c,0xb5,0x2e,0x2f,0x9c,0xf8,0x7c] as IID_IVectorView_1_Windows_Devices_Spi_SpiController }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbBulkInEndpointDescriptor> => [0x9c69ac78,0x309e,0x5763,0xaf,0x26,0x97,0x06,0xff,0xa4,0x7e,0xc0] as IID_IVectorView_1_Windows_Devices_Usb_UsbBulkInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbBulkInPipe> => [0xa93c84bc,0x6484,0x5959,0xb6,0x1a,0x70,0x3c,0xc7,0x11,0x5f,0x6f] as IID_IVectorView_1_Windows_Devices_Usb_UsbBulkInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbBulkOutEndpointDescriptor> => [0x22a53676,0xa3ea,0x5dcd,0xbb,0x39,0xb2,0x8a,0x53,0x27,0xc4,0xa3] as IID_IVectorView_1_Windows_Devices_Usb_UsbBulkOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbBulkOutPipe> => [0x0a873512,0x15f1,0x5e8e,0xa7,0x2a,0x04,0x5c,0xfd,0x7a,0x5e,0x83] as IID_IVectorView_1_Windows_Devices_Usb_UsbBulkOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbDescriptor> => [0x5408baa2,0x291e,0x537a,0xb6,0x1f,0x13,0x70,0x62,0xf7,0xff,0x7d] as IID_IVectorView_1_Windows_Devices_Usb_UsbDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterface> => [0x9c69ec7f,0x2e42,0x58cd,0xa7,0x4a,0xf4,0x97,0x48,0x11,0x13,0x4d] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterface }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterfaceSetting> => [0x71194af7,0x77c2,0x54d5,0xa1,0x16,0x28,0x7f,0x0b,0x7f,0xd5,0x3f] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterfaceSetting }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterruptInEndpointDescriptor> => [0x3fc7f890,0x218e,0x5057,0x90,0x4d,0x63,0x87,0xc5,0x91,0xcc,0x93] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterruptInEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterruptInPipe> => [0x37469574,0xb4c5,0x5ba0,0x96,0x16,0x89,0x4d,0xd8,0x22,0xff,0x5b] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterruptInPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterruptOutEndpointDescriptor> => [0x984e7e15,0xc5ac,0x5140,0xa3,0xc0,0xb5,0x83,0x19,0x00,0x85,0xd7] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterruptOutEndpointDescriptor }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::usb::UsbInterruptOutPipe> => [0x748196c8,0x83bf,0x5ec3,0x8d,0x28,0xa3,0x11,0x2b,0x3e,0xe3,0xcc] as IID_IVectorView_1_Windows_Devices_Usb_UsbInterruptOutPipe }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::wifi::WiFiAdapter> => [0x670a3c41,0xecc8,0x55c2,0x84,0xd4,0x51,0x86,0x44,0x96,0xa3,0x28] as IID_IVectorView_1_Windows_Devices_WiFi_WiFiAdapter }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::wifi::WiFiAvailableNetwork> => [0x7c65d286,0x7285,0x5d63,0xbd,0xea,0x5e,0xf9,0x51,0xbd,0xf6,0x18] as IID_IVectorView_1_Windows_Devices_WiFi_WiFiAvailableNetwork }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::wifidirect::services::WiFiDirectServiceConfigurationMethod> => [0xdc710fe1,0x7f04,0x515b,0x8a,0xc1,0x1c,0x5d,0x3c,0x0d,0x2b,0x28] as IID_IVectorView_1_Windows_Devices_WiFiDirect_Services_WiFiDirectServiceConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::wifidirect::WiFiDirectConfigurationMethod> => [0x61a32670,0x04d3,0x551d,0xad,0x66,0xbd,0x04,0xe9,0xef,0x5c,0x78] as IID_IVectorView_1_Windows_Devices_WiFiDirect_WiFiDirectConfigurationMethod }
		#[cfg(feature="windows.devices")] RT_PINTERFACE!{ for IVectorView<super::super::devices::wifidirect::WiFiDirectInformationElement> => [0x6dcffadb,0x04c5,0x535e,0xad,0xd4,0x13,0x89,0xb3,0xbe,0x6e,0xca] as IID_IVectorView_1_Windows_Devices_WiFiDirect_WiFiDirectInformationElement }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::input::ArcadeStick> => [0xbecace75,0xd0cd,0x5a9c,0x84,0x5f,0x72,0xf0,0x85,0x50,0x3c,0xdf] as IID_IVectorView_1_Windows_Gaming_Input_ArcadeStick }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::input::Gamepad> => [0xeb97bb69,0x09c9,0x5a99,0x86,0xb2,0x3e,0x36,0x08,0x52,0x84,0xd4] as IID_IVectorView_1_Windows_Gaming_Input_Gamepad }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::input::RacingWheel> => [0x153993b2,0x6052,0x5959,0x91,0xec,0x90,0x0c,0x53,0xfe,0xf1,0x20] as IID_IVectorView_1_Windows_Gaming_Input_RacingWheel }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::input::UINavigationController> => [0x684b9e5a,0x2dc2,0x54fc,0xad,0xf5,0x5c,0xa8,0xf6,0x87,0x14,0x25] as IID_IVectorView_1_Windows_Gaming_Input_UINavigationController }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::preview::gamesenumeration::GameListEntry> => [0x0eea1ad9,0x03e2,0x5ba9,0xae,0x02,0xda,0xca,0x43,0x2f,0x36,0x2a] as IID_IVectorView_1_Windows_Gaming_Preview_GamesEnumeration_GameListEntry }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::xboxlive::storage::GameSaveBlobInfo> => [0xb9c466a0,0x2a3f,0x5f28,0xa1,0xc1,0x9c,0xb1,0x92,0xf6,0xc7,0x86] as IID_IVectorView_1_Windows_Gaming_XboxLive_Storage_GameSaveBlobInfo }
		#[cfg(feature="windows.gaming")] RT_PINTERFACE!{ for IVectorView<super::super::gaming::xboxlive::storage::GameSaveContainerInfo> => [0x9c490594,0x0846,0x50f5,0xb2,0xef,0xc6,0xf0,0x3e,0xe6,0x86,0x8a] as IID_IVectorView_1_Windows_Gaming_XboxLive_Storage_GameSaveContainerInfo }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IVectorView<super::super::globalization::JapanesePhoneme> => [0x4cdc5bd0,0xd4aa,0x5b60,0xbf,0x25,0x71,0x44,0x90,0x50,0x50,0xf9] as IID_IVectorView_1_Windows_Globalization_JapanesePhoneme }
		#[cfg(feature="windows.globalization")] RT_PINTERFACE!{ for IVectorView<super::super::globalization::Language> => [0x144b0f3d,0x2d59,0x5dd2,0xb0,0x12,0x90,0x8e,0xc3,0xe0,0x64,0x35] as IID_IVectorView_1_Windows_Globalization_Language }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::directx::direct3d11::IDirect3DSurface> => [0x1a81ec3e,0x5afb,0x5e10,0x92,0xbb,0xc8,0x43,0xfe,0xc7,0x08,0x87] as IID_IVectorView_1_Windows_Graphics_DirectX_Direct3D11_IDirect3DSurface }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::directx::DirectXPixelFormat> => [0x1edda1c2,0x0f6e,0x516c,0x80,0xb8,0x76,0x87,0xdc,0xd1,0x28,0x0e] as IID_IVectorView_1_Windows_Graphics_DirectX_DirectXPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::holographic::HolographicCamera> => [0x01d6c0ae,0xada5,0x50b0,0x85,0x62,0x41,0xfb,0x12,0x05,0xbb,0x4a] as IID_IVectorView_1_Windows_Graphics_Holographic_HolographicCamera }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::holographic::HolographicCameraPose> => [0x17c5dfb1,0x6e87,0x5a17,0xa7,0x91,0xac,0x07,0xf8,0xee,0x92,0x92] as IID_IVectorView_1_Windows_Graphics_Holographic_HolographicCameraPose }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::imaging::BitmapCodecInformation> => [0x97dfde96,0xff1d,0x5aa1,0x86,0x3a,0x90,0x11,0x6a,0x31,0xb8,0x6b] as IID_IVectorView_1_Windows_Graphics_Imaging_BitmapCodecInformation }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::imaging::BitmapPixelFormat> => [0x76ac4bc2,0xc19c,0x559c,0xb2,0x87,0x16,0x94,0xc0,0xdc,0x3a,0x0d] as IID_IVectorView_1_Windows_Graphics_Imaging_BitmapPixelFormat }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::imaging::ImageStream> => [0xab10f3e5,0x2a3e,0x5f81,0xb5,0xe8,0x8d,0xdd,0xdc,0x23,0xcc,0xa2] as IID_IVectorView_1_Windows_Graphics_Imaging_ImageStream }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DBaseMaterial> => [0xccc6f0a2,0x4dd9,0x550d,0x85,0x78,0x33,0x0e,0x13,0x8a,0xda,0x07] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DBaseMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DBaseMaterialGroup> => [0x5c686c2e,0xcd88,0x5255,0xa9,0x61,0x5b,0x4f,0x2b,0xf1,0x3c,0x70] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DBaseMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DColorMaterial> => [0x80da978e,0x7cc2,0x531f,0x81,0x6b,0xfa,0x68,0xaa,0x44,0x6e,0x8c] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DColorMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DColorMaterialGroup> => [0xdcb0b640,0x8a0f,0x57c3,0x9e,0x3e,0xd5,0xa9,0x88,0x1c,0xc2,0x11] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DColorMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DComponent> => [0xc3cc9d7c,0xb25f,0x5e52,0x94,0x74,0x9d,0x29,0x15,0xf4,0x4e,0xac] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DComponent }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DComponentWithMatrix> => [0x0ed56a87,0x7746,0x5448,0x8d,0x9d,0xdf,0xf9,0xfa,0x9f,0xd7,0x60] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DComponentWithMatrix }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DCompositeMaterial> => [0xdc940322,0x2b4f,0x5c6a,0xb7,0xf6,0x35,0x8c,0xed,0x33,0xbc,0x68] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DCompositeMaterialGroup> => [0x06715e0b,0x52f1,0x5d86,0x9e,0xec,0x1f,0x07,0x97,0x36,0x33,0x83] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DCompositeMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DMesh> => [0x4b836ce6,0x1d16,0x5e55,0xb1,0xa0,0x61,0xc7,0x0f,0x29,0x93,0x1b] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DMesh }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DModelTexture> => [0x338e034d,0x8832,0x5c05,0x81,0xbf,0x27,0xab,0x7f,0x49,0x26,0x4a] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DModelTexture }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterial> => [0xac971e5e,0xac32,0x587b,0xa7,0x01,0xfb,0xbe,0x6a,0xf1,0xb1,0x12] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DMultiplePropertyMaterialGroup> => [0x8513d339,0x12e9,0x5d0b,0x97,0x8d,0xfe,0x96,0x7d,0x05,0x13,0x15] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DMultiplePropertyMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DTexture2CoordMaterial> => [0x155500dd,0xf08a,0x5b43,0x87,0x14,0x8b,0xc0,0x17,0x94,0xce,0x23] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterial }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DTexture2CoordMaterialGroup> => [0x4d44ec40,0x4f39,0x5532,0xb9,0xda,0x6a,0x6f,0x9a,0x61,0xa8,0x42] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DTexture2CoordMaterialGroup }
		#[cfg(feature="windows.graphics")] RT_PINTERFACE!{ for IVectorView<super::super::graphics::printing3d::Printing3DTextureResource> => [0x0a4964cd,0xd387,0x5d71,0xa7,0x1d,0x4f,0x0a,0x55,0xb9,0xb6,0x89] as IID_IVectorView_1_Windows_Graphics_Printing3D_Printing3DTextureResource }
		#[cfg(feature="windows.management")] RT_PINTERFACE!{ for IVectorView<super::super::management::deployment::PackageVolume> => [0x50b5715a,0xf077,0x53d1,0x89,0x6d,0xb1,0x32,0xc4,0x87,0x01,0xf4] as IID_IVectorView_1_Windows_Management_Deployment_PackageVolume }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::audio::AudioGraphConnection> => [0x8485aed1,0x9b0c,0x59d2,0xa2,0x06,0x69,0x9b,0xf7,0x46,0xc3,0xff] as IID_IVectorView_1_Windows_Media_Audio_AudioGraphConnection }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::audio::EqualizerBand> => [0x48f26053,0xea7d,0x59e1,0x95,0x2b,0xfb,0x78,0xaf,0x42,0xd2,0xe2] as IID_IVectorView_1_Windows_Media_Audio_EqualizerBand }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::capture::frames::MediaFrameFormat> => [0xbae2547d,0x3fae,0x55cd,0xb2,0x09,0x45,0xc3,0xb5,0xb2,0xf8,0x16] as IID_IVectorView_1_Windows_Media_Capture_Frames_MediaFrameFormat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::capture::frames::MediaFrameSourceGroup> => [0xd01148ae,0xcccd,0x56eb,0xb2,0xb4,0xa7,0xd2,0xac,0xce,0x14,0xec] as IID_IVectorView_1_Windows_Media_Capture_Frames_MediaFrameSourceGroup }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::capture::frames::MediaFrameSourceInfo> => [0xdbdb7946,0x9b30,0x51d0,0x9c,0x8c,0xc7,0x10,0x5a,0xf6,0x90,0xe0] as IID_IVectorView_1_Windows_Media_Capture_Frames_MediaFrameSourceInfo }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::capture::MediaCaptureVideoProfile> => [0x75626cf9,0x1f99,0x5e10,0xbd,0x03,0xf2,0x96,0x1e,0x85,0xaf,0x1f] as IID_IVectorView_1_Windows_Media_Capture_MediaCaptureVideoProfile }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::capture::MediaCaptureVideoProfileMediaDescription> => [0x726c7c8c,0x789e,0x5fcb,0xb3,0x1f,0xf9,0xd9,0xd4,0xa3,0xac,0x42] as IID_IVectorView_1_Windows_Media_Capture_MediaCaptureVideoProfileMediaDescription }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::casting::CastingSource> => [0x7828da61,0xdea4,0x5485,0xb2,0x7a,0x8f,0x78,0xe0,0x47,0x24,0x02] as IID_IVectorView_1_Windows_Media_Casting_CastingSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::AudioStreamDescriptor> => [0x340f4fed,0x1288,0x5b89,0xbe,0x7c,0xc3,0x55,0xfe,0x1c,0xe4,0xd9] as IID_IVectorView_1_Windows_Media_Core_AudioStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::AudioTrack> => [0xe71ffa4a,0x14a7,0x5068,0x89,0x1c,0x6e,0x71,0x7a,0xf8,0xbf,0x8d] as IID_IVectorView_1_Windows_Media_Core_AudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::IMediaCue> => [0x996421a1,0x625c,0x5d92,0xad,0x68,0x8b,0x39,0x11,0xd2,0x94,0xb0] as IID_IVectorView_1_Windows_Media_Core_IMediaCue }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::MseSourceBuffer> => [0x85318263,0x1360,0x5c78,0xb0,0xad,0x52,0xd6,0xb4,0x5b,0x19,0xf3] as IID_IVectorView_1_Windows_Media_Core_MseSourceBuffer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::MseTimeRange> => [0x87ff1dd1,0x7ec3,0x5bc5,0xb5,0x58,0x04,0x25,0xd8,0x06,0xbf,0x4b] as IID_IVectorView_1_Windows_Media_Core_MseTimeRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::TimedMetadataTrack> => [0x0313ae7a,0x2803,0x5d45,0xb5,0xa1,0xa0,0xfc,0x5c,0xd5,0x5e,0x7c] as IID_IVectorView_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::TimedTextLine> => [0x9532b5cc,0x73fc,0x5e3a,0x85,0x31,0x79,0x4c,0x30,0xd7,0xa1,0xae] as IID_IVectorView_1_Windows_Media_Core_TimedTextLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::TimedTextSource> => [0xedcd634e,0xb7e4,0x5ff8,0xb8,0xc2,0x84,0x93,0x84,0x9b,0x2c,0x0d] as IID_IVectorView_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::TimedTextSubformat> => [0x411a0e26,0x42e2,0x5e65,0xb9,0xc4,0x98,0x0c,0x4c,0x3f,0x31,0xf7] as IID_IVectorView_1_Windows_Media_Core_TimedTextSubformat }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::VideoStreamDescriptor> => [0xe965c8af,0xd211,0x52f0,0x83,0x8b,0x46,0x37,0x46,0x9d,0xa7,0xaf] as IID_IVectorView_1_Windows_Media_Core_VideoStreamDescriptor }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::core::VideoTrack> => [0x200c6224,0x0b43,0x54fb,0x99,0x5f,0xfd,0x86,0x88,0xbf,0x24,0xde] as IID_IVectorView_1_Windows_Media_Core_VideoTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::AdvancedPhotoMode> => [0xd05843b6,0x03c8,0x523e,0xb6,0xfb,0x1f,0xcb,0x03,0x21,0x8a,0x54] as IID_IVectorView_1_Windows_Media_Devices_AdvancedPhotoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::AutoFocusRange> => [0x5df64825,0xc9e1,0x525f,0x9a,0xeb,0x3c,0x0f,0x5f,0x80,0x5f,0x26] as IID_IVectorView_1_Windows_Media_Devices_AutoFocusRange }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::CaptureSceneMode> => [0x9b915d69,0xe718,0x5b48,0xbb,0x94,0x54,0xbd,0xf3,0x73,0x7e,0xa5] as IID_IVectorView_1_Windows_Media_Devices_CaptureSceneMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::core::FrameController> => [0xfcd6a2a3,0xb6ff,0x5572,0x91,0x2b,0x99,0xeb,0xaf,0x95,0x16,0x5d] as IID_IVectorView_1_Windows_Media_Devices_Core_FrameController }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::FocusMode> => [0xc877975c,0xf3c3,0x5b3d,0x93,0xe4,0x57,0x87,0xbe,0x9b,0x7f,0x58] as IID_IVectorView_1_Windows_Media_Devices_FocusMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::FocusPreset> => [0xd8a495e3,0xd7d4,0x5e9f,0xa9,0xc2,0x6b,0x25,0x06,0x55,0xa2,0xe0] as IID_IVectorView_1_Windows_Media_Devices_FocusPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::HdrVideoMode> => [0xad0a4bbd,0x7630,0x53a4,0xaa,0x9b,0x35,0xa8,0xc7,0xd4,0x95,0x8c] as IID_IVectorView_1_Windows_Media_Devices_HdrVideoMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::IsoSpeedPreset> => [0xef6c9fe3,0x06f9,0x5eff,0x98,0xa8,0x91,0x7d,0x96,0x44,0xc9,0x46] as IID_IVectorView_1_Windows_Media_Devices_IsoSpeedPreset }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::ManualFocusDistance> => [0x85f7663b,0x5467,0x5736,0x8d,0x34,0x34,0x39,0x5a,0xa6,0xd1,0x23] as IID_IVectorView_1_Windows_Media_Devices_ManualFocusDistance }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::OpticalImageStabilizationMode> => [0x8c2658d8,0xacaa,0x5a80,0xb2,0x59,0x1b,0xa0,0x69,0x7c,0x61,0x38] as IID_IVectorView_1_Windows_Media_Devices_OpticalImageStabilizationMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::devices::ZoomTransitionMode> => [0x4d556155,0xd021,0x5a46,0x9a,0x1c,0xf4,0x01,0xd6,0x1b,0x85,0x29] as IID_IVectorView_1_Windows_Media_Devices_ZoomTransitionMode }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::editing::BackgroundAudioTrack> => [0x7fe52e32,0x867c,0x52a3,0xb3,0xb7,0xd4,0xdd,0x4d,0x57,0x37,0x94] as IID_IVectorView_1_Windows_Media_Editing_BackgroundAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::editing::EmbeddedAudioTrack> => [0x63d85bd5,0x4365,0x5e56,0x9e,0x40,0xe7,0xcd,0x30,0x51,0xae,0xbf] as IID_IVectorView_1_Windows_Media_Editing_EmbeddedAudioTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::editing::MediaClip> => [0xeabf18a6,0xf438,0x53b0,0xbe,0x3c,0xaf,0x21,0xe6,0x7b,0xc8,0xc7] as IID_IVectorView_1_Windows_Media_Editing_MediaClip }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::editing::MediaOverlay> => [0x6bba8a56,0x2f18,0x5a68,0x83,0xcd,0x9a,0xa9,0xd7,0xf8,0xf7,0x57] as IID_IVectorView_1_Windows_Media_Editing_MediaOverlay }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::editing::MediaOverlayLayer> => [0x8bcc3ff4,0x6139,0x52c1,0x96,0x69,0x53,0xda,0x50,0x33,0x18,0x5e] as IID_IVectorView_1_Windows_Media_Editing_MediaOverlayLayer }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::effects::AudioEffect> => [0xcdcbc9e7,0x53d8,0x5e66,0x9e,0x45,0x31,0xd5,0xa2,0x3f,0xd0,0x1d] as IID_IVectorView_1_Windows_Media_Effects_AudioEffect }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::effects::IAudioEffectDefinition> => [0xde9e6a7f,0xd28e,0x5ef1,0x91,0x6a,0xef,0xa8,0x80,0xb4,0x89,0xd1] as IID_IVectorView_1_Windows_Media_Effects_IAudioEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::effects::IVideoEffectDefinition> => [0xa44b4f8e,0x7ca3,0x53b1,0xb6,0x8b,0x09,0x8b,0xaf,0x45,0xc7,0x3e] as IID_IVectorView_1_Windows_Media_Effects_IVideoEffectDefinition }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::faceanalysis::DetectedFace> => [0x39ef4411,0x0618,0x5b8d,0x8e,0xa2,0x81,0xc6,0x37,0xf8,0x23,0xf8] as IID_IVectorView_1_Windows_Media_FaceAnalysis_DetectedFace }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::IMediaMarker> => [0xb543562c,0x02b1,0x5824,0x80,0xa8,0x98,0x54,0x13,0x0c,0xda,0xdd] as IID_IVectorView_1_Windows_Media_IMediaMarker }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportItem> => [0x9a90a84e,0x924b,0x5879,0x88,0xf7,0xbb,0x2f,0x7b,0x13,0x18,0x98] as IID_IVectorView_1_Windows_Media_Import_PhotoImportItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportOperation> => [0xa5b07808,0x7d18,0x5300,0x9f,0x01,0x1d,0x85,0x14,0x95,0x46,0xd2] as IID_IVectorView_1_Windows_Media_Import_PhotoImportOperation }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportSidecar> => [0xa6fa3abe,0xcdb9,0x5054,0xbf,0x3d,0x52,0x56,0x07,0xf9,0xc2,0xd2] as IID_IVectorView_1_Windows_Media_Import_PhotoImportSidecar }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportSource> => [0x8b7e83fc,0xe035,0x59dc,0x81,0x00,0xfc,0xb9,0x35,0xc2,0xd7,0xe4] as IID_IVectorView_1_Windows_Media_Import_PhotoImportSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportStorageMedium> => [0x35499439,0xe03e,0x5711,0xa9,0x55,0xf7,0xc4,0x59,0x28,0xbc,0x90] as IID_IVectorView_1_Windows_Media_Import_PhotoImportStorageMedium }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::import::PhotoImportVideoSegment> => [0xdb5493cd,0x6915,0x5682,0x8d,0xd5,0x1d,0xe1,0x44,0xec,0x59,0x9d] as IID_IVectorView_1_Windows_Media_Import_PhotoImportVideoSegment }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::mediaproperties::AudioEncodingProperties> => [0x64ac506c,0xccd0,0x56cb,0xb0,0x88,0xb1,0xa3,0x6e,0x87,0x55,0xdf] as IID_IVectorView_1_Windows_Media_MediaProperties_AudioEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::mediaproperties::IMediaEncodingProperties> => [0x0f6c3b8b,0x5818,0x5cbf,0xbf,0x26,0x66,0x16,0xbf,0xc3,0x08,0xc4] as IID_IVectorView_1_Windows_Media_MediaProperties_IMediaEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::mediaproperties::VideoEncodingProperties> => [0x04c7baba,0x04d7,0x51db,0xa4,0xe3,0x51,0x47,0x96,0x3e,0xc5,0xff] as IID_IVectorView_1_Windows_Media_MediaProperties_VideoEncodingProperties }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::ocr::OcrLine> => [0x60c76eac,0x8875,0x5ddb,0xa1,0x9b,0x65,0xa3,0x93,0x62,0x79,0xea] as IID_IVectorView_1_Windows_Media_Ocr_OcrLine }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::ocr::OcrWord> => [0x805a60c7,0xdf4f,0x527c,0x86,0xb2,0xe2,0x9e,0x43,0x9a,0x83,0xd2] as IID_IVectorView_1_Windows_Media_Ocr_OcrWord }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::playback::MediaBreak> => [0xc296f3f9,0x1268,0x59a2,0xb7,0xc3,0x2f,0x58,0x8e,0xd4,0xa0,0x17] as IID_IVectorView_1_Windows_Media_Playback_MediaBreak }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::playback::MediaPlaybackItem> => [0xb6a4c9fe,0xc73d,0x5eba,0xb5,0xab,0x6f,0x8d,0xea,0xca,0x30,0xb9] as IID_IVectorView_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::protection::RevocationAndRenewalItem> => [0x4a8793e2,0x33b8,0x5850,0x99,0x43,0x6a,0x94,0x37,0x5c,0xaa,0x89] as IID_IVectorView_1_Windows_Media_Protection_RevocationAndRenewalItem }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::speechrecognition::ISpeechRecognitionConstraint> => [0x341dee1d,0x6ac2,0x5d06,0x90,0x26,0xb3,0x0a,0xda,0x20,0x56,0x65] as IID_IVectorView_1_Windows_Media_SpeechRecognition_ISpeechRecognitionConstraint }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::speechrecognition::SpeechRecognitionResult> => [0x0e37810f,0x1de6,0x5199,0x83,0x3f,0x5a,0x6b,0x0b,0xd9,0x1e,0x23] as IID_IVectorView_1_Windows_Media_SpeechRecognition_SpeechRecognitionResult }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for IVectorView<super::super::media::speechsynthesis::VoiceInformation> => [0xee8d63ce,0x51ac,0x5984,0x89,0x1b,0xd2,0x32,0xfa,0x7f,0x64,0x53] as IID_IVectorView_1_Windows_Media_SpeechSynthesis_VoiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::backgroundtransfer::DownloadOperation> => [0xf87d9755,0x2a7d,0x59fc,0xbc,0x92,0xb4,0x86,0x36,0xf4,0xd9,0x55] as IID_IVectorView_1_Windows_Networking_BackgroundTransfer_DownloadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::backgroundtransfer::UploadOperation> => [0x8e96d4b0,0xf0ae,0x51cb,0xb7,0xc4,0x02,0x42,0x51,0xbd,0x16,0xd8] as IID_IVectorView_1_Windows_Networking_BackgroundTransfer_UploadOperation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::connectivity::AttributedNetworkUsage> => [0x6e7c44ad,0x7753,0x5437,0x9f,0x79,0x97,0x0d,0x39,0x1f,0xf7,0xc4] as IID_IVectorView_1_Windows_Networking_Connectivity_AttributedNetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::connectivity::ConnectionProfile> => [0x6db1b492,0x3852,0x5df8,0xa2,0x9d,0x69,0x44,0x00,0x2f,0x58,0xd4] as IID_IVectorView_1_Windows_Networking_Connectivity_ConnectionProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::connectivity::ConnectivityInterval> => [0xa3d0d117,0x9e21,0x5919,0xb7,0xa0,0xc8,0x19,0x0b,0xd5,0x5a,0xc5] as IID_IVectorView_1_Windows_Networking_Connectivity_ConnectivityInterval }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::connectivity::LanIdentifier> => [0x41286159,0xb91d,0x5736,0xad,0x8b,0xe1,0x6f,0xcf,0x8a,0xce,0xd0] as IID_IVectorView_1_Windows_Networking_Connectivity_LanIdentifier }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::connectivity::NetworkUsage> => [0xb3853391,0x40b6,0x5cf5,0x8f,0x46,0x48,0x82,0x69,0x1d,0x1f,0xf7] as IID_IVectorView_1_Windows_Networking_Connectivity_NetworkUsage }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::EndpointPair> => [0x8780a851,0x6d48,0x5006,0x92,0x88,0x81,0xf3,0xd7,0x04,0x5a,0x96] as IID_IVectorView_1_Windows_Networking_EndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::HostName> => [0xf4706ab1,0x55a3,0x5270,0xaf,0xb2,0x73,0x29,0x88,0xfe,0x82,0x27] as IID_IVectorView_1_Windows_Networking_HostName }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandDeviceServiceInformation> => [0xaca7ee14,0x414a,0x509c,0x9d,0x63,0x36,0x1e,0x66,0x31,0xfc,0x84] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandDeviceServiceInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandNetworkRegistrationStateChange> => [0x077679f5,0x6948,0x5328,0x8a,0xb4,0x72,0xe6,0x3a,0x75,0x29,0xbd] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandNetworkRegistrationStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandPinLockStateChange> => [0x2078b5f0,0x9fa1,0x5056,0x81,0xc7,0x49,0x02,0x46,0xa5,0xbc,0x13] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandPinLockStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandPinType> => [0x33394c13,0x028c,0x553e,0x86,0x7b,0x3c,0x7c,0x21,0xb6,0xf2,0x2d] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandPinType }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandRadioStateChange> => [0xca3d0221,0x58c8,0x516a,0xad,0xdf,0xd0,0xa8,0x69,0xfb,0xaa,0x49] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandRadioStateChange }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::MobileBroadbandUiccApp> => [0xd1e341f3,0x4e36,0x58c5,0x92,0xbf,0xdd,0x33,0x09,0x2e,0x39,0x0c] as IID_IVectorView_1_Windows_Networking_NetworkOperators_MobileBroadbandUiccApp }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::networkoperators::NetworkOperatorTetheringClient> => [0xe21d6797,0x4ef6,0x553f,0xb7,0xf9,0x5e,0xd7,0x4b,0xce,0xbd,0x7e] as IID_IVectorView_1_Windows_Networking_NetworkOperators_NetworkOperatorTetheringClient }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::proximity::PeerInformation> => [0x948f92bc,0x2a05,0x5c80,0x95,0xf2,0x96,0xfe,0x34,0x58,0x52,0xcc] as IID_IVectorView_1_Windows_Networking_Proximity_PeerInformation }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::servicediscovery::dnssd::DnssdServiceInstance> => [0xf75ff82a,0x7e10,0x5cf6,0x80,0x64,0x6a,0xe5,0x85,0xe0,0xbd,0x8d] as IID_IVectorView_1_Windows_Networking_ServiceDiscovery_Dnssd_DnssdServiceInstance }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::IVpnCustomPrompt> => [0x804449c2,0x3bc1,0x5cfe,0x84,0x68,0x3b,0xbe,0xce,0x4a,0x5c,0xd7] as IID_IVectorView_1_Windows_Networking_Vpn_IVpnCustomPrompt }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::IVpnCustomPromptElement> => [0x25eaf5eb,0x2f39,0x5b4d,0xbb,0x6e,0xe6,0x52,0xc7,0xd0,0x0f,0x6a] as IID_IVectorView_1_Windows_Networking_Vpn_IVpnCustomPromptElement }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::IVpnProfile> => [0xf1dc8f7d,0xca33,0x53fd,0x9d,0x4c,0x40,0xc5,0x1b,0x58,0x73,0xec] as IID_IVectorView_1_Windows_Networking_Vpn_IVpnProfile }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::VpnAppId> => [0xfaecbc50,0xda9a,0x5102,0x82,0x29,0x1d,0xd2,0x4e,0x87,0x3d,0x1f] as IID_IVectorView_1_Windows_Networking_Vpn_VpnAppId }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::VpnDomainNameInfo> => [0xd4772f57,0x2328,0x5c25,0x9a,0x11,0x24,0x6d,0xa1,0x7e,0x39,0xd5] as IID_IVectorView_1_Windows_Networking_Vpn_VpnDomainNameInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::VpnNamespaceInfo> => [0xc6ed05a9,0x4dc7,0x507d,0x9c,0x92,0x7c,0x78,0xc2,0xef,0x47,0x86] as IID_IVectorView_1_Windows_Networking_Vpn_VpnNamespaceInfo }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::VpnRoute> => [0x43701a74,0xe497,0x5559,0xa7,0x1b,0x11,0xd0,0x15,0x6f,0xa8,0x39] as IID_IVectorView_1_Windows_Networking_Vpn_VpnRoute }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::vpn::VpnTrafficFilter> => [0x75de1766,0xee22,0x56e9,0xbe,0x99,0x27,0x14,0x06,0x53,0x49,0xe5] as IID_IVectorView_1_Windows_Networking_Vpn_VpnTrafficFilter }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveDeviceAddress> => [0xa0594a5f,0x664d,0x52f2,0xa4,0xef,0x53,0xa2,0x3c,0x0d,0xea,0x3d] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveDeviceAddress }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveEndpointPair> => [0xc88caa17,0xae4a,0x5e4c,0x84,0x35,0xd6,0xdb,0x6b,0x12,0x04,0x64] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveEndpointPair }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveEndpointPairTemplate> => [0x1128b50b,0x3ac4,0x543e,0x9d,0x7e,0xd7,0x96,0xc6,0x22,0x66,0x69] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveEndpointPairTemplate }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetric> => [0x05b168df,0x9678,0x509d,0x90,0x57,0xa7,0x9f,0xd8,0x4b,0x54,0xbf] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetric }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveQualityOfServiceMetricResult> => [0xfd58662f,0xd206,0x5d57,0xa6,0xad,0xa8,0x45,0x67,0x18,0x7f,0x30] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveQualityOfServiceMetricResult }
		#[cfg(feature="windows.networking")] RT_PINTERFACE!{ for IVectorView<super::super::networking::xboxlive::XboxLiveQualityOfServicePrivatePayloadResult> => [0x821b8135,0x7801,0x5cb5,0xba,0xa4,0xfd,0x74,0x77,0x2f,0xb9,0x1c] as IID_IVectorView_1_Windows_Networking_XboxLive_XboxLiveQualityOfServicePrivatePayloadResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::identity::core::MicrosoftAccountMultiFactorSessionInfo> => [0x6abe486b,0xea5e,0x5fda,0x91,0x21,0x79,0xd8,0xa7,0x85,0xc4,0x65] as IID_IVectorView_1_Windows_Security_Authentication_Identity_Core_MicrosoftAccountMultiFactorSessionInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::identity::EnterpriseKeyCredentialRegistrationInfo> => [0x3b631cbb,0x63f8,0x5eff,0x88,0x15,0x69,0xc8,0x22,0xc0,0x9c,0xe1] as IID_IVectorView_1_Windows_Security_Authentication_Identity_EnterpriseKeyCredentialRegistrationInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::identity::provider::SecondaryAuthenticationFactorInfo> => [0x63c2e57e,0x3b00,0x5752,0x8f,0xa7,0xcb,0x9c,0xbe,0x8f,0xe0,0x88] as IID_IVectorView_1_Windows_Security_Authentication_Identity_Provider_SecondaryAuthenticationFactorInfo }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::onlineid::OnlineIdServiceTicket> => [0x45f03233,0xe7a8,0x5ade,0x9f,0xf3,0x0b,0x8a,0x1c,0x6b,0xa7,0x6b] as IID_IVectorView_1_Windows_Security_Authentication_OnlineId_OnlineIdServiceTicket }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::web::core::WebTokenResponse> => [0x199e065c,0x8195,0x55da,0x9c,0x10,0x8a,0xea,0xf9,0xac,0x10,0x62] as IID_IVectorView_1_Windows_Security_Authentication_Web_Core_WebTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::web::provider::WebAccountClientView> => [0x3dfd5eff,0x8fa4,0x5e9d,0x8d,0x1c,0x0f,0x18,0xd5,0x42,0xbe,0x35] as IID_IVectorView_1_Windows_Security_Authentication_Web_Provider_WebAccountClientView }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::authentication::web::provider::WebProviderTokenResponse> => [0x1ae644b7,0x9839,0x585b,0x87,0x92,0xec,0xd5,0x05,0x0b,0x88,0xbb] as IID_IVectorView_1_Windows_Security_Authentication_Web_Provider_WebProviderTokenResponse }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::credentials::PasswordCredential> => [0x4e6185ad,0xa6df,0x5428,0xaf,0xf5,0x17,0xe4,0x5f,0x3f,0x47,0x6f] as IID_IVectorView_1_Windows_Security_Credentials_PasswordCredential }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::credentials::WebAccount> => [0xe0798d3d,0x2b4a,0x589a,0xab,0x12,0x02,0xdc,0xcc,0x15,0x8a,0xfc] as IID_IVectorView_1_Windows_Security_Credentials_WebAccount }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::cryptography::certificates::Certificate> => [0x963f7013,0x77c2,0x51c5,0x80,0x38,0xb5,0xbc,0xef,0x63,0x3e,0xdb] as IID_IVectorView_1_Windows_Security_Cryptography_Certificates_Certificate }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::cryptography::certificates::ChainValidationResult> => [0xcb383486,0xc2bc,0x5756,0x91,0x2d,0x6a,0x70,0x8a,0x07,0xe5,0xbd] as IID_IVectorView_1_Windows_Security_Cryptography_Certificates_ChainValidationResult }
		#[cfg(feature="windows.security")] RT_PINTERFACE!{ for IVectorView<super::super::security::cryptography::certificates::CmsSignerInfo> => [0xf46bcaa8,0x747c,0x5a93,0x82,0xfe,0x85,0xd6,0x35,0x49,0xfe,0x81] as IID_IVectorView_1_Windows_Security_Cryptography_Certificates_CmsSignerInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::guidance::GuidanceLaneInfo> => [0x81493670,0xe515,0x5c62,0xb3,0x4c,0x6e,0x3d,0x99,0x6c,0xad,0x31] as IID_IVectorView_1_Windows_Services_Maps_Guidance_GuidanceLaneInfo }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::guidance::GuidanceManeuver> => [0x875644d8,0x57a4,0x59d6,0x9d,0x2c,0x5d,0x45,0x0d,0x39,0xd2,0xf6] as IID_IVectorView_1_Windows_Services_Maps_Guidance_GuidanceManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::guidance::GuidanceRoadSegment> => [0xf04c7cc2,0x4d54,0x5244,0xbe,0xb2,0x8f,0x4f,0x05,0xc1,0x84,0xe6] as IID_IVectorView_1_Windows_Services_Maps_Guidance_GuidanceRoadSegment }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::localsearch::LocalLocation> => [0x619192f2,0x4f9d,0x5629,0xab,0x01,0xb1,0x85,0x12,0x50,0x3d,0x73] as IID_IVectorView_1_Windows_Services_Maps_LocalSearch_LocalLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::localsearch::LocalLocationHoursOfOperationItem> => [0x65535172,0xcd91,0x5b4c,0xaa,0x60,0xda,0xb1,0x46,0x30,0x12,0x84] as IID_IVectorView_1_Windows_Services_Maps_LocalSearch_LocalLocationHoursOfOperationItem }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::MapLocation> => [0x58d33d10,0xe2ef,0x59f1,0xb8,0x5e,0xa8,0x81,0x9f,0xf0,0xd9,0x26] as IID_IVectorView_1_Windows_Services_Maps_MapLocation }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::MapRoute> => [0x265676a9,0x4a33,0x5d29,0x97,0x1e,0x82,0x44,0xa0,0x21,0xb8,0x4e] as IID_IVectorView_1_Windows_Services_Maps_MapRoute }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::MapRouteLeg> => [0xf9976360,0xb3b0,0x5a88,0xb1,0xb6,0xf4,0x33,0x9b,0xb8,0x5b,0xf0] as IID_IVectorView_1_Windows_Services_Maps_MapRouteLeg }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::maps::MapRouteManeuver> => [0xa3f56695,0x468f,0x55ef,0xb1,0x84,0xc9,0x8b,0x4c,0xc7,0xe4,0x84] as IID_IVectorView_1_Windows_Services_Maps_MapRouteManeuver }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StoreAvailability> => [0x01e5f751,0x8c50,0x52cb,0xab,0xc2,0xe9,0x86,0x24,0x02,0xc7,0x8a] as IID_IVectorView_1_Windows_Services_Store_StoreAvailability }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StoreImage> => [0x7e1ceace,0x82bd,0x5db3,0x8f,0x35,0x9b,0xf0,0xc8,0x8e,0xf8,0x39] as IID_IVectorView_1_Windows_Services_Store_StoreImage }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StorePackageUpdate> => [0x971c3ea6,0x4388,0x5a38,0xae,0x13,0x49,0x29,0xb6,0xd6,0xd7,0x80] as IID_IVectorView_1_Windows_Services_Store_StorePackageUpdate }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StorePackageUpdateStatus> => [0x68e2f036,0x4982,0x55e3,0x8c,0x0f,0x9b,0xf4,0xe6,0x9a,0xa4,0x5a] as IID_IVectorView_1_Windows_Services_Store_StorePackageUpdateStatus }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StoreSku> => [0x407c4593,0x063d,0x5c9b,0xb8,0xe0,0x94,0x9f,0xe1,0x38,0x79,0x63] as IID_IVectorView_1_Windows_Services_Store_StoreSku }
		#[cfg(feature="windows.services")] RT_PINTERFACE!{ for IVectorView<super::super::services::store::StoreVideo> => [0x6e31fca5,0x119e,0x5799,0xa5,0x1b,0xcd,0x6a,0xdd,0xec,0xd8,0x70] as IID_IVectorView_1_Windows_Services_Store_StoreVideo }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::accesscache::AccessListEntry> => [0x42b49b8a,0x3014,0x5d27,0x8f,0x2c,0x1e,0xf5,0xee,0x89,0xec,0x00] as IID_IVectorView_1_Windows_Storage_AccessCache_AccessListEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::bulkaccess::FileInformation> => [0x50bcd975,0x67ba,0x53b7,0xa5,0xa7,0x1f,0xb5,0x9f,0x04,0xbb,0xb3] as IID_IVectorView_1_Windows_Storage_BulkAccess_FileInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::bulkaccess::FolderInformation> => [0x506f1329,0xdbdc,0x5a37,0x91,0xd5,0xb0,0x47,0xcb,0x24,0x27,0x6d] as IID_IVectorView_1_Windows_Storage_BulkAccess_FolderInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::bulkaccess::IStorageItemInformation> => [0xda3a4ef8,0xd315,0x529b,0xa7,0x3b,0x52,0x44,0x90,0x57,0x3f,0x7e] as IID_IVectorView_1_Windows_Storage_BulkAccess_IStorageItemInformation }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::IStorageItem> => [0x85575a41,0x06cb,0x58d0,0xb9,0x8a,0x7c,0x8f,0x06,0xe6,0xe9,0xd7] as IID_IVectorView_1_Windows_Storage_IStorageItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::search::IIndexableContent> => [0xf4512416,0x6bb8,0x5c6f,0xb8,0x3a,0xbf,0x8a,0x27,0x88,0xce,0x9f] as IID_IVectorView_1_Windows_Storage_Search_IIndexableContent }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::search::SortEntry> => [0x823c7604,0xb37b,0x5465,0xa1,0x69,0x29,0x49,0x78,0x93,0xcd,0xb9] as IID_IVectorView_1_Windows_Storage_Search_SortEntry }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::StorageFile> => [0x80646519,0x5e2a,0x595d,0xa8,0xcd,0x2a,0x24,0xb4,0x06,0x7f,0x1b] as IID_IVectorView_1_Windows_Storage_StorageFile }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::StorageFolder> => [0xe20debc6,0xdc4e,0x542e,0xa2,0xe7,0xa2,0x4d,0x19,0xc8,0xdd,0x62] as IID_IVectorView_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::StorageLibraryChange> => [0x0d3879e2,0x5c7e,0x5b6c,0x95,0x4d,0x10,0xc6,0xda,0x95,0xfb,0xff] as IID_IVectorView_1_Windows_Storage_StorageLibraryChange }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::streams::IBuffer> => [0xfd944562,0x11d6,0x5eab,0xbd,0x72,0x70,0x19,0x93,0xb6,0x8f,0xac] as IID_IVectorView_1_Windows_Storage_Streams_IBuffer }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for IVectorView<super::super::storage::streams::IRandomAccessStream> => [0x92cd0a46,0x2266,0x5cd6,0x92,0x93,0xe1,0x11,0x29,0x9f,0x27,0x93] as IID_IVectorView_1_Windows_Storage_Streams_IRandomAccessStream }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IVectorView<super::super::system::diagnostics::ProcessDiagnosticInfo> => [0x74ab2473,0x9624,0x5a06,0x90,0x25,0x6d,0x91,0xe6,0x22,0xbf,0x8e] as IID_IVectorView_1_Windows_System_Diagnostics_ProcessDiagnosticInfo }
		#[cfg(feature="windows.system")] RT_PINTERFACE!{ for IVectorView<super::super::system::User> => [0x8cbd762a,0x1222,0x5ee5,0xb7,0x45,0x48,0x9e,0x7a,0x42,0xc6,0xec] as IID_IVectorView_1_Windows_System_User }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::applicationsettings::CredentialCommand> => [0x95cc1bba,0xc279,0x5ee5,0xa5,0x24,0x78,0x01,0x2b,0x7f,0xe1,0x7e] as IID_IVectorView_1_Windows_UI_ApplicationSettings_CredentialCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::applicationsettings::SettingsCommand> => [0x67b64d17,0x4245,0x5d7c,0xbf,0xb4,0x6b,0x68,0xdd,0x52,0x58,0x77] as IID_IVectorView_1_Windows_UI_ApplicationSettings_SettingsCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::applicationsettings::WebAccountCommand> => [0x207eaa3e,0x5ec9,0x5bd4,0xa1,0xd2,0x73,0x17,0x9a,0x81,0x28,0xa8] as IID_IVectorView_1_Windows_UI_ApplicationSettings_WebAccountCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::applicationsettings::WebAccountProviderCommand> => [0xb2d19260,0x1827,0x5d88,0xb9,0x48,0x96,0x88,0xcf,0xcd,0x63,0xae] as IID_IVectorView_1_Windows_UI_ApplicationSettings_WebAccountProviderCommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::core::animationmetrics::IPropertyAnimation> => [0x3a6ed95d,0x6a50,0x5ead,0xa4,0xc6,0x09,0xf8,0xba,0xbc,0x63,0x2c] as IID_IVectorView_1_Windows_UI_Core_AnimationMetrics_IPropertyAnimation }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::inking::InkPoint> => [0xd1ac414b,0xc87d,0x540f,0x8a,0xb1,0x4e,0x0d,0x09,0xd9,0xd2,0x83] as IID_IVectorView_1_Windows_UI_Input_Inking_InkPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::inking::InkRecognitionResult> => [0xecfc4f0b,0x112c,0x5cd3,0xac,0xf0,0xd7,0x46,0xd6,0xbd,0xfe,0xb5] as IID_IVectorView_1_Windows_UI_Input_Inking_InkRecognitionResult }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::inking::InkRecognizer> => [0x8eadfa4f,0x27ef,0x5a5d,0xb0,0xb8,0x7f,0xd5,0xc0,0xce,0x6b,0x39] as IID_IVectorView_1_Windows_UI_Input_Inking_InkRecognizer }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::inking::InkStroke> => [0x6744f458,0xb242,0x5767,0xa6,0x43,0x99,0x6e,0x01,0xdf,0xf0,0xe4] as IID_IVectorView_1_Windows_UI_Input_Inking_InkStroke }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::inking::InkStrokeRenderingSegment> => [0xf39ea41d,0x4714,0x5d80,0x87,0xde,0x97,0x3d,0xd2,0x6d,0xa2,0x69] as IID_IVectorView_1_Windows_UI_Input_Inking_InkStrokeRenderingSegment }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::PointerPoint> => [0xf0f57411,0x7786,0x5174,0x87,0x52,0x4c,0x5e,0x83,0x4b,0x6d,0xa2] as IID_IVectorView_1_Windows_UI_Input_PointerPoint }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::RadialControllerMenuItem> => [0xb91a7342,0x3fcb,0x512b,0xae,0xf1,0xfd,0xa4,0x71,0x2e,0x58,0x17] as IID_IVectorView_1_Windows_UI_Input_RadialControllerMenuItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::input::spatial::SpatialInteractionSourceState> => [0xdfdcf091,0x6e3c,0x5e5b,0xa1,0x93,0x03,0xac,0xc4,0x14,0xc9,0x21] as IID_IVectorView_1_Windows_UI_Input_Spatial_SpatialInteractionSourceState }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::AdaptiveNotificationText> => [0xb60de92b,0x4e12,0x55af,0xb4,0x2f,0xaf,0xe2,0xd7,0x0b,0xa2,0x78] as IID_IVectorView_1_Windows_UI_Notifications_AdaptiveNotificationText }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::NotificationBinding> => [0x9e4d0240,0x6d5c,0x582a,0xa2,0x9d,0x73,0x4e,0x84,0x75,0x07,0x38] as IID_IVectorView_1_Windows_UI_Notifications_NotificationBinding }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::ScheduledTileNotification> => [0x4f729c64,0xa213,0x52e9,0xaf,0x8b,0x58,0xad,0xca,0x3e,0x59,0x7f] as IID_IVectorView_1_Windows_UI_Notifications_ScheduledTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::ScheduledToastNotification> => [0xba0aff1f,0x6a8a,0x5a7e,0xa9,0xf7,0x50,0x5b,0x62,0x66,0xa4,0x36] as IID_IVectorView_1_Windows_UI_Notifications_ScheduledToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::ShownTileNotification> => [0x2b23baa9,0x1d54,0x5440,0xbd,0x32,0x86,0xed,0x70,0xf1,0x5c,0x9e] as IID_IVectorView_1_Windows_UI_Notifications_ShownTileNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::ToastNotification> => [0xa819f3de,0x60aa,0x5159,0x84,0x07,0xf0,0xa7,0xfb,0x1f,0x68,0x32] as IID_IVectorView_1_Windows_UI_Notifications_ToastNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::notifications::UserNotification> => [0x5a08f98c,0x8e45,0x5705,0xaf,0x54,0xf5,0x41,0x8e,0x59,0x83,0x92] as IID_IVectorView_1_Windows_UI_Notifications_UserNotification }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::popups::IUICommand> => [0xed1165e6,0xf377,0x5b00,0x81,0x72,0x93,0xc1,0xbd,0x04,0xde,0xb4] as IID_IVectorView_1_Windows_UI_Popups_IUICommand }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::startscreen::JumpListItem> => [0xbe418be9,0xab72,0x56b0,0xb6,0xd3,0xec,0x70,0xef,0x11,0xf6,0x63] as IID_IVectorView_1_Windows_UI_StartScreen_JumpListItem }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::startscreen::SecondaryTile> => [0x16f89727,0xd811,0x5051,0x9a,0xb5,0x0c,0xb8,0x6a,0x0f,0x0a,0xc3] as IID_IVectorView_1_Windows_UI_StartScreen_SecondaryTile }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::startscreen::SecondaryTileVisualElements> => [0x1cd2cc9b,0xa41c,0x5dc7,0x9d,0x95,0x4c,0xef,0x69,0xa2,0x93,0xf4] as IID_IVectorView_1_Windows_UI_StartScreen_SecondaryTileVisualElements }
		#[cfg(feature="windows.ui")] RT_PINTERFACE!{ for IVectorView<super::super::ui::text::core::CoreTextCompositionSegment> => [0x214b64ff,0xcf4d,0x5dd4,0x93,0x2a,0x7b,0xc6,0x6e,0x69,0x03,0x6e] as IID_IVectorView_1_Windows_UI_Text_Core_CoreTextCompositionSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::automation::AutomationAnnotation> => [0xa4b8a26c,0x9009,0x5394,0x98,0xc8,0x98,0x10,0x7e,0x80,0xdb,0x61] as IID_IVectorView_1_Windows_UI_Xaml_Automation_AutomationAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::automation::peers::AutomationPeer> => [0xb56a6076,0x19e2,0x50c1,0x93,0x0f,0x82,0x5b,0xfc,0x39,0x63,0x5c] as IID_IVectorView_1_Windows_UI_Xaml_Automation_Peers_AutomationPeer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::automation::peers::AutomationPeerAnnotation> => [0x00775c79,0x589b,0x5c36,0xae,0x72,0x2e,0x7a,0xab,0x02,0x70,0xc6] as IID_IVectorView_1_Windows_UI_Xaml_Automation_Peers_AutomationPeerAnnotation }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::ColumnDefinition> => [0xd8eba449,0xe161,0x5108,0xb4,0xfb,0x70,0xc2,0x42,0x4e,0xa1,0x98] as IID_IVectorView_1_Windows_UI_Xaml_Controls_ColumnDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::GroupStyle> => [0x9abc1b42,0x9b12,0x5178,0xa8,0x98,0xbb,0x33,0xf0,0x4e,0xce,0x9d] as IID_IVectorView_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::HubSection> => [0x19452449,0x44eb,0x54a4,0x92,0xf5,0x12,0x16,0x1e,0xda,0x9b,0xd7] as IID_IVectorView_1_Windows_UI_Xaml_Controls_HubSection }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::ICommandBarElement> => [0xa38e89ec,0xf1a4,0x5d7b,0x97,0xc3,0x8a,0xef,0xb6,0x4a,0x5f,0x43] as IID_IVectorView_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::maps::MapElement> => [0xcec120d8,0xea73,0x5aa3,0x91,0x4a,0x37,0xdd,0x25,0x54,0xf6,0x86] as IID_IVectorView_1_Windows_UI_Xaml_Controls_Maps_MapElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::maps::MapRouteView> => [0xbdbb45ea,0x0c73,0x56bc,0xa3,0x75,0x3f,0x2a,0x7b,0xeb,0x6f,0x2e] as IID_IVectorView_1_Windows_UI_Xaml_Controls_Maps_MapRouteView }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::maps::MapTileSource> => [0xde7aa182,0x8e17,0x5565,0x9a,0x9d,0x94,0xa4,0xff,0x25,0x36,0x4a] as IID_IVectorView_1_Windows_UI_Xaml_Controls_Maps_MapTileSource }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::MenuFlyoutItemBase> => [0xa59e9e24,0xf5a6,0x5272,0xa9,0x7b,0x7d,0xd0,0x1a,0x3e,0xfd,0xd0] as IID_IVectorView_1_Windows_UI_Xaml_Controls_MenuFlyoutItemBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::primitives::Popup> => [0x7d899fb2,0x4666,0x5a3e,0xb3,0x6c,0x98,0x86,0xbc,0xbc,0x46,0x63] as IID_IVectorView_1_Windows_UI_Xaml_Controls_Primitives_Popup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::RowDefinition> => [0x27b5c835,0xb5ac,0x5f58,0xa7,0x70,0xc7,0x39,0xf9,0xe6,0x66,0x5c] as IID_IVectorView_1_Windows_UI_Xaml_Controls_RowDefinition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::controls::WebViewDeferredPermissionRequest> => [0x2065ae49,0x5ad7,0x5a34,0x9f,0x78,0xba,0xd1,0x30,0x8f,0x4e,0x5d] as IID_IVectorView_1_Windows_UI_Xaml_Controls_WebViewDeferredPermissionRequest }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::data::ItemIndexRange> => [0xd0b26b06,0x16e8,0x5767,0xa6,0x0b,0xee,0x3e,0x32,0xe4,0x3d,0xfb] as IID_IVectorView_1_Windows_UI_Xaml_Data_ItemIndexRange }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::DependencyObject> => [0xfe750d77,0x1307,0x5df2,0xa0,0x21,0x1c,0x7a,0x8d,0x6b,0x80,0xad] as IID_IVectorView_1_Windows_UI_Xaml_DependencyObject }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::documents::Block> => [0x995f73c4,0x7cf8,0x5b59,0xa0,0xfb,0x7e,0x0c,0x64,0x77,0x17,0x2e] as IID_IVectorView_1_Windows_UI_Xaml_Documents_Block }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::documents::Inline> => [0xc2dd082f,0x8cb4,0x51d6,0xb9,0x1b,0x7e,0x23,0x77,0x78,0x0c,0xee] as IID_IVectorView_1_Windows_UI_Xaml_Documents_Inline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::input::InputScopeName> => [0xfcd65a82,0x5328,0x53bc,0xa8,0x84,0xc2,0x09,0xaa,0xfa,0xbf,0x78] as IID_IVectorView_1_Windows_UI_Xaml_Input_InputScopeName }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::input::Pointer> => [0x6250f79f,0x7668,0x51e9,0x86,0xa3,0x38,0x21,0x21,0x7a,0x66,0x31] as IID_IVectorView_1_Windows_UI_Xaml_Input_Pointer }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::ColorKeyFrame> => [0x8d66a3ca,0x480c,0x5a76,0x98,0xa2,0x90,0x36,0xc0,0x3e,0xd7,0xbd] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_ColorKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::DoubleKeyFrame> => [0xc12407b6,0x145f,0x5420,0x9e,0x16,0xd0,0xa2,0x0b,0xf1,0x31,0x76] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_DoubleKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::ObjectKeyFrame> => [0x19130523,0x0862,0x5631,0xbc,0x2e,0x09,0x76,0x14,0xb3,0x8b,0x6d] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_ObjectKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::PointKeyFrame> => [0xb366e321,0xdf42,0x500b,0x8a,0xda,0x99,0x85,0x4f,0x64,0x06,0xff] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_PointKeyFrame }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::Timeline> => [0x541af22b,0x280b,0x5276,0xbf,0xcb,0x3e,0x60,0xa1,0x57,0xd6,0x2c] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_Timeline }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::animation::Transition> => [0x43b475a1,0x3811,0x5992,0xbe,0x44,0xab,0x41,0xa8,0x25,0xd3,0x55] as IID_IVectorView_1_Windows_UI_Xaml_Media_Animation_Transition }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::Brush> => [0x2c463363,0xef52,0x5dd5,0xba,0x90,0x41,0x5d,0x89,0x33,0xbe,0xc9] as IID_IVectorView_1_Windows_UI_Xaml_Media_Brush }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::Geometry> => [0x1905e02c,0xde78,0x5136,0xb7,0x61,0x7b,0x7a,0x33,0x40,0x25,0x83] as IID_IVectorView_1_Windows_UI_Xaml_Media_Geometry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::GradientStop> => [0x4c4a7b50,0x4bc3,0x52cb,0x8c,0x81,0x2e,0xa7,0x77,0x02,0xb5,0x66] as IID_IVectorView_1_Windows_UI_Xaml_Media_GradientStop }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::PathFigure> => [0xbfe78700,0x1265,0x548c,0xa0,0x6b,0x25,0x9c,0xc2,0xbd,0x03,0x2b] as IID_IVectorView_1_Windows_UI_Xaml_Media_PathFigure }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::PathSegment> => [0x54735271,0xa3db,0x5e42,0x85,0xbe,0x4f,0xf8,0x54,0x32,0x36,0x4b] as IID_IVectorView_1_Windows_UI_Xaml_Media_PathSegment }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::TimelineMarker> => [0xfef8133f,0x98e9,0x5ca3,0xa6,0x67,0x0d,0x23,0x4c,0x5d,0x1d,0x96] as IID_IVectorView_1_Windows_UI_Xaml_Media_TimelineMarker }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::media::Transform> => [0xb3a869c7,0x9c78,0x525b,0x94,0x3e,0x16,0xa2,0xc8,0x97,0x9b,0x03] as IID_IVectorView_1_Windows_UI_Xaml_Media_Transform }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::navigation::PageStackEntry> => [0xaf6d7eac,0x086f,0x5c5f,0xbe,0x4b,0x08,0x58,0xaf,0x75,0x06,0xf7] as IID_IVectorView_1_Windows_UI_Xaml_Navigation_PageStackEntry }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::ResourceDictionary> => [0x36ce8ed8,0xc1a9,0x55b7,0x86,0xdc,0xb4,0x1b,0x8e,0xd8,0xed,0xf4] as IID_IVectorView_1_Windows_UI_Xaml_ResourceDictionary }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::StateTriggerBase> => [0x2bf3a979,0xa6dc,0x592b,0x98,0xee,0xcc,0x7c,0x3d,0x9c,0xaa,0xb2] as IID_IVectorView_1_Windows_UI_Xaml_StateTriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::TriggerAction> => [0xb6c7ce15,0x6a2f,0x5bbb,0x9e,0xfb,0x49,0xbe,0x20,0xb9,0x28,0xa1] as IID_IVectorView_1_Windows_UI_Xaml_TriggerAction }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::TriggerBase> => [0x6c97f246,0x4010,0x5c09,0x97,0x22,0x39,0xfc,0xc3,0xd0,0x64,0x7d] as IID_IVectorView_1_Windows_UI_Xaml_TriggerBase }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::UIElement> => [0xf3864c10,0x14a4,0x5516,0xb1,0xd9,0x63,0xb6,0x57,0x94,0x29,0xb1] as IID_IVectorView_1_Windows_UI_Xaml_UIElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::VisualState> => [0xeb031bb8,0x8028,0x5164,0x96,0x99,0x1e,0xb2,0x88,0x38,0x3f,0xa8] as IID_IVectorView_1_Windows_UI_Xaml_VisualState }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::VisualStateGroup> => [0xadf1746e,0x8936,0x546a,0x97,0x33,0x86,0x26,0x88,0x0c,0x4c,0xe1] as IID_IVectorView_1_Windows_UI_Xaml_VisualStateGroup }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for IVectorView<super::super::ui::xaml::VisualTransition> => [0xbb3d4d2f,0x3406,0x5f29,0x81,0x2a,0xbb,0x1e,0x43,0x78,0x63,0xda] as IID_IVectorView_1_Windows_UI_Xaml_VisualTransition }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::atompub::ResourceCollection> => [0x32f021c7,0x368b,0x5cfa,0x82,0x9c,0x4a,0xcf,0x8a,0x36,0xc8,0x10] as IID_IVectorView_1_Windows_Web_AtomPub_ResourceCollection }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::atompub::Workspace> => [0xd0d7b58d,0xd97e,0x5761,0xbe,0x66,0x42,0xb8,0x5b,0x3d,0x19,0xc8] as IID_IVectorView_1_Windows_Web_AtomPub_Workspace }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::http::diagnostics::HttpDiagnosticSourceLocation> => [0xe9af27d3,0x80e8,0x5aff,0xa7,0xe5,0x1b,0x22,0x17,0x87,0xf0,0x96] as IID_IVectorView_1_Windows_Web_Http_Diagnostics_HttpDiagnosticSourceLocation }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::http::headers::HttpNameValueHeaderValue> => [0x1ef903c8,0x8eef,0x5e9e,0xb9,0x38,0xb9,0xe4,0x28,0xa7,0x76,0x72] as IID_IVectorView_1_Windows_Web_Http_Headers_HttpNameValueHeaderValue }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::http::HttpCookie> => [0x0064c4f6,0x3fca,0x5823,0x9d,0x92,0x86,0xc4,0x0b,0x28,0xad,0xbc] as IID_IVectorView_1_Windows_Web_Http_HttpCookie }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::ISyndicationNode> => [0x6b4bd4a1,0xb4f6,0x5433,0xaf,0xd7,0xbd,0x2e,0x50,0x1a,0x10,0x41] as IID_IVectorView_1_Windows_Web_Syndication_ISyndicationNode }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::SyndicationAttribute> => [0xc1d6d1cc,0x69ce,0x5486,0x9f,0x35,0xc8,0x7e,0x13,0x11,0x13,0x87] as IID_IVectorView_1_Windows_Web_Syndication_SyndicationAttribute }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::SyndicationCategory> => [0xa1ac007c,0x9d94,0x552e,0x84,0x0e,0x13,0x9f,0x10,0x9a,0x9b,0x88] as IID_IVectorView_1_Windows_Web_Syndication_SyndicationCategory }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::SyndicationItem> => [0x9496279b,0x567e,0x5652,0xb9,0x42,0xf6,0xfb,0x70,0xc3,0x41,0x73] as IID_IVectorView_1_Windows_Web_Syndication_SyndicationItem }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::SyndicationLink> => [0xeb8b7ff6,0xfa64,0x576a,0x8b,0xe4,0xa0,0x55,0xf7,0xa0,0x4a,0x73] as IID_IVectorView_1_Windows_Web_Syndication_SyndicationLink }
		#[cfg(feature="windows.web")] RT_PINTERFACE!{ for IVectorView<super::super::web::syndication::SyndicationPerson> => [0x0e450d3d,0xe750,0x5787,0x88,0x5b,0x48,0x8a,0xbc,0x72,0xb5,0xb9] as IID_IVectorView_1_Windows_Web_Syndication_SyndicationPerson }
		RT_PINTERFACE!{ for IVectorView<super::Uri> => [0x4b8385bd,0xa2cd,0x5ff1,0xbf,0x74,0x7e,0xa5,0x80,0x42,0x3e,0x50] as IID_IVectorView_1_Windows_Foundation_Uri }
		RT_PINTERFACE!{ for IVectorView<u32> => [0xe5ce1a07,0x8d33,0x5007,0xba,0x64,0x7d,0x25,0x08,0xcc,0xf8,0x5c] as IID_IVectorView_1_System_UInt32 }
		RT_PINTERFACE!{ for IVectorView<u8> => [0x6d05fb29,0x7885,0x544e,0x93,0x82,0xa1,0xad,0x39,0x1a,0x3f,0xa4] as IID_IVectorView_1_System_Byte }
		RT_PINTERFACE!{ for MapChangedEventHandler<HString, HString> => [0xe2663f37,0x2e1b,0x500c,0xad,0x68,0xc3,0xed,0x7a,0x8f,0x74,0xc8] as IID_MapChangedEventHandler_2_System_String_System_String }
		RT_PINTERFACE!{ for VectorChangedEventHandler<IInspectable> => [0xb423a801,0xd35e,0x56b9,0x81,0x3b,0x00,0x88,0x95,0x36,0xcb,0x98] as IID_VectorChangedEventHandler_1_System_Object }
		#[cfg(feature="windows.applicationmodel")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::applicationmodel::search::core::SearchSuggestion> => [0xcb7b988b,0x468a,0x5eae,0xaf,0xe4,0xdf,0x8b,0x00,0x5f,0x80,0xaf] as IID_VectorChangedEventHandler_1_Windows_ApplicationModel_Search_Core_SearchSuggestion }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::media::core::TimedMetadataTrack> => [0xbd1dc81c,0x23c4,0x5b4b,0xac,0x38,0xc5,0xd3,0x4c,0xdf,0x34,0xe4] as IID_VectorChangedEventHandler_1_Windows_Media_Core_TimedMetadataTrack }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::media::core::TimedTextSource> => [0xe12e6261,0xb198,0x56e0,0x98,0x22,0xba,0x2d,0x3b,0xb6,0xf8,0xfe] as IID_VectorChangedEventHandler_1_Windows_Media_Core_TimedTextSource }
		#[cfg(feature="windows.media")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::media::playback::MediaPlaybackItem> => [0x891bddde,0x6bf3,0x5d1f,0x80,0xab,0x5a,0x34,0x2a,0x16,0xa0,0xbb] as IID_VectorChangedEventHandler_1_Windows_Media_Playback_MediaPlaybackItem }
		#[cfg(feature="windows.storage")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::storage::StorageFolder> => [0x2057b641,0x4b9b,0x5338,0xa1,0x9a,0xe9,0xa9,0x51,0x91,0x67,0x75] as IID_VectorChangedEventHandler_1_Windows_Storage_StorageFolder }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::ui::xaml::controls::GroupStyle> => [0x2caa8225,0xb3d4,0x5725,0xb0,0xcf,0x5e,0x6e,0x61,0x45,0x3b,0x23] as IID_VectorChangedEventHandler_1_Windows_UI_Xaml_Controls_GroupStyle }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::ui::xaml::controls::ICommandBarElement> => [0x20b884e1,0xc1da,0x5332,0xb8,0x01,0x4f,0x1c,0x21,0x74,0x4a,0xc8] as IID_VectorChangedEventHandler_1_Windows_UI_Xaml_Controls_ICommandBarElement }
		#[cfg(feature="windows.ui.xaml")] RT_PINTERFACE!{ for VectorChangedEventHandler<super::super::ui::xaml::DependencyObject> => [0xb62dec93,0xa7a5,0x5ff5,0xb2,0xd2,0x6b,0xd2,0x0c,0xa0,0xbd,0x4d] as IID_VectorChangedEventHandler_1_Windows_UI_Xaml_DependencyObject }
} // Windows.Foundation.Collections
pub mod metadata { // Windows.Foundation.Metadata
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum GCPressureAmount: i32 {
			Low (GCPressureAmount_Low) = 0, Medium (GCPressureAmount_Medium) = 1, High (GCPressureAmount_High) = 2,
		}}
		DEFINE_IID!(IID_IApiInformationStatics, 2574531070, 63105, 18961, 180, 22, 193, 58, 71, 232, 186, 54);
		RT_INTERFACE!{static interface IApiInformationStatics(IApiInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApiInformationStatics] {
			fn IsTypePresent(&mut self, typeName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsMethodPresent(&mut self, typeName: ::w::HSTRING, methodName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsMethodPresentWithArity(&mut self, typeName: ::w::HSTRING, methodName: ::w::HSTRING, inputParameterCount: u32, out: *mut bool) -> ::w::HRESULT,
			fn IsEventPresent(&mut self, typeName: ::w::HSTRING, eventName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsPropertyPresent(&mut self, typeName: ::w::HSTRING, propertyName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsReadOnlyPropertyPresent(&mut self, typeName: ::w::HSTRING, propertyName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsWriteablePropertyPresent(&mut self, typeName: ::w::HSTRING, propertyName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsEnumNamedValuePresent(&mut self, enumTypeName: ::w::HSTRING, valueName: ::w::HSTRING, out: *mut bool) -> ::w::HRESULT,
			fn IsApiContractPresentByMajor(&mut self, contractName: ::w::HSTRING, majorVersion: u16, out: *mut bool) -> ::w::HRESULT,
			fn IsApiContractPresentByMajorAndMinor(&mut self, contractName: ::w::HSTRING, majorVersion: u16, minorVersion: u16, out: *mut bool) -> ::w::HRESULT
		}}
		impl IApiInformationStatics {
			#[inline] pub unsafe fn is_type_present(&mut self, typeName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsTypePresent)(self, typeName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_method_present(&mut self, typeName: &HStringArg, methodName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsMethodPresent)(self, typeName.get(), methodName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_method_present_with_arity(&mut self, typeName: &HStringArg, methodName: &HStringArg, inputParameterCount: u32) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsMethodPresentWithArity)(self, typeName.get(), methodName.get(), inputParameterCount, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_event_present(&mut self, typeName: &HStringArg, eventName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEventPresent)(self, typeName.get(), eventName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_property_present(&mut self, typeName: &HStringArg, propertyName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsPropertyPresent)(self, typeName.get(), propertyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_read_only_property_present(&mut self, typeName: &HStringArg, propertyName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsReadOnlyPropertyPresent)(self, typeName.get(), propertyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_writeable_property_present(&mut self, typeName: &HStringArg, propertyName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsWriteablePropertyPresent)(self, typeName.get(), propertyName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_enum_named_value_present(&mut self, enumTypeName: &HStringArg, valueName: &HStringArg) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEnumNamedValuePresent)(self, enumTypeName.get(), valueName.get(), &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_api_contract_present_by_major(&mut self, contractName: &HStringArg, majorVersion: u16) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsApiContractPresentByMajor)(self, contractName.get(), majorVersion, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_api_contract_present_by_major_and_minor(&mut self, contractName: &HStringArg, majorVersion: u16, minorVersion: u16) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsApiContractPresentByMajorAndMinor)(self, contractName.get(), majorVersion, minorVersion, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_ACTIVATABLE!{IApiInformationStatics [CLSID_ApiInformation]}
		DEFINE_CLSID!(CLSID_ApiInformation = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,77,101,116,97,100,97,116,97,46,65,112,105,73,110,102,111,114,109,97,116,105,111,110,0]);
		RT_ENUM! { enum Platform: i32 {
			Windows (Platform_Windows) = 0, WindowsPhone (Platform_WindowsPhone) = 1,
		}}
		RT_ENUM! { enum AttributeTargets: u32 {
			All (AttributeTargets_All) = 4294967295, Delegate (AttributeTargets_Delegate) = 1, Enum (AttributeTargets_Enum) = 2, Event (AttributeTargets_Event) = 4, Field (AttributeTargets_Field) = 8, Interface (AttributeTargets_Interface) = 16, Method (AttributeTargets_Method) = 64, Parameter (AttributeTargets_Parameter) = 128, Property (AttributeTargets_Property) = 256, RuntimeClass (AttributeTargets_RuntimeClass) = 512, Struct (AttributeTargets_Struct) = 1024, InterfaceImpl (AttributeTargets_InterfaceImpl) = 2048, ApiContract (AttributeTargets_ApiContract) = 8192,
		}}
		RT_ENUM! { enum CompositionType: i32 {
			Protected (CompositionType_Protected) = 1, Public (CompositionType_Public) = 2,
		}}
		RT_ENUM! { enum ThreadingModel: i32 {
			STA (ThreadingModel_STA) = 1, MTA (ThreadingModel_MTA) = 2, Both (ThreadingModel_Both) = 3, InvalidThreading (ThreadingModel_InvalidThreading) = 0,
		}}
		RT_ENUM! { enum MarshalingType: i32 {
			None (MarshalingType_None) = 1, Agile (MarshalingType_Agile) = 2, Standard (MarshalingType_Standard) = 3, InvalidMarshaling (MarshalingType_InvalidMarshaling) = 0,
		}}
		RT_ENUM! { enum DeprecationType: i32 {
			Deprecate (DeprecationType_Deprecate) = 0, Remove (DeprecationType_Remove) = 1,
		}}
} // Windows.Foundation.Metadata
pub mod diagnostics { // Windows.Foundation.Diagnostics
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_ENUM! { enum CausalityTraceLevel: i32 {
			Required (CausalityTraceLevel_Required) = 0, Important (CausalityTraceLevel_Important) = 1, Verbose (CausalityTraceLevel_Verbose) = 2,
		}}
		RT_ENUM! { enum CausalitySource: i32 {
			Application (CausalitySource_Application) = 0, Library (CausalitySource_Library) = 1, System (CausalitySource_System) = 2,
		}}
		RT_ENUM! { enum CausalityRelation: i32 {
			AssignDelegate (CausalityRelation_AssignDelegate) = 0, Join (CausalityRelation_Join) = 1, Choice (CausalityRelation_Choice) = 2, Cancel (CausalityRelation_Cancel) = 3, Error (CausalityRelation_Error) = 4,
		}}
		RT_ENUM! { enum CausalitySynchronousWork: i32 {
			CompletionNotification (CausalitySynchronousWork_CompletionNotification) = 0, ProgressNotification (CausalitySynchronousWork_ProgressNotification) = 1, Execution (CausalitySynchronousWork_Execution) = 2,
		}}
		DEFINE_IID!(IID_ITracingStatusChangedEventArgs, 1091270417, 65339, 18303, 156, 154, 210, 239, 218, 48, 45, 195);
		RT_INTERFACE!{interface ITracingStatusChangedEventArgs(ITracingStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITracingStatusChangedEventArgs] {
			fn get_Enabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_TraceLevel(&mut self, out: *mut CausalityTraceLevel) -> ::w::HRESULT
		}}
		impl ITracingStatusChangedEventArgs {
			#[inline] pub unsafe fn get_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Enabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_trace_level(&mut self) -> RtResult<CausalityTraceLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_TraceLevel)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IAsyncCausalityTracerStatics, 1350896422, 9854, 17691, 168, 144, 171, 106, 55, 2, 69, 238);
		RT_INTERFACE!{static interface IAsyncCausalityTracerStatics(IAsyncCausalityTracerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAsyncCausalityTracerStatics] {
			fn TraceOperationCreation(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, operationName: ::w::HSTRING, relatedContext: u64) -> ::w::HRESULT,
			fn TraceOperationCompletion(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, status: super::AsyncStatus) -> ::w::HRESULT,
			fn TraceOperationRelation(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, relation: CausalityRelation) -> ::w::HRESULT,
			fn TraceSynchronousWorkStart(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, work: CausalitySynchronousWork) -> ::w::HRESULT,
			fn TraceSynchronousWorkCompletion(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, work: CausalitySynchronousWork) -> ::w::HRESULT,
			fn add_TracingStatusChanged(&mut self, handler: *mut super::EventHandler<TracingStatusChangedEventArgs>, out: *mut super::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_TracingStatusChanged(&mut self, cookie: super::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IAsyncCausalityTracerStatics {
			#[inline] pub unsafe fn trace_operation_creation(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, operationName: &HStringArg, relatedContext: u64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TraceOperationCreation)(self, traceLevel, source, platformId, operationId, operationName.get(), relatedContext);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn trace_operation_completion(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, status: super::AsyncStatus) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TraceOperationCompletion)(self, traceLevel, source, platformId, operationId, status);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn trace_operation_relation(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, relation: CausalityRelation) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TraceOperationRelation)(self, traceLevel, source, platformId, operationId, relation);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn trace_synchronous_work_start(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, platformId: ::Guid, operationId: u64, work: CausalitySynchronousWork) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TraceSynchronousWorkStart)(self, traceLevel, source, platformId, operationId, work);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn trace_synchronous_work_completion(&mut self, traceLevel: CausalityTraceLevel, source: CausalitySource, work: CausalitySynchronousWork) -> RtResult<()> {
				let hr = ((*self.lpVtbl).TraceSynchronousWorkCompletion)(self, traceLevel, source, work);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_tracing_status_changed(&mut self, handler: &super::EventHandler<TracingStatusChangedEventArgs>) -> RtResult<super::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_TracingStatusChanged)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_tracing_status_changed(&mut self, cookie: super::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_TracingStatusChanged)(self, cookie);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class TracingStatusChangedEventArgs: ITracingStatusChangedEventArgs}
		RT_ACTIVATABLE!{IAsyncCausalityTracerStatics [CLSID_AsyncCausalityTracer]}
		DEFINE_CLSID!(CLSID_AsyncCausalityTracer = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,65,115,121,110,99,67,97,117,115,97,108,105,116,121,84,114,97,99,101,114,0]);
		RT_ENUM! { enum ErrorOptions: u32 {
			None (ErrorOptions_None) = 0, SuppressExceptions (ErrorOptions_SuppressExceptions) = 1, ForceExceptions (ErrorOptions_ForceExceptions) = 2, UseSetErrorInfo (ErrorOptions_UseSetErrorInfo) = 4, SuppressSetErrorInfo (ErrorOptions_SuppressSetErrorInfo) = 8,
		}}
		DEFINE_IID!(IID_IErrorReportingSettings, 372676498, 45118, 19361, 139, 184, 210, 143, 74, 180, 210, 192);
		RT_INTERFACE!{interface IErrorReportingSettings(IErrorReportingSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IErrorReportingSettings] {
			fn SetErrorOptions(&mut self, value: ErrorOptions) -> ::w::HRESULT,
			fn GetErrorOptions(&mut self, out: *mut ErrorOptions) -> ::w::HRESULT
		}}
		impl IErrorReportingSettings {
			#[inline] pub unsafe fn set_error_options(&mut self, value: ErrorOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).SetErrorOptions)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_error_options(&mut self) -> RtResult<ErrorOptions> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).GetErrorOptions)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		RT_CLASS!{class RuntimeBrokerErrorSettings: IErrorReportingSettings}
		DEFINE_IID!(IID_IErrorDetailsStatics, 3077584720, 2845, 18120, 170, 14, 75, 129, 120, 228, 252, 233);
		RT_INTERFACE!{static interface IErrorDetailsStatics(IErrorDetailsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IErrorDetailsStatics] {
			fn CreateFromHResultAsync(&mut self, errorCode: i32, out: *mut *mut super::IAsyncOperation<ErrorDetails>) -> ::w::HRESULT
		}}
		impl IErrorDetailsStatics {
			#[inline] pub unsafe fn create_from_hresult_async(&mut self, errorCode: i32) -> RtResult<ComPtr<super::IAsyncOperation<ErrorDetails>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateFromHResultAsync)(self, errorCode, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class ErrorDetails: IErrorDetails}
		RT_ACTIVATABLE!{IErrorDetailsStatics [CLSID_ErrorDetails]}
		DEFINE_CLSID!(CLSID_ErrorDetails = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,69,114,114,111,114,68,101,116,97,105,108,115,0]);
		DEFINE_IID!(IID_IErrorDetails, 931969793, 11465, 17039, 140, 85, 44, 153, 13, 70, 62, 143);
		RT_INTERFACE!{interface IErrorDetails(IErrorDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IErrorDetails] {
			fn get_Description(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_LongDescription(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_HelpUri(&mut self, out: *mut *mut super::Uri) -> ::w::HRESULT
		}}
		impl IErrorDetails {
			#[inline] pub unsafe fn get_description(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Description)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_long_description(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_LongDescription)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_help_uri(&mut self) -> RtResult<ComPtr<super::Uri>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_HelpUri)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_ENUM! { enum LoggingLevel: i32 {
			Verbose (LoggingLevel_Verbose) = 0, Information (LoggingLevel_Information) = 1, Warning (LoggingLevel_Warning) = 2, Error (LoggingLevel_Error) = 3, Critical (LoggingLevel_Critical) = 4,
		}}
		RT_ENUM! { enum LoggingOpcode: i32 {
			Info (LoggingOpcode_Info) = 0, Start (LoggingOpcode_Start) = 1, Stop (LoggingOpcode_Stop) = 2, Reply (LoggingOpcode_Reply) = 6, Resume (LoggingOpcode_Resume) = 7, Suspend (LoggingOpcode_Suspend) = 8, Send (LoggingOpcode_Send) = 9,
		}}
		RT_ENUM! { enum LoggingFieldFormat: i32 {
			Default (LoggingFieldFormat_Default) = 0, Hidden (LoggingFieldFormat_Hidden) = 1, String (LoggingFieldFormat_String) = 2, Boolean (LoggingFieldFormat_Boolean) = 3, Hexadecimal (LoggingFieldFormat_Hexadecimal) = 4, ProcessId (LoggingFieldFormat_ProcessId) = 5, ThreadId (LoggingFieldFormat_ThreadId) = 6, Port (LoggingFieldFormat_Port) = 7, Ipv4Address (LoggingFieldFormat_Ipv4Address) = 8, Ipv6Address (LoggingFieldFormat_Ipv6Address) = 9, SocketAddress (LoggingFieldFormat_SocketAddress) = 10, Xml (LoggingFieldFormat_Xml) = 11, Json (LoggingFieldFormat_Json) = 12, Win32Error (LoggingFieldFormat_Win32Error) = 13, NTStatus (LoggingFieldFormat_NTStatus) = 14, HResult (LoggingFieldFormat_HResult) = 15, FileTime (LoggingFieldFormat_FileTime) = 16, Signed (LoggingFieldFormat_Signed) = 17, Unsigned (LoggingFieldFormat_Unsigned) = 18,
		}}
		DEFINE_IID!(IID_ILoggingOptions, 2428270672, 402, 20317, 172, 38, 0, 106, 218, 202, 18, 216);
		RT_INTERFACE!{interface ILoggingOptions(ILoggingOptionsVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingOptions] {
			fn get_Keywords(&mut self, out: *mut i64) -> ::w::HRESULT,
			fn put_Keywords(&mut self, value: i64) -> ::w::HRESULT,
			fn get_Tags(&mut self, out: *mut i32) -> ::w::HRESULT,
			fn put_Tags(&mut self, value: i32) -> ::w::HRESULT,
			fn get_Task(&mut self, out: *mut i16) -> ::w::HRESULT,
			fn put_Task(&mut self, value: i16) -> ::w::HRESULT,
			fn get_Opcode(&mut self, out: *mut LoggingOpcode) -> ::w::HRESULT,
			fn put_Opcode(&mut self, value: LoggingOpcode) -> ::w::HRESULT,
			fn get_ActivityId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn put_ActivityId(&mut self, value: ::Guid) -> ::w::HRESULT,
			fn get_RelatedActivityId(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn put_RelatedActivityId(&mut self, value: ::Guid) -> ::w::HRESULT
		}}
		impl ILoggingOptions {
			#[inline] pub unsafe fn get_keywords(&mut self) -> RtResult<i64> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Keywords)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_keywords(&mut self, value: i64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Keywords)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_tags(&mut self) -> RtResult<i32> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Tags)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_tags(&mut self, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Tags)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_task(&mut self) -> RtResult<i16> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Task)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_task(&mut self, value: i16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Task)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_opcode(&mut self) -> RtResult<LoggingOpcode> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Opcode)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_opcode(&mut self, value: LoggingOpcode) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Opcode)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_activity_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_ActivityId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_activity_id(&mut self, value: ::Guid) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_ActivityId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_related_activity_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_RelatedActivityId)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_related_activity_id(&mut self, value: ::Guid) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_RelatedActivityId)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingOptionsFactory, 3608397515, 39083, 17995, 159, 34, 163, 38, 132, 120, 54, 138);
		RT_INTERFACE!{static interface ILoggingOptionsFactory(ILoggingOptionsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingOptionsFactory] {
			fn CreateWithKeywords(&mut self, keywords: i64, out: *mut *mut LoggingOptions) -> ::w::HRESULT
		}}
		impl ILoggingOptionsFactory {
			#[inline] pub unsafe fn create_with_keywords(&mut self, keywords: i64) -> RtResult<ComPtr<LoggingOptions>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithKeywords)(self, keywords, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingOptions: ILoggingOptions [ILoggingOptionsFactory] [CLSID_LoggingOptions]}
		DEFINE_CLSID!(CLSID_LoggingOptions = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,76,111,103,103,105,110,103,79,112,116,105,111,110,115,0]);
		DEFINE_IID!(IID_ILoggingChannelOptions, 3286779903, 3771, 19027, 140, 84, 222, 194, 73, 38, 203, 44);
		RT_INTERFACE!{interface ILoggingChannelOptions(ILoggingChannelOptionsVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannelOptions] {
			fn get_Group(&mut self, out: *mut ::Guid) -> ::w::HRESULT,
			fn put_Group(&mut self, value: ::Guid) -> ::w::HRESULT
		}}
		impl ILoggingChannelOptions {
			#[inline] pub unsafe fn get_group(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Group)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn set_group(&mut self, value: ::Guid) -> RtResult<()> {
				let hr = ((*self.lpVtbl).put_Group)(self, value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingChannelOptionsFactory, 2838581722, 32687, 16785, 135, 85, 94, 134, 220, 101, 216, 150);
		RT_INTERFACE!{static interface ILoggingChannelOptionsFactory(ILoggingChannelOptionsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannelOptionsFactory] {
			fn Create(&mut self, group: ::Guid, out: *mut *mut LoggingChannelOptions) -> ::w::HRESULT
		}}
		impl ILoggingChannelOptionsFactory {
			#[inline] pub unsafe fn create(&mut self, group: ::Guid) -> RtResult<ComPtr<LoggingChannelOptions>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, group, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingChannelOptions: ILoggingChannelOptions [ILoggingChannelOptionsFactory] [CLSID_LoggingChannelOptions]}
		DEFINE_CLSID!(CLSID_LoggingChannelOptions = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,76,111,103,103,105,110,103,67,104,97,110,110,101,108,79,112,116,105,111,110,115,0]);
		DEFINE_IID!(IID_ILoggingFields, 3623270319, 30253, 17785, 131, 189, 82, 194, 59, 195, 51, 188);
		RT_INTERFACE!{interface ILoggingFields(ILoggingFieldsVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingFields] {
			fn Clear(&mut self) -> ::w::HRESULT,
			fn BeginStruct(&mut self, name: ::w::HSTRING) -> ::w::HRESULT,
			fn BeginStructWithTags(&mut self, name: ::w::HSTRING, tags: i32) -> ::w::HRESULT,
			fn EndStruct(&mut self) -> ::w::HRESULT,
			fn AddEmpty(&mut self, name: ::w::HSTRING) -> ::w::HRESULT,
			fn AddEmptyWithFormat(&mut self, name: ::w::HSTRING, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddEmptyWithFormatAndTags(&mut self, name: ::w::HSTRING, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt8(&mut self, name: ::w::HSTRING, value: u8) -> ::w::HRESULT,
			fn AddUInt8WithFormat(&mut self, name: ::w::HSTRING, value: u8, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt8WithFormatAndTags(&mut self, name: ::w::HSTRING, value: u8, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt8Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u8) -> ::w::HRESULT,
			fn AddUInt8ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u8, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt8ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u8, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt16(&mut self, name: ::w::HSTRING, value: i16) -> ::w::HRESULT,
			fn AddInt16WithFormat(&mut self, name: ::w::HSTRING, value: i16, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt16WithFormatAndTags(&mut self, name: ::w::HSTRING, value: i16, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt16Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i16) -> ::w::HRESULT,
			fn AddInt16ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i16, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt16ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i16, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt16(&mut self, name: ::w::HSTRING, value: u16) -> ::w::HRESULT,
			fn AddUInt16WithFormat(&mut self, name: ::w::HSTRING, value: u16, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt16WithFormatAndTags(&mut self, name: ::w::HSTRING, value: u16, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt16Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u16) -> ::w::HRESULT,
			fn AddUInt16ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u16, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt16ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u16, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt32(&mut self, name: ::w::HSTRING, value: i32) -> ::w::HRESULT,
			fn AddInt32WithFormat(&mut self, name: ::w::HSTRING, value: i32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt32WithFormatAndTags(&mut self, name: ::w::HSTRING, value: i32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt32Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i32) -> ::w::HRESULT,
			fn AddInt32ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt32ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt32(&mut self, name: ::w::HSTRING, value: u32) -> ::w::HRESULT,
			fn AddUInt32WithFormat(&mut self, name: ::w::HSTRING, value: u32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt32WithFormatAndTags(&mut self, name: ::w::HSTRING, value: u32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt32Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u32) -> ::w::HRESULT,
			fn AddUInt32ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt32ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt64(&mut self, name: ::w::HSTRING, value: i64) -> ::w::HRESULT,
			fn AddInt64WithFormat(&mut self, name: ::w::HSTRING, value: i64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt64WithFormatAndTags(&mut self, name: ::w::HSTRING, value: i64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddInt64Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i64) -> ::w::HRESULT,
			fn AddInt64ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddInt64ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut i64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt64(&mut self, name: ::w::HSTRING, value: u64) -> ::w::HRESULT,
			fn AddUInt64WithFormat(&mut self, name: ::w::HSTRING, value: u64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt64WithFormatAndTags(&mut self, name: ::w::HSTRING, value: u64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddUInt64Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u64) -> ::w::HRESULT,
			fn AddUInt64ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddUInt64ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut u64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddSingle(&mut self, name: ::w::HSTRING, value: f32) -> ::w::HRESULT,
			fn AddSingleWithFormat(&mut self, name: ::w::HSTRING, value: f32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddSingleWithFormatAndTags(&mut self, name: ::w::HSTRING, value: f32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddSingleArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f32) -> ::w::HRESULT,
			fn AddSingleArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f32, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddSingleArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f32, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddDouble(&mut self, name: ::w::HSTRING, value: f64) -> ::w::HRESULT,
			fn AddDoubleWithFormat(&mut self, name: ::w::HSTRING, value: f64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddDoubleWithFormatAndTags(&mut self, name: ::w::HSTRING, value: f64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddDoubleArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f64) -> ::w::HRESULT,
			fn AddDoubleArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f64, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddDoubleArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut f64, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddChar16(&mut self, name: ::w::HSTRING, value: ::Char) -> ::w::HRESULT,
			fn AddChar16WithFormat(&mut self, name: ::w::HSTRING, value: ::Char, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddChar16WithFormatAndTags(&mut self, name: ::w::HSTRING, value: ::Char, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddChar16Array(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Char) -> ::w::HRESULT,
			fn AddChar16ArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Char, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddChar16ArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Char, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddBoolean(&mut self, name: ::w::HSTRING, value: bool) -> ::w::HRESULT,
			fn AddBooleanWithFormat(&mut self, name: ::w::HSTRING, value: bool, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddBooleanWithFormatAndTags(&mut self, name: ::w::HSTRING, value: bool, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddBooleanArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut bool) -> ::w::HRESULT,
			fn AddBooleanArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut bool, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddBooleanArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut bool, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddString(&mut self, name: ::w::HSTRING, value: ::w::HSTRING) -> ::w::HRESULT,
			fn AddStringWithFormat(&mut self, name: ::w::HSTRING, value: ::w::HSTRING, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddStringWithFormatAndTags(&mut self, name: ::w::HSTRING, value: ::w::HSTRING, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddStringArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn AddStringArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::w::HSTRING, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddStringArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::w::HSTRING, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddGuid(&mut self, name: ::w::HSTRING, value: ::Guid) -> ::w::HRESULT,
			fn AddGuidWithFormat(&mut self, name: ::w::HSTRING, value: ::Guid, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddGuidWithFormatAndTags(&mut self, name: ::w::HSTRING, value: ::Guid, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddGuidArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Guid) -> ::w::HRESULT,
			fn AddGuidArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Guid, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddGuidArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut ::Guid, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddDateTime(&mut self, name: ::w::HSTRING, value: super::DateTime) -> ::w::HRESULT,
			fn AddDateTimeWithFormat(&mut self, name: ::w::HSTRING, value: super::DateTime, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddDateTimeWithFormatAndTags(&mut self, name: ::w::HSTRING, value: super::DateTime, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddDateTimeArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::DateTime) -> ::w::HRESULT,
			fn AddDateTimeArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::DateTime, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddDateTimeArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::DateTime, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddTimeSpan(&mut self, name: ::w::HSTRING, value: super::TimeSpan) -> ::w::HRESULT,
			fn AddTimeSpanWithFormat(&mut self, name: ::w::HSTRING, value: super::TimeSpan, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddTimeSpanWithFormatAndTags(&mut self, name: ::w::HSTRING, value: super::TimeSpan, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddTimeSpanArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::TimeSpan) -> ::w::HRESULT,
			fn AddTimeSpanArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::TimeSpan, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddTimeSpanArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::TimeSpan, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddPoint(&mut self, name: ::w::HSTRING, value: super::Point) -> ::w::HRESULT,
			fn AddPointWithFormat(&mut self, name: ::w::HSTRING, value: super::Point, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddPointWithFormatAndTags(&mut self, name: ::w::HSTRING, value: super::Point, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddPointArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Point) -> ::w::HRESULT,
			fn AddPointArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Point, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddPointArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Point, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddSize(&mut self, name: ::w::HSTRING, value: super::Size) -> ::w::HRESULT,
			fn AddSizeWithFormat(&mut self, name: ::w::HSTRING, value: super::Size, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddSizeWithFormatAndTags(&mut self, name: ::w::HSTRING, value: super::Size, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddSizeArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Size) -> ::w::HRESULT,
			fn AddSizeArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Size, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddSizeArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Size, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddRect(&mut self, name: ::w::HSTRING, value: super::Rect) -> ::w::HRESULT,
			fn AddRectWithFormat(&mut self, name: ::w::HSTRING, value: super::Rect, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddRectWithFormatAndTags(&mut self, name: ::w::HSTRING, value: super::Rect, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT,
			fn AddRectArray(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Rect) -> ::w::HRESULT,
			fn AddRectArrayWithFormat(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Rect, format: LoggingFieldFormat) -> ::w::HRESULT,
			fn AddRectArrayWithFormatAndTags(&mut self, name: ::w::HSTRING, valueSize: u32, value: *mut super::Rect, format: LoggingFieldFormat, tags: i32) -> ::w::HRESULT
		}}
		impl ILoggingFields {
			#[inline] pub unsafe fn clear(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).Clear)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn begin_struct(&mut self, name: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).BeginStruct)(self, name.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn begin_struct_with_tags(&mut self, name: &HStringArg, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).BeginStructWithTags)(self, name.get(), tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn end_struct(&mut self) -> RtResult<()> {
				let hr = ((*self.lpVtbl).EndStruct)(self);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_empty(&mut self, name: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddEmpty)(self, name.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_empty_with_format(&mut self, name: &HStringArg, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddEmptyWithFormat)(self, name.get(), format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_empty_with_format_and_tags(&mut self, name: &HStringArg, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddEmptyWithFormatAndTags)(self, name.get(), format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8(&mut self, name: &HStringArg, value: u8) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8_with_format(&mut self, name: &HStringArg, value: u8, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8_with_format_and_tags(&mut self, name: &HStringArg, value: u8, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8_array(&mut self, name: &HStringArg, value: &[u8]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8_array_with_format(&mut self, name: &HStringArg, value: &[u8], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint8_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[u8], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt8ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16(&mut self, name: &HStringArg, value: i16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16_with_format(&mut self, name: &HStringArg, value: i16, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16_with_format_and_tags(&mut self, name: &HStringArg, value: i16, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16_array(&mut self, name: &HStringArg, value: &[i16]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16_array_with_format(&mut self, name: &HStringArg, value: &[i16], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int16_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[i16], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt16ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16(&mut self, name: &HStringArg, value: u16) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16_with_format(&mut self, name: &HStringArg, value: u16, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16_with_format_and_tags(&mut self, name: &HStringArg, value: u16, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16_array(&mut self, name: &HStringArg, value: &[u16]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16_array_with_format(&mut self, name: &HStringArg, value: &[u16], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint16_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[u16], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt16ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32(&mut self, name: &HStringArg, value: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32_with_format(&mut self, name: &HStringArg, value: i32, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32_with_format_and_tags(&mut self, name: &HStringArg, value: i32, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32_array(&mut self, name: &HStringArg, value: &[i32]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32_array_with_format(&mut self, name: &HStringArg, value: &[i32], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int32_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[i32], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt32ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32(&mut self, name: &HStringArg, value: u32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32_with_format(&mut self, name: &HStringArg, value: u32, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32_with_format_and_tags(&mut self, name: &HStringArg, value: u32, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32_array(&mut self, name: &HStringArg, value: &[u32]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32_array_with_format(&mut self, name: &HStringArg, value: &[u32], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint32_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[u32], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt32ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64(&mut self, name: &HStringArg, value: i64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64_with_format(&mut self, name: &HStringArg, value: i64, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64_with_format_and_tags(&mut self, name: &HStringArg, value: i64, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64_array(&mut self, name: &HStringArg, value: &[i64]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64_array_with_format(&mut self, name: &HStringArg, value: &[i64], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_int64_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[i64], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddInt64ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64(&mut self, name: &HStringArg, value: u64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64_with_format(&mut self, name: &HStringArg, value: u64, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64_with_format_and_tags(&mut self, name: &HStringArg, value: u64, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64_array(&mut self, name: &HStringArg, value: &[u64]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64_array_with_format(&mut self, name: &HStringArg, value: &[u64], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_uint64_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[u64], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddUInt64ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single(&mut self, name: &HStringArg, value: f32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingle)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single_with_format(&mut self, name: &HStringArg, value: f32, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingleWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single_with_format_and_tags(&mut self, name: &HStringArg, value: f32, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingleWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single_array(&mut self, name: &HStringArg, value: &[f32]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingleArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single_array_with_format(&mut self, name: &HStringArg, value: &[f32], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingleArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_single_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[f32], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSingleArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double(&mut self, name: &HStringArg, value: f64) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDouble)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double_with_format(&mut self, name: &HStringArg, value: f64, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDoubleWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double_with_format_and_tags(&mut self, name: &HStringArg, value: f64, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDoubleWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double_array(&mut self, name: &HStringArg, value: &[f64]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDoubleArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double_array_with_format(&mut self, name: &HStringArg, value: &[f64], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDoubleArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_double_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[f64], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDoubleArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16(&mut self, name: &HStringArg, value: ::Char) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16_with_format(&mut self, name: &HStringArg, value: ::Char, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16WithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16_with_format_and_tags(&mut self, name: &HStringArg, value: ::Char, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16WithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16_array(&mut self, name: &HStringArg, value: &[::Char]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16Array)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16_array_with_format(&mut self, name: &HStringArg, value: &[::Char], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16ArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_char16_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[::Char], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddChar16ArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean(&mut self, name: &HStringArg, value: bool) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBoolean)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean_with_format(&mut self, name: &HStringArg, value: bool, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBooleanWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean_with_format_and_tags(&mut self, name: &HStringArg, value: bool, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBooleanWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean_array(&mut self, name: &HStringArg, value: &[bool]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBooleanArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean_array_with_format(&mut self, name: &HStringArg, value: &[bool], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBooleanArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_boolean_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[bool], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddBooleanArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string(&mut self, name: &HStringArg, value: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddString)(self, name.get(), value.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string_with_format(&mut self, name: &HStringArg, value: &HStringArg, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddStringWithFormat)(self, name.get(), value.get(), format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string_with_format_and_tags(&mut self, name: &HStringArg, value: &HStringArg, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddStringWithFormatAndTags)(self, name.get(), value.get(), format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string_array(&mut self, name: &HStringArg, value: &[&HStringArg]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddStringArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string_array_with_format(&mut self, name: &HStringArg, value: &[&HStringArg], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddStringArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_string_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[&HStringArg], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddStringArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid(&mut self, name: &HStringArg, value: ::Guid) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuid)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid_with_format(&mut self, name: &HStringArg, value: ::Guid, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuidWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid_with_format_and_tags(&mut self, name: &HStringArg, value: ::Guid, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuidWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid_array(&mut self, name: &HStringArg, value: &[::Guid]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuidArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid_array_with_format(&mut self, name: &HStringArg, value: &[::Guid], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuidArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_guid_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[::Guid], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddGuidArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time(&mut self, name: &HStringArg, value: super::DateTime) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTime)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time_with_format(&mut self, name: &HStringArg, value: super::DateTime, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTimeWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time_with_format_and_tags(&mut self, name: &HStringArg, value: super::DateTime, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTimeWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time_array(&mut self, name: &HStringArg, value: &[super::DateTime]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTimeArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time_array_with_format(&mut self, name: &HStringArg, value: &[super::DateTime], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTimeArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_date_time_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[super::DateTime], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddDateTimeArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span(&mut self, name: &HStringArg, value: super::TimeSpan) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpan)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span_with_format(&mut self, name: &HStringArg, value: super::TimeSpan, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpanWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span_with_format_and_tags(&mut self, name: &HStringArg, value: super::TimeSpan, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpanWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span_array(&mut self, name: &HStringArg, value: &[super::TimeSpan]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpanArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span_array_with_format(&mut self, name: &HStringArg, value: &[super::TimeSpan], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpanArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_time_span_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[super::TimeSpan], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddTimeSpanArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point(&mut self, name: &HStringArg, value: super::Point) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPoint)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point_with_format(&mut self, name: &HStringArg, value: super::Point, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPointWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point_with_format_and_tags(&mut self, name: &HStringArg, value: super::Point, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPointWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point_array(&mut self, name: &HStringArg, value: &[super::Point]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPointArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point_array_with_format(&mut self, name: &HStringArg, value: &[super::Point], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPointArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_point_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[super::Point], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddPointArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size(&mut self, name: &HStringArg, value: super::Size) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSize)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size_with_format(&mut self, name: &HStringArg, value: super::Size, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSizeWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size_with_format_and_tags(&mut self, name: &HStringArg, value: super::Size, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSizeWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size_array(&mut self, name: &HStringArg, value: &[super::Size]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSizeArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size_array_with_format(&mut self, name: &HStringArg, value: &[super::Size], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSizeArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_size_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[super::Size], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddSizeArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect(&mut self, name: &HStringArg, value: super::Rect) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRect)(self, name.get(), value);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect_with_format(&mut self, name: &HStringArg, value: super::Rect, format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRectWithFormat)(self, name.get(), value, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect_with_format_and_tags(&mut self, name: &HStringArg, value: super::Rect, format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRectWithFormatAndTags)(self, name.get(), value, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect_array(&mut self, name: &HStringArg, value: &[super::Rect]) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRectArray)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect_array_with_format(&mut self, name: &HStringArg, value: &[super::Rect], format: LoggingFieldFormat) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRectArrayWithFormat)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_rect_array_with_format_and_tags(&mut self, name: &HStringArg, value: &[super::Rect], format: LoggingFieldFormat, tags: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddRectArrayWithFormatAndTags)(self, name.get(), value.len() as u32, value.as_ptr() as *mut _, format, tags);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingFields: ILoggingFields}
		DEFINE_IID!(IID_ILoggingTarget, 1710320693, 58248, 20006, 177, 122, 245, 28, 211, 168, 57, 22);
		RT_INTERFACE!{interface ILoggingTarget(ILoggingTargetVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingTarget] {
			fn IsEnabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn IsEnabledWithLevel(&mut self, level: LoggingLevel, out: *mut bool) -> ::w::HRESULT,
			fn IsEnabledWithLevelAndKeywords(&mut self, level: LoggingLevel, keywords: i64, out: *mut bool) -> ::w::HRESULT,
			fn LogEvent(&mut self, eventName: ::w::HSTRING) -> ::w::HRESULT,
			fn LogEventWithFields(&mut self, eventName: ::w::HSTRING, fields: *mut LoggingFields) -> ::w::HRESULT,
			fn LogEventWithFieldsAndLevel(&mut self, eventName: ::w::HSTRING, fields: *mut LoggingFields, level: LoggingLevel) -> ::w::HRESULT,
			fn LogEventWithFieldsAndOptions(&mut self, eventName: ::w::HSTRING, fields: *mut LoggingFields, level: LoggingLevel, options: *mut LoggingOptions) -> ::w::HRESULT,
			fn StartActivity(&mut self, startEventName: ::w::HSTRING, out: *mut *mut LoggingActivity) -> ::w::HRESULT,
			fn StartActivityWithFields(&mut self, startEventName: ::w::HSTRING, fields: *mut LoggingFields, out: *mut *mut LoggingActivity) -> ::w::HRESULT,
			fn StartActivityWithFieldsAndLevel(&mut self, startEventName: ::w::HSTRING, fields: *mut LoggingFields, level: LoggingLevel, out: *mut *mut LoggingActivity) -> ::w::HRESULT,
			fn StartActivityWithFieldsAndOptions(&mut self, startEventName: ::w::HSTRING, fields: *mut LoggingFields, level: LoggingLevel, options: *mut LoggingOptions, out: *mut *mut LoggingActivity) -> ::w::HRESULT
		}}
		impl ILoggingTarget {
			#[inline] pub unsafe fn is_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEnabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_enabled_with_level(&mut self, level: LoggingLevel) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEnabledWithLevel)(self, level, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn is_enabled_with_level_and_keywords(&mut self, level: LoggingLevel, keywords: i64) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).IsEnabledWithLevelAndKeywords)(self, level, keywords, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_event(&mut self, eventName: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogEvent)(self, eventName.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_event_with_fields(&mut self, eventName: &HStringArg, fields: &LoggingFields) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogEventWithFields)(self, eventName.get(), fields as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_event_with_fields_and_level(&mut self, eventName: &HStringArg, fields: &LoggingFields, level: LoggingLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogEventWithFieldsAndLevel)(self, eventName.get(), fields as *const _ as *mut _, level);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_event_with_fields_and_options(&mut self, eventName: &HStringArg, fields: &LoggingFields, level: LoggingLevel, options: &LoggingOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogEventWithFieldsAndOptions)(self, eventName.get(), fields as *const _ as *mut _, level, options as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start_activity(&mut self, startEventName: &HStringArg) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartActivity)(self, startEventName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start_activity_with_fields(&mut self, startEventName: &HStringArg, fields: &LoggingFields) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartActivityWithFields)(self, startEventName.get(), fields as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start_activity_with_fields_and_level(&mut self, startEventName: &HStringArg, fields: &LoggingFields, level: LoggingLevel) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartActivityWithFieldsAndLevel)(self, startEventName.get(), fields as *const _ as *mut _, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn start_activity_with_fields_and_options(&mut self, startEventName: &HStringArg, fields: &LoggingFields, level: LoggingLevel, options: &LoggingOptions) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).StartActivityWithFieldsAndOptions)(self, startEventName.get(), fields as *const _ as *mut _, level, options as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingActivity: ILoggingActivity [ILoggingActivityFactory] [CLSID_LoggingActivity]}
		DEFINE_CLSID!(CLSID_LoggingActivity = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,76,111,103,103,105,110,103,65,99,116,105,118,105,116,121,0]);
		DEFINE_IID!(IID_ILoggingChannel, 3919905603, 4567, 20225, 181, 202, 207, 73, 82, 120, 192, 168);
		RT_INTERFACE!{interface ILoggingChannel(ILoggingChannelVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannel] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Enabled(&mut self, out: *mut bool) -> ::w::HRESULT,
			fn get_Level(&mut self, out: *mut LoggingLevel) -> ::w::HRESULT,
			fn LogMessage(&mut self, eventString: ::w::HSTRING) -> ::w::HRESULT,
			fn LogMessageWithLevel(&mut self, eventString: ::w::HSTRING, level: LoggingLevel) -> ::w::HRESULT,
			fn LogValuePair(&mut self, value1: ::w::HSTRING, value2: i32) -> ::w::HRESULT,
			fn LogValuePairWithLevel(&mut self, value1: ::w::HSTRING, value2: i32, level: LoggingLevel) -> ::w::HRESULT,
			fn add_LoggingEnabled(&mut self, handler: *mut super::TypedEventHandler<ILoggingChannel, IInspectable>, out: *mut super::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_LoggingEnabled(&mut self, token: super::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl ILoggingChannel {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_enabled(&mut self) -> RtResult<bool> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Enabled)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_level(&mut self) -> RtResult<LoggingLevel> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Level)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_message(&mut self, eventString: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogMessage)(self, eventString.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_message_with_level(&mut self, eventString: &HStringArg, level: LoggingLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogMessageWithLevel)(self, eventString.get(), level);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_value_pair(&mut self, value1: &HStringArg, value2: i32) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogValuePair)(self, value1.get(), value2);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn log_value_pair_with_level(&mut self, value1: &HStringArg, value2: i32, level: LoggingLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).LogValuePairWithLevel)(self, value1.get(), value2, level);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_logging_enabled(&mut self, handler: &super::TypedEventHandler<ILoggingChannel, IInspectable>) -> RtResult<super::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_LoggingEnabled)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_logging_enabled(&mut self, token: super::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_LoggingEnabled)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingChannel2, 2672573683, 2988, 17829, 158, 51, 186, 243, 243, 162, 70, 165);
		RT_INTERFACE!{interface ILoggingChannel2(ILoggingChannel2Vtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannel2] {
			fn get_Id(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl ILoggingChannel2 {
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingChannelFactory, 1323064220, 44928, 19099, 176, 220, 57, 143, 154, 229, 32, 123);
		RT_INTERFACE!{static interface ILoggingChannelFactory(ILoggingChannelFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannelFactory] {
			fn Create(&mut self, name: ::w::HSTRING, out: *mut *mut LoggingChannel) -> ::w::HRESULT
		}}
		impl ILoggingChannelFactory {
			#[inline] pub unsafe fn create(&mut self, name: &HStringArg) -> RtResult<ComPtr<LoggingChannel>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, name.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingChannel: ILoggingChannel [ILoggingChannelFactory] [CLSID_LoggingChannel]}
		DEFINE_CLSID!(CLSID_LoggingChannel = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,76,111,103,103,105,110,103,67,104,97,110,110,101,108,0]);
		DEFINE_IID!(IID_ILoggingChannelFactory2, 1282340317, 15143, 19913, 153, 240, 41, 156, 110, 70, 3, 161);
		RT_INTERFACE!{interface ILoggingChannelFactory2(ILoggingChannelFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_ILoggingChannelFactory2] {
			fn CreateWithOptions(&mut self, name: ::w::HSTRING, options: *mut LoggingChannelOptions, out: *mut *mut LoggingChannel) -> ::w::HRESULT,
			fn CreateWithOptionsAndId(&mut self, name: ::w::HSTRING, options: *mut LoggingChannelOptions, id: ::Guid, out: *mut *mut LoggingChannel) -> ::w::HRESULT
		}}
		impl ILoggingChannelFactory2 {
			#[inline] pub unsafe fn create_with_options(&mut self, name: &HStringArg, options: &LoggingChannelOptions) -> RtResult<ComPtr<LoggingChannel>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithOptions)(self, name.get(), options as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_with_options_and_id(&mut self, name: &HStringArg, options: &LoggingChannelOptions, id: ::Guid) -> RtResult<ComPtr<LoggingChannel>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateWithOptionsAndId)(self, name.get(), options as *const _ as *mut _, id, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingActivity, 3154323777, 46950, 19637, 152, 72, 151, 172, 107, 166, 214, 12);
		RT_INTERFACE!{interface ILoggingActivity(ILoggingActivityVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingActivity] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn get_Id(&mut self, out: *mut ::Guid) -> ::w::HRESULT
		}}
		impl ILoggingActivity {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn get_id(&mut self) -> RtResult<::Guid> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).get_Id)(self, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingActivity2, 650287112, 25378, 17770, 175, 130, 128, 200, 100, 47, 23, 139);
		RT_INTERFACE!{interface ILoggingActivity2(ILoggingActivity2Vtbl): IInspectable(IInspectableVtbl) [IID_ILoggingActivity2] {
			fn get_Channel(&mut self, out: *mut *mut LoggingChannel) -> ::w::HRESULT,
			fn StopActivity(&mut self, stopEventName: ::w::HSTRING) -> ::w::HRESULT,
			fn StopActivityWithFields(&mut self, stopEventName: ::w::HSTRING, fields: *mut LoggingFields) -> ::w::HRESULT,
			fn StopActivityWithFieldsAndOptions(&mut self, stopEventName: ::w::HSTRING, fields: *mut LoggingFields, options: *mut LoggingOptions) -> ::w::HRESULT
		}}
		impl ILoggingActivity2 {
			#[inline] pub unsafe fn get_channel(&mut self) -> RtResult<ComPtr<LoggingChannel>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Channel)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop_activity(&mut self, stopEventName: &HStringArg) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StopActivity)(self, stopEventName.get());
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop_activity_with_fields(&mut self, stopEventName: &HStringArg, fields: &LoggingFields) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StopActivityWithFields)(self, stopEventName.get(), fields as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn stop_activity_with_fields_and_options(&mut self, stopEventName: &HStringArg, fields: &LoggingFields, options: &LoggingOptions) -> RtResult<()> {
				let hr = ((*self.lpVtbl).StopActivityWithFieldsAndOptions)(self, stopEventName.get(), fields as *const _ as *mut _, options as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingActivityFactory, 1798550659, 57610, 19544, 151, 213, 16, 251, 69, 16, 116, 251);
		RT_INTERFACE!{static interface ILoggingActivityFactory(ILoggingActivityFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingActivityFactory] {
			fn CreateLoggingActivity(&mut self, activityName: ::w::HSTRING, loggingChannel: *mut ILoggingChannel, out: *mut *mut LoggingActivity) -> ::w::HRESULT,
			fn CreateLoggingActivityWithLevel(&mut self, activityName: ::w::HSTRING, loggingChannel: *mut ILoggingChannel, level: LoggingLevel, out: *mut *mut LoggingActivity) -> ::w::HRESULT
		}}
		impl ILoggingActivityFactory {
			#[inline] pub unsafe fn create_logging_activity(&mut self, activityName: &HStringArg, loggingChannel: &ILoggingChannel) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateLoggingActivity)(self, activityName.get(), loggingChannel as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn create_logging_activity_with_level(&mut self, activityName: &HStringArg, loggingChannel: &ILoggingChannel, level: LoggingLevel) -> RtResult<ComPtr<LoggingActivity>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CreateLoggingActivityWithLevel)(self, activityName.get(), loggingChannel as *const _ as *mut _, level, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingSession, 1646392070, 37760, 19159, 186, 245, 65, 234, 147, 16, 215, 104);
		RT_INTERFACE!{interface ILoggingSession(ILoggingSessionVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingSession] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy1(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn SaveToFileAsync(&mut self, folder: *mut super::super::storage::IStorageFolder, fileName: ::w::HSTRING, out: *mut *mut super::IAsyncOperation<super::super::storage::StorageFile>) -> ::w::HRESULT,
			fn AddLoggingChannel(&mut self, loggingChannel: *mut ILoggingChannel) -> ::w::HRESULT,
			fn AddLoggingChannelWithLevel(&mut self, loggingChannel: *mut ILoggingChannel, maxLevel: LoggingLevel) -> ::w::HRESULT,
			fn RemoveLoggingChannel(&mut self, loggingChannel: *mut ILoggingChannel) -> ::w::HRESULT
		}}
		impl ILoggingSession {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn save_to_file_async(&mut self, folder: &super::super::storage::IStorageFolder, fileName: &HStringArg) -> RtResult<ComPtr<super::IAsyncOperation<super::super::storage::StorageFile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).SaveToFileAsync)(self, folder as *const _ as *mut _, fileName.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_logging_channel(&mut self, loggingChannel: &ILoggingChannel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddLoggingChannel)(self, loggingChannel as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_logging_channel_with_level(&mut self, loggingChannel: &ILoggingChannel, maxLevel: LoggingLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddLoggingChannelWithLevel)(self, loggingChannel as *const _ as *mut _, maxLevel);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_logging_channel(&mut self, loggingChannel: &ILoggingChannel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RemoveLoggingChannel)(self, loggingChannel as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_ILoggingSessionFactory, 1318289125, 22781, 17888, 140, 47, 161, 50, 239, 249, 92, 30);
		RT_INTERFACE!{static interface ILoggingSessionFactory(ILoggingSessionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILoggingSessionFactory] {
			fn Create(&mut self, name: ::w::HSTRING, out: *mut *mut LoggingSession) -> ::w::HRESULT
		}}
		impl ILoggingSessionFactory {
			#[inline] pub unsafe fn create(&mut self, name: &HStringArg) -> RtResult<ComPtr<LoggingSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, name.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LoggingSession: ILoggingSession [ILoggingSessionFactory] [CLSID_LoggingSession]}
		DEFINE_CLSID!(CLSID_LoggingSession = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,76,111,103,103,105,110,103,83,101,115,115,105,111,110,0]);
		DEFINE_IID!(IID_ILogFileGeneratedEventArgs, 647927663, 3384, 19482, 181, 63, 179, 149, 216, 129, 223, 132);
		RT_INTERFACE!{interface ILogFileGeneratedEventArgs(ILogFileGeneratedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILogFileGeneratedEventArgs] {
			#[cfg(feature="windows.storage")] fn get_File(&mut self, out: *mut *mut super::super::storage::StorageFile) -> ::w::HRESULT
		}}
		impl ILogFileGeneratedEventArgs {
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn get_file(&mut self) -> RtResult<ComPtr<super::super::storage::StorageFile>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_File)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class LogFileGeneratedEventArgs: ILogFileGeneratedEventArgs}
		DEFINE_IID!(IID_IFileLoggingSession, 617038358, 65234, 16460, 137, 95, 31, 150, 153, 203, 2, 247);
		RT_INTERFACE!{interface IFileLoggingSession(IFileLoggingSessionVtbl): IInspectable(IInspectableVtbl) [IID_IFileLoggingSession] {
			fn get_Name(&mut self, out: *mut ::w::HSTRING) -> ::w::HRESULT,
			fn AddLoggingChannel(&mut self, loggingChannel: *mut ILoggingChannel) -> ::w::HRESULT,
			fn AddLoggingChannelWithLevel(&mut self, loggingChannel: *mut ILoggingChannel, maxLevel: LoggingLevel) -> ::w::HRESULT,
			fn RemoveLoggingChannel(&mut self, loggingChannel: *mut ILoggingChannel) -> ::w::HRESULT,
			#[cfg(not(feature="windows.storage"))] fn __Dummy4(&mut self) -> (),
			#[cfg(feature="windows.storage")] fn CloseAndSaveToFileAsync(&mut self, out: *mut *mut super::IAsyncOperation<super::super::storage::StorageFile>) -> ::w::HRESULT,
			fn add_LogFileGenerated(&mut self, handler: *mut super::TypedEventHandler<IFileLoggingSession, LogFileGeneratedEventArgs>, out: *mut super::EventRegistrationToken) -> ::w::HRESULT,
			fn remove_LogFileGenerated(&mut self, token: super::EventRegistrationToken) -> ::w::HRESULT
		}}
		impl IFileLoggingSession {
			#[inline] pub unsafe fn get_name(&mut self) -> RtResult<HString> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).get_Name)(self, &mut out);
				if hr == ::w::S_OK { Ok(HString::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_logging_channel(&mut self, loggingChannel: &ILoggingChannel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddLoggingChannel)(self, loggingChannel as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_logging_channel_with_level(&mut self, loggingChannel: &ILoggingChannel, maxLevel: LoggingLevel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).AddLoggingChannelWithLevel)(self, loggingChannel as *const _ as *mut _, maxLevel);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_logging_channel(&mut self, loggingChannel: &ILoggingChannel) -> RtResult<()> {
				let hr = ((*self.lpVtbl).RemoveLoggingChannel)(self, loggingChannel as *const _ as *mut _);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
			#[cfg(feature="windows.storage")] #[inline] pub unsafe fn close_and_save_to_file_async(&mut self) -> RtResult<ComPtr<super::IAsyncOperation<super::super::storage::StorageFile>>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).CloseAndSaveToFileAsync)(self, &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
			#[inline] pub unsafe fn add_log_file_generated(&mut self, handler: &super::TypedEventHandler<IFileLoggingSession, LogFileGeneratedEventArgs>) -> RtResult<super::EventRegistrationToken> {
				let mut out = ::std::mem::zeroed();
				let hr = ((*self.lpVtbl).add_LogFileGenerated)(self, handler as *const _ as *mut _, &mut out);
				if hr == ::w::S_OK { Ok(out) } else { Err(hr) }
			}
			#[inline] pub unsafe fn remove_log_file_generated(&mut self, token: super::EventRegistrationToken) -> RtResult<()> {
				let hr = ((*self.lpVtbl).remove_LogFileGenerated)(self, token);
				if hr == ::w::S_OK { Ok(()) } else { Err(hr) }
			}
		}
		DEFINE_IID!(IID_IFileLoggingSessionFactory, 4003499470, 33863, 19882, 145, 51, 18, 235, 70, 246, 151, 212);
		RT_INTERFACE!{static interface IFileLoggingSessionFactory(IFileLoggingSessionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IFileLoggingSessionFactory] {
			fn Create(&mut self, name: ::w::HSTRING, out: *mut *mut FileLoggingSession) -> ::w::HRESULT
		}}
		impl IFileLoggingSessionFactory {
			#[inline] pub unsafe fn create(&mut self, name: &HStringArg) -> RtResult<ComPtr<FileLoggingSession>> {
				let mut out = ::std::ptr::null_mut();
				let hr = ((*self.lpVtbl).Create)(self, name.get(), &mut out);
				if hr == ::w::S_OK { Ok(ComPtr::wrap(out)) } else { Err(hr) }
			}
		}
		RT_CLASS!{class FileLoggingSession: IFileLoggingSession [IFileLoggingSessionFactory] [CLSID_FileLoggingSession]}
		DEFINE_CLSID!(CLSID_FileLoggingSession = &[87,105,110,100,111,119,115,46,70,111,117,110,100,97,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,70,105,108,101,76,111,103,103,105,110,103,83,101,115,115,105,111,110,0]);
} // Windows.Foundation.Diagnostics
pub mod numerics { // Windows.Foundation.Numerics
use ::{ComInterface, HString, HStringArg, ComPtr, ComArray, ComIid, IUnknown};
use ::rt::{RtType, IInspectable, RtResult}; use ::rt::handler::IntoInterface;
		RT_STRUCT! { struct Vector2 {
			X: f32, Y: f32,
		}}
		RT_STRUCT! { struct Vector3 {
			X: f32, Y: f32, Z: f32,
		}}
		RT_STRUCT! { struct Vector4 {
			X: f32, Y: f32, Z: f32, W: f32,
		}}
		RT_STRUCT! { struct Matrix3x2 {
			M11: f32, M12: f32, M21: f32, M22: f32, M31: f32, M32: f32,
		}}
		RT_STRUCT! { struct Matrix4x4 {
			M11: f32, M12: f32, M13: f32, M14: f32, M21: f32, M22: f32, M23: f32, M24: f32, M31: f32, M32: f32, M33: f32, M34: f32, M41: f32, M42: f32, M43: f32, M44: f32,
		}}
		RT_STRUCT! { struct Plane {
			Normal: Vector3, D: f32,
		}}
		RT_STRUCT! { struct Quaternion {
			X: f32, Y: f32, Z: f32, W: f32,
		}}
} // Windows.Foundation.Numerics
} // Windows.Foundation
} // Windows
